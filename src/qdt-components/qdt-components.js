(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["QdtComponents"] = factory();
	else
		root["QdtComponents"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 50);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(35)();
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(25);
} else {}


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(24);


/***/ }),
/* 3 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

module.exports = _applyDecoratedDescriptor;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(13);

var assertThisInitialized = __webpack_require__(33);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(34);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

!function(n,e){ true?module.exports=e(__webpack_require__(1)):undefined}("undefined"!=typeof self?self:this,function(n){return function(n){function e(t){if(o[t])return o[t].exports;var i=o[t]={i:t,l:!1,exports:{}};return n[t].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var o={};return e.m=n,e.c=o,e.d=function(n,o,t){e.o(n,o)||Object.defineProperty(n,o,{configurable:!1,enumerable:!0,get:t})},e.n=function(n){var o=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(o,"a",o),o},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="node_modules/qdt-lui/dist/",e(e.s=55)}([function(e,o){e.exports=n},function(n,e,o){n.exports=o(65)()},function(n,e){var o=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=o)},function(n,e,o){var t=o(25)("wks"),i=o(18),r=o(4).Symbol,l="function"==typeof r;(n.exports=function(n){return t[n]||(t[n]=l&&r[n]||(l?r:i)("Symbol."+n))}).store=t},function(n,e){var o=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=o)},function(n,e,o){var t=o(4),i=o(2),r=o(26),l=o(9),u=o(7),a=function(n,e,o){var c,d,b,s=n&a.F,p=n&a.G,g=n&a.S,f=n&a.P,h=n&a.B,A=n&a.W,x=p?i:i[e]||(i[e]={}),v=x.prototype,w=p?t:g?t[e]:(t[e]||{}).prototype;p&&(o=e);for(c in o)(d=!s&&w&&void 0!==w[c])&&u(x,c)||(b=d?w[c]:o[c],x[c]=p&&"function"!=typeof w[c]?o[c]:h&&d?r(b,t):A&&w[c]==b?function(n){var e=function(e,o,t){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(e);case 2:return new n(e,o)}return new n(e,o,t)}return n.apply(this,arguments)};return e.prototype=n.prototype,e}(b):f&&"function"==typeof b?r(Function.call,b):b,f&&((x.virtual||(x.virtual={}))[c]=b,n&a.R&&v&&!v[c]&&l(v,c,b)))};a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,n.exports=a},function(n,e,o){var t=o(10),i=o(44),r=o(27),l=Object.defineProperty;e.f=o(8)?Object.defineProperty:function(n,e,o){if(t(n),e=r(e,!0),t(o),i)try{return l(n,e,o)}catch(n){}if("get"in o||"set"in o)throw TypeError("Accessors not supported!");return"value"in o&&(n[e]=o.value),n}},function(n,e){var o={}.hasOwnProperty;n.exports=function(n,e){return o.call(n,e)}},function(n,e,o){n.exports=!o(12)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(n,e,o){var t=o(6),i=o(14);n.exports=o(8)?function(n,e,o){return t.f(n,e,i(1,o))}:function(n,e,o){return n[e]=o,n}},function(n,e,o){var t=o(11);n.exports=function(n){if(!t(n))throw TypeError(n+" is not an object!");return n}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,o){var t=o(51),i=o(23);n.exports=function(n){return t(i(n))}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports={}},function(n,e,o){var t=o(23);n.exports=function(n){return Object(t(n))}},function(n,e){n.exports=!0},function(n,e){var o=0,t=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++o+t).toString(36))}},function(n,e,o){var t=o(50),i=o(34);n.exports=Object.keys||function(n){return t(n,i)}},function(n,e){e.f={}.propertyIsEnumerable},function(n,e,o){"use strict";e.__esModule=!0;var t=o(108),i=function(n){return n&&n.__esModule?n:{default:n}}(t);e.default=i.default||function(n){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&(n[t]=o[t])}return n}},function(n,e,o){n.exports={default:o(68),__esModule:!0}},function(n,e){n.exports=function(n){if(void 0==n)throw TypeError("Can't call method on  "+n);return n}},function(n,e,o){var t=o(25)("keys"),i=o(18);n.exports=function(n){return t[n]||(t[n]=i(n))}},function(n,e,o){var t=o(2),i=o(4),r=i["__core-js_shared__"]||(i["__core-js_shared__"]={});(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:t.version,mode:o(17)?"pure":"global",copyright:"© 2018 Denis Pushkarev (zloirock.ru)"})},function(n,e,o){var t=o(71);n.exports=function(n,e,o){if(t(n),void 0===e)return n;switch(o){case 1:return function(o){return n.call(e,o)};case 2:return function(o,t){return n.call(e,o,t)};case 3:return function(o,t,i){return n.call(e,o,t,i)}}return function(){return n.apply(e,arguments)}}},function(n,e,o){var t=o(11);n.exports=function(n,e){if(!t(n))return n;var o,i;if(e&&"function"==typeof(o=n.toString)&&!t(i=o.call(n)))return i;if("function"==typeof(o=n.valueOf)&&!t(i=o.call(n)))return i;if(!e&&"function"==typeof(o=n.toString)&&!t(i=o.call(n)))return i;throw TypeError("Can't convert object to primitive value")}},function(n,e,o){"use strict";e.__esModule=!0,e.default=function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}},function(n,e,o){"use strict";e.__esModule=!0;var t=o(72),i=function(n){return n&&n.__esModule?n:{default:n}}(t);e.default=function(){function n(n,e){for(var o=0;o<e.length;o++){var t=e[o];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),(0,i.default)(n,t.key,t)}}return function(e,o,t){return o&&n(e.prototype,o),t&&n(e,t),e}}()},function(n,e,o){"use strict";e.__esModule=!0;var t=o(46),i=function(n){return n&&n.__esModule?n:{default:n}}(t);e.default=function(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!==(void 0===e?"undefined":(0,i.default)(e))&&"function"!=typeof e?n:e}},function(n,e){var o=Math.ceil,t=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?t:o)(n)}},function(n,e,o){var t=o(10),i=o(79),r=o(34),l=o(24)("IE_PROTO"),u=function(){},a=function(){var n,e=o(45)("iframe"),t=r.length;for(e.style.display="none",o(82).appendChild(e),e.src="javascript:",n=e.contentWindow.document,n.open(),n.write("<script>document.F=Object<\/script>"),n.close(),a=n.F;t--;)delete a.prototype[r[t]];return a()};n.exports=Object.create||function(n,e){var o;return null!==n?(u.prototype=t(n),o=new u,u.prototype=null,o[l]=n):o=a(),void 0===e?o:i(o,e)}},function(n,e){var o={}.toString;n.exports=function(n){return o.call(n).slice(8,-1)}},function(n,e){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(n,e,o){var t=o(6).f,i=o(7),r=o(3)("toStringTag");n.exports=function(n,e,o){n&&!i(n=o?n:n.prototype,r)&&t(n,r,{configurable:!0,value:e})}},function(n,e,o){e.f=o(3)},function(n,e,o){var t=o(4),i=o(2),r=o(17),l=o(36),u=o(6).f;n.exports=function(n){var e=i.Symbol||(i.Symbol=r?{}:t.Symbol||{});"_"==n.charAt(0)||n in e||u(e,n,{value:l.f(n)})}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var i=o(97),r=t(i),l=o(101),u=t(l),a=o(46),c=t(a);e.default=function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+(void 0===e?"undefined":(0,c.default)(e)));n.prototype=(0,u.default)(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(r.default?(0,r.default)(n,e):n.__proto__=e)}},function(n,e,o){"use strict";e.__esModule=!0,e.default=function(n,e){var o={};for(var t in n)e.indexOf(t)>=0||Object.prototype.hasOwnProperty.call(n,t)&&(o[t]=n[t]);return o}},function(n,e){function o(n,e){var o=n[1]||"",i=n[3];if(!i)return o;if(e&&"function"==typeof btoa){var r=t(i);return[o].concat(i.sources.map(function(n){return"/*# sourceURL="+i.sourceRoot+n+" */"})).concat([r]).join("\n")}return[o].join("\n")}function t(n){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"}n.exports=function(n){var e=[];return e.toString=function(){return this.map(function(e){var t=o(e,n);return e[2]?"@media "+e[2]+"{"+t+"}":t}).join("")},e.i=function(n,o){"string"==typeof n&&(n=[[null,n,""]]);for(var t={},i=0;i<this.length;i++){var r=this[i][0];"number"==typeof r&&(t[r]=!0)}for(i=0;i<n.length;i++){var l=n[i];"number"==typeof l[0]&&t[l[0]]||(o&&!l[2]?l[2]=o:o&&(l[2]="("+l[2]+") and ("+o+")"),e.push(l))}},e}},function(n,e,o){function t(n,e){for(var o=0;o<n.length;o++){var t=n[o],i=g[t.id];if(i){i.refs++;for(var r=0;r<i.parts.length;r++)i.parts[r](t.parts[r]);for(;r<t.parts.length;r++)i.parts.push(d(t.parts[r],e))}else{for(var l=[],r=0;r<t.parts.length;r++)l.push(d(t.parts[r],e));g[t.id]={id:t.id,refs:1,parts:l}}}}function i(n,e){for(var o=[],t={},i=0;i<n.length;i++){var r=n[i],l=e.base?r[0]+e.base:r[0],u=r[1],a=r[2],c=r[3],d={css:u,media:a,sourceMap:c};t[l]?t[l].parts.push(d):o.push(t[l]={id:l,parts:[d]})}return o}function r(n,e){var o=h(n.insertInto);if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var t=v[v.length-1];if("top"===n.insertAt)t?t.nextSibling?o.insertBefore(e,t.nextSibling):o.appendChild(e):o.insertBefore(e,o.firstChild),v.push(e);else if("bottom"===n.insertAt)o.appendChild(e);else{if("object"!=typeof n.insertAt||!n.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var i=h(n.insertInto+" "+n.insertAt.before);o.insertBefore(e,i)}}function l(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=v.indexOf(n);e>=0&&v.splice(e,1)}function u(n){var e=document.createElement("style");return n.attrs.type="text/css",c(e,n.attrs),r(n,e),e}function a(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",c(e,n.attrs),r(n,e),e}function c(n,e){Object.keys(e).forEach(function(o){n.setAttribute(o,e[o])})}function d(n,e){var o,t,i,r;if(e.transform&&n.css){if(!(r=e.transform(n.css)))return function(){};n.css=r}if(e.singleton){var c=x++;o=A||(A=u(e)),t=b.bind(null,o,c,!1),i=b.bind(null,o,c,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(o=a(e),t=p.bind(null,o,e),i=function(){l(o),o.href&&URL.revokeObjectURL(o.href)}):(o=u(e),t=s.bind(null,o),i=function(){l(o)});return t(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;t(n=e)}else i()}}function b(n,e,o,t){var i=o?"":t.css;if(n.styleSheet)n.styleSheet.cssText=m(e,i);else{var r=document.createTextNode(i),l=n.childNodes;l[e]&&n.removeChild(l[e]),l.length?n.insertBefore(r,l[e]):n.appendChild(r)}}function s(n,e){var o=e.css,t=e.media;if(t&&n.setAttribute("media",t),n.styleSheet)n.styleSheet.cssText=o;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(o))}}function p(n,e,o){var t=o.css,i=o.sourceMap,r=void 0===e.convertToAbsoluteUrls&&i;(e.convertToAbsoluteUrls||r)&&(t=w(t)),i&&(t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */");var l=new Blob([t],{type:"text/css"}),u=n.href;n.href=URL.createObjectURL(l),u&&URL.revokeObjectURL(u)}var g={},f=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}(function(){return window&&document&&document.all&&!window.atob}),h=function(n){var e={};return function(o){if(void 0===e[o]){var t=n.call(this,o);if(t instanceof window.HTMLIFrameElement)try{t=t.contentDocument.head}catch(n){t=null}e[o]=t}return e[o]}}(function(n){return document.querySelector(n)}),A=null,x=0,v=[],w=o(58);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");e=e||{},e.attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||"boolean"==typeof e.singleton||(e.singleton=f()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var o=i(n,e);return t(o,e),function(n){for(var r=[],l=0;l<o.length;l++){var u=o[l],a=g[u.id];a.refs--,r.push(a)}if(n){t(i(n,e),e)}for(var l=0;l<r.length;l++){var a=r[l];if(0===a.refs){for(var c=0;c<a.parts.length;c++)a.parts[c]();delete g[a.id]}}}};var m=function(){var n=[];return function(e,o){return n[e]=o,n.filter(Boolean).join("\n")}}()},function(n,e,o){var t=o(7),i=o(16),r=o(24)("IE_PROTO"),l=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=i(n),t(n,r)?n[r]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?l:null}},function(n,e,o){n.exports=!o(8)&&!o(12)(function(){return 7!=Object.defineProperty(o(45)("div"),"a",{get:function(){return 7}}).a})},function(n,e,o){var t=o(11),i=o(4).document,r=t(i)&&t(i.createElement);n.exports=function(n){return r?i.createElement(n):{}}},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}e.__esModule=!0;var i=o(75),r=t(i),l=o(87),u=t(l),a="function"==typeof u.default&&"symbol"==typeof r.default?function(n){return typeof n}:function(n){return n&&"function"==typeof u.default&&n.constructor===u.default&&n!==u.default.prototype?"symbol":typeof n};e.default="function"==typeof u.default&&"symbol"===a(r.default)?function(n){return void 0===n?"undefined":a(n)}:function(n){return n&&"function"==typeof u.default&&n.constructor===u.default&&n!==u.default.prototype?"symbol":void 0===n?"undefined":a(n)}},function(n,e,o){"use strict";var t=o(77)(!0);o(48)(String,"String",function(n){this._t=String(n),this._i=0},function(){var n,e=this._t,o=this._i;return o>=e.length?{value:void 0,done:!0}:(n=t(e,o),this._i+=n.length,{value:n,done:!1})})},function(n,e,o){"use strict";var t=o(17),i=o(5),r=o(49),l=o(9),u=o(15),a=o(78),c=o(35),d=o(43),b=o(3)("iterator"),s=!([].keys&&"next"in[].keys()),p=function(){return this};n.exports=function(n,e,o,g,f,h,A){a(o,e,g);var x,v,w,m=function(n){if(!s&&n in F)return F[n];switch(n){case"keys":case"values":return function(){return new o(this,n)}}return function(){return new o(this,n)}},k=e+" Iterator",y="values"==f,_=!1,F=n.prototype,N=F[b]||F["@@iterator"]||f&&F[f],M=N||m(f),D=f?y?m("entries"):M:void 0,I="Array"==e?F.entries||N:N;if(I&&(w=d(I.call(new n)))!==Object.prototype&&w.next&&(c(w,k,!0),t||"function"==typeof w[b]||l(w,b,p)),y&&N&&"values"!==N.name&&(_=!0,M=function(){return N.call(this)}),t&&!A||!s&&!_&&F[b]||l(F,b,M),u[e]=M,u[k]=p,f)if(x={values:y?M:m("values"),keys:h?M:m("keys"),entries:D},A)for(v in x)v in F||r(F,v,x[v]);else i(i.P+i.F*(s||_),e,x);return x}},function(n,e,o){n.exports=o(9)},function(n,e,o){var t=o(7),i=o(13),r=o(80)(!1),l=o(24)("IE_PROTO");n.exports=function(n,e){var o,u=i(n),a=0,c=[];for(o in u)o!=l&&t(u,o)&&c.push(o);for(;e.length>a;)t(u,o=e[a++])&&(~r(c,o)||c.push(o));return c}},function(n,e,o){var t=o(33);n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==t(n)?n.split(""):Object(n)}},function(n,e,o){var t=o(31),i=Math.min;n.exports=function(n){return n>0?i(t(n),9007199254740991):0}},function(n,e,o){var t=o(50),i=o(34).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return t(n,i)}},function(n,e,o){var t=o(20),i=o(14),r=o(13),l=o(27),u=o(7),a=o(44),c=Object.getOwnPropertyDescriptor;e.f=o(8)?c:function(n,e){if(n=r(n),e=l(e,!0),a)try{return c(n,e)}catch(n){}if(u(n,e))return i(!t.f.call(n,e),n[e])}},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0}),e.LuiTab=e.LuiTabset=e.LuiSearch=e.LuiListItem=e.LuiList=e.LuiIcon=e.LuiDropdown=e.LuiDialogHeader=e.LuiDialogFooter=e.LuiDialogBody=e.LuiDialog=e.LuiButton=void 0,o(56),o(59);var i=o(64),r=t(i),l=o(67),u=t(l),a=o(104),c=t(a),d=o(105),b=t(d),s=o(106),p=t(s),g=o(107),f=t(g),h=o(122),A=t(h),x=o(123),v=t(x),w=o(124),m=t(w),k=o(125),y=t(k),_=o(127),F=t(_),N=o(128),M=t(N);e.LuiButton=r.default,e.LuiDialog=u.default,e.LuiDialogBody=c.default,e.LuiDialogFooter=b.default,e.LuiDialogHeader=p.default,e.LuiDropdown=f.default,e.LuiIcon=A.default,e.LuiList=v.default,e.LuiListItem=m.default,e.LuiSearch=y.default,e.LuiTabset=F.default,e.LuiTab=M.default},function(n,e,o){var t=o(57);"string"==typeof t&&(t=[[n.i,t,""]]);var i={hmr:!0};i.transform=void 0;o(42)(t,i);t.locals&&(n.exports=t.locals)},function(n,e,o){e=n.exports=o(41)(!1),e.push([n.i,'/*\n * Set default focus styling\n */\n/**\n* Mixin to harmonize button layout between browsers\n*/\n/**\n* Mixin to add content positioning for buttons.\n*/\n/**\n* Mixin for content positioning using the block modifier\n*/\n.lui-button {\n  /* remove firefox dotted outline */\n  vertical-align: middle;\n  height: 28px;\n  min-width: 44px;\n  padding: 0 16px;\n  border: 1px solid transparent;\n  font-size: 13px;\n  font-weight: bold;\n  text-decoration: none;\n  line-height: 24px;\n  position: relative;\n  outline: none;\n  cursor: pointer;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  border-radius: 3px;\n  color: #595959;\n  background-color: transparent;\n  border-color: #B3B3B3;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-button::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.lui-button__caret:after {\n  vertical-align: top;\n  margin-bottom: -1px;\n  padding-top: 1px;\n}\n.lui-button__text, .lui-button__icon, .lui-button__caret {\n  display: inline-block;\n  vertical-align: top;\n}\n.lui-button__text:not(:only-child), .lui-button__icon:not(:only-child), .lui-button__caret:not(:only-child) {\n  margin-left: 5px;\n  margin-right: 5px;\n}\n.lui-button__text:not(:only-child):first-child, .lui-button__icon:not(:only-child):first-child, .lui-button__caret:not(:only-child):first-child {\n  min-width: 6px;\n  margin-left: -6px;\n}\n[dir="rtl"] .lui-button__text:not(:only-child):first-child, [dir="rtl"] .lui-button__icon:not(:only-child):first-child, [dir="rtl"] .lui-button__caret:not(:only-child):first-child {\n  margin-left: 5px;\n  margin-right: -6px;\n}\n.lui-button__text:not(:only-child):last-child, .lui-button__icon:not(:only-child):last-child, .lui-button__caret:not(:only-child):last-child {\n  min-width: 6px;\n  margin-right: -6px;\n}\n[dir="rtl"] .lui-button__text:not(:only-child):last-child, [dir="rtl"] .lui-button__icon:not(:only-child):last-child, [dir="rtl"] .lui-button__caret:not(:only-child):last-child {\n  margin-left: -6px;\n  margin-right: 5px;\n}\n.lui-button__text + .lui-button__caret:last-child {\n  margin-left: 15px;\n  margin-right: -6px;\n}\n[dir="rtl"] .lui-button__text + .lui-button__caret:last-child {\n  margin-left: -6px;\n  margin-right: 15px;\n}\n.lui-button__icon:only-child, .lui-button__caret:only-child {\n  margin-left: -6px;\n  margin-right: -6px;\n  min-width: 18px;\n}\n.lui-button:hover, .lui-button.lui-hovered {\n  border-color: #666666;\n}\n.lui-button:active, .lui-button.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button[disabled], .lui-button.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button:focus, .lui-button.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-button:focus:active, .lui-button.lui-focused:active, .lui-button:focus.lui-active, .lui-button.lui-focused.lui-active {\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--inverse {\n  color: #FFFFFF;\n  background-color: transparent;\n  border-color: rgba(255, 255, 255, 0.5);\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-button--inverse:hover, .lui-button--inverse.lui-hovered {\n  border-color: rgba(255, 255, 255, 0.8);\n}\n.lui-button--inverse:active, .lui-button--inverse.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--inverse[disabled], .lui-button--inverse.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--inverse:focus, .lui-button--inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-button--inverse:focus:active, .lui-button--inverse.lui-focused:active, .lui-button--inverse:focus.lui-active, .lui-button--inverse.lui-focused.lui-active {\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--info {\n  color: #FFFFFF;\n  background-color: #52a2cc;\n  border: 0;\n  padding: 1px 17px;\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--info:hover, .lui-button--info.lui-hovered {\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n}\n.lui-button--info:active, .lui-button--info.lui-active {\n  border: 1px solid transparent;\n  padding: 0 16px;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--info[disabled], .lui-button--info.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--info:focus, .lui-button--info.lui-focused {\n  padding: 0 16px;\n  border: 1px solid #52a2cc;\n}\n.lui-button--success {\n  color: #FFFFFF;\n  background-color: #61a729;\n  border: 0;\n  padding: 1px 17px;\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--success:hover, .lui-button--success.lui-hovered {\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n}\n.lui-button--success:active, .lui-button--success.lui-active {\n  border: 1px solid transparent;\n  padding: 0 16px;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--success[disabled], .lui-button--success.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--success:focus, .lui-button--success.lui-focused {\n  padding: 0 16px;\n  border: 1px solid #52a2cc;\n}\n.lui-button--warning {\n  color: #FFFFFF;\n  background-color: #f8981d;\n  border: 0;\n  padding: 1px 17px;\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--warning:hover, .lui-button--warning.lui-hovered {\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n}\n.lui-button--warning:active, .lui-button--warning.lui-active {\n  border: 1px solid transparent;\n  padding: 0 16px;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--warning[disabled], .lui-button--warning.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--warning:focus, .lui-button--warning.lui-focused {\n  padding: 0 16px;\n  border: 1px solid #52a2cc;\n}\n.lui-button--danger {\n  color: #FFFFFF;\n  background-color: #f05555;\n  border: 0;\n  padding: 1px 17px;\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1);\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--danger:hover, .lui-button--danger.lui-hovered {\n  -webkit-box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n          box-shadow: inset 0 -2px rgba(0, 0, 0, 0.1), inset 0 0 0 250px rgba(255, 255, 255, 0.2);\n}\n.lui-button--danger:active, .lui-button--danger.lui-active {\n  border: 1px solid transparent;\n  padding: 0 16px;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--danger[disabled], .lui-button--danger.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--danger:focus, .lui-button--danger.lui-focused {\n  padding: 0 16px;\n  border: 1px solid #52a2cc;\n}\n.lui-button--toolbar, .lui-button--gradient {\n  color: #595959;\n  background-color: #E6E6E6;\n  background-image: -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n  border-color: #B3B3B3;\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--toolbar:hover, .lui-button--gradient:hover, .lui-button--toolbar.lui-hovered, .lui-button--gradient.lui-hovered {\n  border-color: #B3B3B3;\n}\n.lui-button--toolbar:active, .lui-button--gradient:active, .lui-button--toolbar.lui-active, .lui-button--gradient.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: none;\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--toolbar[disabled], .lui-button--gradient[disabled], .lui-button--toolbar.lui-disabled, .lui-button--gradient.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--toolbar:focus, .lui-button--gradient:focus, .lui-button--toolbar.lui-focused, .lui-button--gradient.lui-focused {\n  border: 1px solid #52a2cc;\n}\n.lui-button--toolbar-inverse, .lui-button--gradient-inverse {\n  color: #FFFFFF;\n  background-color: #4D4D4D;\n  background-image: -webkit-gradient(linear, left top, left bottom, from(#666666), to(#4D4D4D));\n  background-image: linear-gradient(to bottom, #666666, #4D4D4D);\n  border-color: rgba(0, 0, 0, 0.6);\n  -webkit-transition: -webkit-box-shadow 200ms ease-out;\n  transition: -webkit-box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out;\n  transition: box-shadow 200ms ease-out, -webkit-box-shadow 200ms ease-out;\n}\n.lui-button--toolbar-inverse:hover, .lui-button--gradient-inverse:hover, .lui-button--toolbar-inverse.lui-hovered, .lui-button--gradient-inverse.lui-hovered {\n  border-color: rgba(0, 0, 0, 0.6);\n}\n.lui-button--toolbar-inverse:active, .lui-button--gradient-inverse:active, .lui-button--toolbar-inverse.lui-active, .lui-button--gradient-inverse.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: none;\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-button--toolbar-inverse[disabled], .lui-button--gradient-inverse[disabled], .lui-button--toolbar-inverse.lui-disabled, .lui-button--gradient-inverse.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-button--toolbar-inverse:focus, .lui-button--gradient-inverse:focus, .lui-button--toolbar-inverse.lui-focused, .lui-button--gradient-inverse.lui-focused {\n  border: 1px solid #52a2cc;\n}\n.lui-button--block {\n  width: 100%;\n  padding-left: 40px;\n  padding-right: 40px;\n  white-space: nowrap;\n}\n.lui-button--block.lui-button--block.lui-button--block .lui-button__text, .lui-button--block.lui-button--block.lui-button--block .lui-button__icon, .lui-button--block.lui-button--block.lui-button--block .lui-button__caret {\n  margin-left: 0;\n  margin-right: 0;\n  min-width: unset;\n}\n.lui-button--block .lui-button__text {\n  text-overflow: ellipsis;\n  display: inline-block;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n  vertical-align: top;\n}\n.lui-button--block .lui-button__icon:not(:only-child):first-child, .lui-button--block .lui-button__caret:not(:only-child):first-child {\n  position: absolute;\n  left: 10px;\n}\n[dir="rtl"] .lui-button--block .lui-button__icon:not(:only-child):first-child, [dir="rtl"] .lui-button--block .lui-button__caret:not(:only-child):first-child, [dir="rtl"].lui-button--block .lui-button__icon:not(:only-child):first-child, [dir="rtl"].lui-button--block .lui-button__caret:not(:only-child):first-child {\n  left: auto;\n  right: 10px;\n}\n.lui-button--block .lui-button__icon:not(:only-child):last-child, .lui-button--block .lui-button__caret:not(:only-child):last-child {\n  position: absolute;\n  right: 10px;\n}\n[dir="rtl"] .lui-button--block .lui-button__icon:not(:only-child):last-child, [dir="rtl"] .lui-button--block .lui-button__caret:not(:only-child):last-child, [dir="rtl"].lui-button--block .lui-button__icon:not(:only-child):last-child, [dir="rtl"].lui-button--block .lui-button__caret:not(:only-child):last-child {\n  left: 10px;\n  right: auto;\n}\n.lui-button--rounded {\n  border-radius: 16px;\n}\n.lui-button--rounded__icon:only-child, .lui-button--rounded__caret:only-child {\n  margin-left: -8px;\n  margin-right: -8px;\n  min-width: 18px;\n}\n.lui-button--rounded.lui-button--large {\n  border-radius: 19px;\n}\n.lui-button--rounded.lui-button--x-large {\n  border-radius: 27px;\n}\n.lui-button--large {\n  height: 38px;\n  font-size: 14px;\n  padding: 0 16px;\n}\n.lui-button--x-large {\n  height: 54px;\n  font-size: 16px;\n  padding: 0 30px;\n}\n.lui-buttongroup {\n  display: inline-block;\n  vertical-align: middle;\n  /*\n   * Set font-size to 0 to avoid undesired spaces between inline block elements when\n   * developer formats HTML with line-breaks: http://css-tricks.com/fighting-the-space-between-inline-block-elements/\n   */\n  font-size: 0;\n}\n.lui-buttongroup .lui-button, .lui-buttongroup__button {\n  margin: 0;\n}\n.lui-buttongroup .lui-button.lui-active, .lui-buttongroup__button.lui-active, .lui-buttongroup .lui-button.lui-hovered, .lui-buttongroup__button.lui-hovered, .lui-buttongroup .lui-button.lui-focused, .lui-buttongroup__button.lui-focused {\n  z-index: 1;\n}\n.lui-buttongroup .lui-button:hover, .lui-buttongroup__button:hover, .lui-buttongroup .lui-button:active, .lui-buttongroup__button:active {\n  z-index: 2;\n}\n.lui-buttongroup .lui-button:focus, .lui-buttongroup__button:focus {\n  z-index: 3;\n}\n.lui-buttongroup .lui-button:first-child:not(:last-child), .lui-buttongroup__button:first-child:not(:last-child) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.lui-buttongroup .lui-button:not(:last-child):not(:first-child), .lui-buttongroup__button:not(:last-child):not(:first-child) {\n  border-radius: 0;\n}\n.lui-buttongroup .lui-button:not(:last-child), .lui-buttongroup__button:not(:last-child) {\n  margin-right: -1px;\n}\n.lui-buttongroup .lui-button:last-child:not(:first-child), .lui-buttongroup__button:last-child:not(:first-child) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n[dir="rtl"] .lui-buttongroup .lui-button:first-child:not(:last-child), [dir="rtl"] .lui-buttongroup__button:first-child:not(:last-child) {\n  border-radius: 0 3px 3px 0;\n}\n[dir="rtl"] .lui-buttongroup .lui-button:not(:last-child), [dir="rtl"] .lui-buttongroup__button:not(:last-child) {\n  margin-right: 0;\n  margin-left: -1px;\n}\n[dir="rtl"] .lui-buttongroup .lui-button:last-child:not(:first-child), [dir="rtl"] .lui-buttongroup__button:last-child:not(:first-child) {\n  border-radius: 3px 0 0 3px;\n}\n.lui-dialog {\n  position: relative;\n  border-radius: 3px;\n  margin: auto;\n  min-width: 250px;\n  max-height: 100%;\n  border: 1px solid transparent;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex-direction: column;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n          flex-direction: column;\n  z-index: 1021;\n  color: #595959;\n  background-color: #FFFFFF;\n  border-color: #808080;\n  -webkit-box-shadow: 0 2px 25px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 2px 25px rgba(0, 0, 0, 0.4);\n}\n.lui-dialog.lui-fade {\n  opacity: 0;\n}\n.lui-dialog .lui-dialog__header, .lui-dialog .lui-dialog__footer {\n  background-color: #FBFBFB;\n}\n.lui-dialog .lui-dialog__header {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.2);\n}\n.lui-dialog .lui-dialog__footer, .lui-dialog .lui-dialog__footer--mobile {\n  border-top: 1px solid rgba(0, 0, 0, 0.2);\n}\n.lui-dialog .lui-dialog__button--mobile {\n  border-top: 1px solid rgba(0, 0, 0, 0.2);\n}\n.lui-dialog-container {\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  height: 100%;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex-direction: column;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n          flex-direction: column;\n  padding: 20px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-transition: opacity 200ms ease-out;\n  transition: opacity 200ms ease-out;\n  opacity: 1;\n  z-index: 1021;\n}\n.lui-dialog--inverse {\n  color: #FFFFFF;\n  background-color: #404040;\n  border-color: #333333;\n  -webkit-box-shadow: 0 2px 25px rgba(0, 0, 0, 0.6);\n          box-shadow: 0 2px 25px rgba(0, 0, 0, 0.6);\n}\n.lui-dialog--inverse .lui-dialog__header, .lui-dialog--inverse .lui-dialog__footer {\n  background-color: #474747;\n}\n.lui-dialog--inverse .lui-dialog__header {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.3);\n}\n.lui-dialog--inverse .lui-dialog__footer, .lui-dialog--inverse .lui-dialog__footer--mobile {\n  border-top: 1px solid rgba(0, 0, 0, 0.3);\n}\n.lui-dialog--inverse .lui-dialog__button--mobile {\n  border-top: 1px solid rgba(0, 0, 0, 0.3);\n}\n.lui-dialog__header {\n  font-size: 14px;\n  font-weight: bold;\n  height: 44px;\n  padding: 8px;\n  line-height: 28px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n}\n.lui-dialog__header--mobile {\n  height: 54px;\n  padding: 14px;\n  height: 100%;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex-pack: justify;\n  -webkit-box-pack: justify;\n          justify-content: space-between;\n  -ms-flex-direction: row;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n          flex-direction: row;\n  overflow: hidden;\n}\n.lui-dialog__body {\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  padding: 20px;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.lui-dialog__footer {\n  height: 44px;\n  padding: 8px;\n  text-align: right;\n  border-bottom-left-radius: 3px;\n  border-bottom-right-radius: 3px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n}\n[dir="rtl"] .lui-dialog__footer {\n  text-align: left;\n}\n.lui-dialog__footer--mobile {\n  padding: 0;\n  height: auto;\n}\n.lui-dialog__footer .lui-button, .lui-dialog__button {\n  margin: 0 3px;\n}\n.lui-dialog__footer .lui-button:last-child, .lui-dialog__button:last-child {\n  margin-right: 0;\n}\n[dir="rtl"] .lui-dialog__footer .lui-button:last-child, [dir="rtl"] .lui-dialog__button:last-child {\n  margin-right: 3px;\n  margin-left: 0;\n}\n.lui-dialog__button--mobile.lui-button {\n  width: 100%;\n  padding-left: 40px;\n  padding-right: 40px;\n  white-space: nowrap;\n  height: 54px;\n  font-size: 16px;\n  margin: 0;\n}\n.lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__text, .lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon, .lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret {\n  margin-left: 0;\n  margin-right: 0;\n  min-width: unset;\n}\n.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__text {\n  text-overflow: ellipsis;\n  display: inline-block;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n  vertical-align: top;\n}\n.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):first-child, .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):first-child {\n  position: absolute;\n  left: 10px;\n}\n[dir="rtl"] .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):first-child, [dir="rtl"] .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):first-child, [dir="rtl"].lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):first-child, [dir="rtl"].lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):first-child {\n  left: auto;\n  right: 10px;\n}\n.lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):last-child, .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):last-child {\n  position: absolute;\n  right: 10px;\n}\n[dir="rtl"] .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):last-child, [dir="rtl"] .lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):last-child, [dir="rtl"].lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__icon:not(:only-child):last-child, [dir="rtl"].lui-dialog__button--mobile.lui-button .lui-dialog__button--mobile__caret:not(:only-child):last-child {\n  left: 10px;\n  right: auto;\n}\n.lui-dialog__button--mobile.lui-button:first-child:not(:last-child) {\n  border-top: none;\n  border-left: hidden;\n  border-right: hidden;\n  border-bottom: hidden;\n  border-radius: 0;\n}\n.lui-dialog__button--mobile.lui-button:last-child:not(:first-child) {\n  border-left: hidden;\n  border-right: hidden;\n  border-bottom: hidden;\n  border-top-right-radius: 0;\n  border-top-left-radius: 0;\n}\n[dir="rtl"] .lui-dialog__button--mobile.lui-button {\n  margin: 0;\n}\n.lui-dialog__title {\n  margin-left: 12px;\n  margin-right: 12px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.lui-fade-button {\n  /* remove firefox dotted outline */\n  vertical-align: middle;\n  height: 28px;\n  padding: 0 6px;\n  min-width: 40px;\n  border: 1px solid transparent;\n  background-color: transparent;\n  font-size: 13px;\n  font-weight: bold;\n  text-decoration: none;\n  line-height: 24px;\n  position: relative;\n  outline: none;\n  cursor: pointer;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  border-radius: 3px;\n  -webkit-transition: color 200ms ease-out;\n  transition: color 200ms ease-out;\n  color: rgba(89, 89, 89, 0.8);\n}\n.lui-fade-button::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.lui-fade-button__text, .lui-fade-button__icon, .lui-fade-button__caret {\n  display: inline-block;\n  vertical-align: top;\n}\n.lui-fade-button__text:not(:only-child), .lui-fade-button__icon:not(:only-child), .lui-fade-button__caret:not(:only-child) {\n  margin-left: 5px;\n  margin-right: 5px;\n}\n.lui-fade-button__text:not(:only-child):first-child, .lui-fade-button__icon:not(:only-child):first-child, .lui-fade-button__caret:not(:only-child):first-child {\n  min-width: 6px;\n  margin-left: 0px;\n}\n[dir="rtl"] .lui-fade-button__text:not(:only-child):first-child, [dir="rtl"] .lui-fade-button__icon:not(:only-child):first-child, [dir="rtl"] .lui-fade-button__caret:not(:only-child):first-child {\n  margin-left: 5px;\n  margin-right: 0px;\n}\n.lui-fade-button__text:not(:only-child):last-child, .lui-fade-button__icon:not(:only-child):last-child, .lui-fade-button__caret:not(:only-child):last-child {\n  min-width: 6px;\n  margin-right: 0px;\n}\n[dir="rtl"] .lui-fade-button__text:not(:only-child):last-child, [dir="rtl"] .lui-fade-button__icon:not(:only-child):last-child, [dir="rtl"] .lui-fade-button__caret:not(:only-child):last-child {\n  margin-left: 0px;\n  margin-right: 5px;\n}\n.lui-fade-button:hover, .lui-fade-button.lui-hovered, .lui-fade-button:active, .lui-fade-button:focus, .lui-fade-button.lui-focused {\n  color: #595959;\n}\n.lui-fade-button.lui-active {\n  background-color: rgba(0, 0, 0, 0.05);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button[disabled], .lui-fade-button.lui-disabled {\n  color: rgba(89, 89, 89, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--inverse {\n  color: rgba(255, 255, 255, 0.8);\n}\n.lui-fade-button--inverse:hover, .lui-fade-button--inverse.lui-hovered, .lui-fade-button--inverse:active, .lui-fade-button--inverse:focus, .lui-fade-button--inverse.lui-focused {\n  color: #FFFFFF;\n}\n.lui-fade-button--inverse.lui-active {\n  background-color: rgba(255, 255, 255, 0.1);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button--inverse[disabled], .lui-fade-button--inverse.lui-disabled {\n  color: rgba(255, 255, 255, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--info {\n  color: rgba(82, 162, 204, 0.8);\n}\n.lui-fade-button--info:hover, .lui-fade-button--info.lui-hovered, .lui-fade-button--info:active, .lui-fade-button--info:focus, .lui-fade-button--info.lui-focused {\n  color: #52a2cc;\n}\n.lui-fade-button--info.lui-active {\n  background-color: rgba(255, 255, 255, 0.1);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button--info[disabled], .lui-fade-button--info.lui-disabled {\n  color: rgba(82, 162, 204, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--success {\n  color: rgba(97, 167, 41, 0.8);\n}\n.lui-fade-button--success:hover, .lui-fade-button--success.lui-hovered, .lui-fade-button--success:active, .lui-fade-button--success:focus, .lui-fade-button--success.lui-focused {\n  color: #61a729;\n}\n.lui-fade-button--success.lui-active {\n  background-color: rgba(255, 255, 255, 0.1);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button--success[disabled], .lui-fade-button--success.lui-disabled {\n  color: rgba(97, 167, 41, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--warning {\n  color: rgba(248, 152, 29, 0.8);\n}\n.lui-fade-button--warning:hover, .lui-fade-button--warning.lui-hovered, .lui-fade-button--warning:active, .lui-fade-button--warning:focus, .lui-fade-button--warning.lui-focused {\n  color: #f8981d;\n}\n.lui-fade-button--warning.lui-active {\n  background-color: rgba(255, 255, 255, 0.1);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button--warning[disabled], .lui-fade-button--warning.lui-disabled {\n  color: rgba(248, 152, 29, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--danger {\n  color: rgba(240, 85, 85, 0.8);\n}\n.lui-fade-button--danger:hover, .lui-fade-button--danger.lui-hovered, .lui-fade-button--danger:active, .lui-fade-button--danger:focus, .lui-fade-button--danger.lui-focused {\n  color: #f05555;\n}\n.lui-fade-button--danger.lui-active {\n  background-color: rgba(255, 255, 255, 0.1);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-fade-button--danger[disabled], .lui-fade-button--danger.lui-disabled {\n  color: rgba(240, 85, 85, 0.2);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-fade-button--large {\n  height: 44px;\n  width: 44px;\n  font-size: 14px;\n}\n.lui-tabset {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  height: 38px;\n  width: 100%;\n  overflow-y: auto;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.lui-tabset--large {\n  height: 54px;\n}\n.lui-tab {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex: 0 1 auto;\n  -webkit-box-flex: 0;\n          flex: 0 1 auto;\n  border-bottom: 2px solid transparent;\n  -webkit-transition: background-color 50ms ease-out;\n  transition: background-color 50ms ease-out;\n  min-width: 100px;\n  max-width: 200px;\n  height: 38px;\n  min-height: 38px;\n  padding-left: 10px;\n  padding-right: 10px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 13px;\n  line-height: 36px;\n  font-weight: bold;\n  cursor: pointer;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  background-color: transparent;\n  border-right: 1px solid rgba(0, 0, 0, 0.1);\n  color: #595959;\n  border-left-color: rgba(0, 0, 0, 0.1);\n}\n.lui-tab[disabled], .lui-tab.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-tab .lui-tab__text {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  text-align: left;\n  font-size: 13px;\n  line-height: 36px;\n  font-weight: bold;\n}\n.lui-tab .lui-tab__text--large {\n  line-height: 52px;\n  font-size: 14px;\n}\n.lui-tab .lui-tab__aside {\n  margin-right: 0;\n  padding: 3px;\n  margin-left: 20px;\n  font-size: 10px;\n  line-height: normal;\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n  -ms-grid-row-align: center;\n  align-self: center;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n}\n[dir=\'rtl\'] .lui-tab .lui-tab {\n  border-right: none;\n  border-left-width: 1px;\n  border-left-style: solid;\n  text-align: right;\n}\n[dir=\'rtl\'] .lui-tab .lui-tab .lui-tab__text {\n  text-align: right;\n}\n[dir=\'rtl\'] .lui-tab .lui-tab .lui-tab__aside {\n  margin-right: 20px;\n  margin-left: 0;\n}\n[dir=\'rtl\'] .lui-tab .lui-tab .lui-tab-transclusion {\n  -ms-flex-pack: start;\n  -webkit-box-pack: start;\n          justify-content: flex-start;\n}\n.lui-tab:hover, .lui-tab.lui-hovered {\n  background-color: rgba(0, 0, 0, 0.03);\n}\n.lui-tab.lui-active, .lui-tab:focus, .lui-tab.lui-focused {\n  background-color: #FFFFFF;\n  border-bottom: 2px solid #f8981d;\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-tab .lui-tab__text {\n  color: #595959;\n}\n.lui-tab .lui-icon {\n  color: rgba(89, 89, 89, 0.8);\n}\n.lui-tab .lui-tab__aside.lui-icon {\n  color: rgba(89, 89, 89, 0.8);\n}\n.lui-tab .lui-tab__aside:hover {\n  color: #595959;\n}\n.lui-tab--inverse {\n  background-color: transparent;\n  border-right: 1px solid rgba(255, 255, 255, 0.15);\n  color: #FFFFFF;\n  border-left-color: rgba(255, 255, 255, 0.15);\n}\n.lui-tab--inverse:hover, .lui-tab--inverse.lui-hovered {\n  background-color: rgba(255, 255, 255, 0.1);\n}\n.lui-tab--inverse.lui-active, .lui-tab--inverse:focus, .lui-tab--inverse.lui-focused {\n  background-color: rgba(255, 255, 255, 0.15);\n  border-bottom: 2px solid #f8981d;\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-tab--inverse .lui-tab__text {\n  color: #FFFFFF;\n}\n.lui-tab--inverse .lui-icon {\n  color: rgba(255, 255, 255, 0.8);\n}\n.lui-tab--inverse .lui-tab__aside.lui-icon {\n  color: rgba(255, 255, 255, 0.8);\n}\n.lui-tab--inverse .lui-tab__aside:hover {\n  color: #FFFFFF;\n}\n.lui-tab--large {\n  height: 54px;\n  padding-left: 14px;\n  padding-right: 14px;\n}\n.lui-tabset--fill .lui-tab {\n  max-width: none;\n  min-width: 50px;\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  -ms-flex-pack: center;\n  -webkit-box-pack: center;\n          justify-content: center;\n  width: 150px;\n}\n.lui-tabset--fill .lui-tab:last-child {\n  border-right: none;\n}\n.lui-tabset--fill .lui-tab .lui-tab__text {\n  -ms-flex: 0 1 auto;\n  -webkit-box-flex: 0;\n          flex: 0 1 auto;\n  text-align: center;\n}\n.lui-tabset--fill .lui-tab__aside {\n  margin-right: 0;\n  margin-left: 10px;\n}\n[dir=\'rtl\'] .lui-tabset--fill .lui-tabset--fill .lui-tab:last-child {\n  border-left: none;\n}\n[dir=\'rtl\'] .lui-tabset--fill .lui-tabset--fill .lui-tab .lui-tab__aside {\n  margin-right: 10px;\n  margin-left: 0;\n}\n.lui-checkbox {\n  cursor: pointer;\n  vertical-align: middle;\n  position: relative;\n  display: block;\n}\n.lui-checkbox__input {\n  position: absolute;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  opacity: 0;\n  z-index: -1;\n}\n.lui-checkbox__check-wrap {\n  display: inline-block;\n  vertical-align: middle;\n}\n.lui-checkbox__check-text {\n  display: inline-block;\n  vertical-align: middle;\n  padding-left: 5px;\n}\n[dir="rtl"] .lui-checkbox__check-text {\n  padding-left: unset;\n  padding-right: 5px;\n}\n.lui-checkbox__check {\n  display: inline-block;\n  font-family: "LUI icons";\n  font-size: 16px;\n  font-weight: normal;\n  text-decoration: inherit;\n  direction: ltr;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  border-radius: 3px;\n  vertical-align: middle;\n  text-transform: none;\n  width: 22px;\n  height: 22px;\n  line-height: 20px;\n  font-size: 14px;\n  font-style: normal;\n  text-align: center;\n  border: 1px solid;\n}\n.lui-checkbox__check:after {\n  content: none;\n}\n.lui-checkbox__input:checked + .lui-checkbox__check-wrap .lui-checkbox__check:after {\n  content: "m";\n}\n.lui-checkbox__input:indeterminate + .lui-checkbox__check-wrap .lui-checkbox__check:after {\n  content: "\\2013";\n}\n.lui-checkbox.lui-disabled, .lui-checkbox__input:disabled + .lui-checkbox__check-wrap {\n  cursor: default;\n}\n.lui-checkbox .lui-checkbox__check {\n  border-color: #CCCCCC;\n  background: #FFFFFF;\n  color: #FFFFFF;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-checkbox .lui-checkbox__check-text {\n  color: #595959;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\n.lui-checkbox .lui-checkbox__input:checked + .lui-checkbox__check-wrap .lui-checkbox__check, .lui-checkbox .lui-checkbox__input:indeterminate + .lui-checkbox__check-wrap .lui-checkbox__check {\n  background: #fab761;\n  border-color: transparent;\n}\n.lui-checkbox.lui-checkbox.lui-checkbox.lui-active .lui-checkbox__check, .lui-checkbox.lui-checkbox.lui-checkbox:active .lui-checkbox__check, .lui-checkbox.lui-checkbox.lui-checkbox .lui-checkbox__check:active {\n  background: #595959;\n  border-color: transparent;\n}\n.lui-checkbox.lui-checkbox.lui-checkbox:hover .lui-checkbox__check, .lui-checkbox.lui-checkbox.lui-checkbox.lui-hovered .lui-checkbox__check {\n  border-color: #595959;\n}\n.lui-checkbox .lui-checkbox__input:focus + .lui-checkbox__check-wrap .lui-checkbox__check, .lui-checkbox.lui-checkbox.lui-checkbox.lui-focused .lui-checkbox__check {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-checkbox.lui-checkbox.lui-checkbox.lui-disabled .lui-checkbox__check, .lui-checkbox .lui-checkbox__input:disabled + .lui-checkbox__check-wrap .lui-checkbox__check {\n  background: rgba(0, 0, 0, 0.1);\n  border-color: transparent;\n  color: #FFFFFF;\n}\n.lui-checkbox--inverse .lui-checkbox__check {\n  border-color: rgba(255, 255, 255, 0.3);\n  background: rgba(255, 255, 255, 0.3);\n  color: #FFFFFF;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-checkbox--inverse .lui-checkbox__check-text {\n  color: #FFFFFF;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n}\n.lui-checkbox--inverse .lui-checkbox__input:checked + .lui-checkbox__check-wrap .lui-checkbox__check, .lui-checkbox--inverse .lui-checkbox__input:indeterminate + .lui-checkbox__check-wrap .lui-checkbox__check {\n  background: #f8981d;\n  border-color: transparent;\n}\n.lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse.lui-active .lui-checkbox__check, .lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse:active .lui-checkbox__check, .lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse .lui-checkbox__check:active {\n  background: rgba(0, 0, 0, 0.6);\n  border-color: transparent;\n}\n.lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse:hover .lui-checkbox__check, .lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse.lui-hovered .lui-checkbox__check {\n  border-color: #FFFFFF;\n}\n.lui-checkbox--inverse .lui-checkbox__input:focus + .lui-checkbox__check-wrap .lui-checkbox__check, .lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse.lui-focused .lui-checkbox__check {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-checkbox--inverse.lui-checkbox--inverse.lui-checkbox--inverse.lui-disabled .lui-checkbox__check, .lui-checkbox--inverse .lui-checkbox__input:disabled + .lui-checkbox__check-wrap .lui-checkbox__check {\n  background: rgba(255, 255, 255, 0.1);\n  border-color: transparent;\n  color: rgba(255, 255, 255, 0.2);\n}\n.lui-radiobutton {\n  cursor: pointer;\n  vertical-align: middle;\n  position: relative;\n  display: block;\n}\n.lui-radiobutton__input {\n  position: absolute;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  opacity: 0;\n  z-index: -1;\n}\n.lui-radiobutton__radio-wrap {\n  display: inline-block;\n  vertical-align: middle;\n}\n.lui-radiobutton__radio-text {\n  display: inline-block;\n  vertical-align: middle;\n  padding-left: 5px;\n}\n[dir="rtl"] .lui-radiobutton__radio-text {\n  padding-left: unset;\n  padding-right: 5px;\n}\n.lui-radiobutton__radio {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  border-radius: 11px;\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  width: 22px;\n  height: 22px;\n  border-width: 1px;\n  border-style: solid;\n}\n.lui-radiobutton__radio::after {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  content: "";\n  width: 10px;\n  height: 10px;\n  border-radius: 5px;\n  position: absolute;\n  top: 5px;\n  left: 5px;\n}\n.lui-radiobutton .lui-radiobutton__radio {\n  border-color: #CCCCCC;\n  background: #FFFFFF;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-radiobutton .lui-radiobutton__radio-text {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  color: #595959;\n}\n.lui-radiobutton .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio {\n  background: #fab761;\n  border-color: transparent;\n}\n.lui-radiobutton .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after {\n  background-color: #FFFFFF;\n}\n.lui-radiobutton.lui-radiobutton.lui-radiobutton.lui-active .lui-radiobutton__radio, .lui-radiobutton.lui-radiobutton.lui-radiobutton:active .lui-radiobutton__radio, .lui-radiobutton.lui-radiobutton.lui-radiobutton .lui-radiobutton__radio:active {\n  background: #595959;\n  border-color: transparent;\n}\n.lui-radiobutton.lui-radiobutton.lui-radiobutton:hover .lui-radiobutton__radio, .lui-radiobutton.lui-radiobutton.lui-radiobutton.lui-hovered .lui-radiobutton__radio {\n  border-color: #595959;\n}\n.lui-radiobutton .lui-radiobutton__input:focus + .lui-radiobutton__radio-wrap .lui-radiobutton__radio, .lui-radiobutton.lui-radiobutton.lui-radiobutton.lui-focused .lui-radiobutton__radio {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-radiobutton.lui-radiobutton.lui-radiobutton.lui-disabled .lui-radiobutton__radio, .lui-radiobutton .lui-radiobutton__input:disabled + .lui-radiobutton__radio-wrap .lui-radiobutton__radio {\n  background: rgba(0, 0, 0, 0.1);\n  border-color: transparent;\n}\n.lui-radiobutton.lui-disabled .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after, .lui-radiobutton .lui-radiobutton__input:disabled:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after {\n  background-color: #FFFFFF;\n}\n.lui-radiobutton.lui-disabled .lui-radiobutton__radio-wrap, .lui-radiobutton .lui-radiobutton__input:disabled + .lui-radiobutton__radio-wrap {\n  cursor: default;\n}\n.lui-radiobutton--inverse .lui-radiobutton__radio {\n  border-color: transparent;\n  background: rgba(255, 255, 255, 0.3);\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-radiobutton--inverse .lui-radiobutton__radio-text {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  color: #FFFFFF;\n}\n.lui-radiobutton--inverse .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio {\n  background: #f8981d;\n  border-color: transparent;\n}\n.lui-radiobutton--inverse .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after {\n  background-color: #FFFFFF;\n}\n.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-active .lui-radiobutton__radio, .lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse:active .lui-radiobutton__radio, .lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse .lui-radiobutton__radio:active {\n  background: rgba(0, 0, 0, 0.6);\n  border-color: transparent;\n}\n.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse:hover .lui-radiobutton__radio, .lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-hovered .lui-radiobutton__radio {\n  border-color: #FFFFFF;\n}\n.lui-radiobutton--inverse .lui-radiobutton__input:focus + .lui-radiobutton__radio-wrap .lui-radiobutton__radio, .lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-focused .lui-radiobutton__radio {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-radiobutton--inverse.lui-disabled .lui-radiobutton__radio, .lui-radiobutton--inverse .lui-radiobutton__input:disabled + .lui-radiobutton__radio-wrap .lui-radiobutton__radio {\n  background: rgba(255, 255, 255, 0.1);\n  border-color: transparent;\n}\n.lui-radiobutton--inverse.lui-disabled .lui-radiobutton__input:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after, .lui-radiobutton--inverse .lui-radiobutton__input:disabled:checked + .lui-radiobutton__radio-wrap .lui-radiobutton__radio:after {\n  background-color: rgba(255, 255, 255, 0.2);\n}\n.lui-radiobutton--inverse.lui-disabled .lui-radiobutton__radio-wrap, .lui-radiobutton--inverse .lui-radiobutton__input:disabled + .lui-radiobutton__radio-wrap {\n  cursor: default;\n}\n.lui-select {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  border: solid 1px;\n  height: 28px;\n  width: 100%;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  line-height: 24px;\n  padding: 1px 30px 1px 10px;\n  min-width: 44px;\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  font-size: 13px;\n  font-weight: bold;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  background-clip: border-box;\n  border-radius: 3px;\n  outline: none;\n  cursor: pointer;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n  background-size: 10px 7px, auto auto;\n  background-origin: border-box, padding-box;\n  background-repeat: no-repeat, no-repeat;\n  background-position: right 11px top 50%, left top;\n}\n.lui-select::-moz-focus-inner {\n  border: 0;\n}\n.lui-select::-ms-expand {\n  display: none;\n}\n.lui-select:active, .lui-select.lui-active {\n  background-size: 10px 7px, auto auto;\n  background-origin: border-box;\n  background-repeat: no-repeat;\n  background-position: right 11px top 50%;\n}\n.lui-select[disabled], .lui-select.lui-disabled {\n  cursor: default;\n  background-size: 8px 5.5px, auto auto;\n  background-origin: border-box, padding-box;\n  background-repeat: no-repeat, no-repeat;\n  background-position: right 10px top 50%, left top;\n}\n.lui-select option, .lui-select optgroup {\n  color: #595959;\n  background: #FFFFFF;\n}\n.lui-select option {\n  font-weight: normal;\n  padding: 1px 9px;\n}\n.lui-select--large {\n  height: 38px;\n  font-size: 14px;\n}\n.lui-select {\n  color: #595959;\n  border-color: #B3B3B3;\n  background-color: transparent;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(transparent), to(transparent));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), linear-gradient(to bottom, transparent, transparent);\n}\n.lui-select:hover, .lui-select.lui-hovered {\n  border-color: #666666;\n}\n.lui-select:active, .lui-select.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select:focus, .lui-select.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select:focus::-ms-value, .lui-select.lui-focused::-ms-value {\n  background: none;\n  color: #595959;\n}\n.lui-select[disabled], .lui-select.lui-disabled {\n  border: solid 1px #B3B3B3;\n  color: #BFBFBF;\n  background-color: transparent;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(transparent), to(transparent));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, transparent, transparent);\n}\n.lui-select--inverse {\n  color: #FFFFFF;\n  border-color: #A6A6A6;\n  background-color: transparent;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(transparent), to(transparent));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), linear-gradient(to bottom, transparent, transparent);\n}\n.lui-select--inverse:hover, .lui-select--inverse.lui-hovered {\n  border-color: #F2F2F2;\n}\n.lui-select--inverse:active, .lui-select--inverse.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select--inverse:focus, .lui-select--inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select--inverse:focus::-ms-value, .lui-select--inverse.lui-focused::-ms-value {\n  background: none;\n  color: #FFFFFF;\n}\n.lui-select--inverse[disabled], .lui-select--inverse.lui-disabled {\n  border: solid 1px #A6A6A6;\n  color: #999999;\n  background-color: transparent;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(transparent), to(transparent));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, transparent, transparent);\n}\n.lui-select--toolbar, .lui-select--gradient {\n  color: #595959;\n  border-color: rgba(0, 0, 0, 0.2);\n  background-color: #E6E6E6;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n}\n.lui-select--toolbar:hover, .lui-select--gradient:hover, .lui-select--toolbar.lui-hovered, .lui-select--gradient.lui-hovered {\n  border-color: rgba(0, 0, 0, 0.6);\n}\n.lui-select--toolbar:active, .lui-select--gradient:active, .lui-select--toolbar.lui-active, .lui-select--gradient.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select--toolbar:focus, .lui-select--gradient:focus, .lui-select--toolbar.lui-focused, .lui-select--gradient.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select--toolbar:focus::-ms-value, .lui-select--gradient:focus::-ms-value, .lui-select--toolbar.lui-focused::-ms-value, .lui-select--gradient.lui-focused::-ms-value {\n  background: none;\n  color: #595959;\n}\n.lui-select--toolbar[disabled], .lui-select--gradient[disabled], .lui-select--toolbar.lui-disabled, .lui-select--gradient.lui-disabled {\n  border: solid 1px rgba(0, 0, 0, 0.2);\n  color: #BFBFBF;\n  background-color: #E6E6E6;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n}\n.lui-select--toolbar-inverse, .lui-select--gradient-inverse {\n  color: #FFFFFF;\n  border-color: rgba(0, 0, 0, 0.6);\n  background-color: #4D4D4D;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#666666), to(#4D4D4D));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #666666, #4D4D4D);\n}\n.lui-select--toolbar-inverse:hover, .lui-select--gradient-inverse:hover, .lui-select--toolbar-inverse.lui-hovered, .lui-select--gradient-inverse.lui-hovered {\n  border-color: rgba(0, 0, 0, 0.8);\n}\n.lui-select--toolbar-inverse:active, .lui-select--gradient-inverse:active, .lui-select--toolbar-inverse.lui-active, .lui-select--gradient-inverse.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select--toolbar-inverse:focus, .lui-select--gradient-inverse:focus, .lui-select--toolbar-inverse.lui-focused, .lui-select--gradient-inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select--toolbar-inverse:focus::-ms-value, .lui-select--gradient-inverse:focus::-ms-value, .lui-select--toolbar-inverse.lui-focused::-ms-value, .lui-select--gradient-inverse.lui-focused::-ms-value {\n  background: none;\n  color: #FFFFFF;\n}\n.lui-select--toolbar-inverse[disabled], .lui-select--gradient-inverse[disabled], .lui-select--toolbar-inverse.lui-disabled, .lui-select--gradient-inverse.lui-disabled {\n  border: solid 1px rgba(0, 0, 0, 0.6);\n  color: rgba(255, 255, 255, 0.2);\n  background-color: #4D4D4D;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#666666), to(#4D4D4D));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #666666, #4D4D4D);\n}\n.lui-select--toolbar, .lui-select--gradient {\n  color: #595959;\n  border-color: rgba(0, 0, 0, 0.2);\n  background-color: #E6E6E6;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0EyMDI0MDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0EyMDI0MTUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA5NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjBBNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+W6bLaAAAAKBJREFUeNpijIyMFGRgYJgJxCCaEvAeiNNZoIzVQLyKQgPDli1b9p4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMA3kgpizEmuD8AAAAASUVORK5CYII=\'), linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n}\n.lui-select--toolbar:hover, .lui-select--gradient:hover, .lui-select--toolbar.lui-hovered, .lui-select--gradient.lui-hovered {\n  border-color: rgba(0, 0, 0, 0.6);\n}\n.lui-select--toolbar:active, .lui-select--gradient:active, .lui-select--toolbar.lui-active, .lui-select--gradient.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select--toolbar:focus, .lui-select--gradient:focus, .lui-select--toolbar.lui-focused, .lui-select--gradient.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select--toolbar:focus::-ms-value, .lui-select--gradient:focus::-ms-value, .lui-select--toolbar.lui-focused::-ms-value, .lui-select--gradient.lui-focused::-ms-value {\n  background: none;\n  color: #595959;\n}\n.lui-select--toolbar[disabled], .lui-select--gradient[disabled], .lui-select--toolbar.lui-disabled, .lui-select--gradient.lui-disabled {\n  border: solid 1px rgba(0, 0, 0, 0.2);\n  color: #BFBFBF;\n  background-color: #E6E6E6;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n}\n.lui-select--toolbar-inverse, .lui-select--gradient-inverse {\n  color: #FFFFFF;\n  border-color: rgba(0, 0, 0, 0.6);\n  background-color: #4D4D4D;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#666666), to(#4D4D4D));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #666666, #4D4D4D);\n}\n.lui-select--toolbar-inverse:hover, .lui-select--gradient-inverse:hover, .lui-select--toolbar-inverse.lui-hovered, .lui-select--gradient-inverse.lui-hovered {\n  border-color: rgba(0, 0, 0, 0.8);\n}\n.lui-select--toolbar-inverse:active, .lui-select--gradient-inverse:active, .lui-select--toolbar-inverse.lui-active, .lui-select--gradient-inverse.lui-active {\n  color: #FFFFFF;\n  border-color: transparent;\n  background-color: rgba(0, 0, 0, 0.65);\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwNzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwODUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjA1NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjA2NTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+TyNpegAAAJpJREFUeNqk028JgDAQBfATLLAKVjCLFWaEZZlVrGAFK2iEeU8cHGN/3cFjftj9kAcbnHOKiCwHZ8/cnJUYRBbXPzDIg4jpwIx3JIjsP7BdGiGoOGcDdn47SRCZG8A53I+BtX2a2G4KRGwGs6m9HIhujgh2hL3Vgr7PS2BXrLcWENEC1KX7Y8WT2jiT+M7O8P5medT3VovzCDAAHQ/AEpCPfhwAAAAASUVORK5CYII=\');\n}\n.lui-select--toolbar-inverse:focus, .lui-select--gradient-inverse:focus, .lui-select--toolbar-inverse.lui-focused, .lui-select--gradient-inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-select--toolbar-inverse:focus::-ms-value, .lui-select--gradient-inverse:focus::-ms-value, .lui-select--toolbar-inverse.lui-focused::-ms-value, .lui-select--gradient-inverse.lui-focused::-ms-value {\n  background: none;\n  color: #FFFFFF;\n}\n.lui-select--toolbar-inverse[disabled], .lui-select--gradient-inverse[disabled], .lui-select--toolbar-inverse.lui-disabled, .lui-select--gradient-inverse.lui-disabled {\n  border: solid 1px rgba(0, 0, 0, 0.6);\n  color: rgba(255, 255, 255, 0.2);\n  background-color: #4D4D4D;\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), -webkit-gradient(linear, left top, left bottom, from(#666666), to(#4D4D4D));\n  background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0QyNjYwMzUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0QyNjYwNDUwODQxMUU1QkJFMzg2MTdBNUFDNTM1RSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjMzRDI2NjAxNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjMzRDI2NjAyNTA4NDExRTVCQkUzODYxN0E1QUM1MzVFIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+oBePfwAAAKBJREFUeNpi3L9/vyADA8NMIAbRlID3QJzOAmWsBuJVFBoY5uDg8J4JygEZWEGBYRVAw0BmMDAhCXYC8R4yDNsDNKwTxmFCdzYQ3yPBsHtQPQy4DHyProCYcMNnIAicJTI8K6BqGQgZCAvPWXgMmwVVw0CsgThdQMgHTIQSKpTGJ0a0gdhcg8vVcMBCROCDwksJic1AqYGwSHpPjEKAAAMAnKUl9RWLJ8UAAAAASUVORK5CYII=\'), linear-gradient(to bottom, #666666, #4D4D4D);\n}\n.lui-select--large {\n  height: 38px;\n  font-size: 14px;\n  padding: 1px 30px 1px 14px;\n}\n.lui-switch {\n  vertical-align: middle;\n  position: relative;\n  max-width: 40px;\n  min-width: 40px;\n  height: 22px;\n  padding-top: 5px;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.lui-switch__checkbox {\n  position: absolute;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  opacity: 0;\n  z-index: -1;\n}\n.lui-switch__label {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  height: 12px;\n  display: block;\n  overflow: hidden;\n  cursor: pointer;\n  border-width: 1px;\n  border-style: solid;\n  border-radius: 11px;\n}\n.lui-switch__inner {\n  display: inline-block;\n  width: 200%;\n  margin-left: -100%;\n  /*transition: margin 0.3s ease-in 0s;*/\n}\n[dir="rtl"] .lui-switch__inner {\n  margin-left: unset;\n  margin-right: -100%;\n}\n.lui-switch__inner:before, .lui-switch__inner:after {\n  float: left;\n  width: 50%;\n  height: 22px;\n  padding: 0;\n  font-size: 12px;\n}\n[dir="rtl"] .lui-switch__inner:before, [dir="rtl"] .lui-switch__inner:after {\n  float: right;\n}\n.lui-switch__switch {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  background-clip: padding-box;\n  border-radius: 12px;\n  width: 24px;\n  height: 24px;\n  position: absolute;\n  top: -1px;\n  right: 19px;\n  border-width: 1px;\n  border-style: solid;\n}\n[dir="rtl"] .lui-switch__switch {\n  left: 19px;\n  right: unset;\n}\n.lui-switch__checkbox:checked + .lui-switch__wrap .lui-switch__inner {\n  margin-left: 0;\n}\n[dir="rtl"] .lui-switch__checkbox:checked + .lui-switch__wrap .lui-switch__inner {\n  margin-right: 0;\n}\n.lui-switch__checkbox:checked + .lui-switch__wrap .lui-switch__switch {\n  right: -1px;\n}\n[dir="rtl"] .lui-switch__checkbox:checked + .lui-switch__wrap .lui-switch__switch {\n  left: -1px;\n  right: unset;\n}\n.lui-switch__inner:before {\n  content: "";\n}\n.lui-switch__inner:after {\n  content: "";\n  text-align: right;\n}\n[dir="rtl"] .lui-switch__inner:after {\n  text-align: left;\n}\n.lui-switch .lui-switch__label {\n  border-color: #CCCCCC;\n}\n.lui-switch .lui-switch__switch {\n  border-color: #CCCCCC;\n  background-color: #E6E6E6;\n  background-image: -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-switch .lui-switch__inner:after {\n  background: #FFFFFF;\n}\n.lui-switch .lui-switch__inner:before {\n  background: #fab761;\n}\n.lui-switch.lui-checked .lui-switch__label {\n  border-color: transparent;\n}\n.lui-switch.lui-active .lui-switch__inner:after, .lui-switch:active .lui-switch__inner:after, .lui-switch.lui-active .lui-switch__inner:before, .lui-switch:active .lui-switch__inner:before {\n  background-color: #595959;\n}\n.lui-switch .lui-switch__checkbox:focus + .lui-switch__wrap .lui-switch__switch, .lui-switch.lui-focused .lui-switch__checkbox + .lui-switch__wrap .lui-switch__switch {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-switch:hover .lui-switch__switch, .lui-switch.lui-hovered .lui-switch__switch {\n  border-color: #595959;\n}\n.lui-switch.lui-disabled .lui-switch__inner:before, .lui-switch[disabled] .lui-switch__inner:before {\n  background: #E6E6E6;\n}\n.lui-switch.lui-disabled .lui-switch__inner:after, .lui-switch[disabled] .lui-switch__inner:after {\n  background: #E6E6E6;\n}\n.lui-switch.lui-disabled:hover .lui-switch__switch, .lui-switch[disabled]:hover .lui-switch__switch {\n  border-color: #CCCCCC;\n}\n.lui-switch--inverse .lui-switch__label {\n  border-color: transparent;\n}\n.lui-switch--inverse .lui-switch__switch {\n  border-color: rgba(0, 0, 0, 0.1);\n  background-color: #E6E6E6;\n  background-image: -webkit-gradient(linear, left top, left bottom, from(#FFFFFF), to(#E6E6E6));\n  background-image: linear-gradient(to bottom, #FFFFFF, #E6E6E6);\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-switch--inverse .lui-switch__inner:after {\n  background: rgba(255, 255, 255, 0.3);\n}\n.lui-switch--inverse .lui-switch__inner:before {\n  background: #f8981d;\n}\n.lui-switch--inverse.lui-checked .lui-switch__label {\n  border-color: transparent;\n}\n.lui-switch--inverse.lui-active .lui-switch__inner:after, .lui-switch--inverse:active .lui-switch__inner:after, .lui-switch--inverse.lui-active .lui-switch__inner:before, .lui-switch--inverse:active .lui-switch__inner:before {\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.lui-switch--inverse .lui-switch__checkbox:focus + .lui-switch__wrap .lui-switch__switch, .lui-switch--inverse.lui-focused .lui-switch__checkbox + .lui-switch__wrap .lui-switch__switch {\n  border-color: #52a2cc;\n  border: 1px solid #52a2cc;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-switch--inverse:hover .lui-switch__switch, .lui-switch--inverse.lui-hovered .lui-switch__switch {\n  border-color: #000000;\n}\n.lui-switch--inverse.lui-disabled .lui-switch__inner:before, .lui-switch--inverse[disabled] .lui-switch__inner:before {\n  background: rgba(255, 255, 255, 0.1);\n}\n.lui-switch--inverse.lui-disabled .lui-switch__inner:after, .lui-switch--inverse[disabled] .lui-switch__inner:after {\n  background: rgba(255, 255, 255, 0.1);\n}\n.lui-switch--inverse.lui-disabled:hover .lui-switch__switch, .lui-switch--inverse[disabled]:hover .lui-switch__switch {\n  border-color: rgba(0, 0, 0, 0.1);\n}\n.lui-input {\n  vertical-align: middle;\n  width: 100%;\n  height: 28px;\n  display: block;\n  outline: none;\n  font-size: 13px;\n  padding: 3px 6px;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n  color: #595959;\n  background-color: #FFFFFF;\n  border-color: #B3B3B3;\n}\n.lui-input::-webkit-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis !important;\n}\n.lui-input::-moz-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis;\n}\n.lui-input:-ms-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n}\n.lui-input:hover, .lui-input.lui-hovered {\n  border-color: #666666;\n}\n.lui-input.lui-invalid {\n  border-color: #f05555;\n}\n.lui-input:focus, .lui-input.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-input:focus.lui-invalid, .lui-input.lui-focused.lui-invalid {\n  border: 1px solid #f05555;\n}\n.lui-input[disabled], .lui-input.lui-disabled {\n  color: rgba(89, 89, 89, 0.8);\n  opacity: 1;\n  -webkit-text-fill-color: rgba(89, 89, 89, 0.8);\n  background-color: #E6E6E6;\n  border-color: #B3B3B3;\n}\n.lui-input--inverse {\n  color: #FFFFFF;\n  background-color: rgba(255, 255, 255, 0.3);\n  border-color: transparent;\n}\n.lui-input--inverse::-webkit-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis !important;\n}\n.lui-input--inverse::-moz-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis;\n}\n.lui-input--inverse:-ms-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n}\n.lui-input--inverse:hover, .lui-input--inverse.lui-hovered {\n  border-color: #FFFFFF;\n}\n.lui-input--inverse.lui-invalid {\n  border-color: #f05555;\n}\n.lui-input--inverse:focus, .lui-input--inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-input--inverse:focus.lui-invalid, .lui-input--inverse.lui-focused.lui-invalid {\n  border: 1px solid #f05555;\n}\n.lui-input--inverse[disabled], .lui-input--inverse.lui-disabled {\n  color: #BFBFBF;\n  opacity: 1;\n  -webkit-text-fill-color: #BFBFBF;\n  background-color: #B3B3B3;\n  border-color: transparent;\n}\n.lui-input--large {\n  height: 38px;\n  padding: 10px;\n  font-size: 16px;\n}\n.lui-input-group {\n  vertical-align: middle;\n  height: 28px;\n  width: 100%;\n  outline: none;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  font-size: 0;\n}\n.lui-input-group .lui-input-group__item {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n  margin: 0;\n  border-radius: 0;\n}\n.lui-input-group .lui-input-group__item:invalid, .lui-input-group .lui-input-group__item.lui-invalid {\n  z-index: 1;\n}\n.lui-input-group .lui-input-group__item.lui-active, .lui-input-group .lui-input-group__item.lui-hovered, .lui-input-group .lui-input-group__item.lui-focused {\n  z-index: 2;\n}\n.lui-input-group .lui-input-group__item:hover, .lui-input-group .lui-input-group__item:active {\n  z-index: 3;\n}\n.lui-input-group .lui-input-group__item:focus {\n  z-index: 4;\n}\n.lui-input-group .lui-input-group__item:first-child {\n  border-radius: 3px 0 0 3px;\n}\n.lui-input-group .lui-input-group__item:last-child {\n  border-radius: 0 3px 3px 0;\n}\n.lui-input-group .lui-input-group__item:not(:last-child) {\n  margin-right: -1px;\n}\n[dir="rtl"] .lui-input-group .lui-input-group__item:first-child {\n  border-radius: 0 3px 3px 0;\n}\n[dir="rtl"] .lui-input-group .lui-input-group__item:last-child {\n  border-radius: 3px 0 0 3px;\n}\n[dir="rtl"] .lui-input-group .lui-input-group__item:not(:last-child) {\n  margin-right: 0;\n  margin-left: -1px;\n}\n.lui-input-group .lui-input-group__input {\n  min-width: 44px;\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n}\n.lui-input-group .lui-input-group__button {\n  color: #595959;\n  background-color: #FFFFFF;\n  border-color: #B3B3B3;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-input-group .lui-input-group__button:hover, .lui-input-group .lui-input-group__button.lui-hovered {\n  border-color: #666666;\n}\n.lui-input-group .lui-input-group__button:active, .lui-input-group .lui-input-group__button.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-input-group .lui-input-group__button[disabled], .lui-input-group .lui-input-group__button.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-input-group .lui-input-group__button:focus, .lui-input-group .lui-input-group__button.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-input-group .lui-input-group__button:focus:active, .lui-input-group .lui-input-group__button.lui-focused:active, .lui-input-group .lui-input-group__button:focus.lui-active, .lui-input-group .lui-input-group__button.lui-focused.lui-active {\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-input-group .lui-input-group__input {\n  color: #595959;\n}\n.lui-input-group--inverse .lui-input-group__button {\n  color: rgba(255, 255, 255, 0.6);\n  background-color: rgba(255, 255, 255, 0.3);\n  border-color: transparent;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n}\n.lui-input-group--inverse .lui-input-group__button:hover, .lui-input-group--inverse .lui-input-group__button.lui-hovered {\n  border-color: #FFFFFF;\n}\n.lui-input-group--inverse .lui-input-group__button:active, .lui-input-group--inverse .lui-input-group__button.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-input-group--inverse .lui-input-group__button[disabled], .lui-input-group--inverse .lui-input-group__button.lui-disabled {\n  opacity: 0.6;\n  cursor: default;\n  pointer-events: none;\n}\n.lui-input-group--inverse .lui-input-group__button:focus, .lui-input-group--inverse .lui-input-group__button.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-input-group--inverse .lui-input-group__button:focus:active, .lui-input-group--inverse .lui-input-group__button.lui-focused:active, .lui-input-group--inverse .lui-input-group__button:focus.lui-active, .lui-input-group--inverse .lui-input-group__button.lui-focused.lui-active {\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-input-group--inverse .lui-input-group__input {\n  color: #FFFFFF;\n}\n.lui-overlay-button {\n  /* remove firefox dotted outline */\n  vertical-align: middle;\n  height: 38px;\n  padding: 0 16px;\n  min-width: 38px;\n  font-size: 13px;\n  font-weight: bold;\n  text-decoration: none;\n  line-height: 24px;\n  position: relative;\n  outline: none;\n  cursor: pointer;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  border-radius: 19px;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.4);\n  border: 2px solid rgba(255, 255, 255, 0.7);\n  -webkit-transition: all 200ms ease-out;\n  transition: all 200ms ease-out;\n}\n.lui-overlay-button::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.lui-overlay-button__caret:after {\n  vertical-align: top;\n  margin-bottom: -1px;\n  padding-top: 1px;\n}\n.lui-overlay-button__text, .lui-overlay-button__icon, .lui-overlay-button__caret {\n  display: inline-block;\n  vertical-align: top;\n}\n.lui-overlay-button__text:not(:only-child), .lui-overlay-button__icon:not(:only-child), .lui-overlay-button__caret:not(:only-child) {\n  margin-left: 5px;\n  margin-right: 5px;\n}\n.lui-overlay-button__text:not(:only-child):first-child, .lui-overlay-button__icon:not(:only-child):first-child, .lui-overlay-button__caret:not(:only-child):first-child {\n  min-width: 6px;\n  margin-left: -6px;\n}\n[dir="rtl"] .lui-overlay-button__text:not(:only-child):first-child, [dir="rtl"] .lui-overlay-button__icon:not(:only-child):first-child, [dir="rtl"] .lui-overlay-button__caret:not(:only-child):first-child {\n  margin-left: 5px;\n  margin-right: -6px;\n}\n.lui-overlay-button__text:not(:only-child):last-child, .lui-overlay-button__icon:not(:only-child):last-child, .lui-overlay-button__caret:not(:only-child):last-child {\n  min-width: 6px;\n  margin-right: -6px;\n}\n[dir="rtl"] .lui-overlay-button__text:not(:only-child):last-child, [dir="rtl"] .lui-overlay-button__icon:not(:only-child):last-child, [dir="rtl"] .lui-overlay-button__caret:not(:only-child):last-child {\n  margin-left: -6px;\n  margin-right: 5px;\n}\n.lui-overlay-button__text + .lui-overlay-button__caret:last-child {\n  margin-left: 15px;\n  margin-right: -6px;\n}\n[dir="rtl"] .lui-overlay-button__text + .lui-overlay-button__caret:last-child {\n  margin-left: -6px;\n  margin-right: 15px;\n}\n.lui-overlay-button__icon:only-child, .lui-overlay-button__caret:only-child {\n  margin-left: -6px;\n  margin-right: -6px;\n  min-width: 18px;\n}\n.lui-overlay-button__icon:only-child, .lui-overlay-button__caret:only-child {\n  margin-left: -8px;\n  margin-right: -8px;\n  min-width: 18px;\n}\n.lui-overlay-button:hover, .lui-overlay-button.lui-hovered {\n  background-color: rgba(0, 0, 0, 0.6);\n  border-color: #FFFFFF;\n}\n.lui-overlay-button:active, .lui-overlay-button.lui-active {\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.65);\n  border-color: transparent;\n  -webkit-box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n          box-shadow: 0 1px 0 rgba(255, 255, 255, 0.25);\n}\n.lui-overlay-button:focus, .lui-overlay-button.lui-focused {\n  border: 2px solid #52a2cc;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  -webkit-transition: none;\n  transition: none;\n}\n.lui-overlay-button[disabled], .lui-overlay-button.lui-disabled {\n  color: #999999;\n  border-color: rgba(255, 255, 255, 0.7);\n  background-color: rgba(0, 0, 0, 0.4);\n  cursor: default;\n  pointer-events: none;\n}\n.lui-overlay-button--block {\n  width: 100%;\n  padding-left: 40px;\n  padding-right: 40px;\n  white-space: nowrap;\n}\n.lui-overlay-button--block.lui-overlay-button--block.lui-overlay-button--block .lui-overlay-button__text, .lui-overlay-button--block.lui-overlay-button--block.lui-overlay-button--block .lui-overlay-button__icon, .lui-overlay-button--block.lui-overlay-button--block.lui-overlay-button--block .lui-overlay-button__caret {\n  margin-left: 0;\n  margin-right: 0;\n  min-width: unset;\n}\n.lui-overlay-button--block .lui-overlay-button__text {\n  text-overflow: ellipsis;\n  display: inline-block;\n  white-space: nowrap;\n  overflow: hidden;\n  width: 100%;\n  vertical-align: top;\n}\n.lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):first-child, .lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):first-child {\n  position: absolute;\n  left: 10px;\n}\n[dir="rtl"] .lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):first-child, [dir="rtl"] .lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):first-child, [dir="rtl"].lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):first-child, [dir="rtl"].lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):first-child {\n  left: auto;\n  right: 10px;\n}\n.lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):last-child, .lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):last-child {\n  position: absolute;\n  right: 10px;\n}\n[dir="rtl"] .lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):last-child, [dir="rtl"] .lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):last-child, [dir="rtl"].lui-overlay-button--block .lui-overlay-button__icon:not(:only-child):last-child, [dir="rtl"].lui-overlay-button--block .lui-overlay-button__caret:not(:only-child):last-child {\n  left: 10px;\n  right: auto;\n}\n.lui-overlay-button--small {\n  height: 26px;\n  min-width: 26px;\n  line-height: 20px;\n  font-size: 12px;\n  padding: 0 10px;\n}\n.lui-search {\n  height: 38px;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex-align: center;\n  -webkit-box-align: center;\n          align-items: center;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #595959;\n  background-color: #FFFFFF;\n}\n.lui-search .lui-search__input {\n  color: #595959;\n}\n.lui-search .lui-search__input::-webkit-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: italic;\n  text-overflow: ellipsis !important;\n}\n.lui-search .lui-search__input::-moz-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: italic;\n  text-overflow: ellipsis;\n}\n.lui-search .lui-search__input:-ms-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: italic;\n}\n.lui-search .lui-search__search-icon, .lui-search .lui-search__clear-icon {\n  color: #595959;\n}\n.lui-search .lui-search__clear-button {\n  color: rgba(89, 89, 89, 0.8);\n}\n.lui-search .lui-search__clear-button:hover, .lui-search .lui-search__clear-button:active, .lui-search .lui-search__clear-button:focus {\n  color: #595959;\n}\n.lui-search__input {\n  height: 38px;\n  width: 100%;\n  min-width: 0;\n  padding: 0;\n  border: none;\n  background: transparent;\n  color: inherit;\n  font-size: 13px;\n  outline: 0;\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  border-radius: 0;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  /* Fix for IE duplicate remove icons */\n}\n.lui-search__input::-ms-clear {\n  display: none;\n}\n.lui-search__clear-button {\n  /* remove firefox dotted outline */\n  -ms-flex: 0 0 32px;\n  -webkit-box-flex: 0;\n          flex: 0 0 32px;\n  text-align: center;\n  height: 100%;\n  background-color: transparent;\n  border: none;\n  cursor: pointer;\n  outline: none;\n  -webkit-transition: color 200ms ease-out;\n  transition: color 200ms ease-out;\n}\n.lui-search__clear-button::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\n.lui-search__clear-icon {\n  display: inline-block;\n  font-family: "LUI icons";\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  text-decoration: inherit;\n  text-transform: none;\n  direction: ltr;\n  line-height: 38px;\n  -ms-flex: 0 0 32px;\n  -webkit-box-flex: 0;\n          flex: 0 0 32px;\n  text-align: center;\n  font-size: 12px;\n  cursor: pointer;\n}\n.lui-search__clear-icon:before {\n  content: "\\2030";\n}\n.lui-search__search-icon {\n  display: inline-block;\n  font-family: "LUI icons";\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  text-decoration: inherit;\n  text-transform: none;\n  direction: ltr;\n  line-height: 38px;\n  -ms-flex: 0 0 32px;\n  -webkit-box-flex: 0;\n          flex: 0 0 32px;\n  text-align: center;\n  cursor: default;\n}\n.lui-search__search-icon:before {\n  content: "F";\n}\n.lui-search--inverse {\n  color: #FFFFFF;\n  background-color: rgba(255, 255, 255, 0.3);\n}\n.lui-search--inverse .lui-search__input {\n  color: #FFFFFF;\n}\n.lui-search--inverse .lui-search__input::-webkit-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: italic;\n  text-overflow: ellipsis !important;\n}\n.lui-search--inverse .lui-search__input::-moz-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: italic;\n  text-overflow: ellipsis;\n}\n.lui-search--inverse .lui-search__input:-ms-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: italic;\n}\n.lui-search--inverse .lui-search__search-icon, .lui-search--inverse .lui-search__clear-icon {\n  color: rgba(255, 255, 255, 0.6);\n}\n.lui-search--inverse .lui-search__clear-button {\n  color: rgba(255, 255, 255, 0.8);\n}\n.lui-search--inverse .lui-search__clear-button:hover, .lui-search--inverse .lui-search__clear-button:active, .lui-search--inverse .lui-search__clear-button:focus {\n  color: #FFFFFF;\n}\n.lui-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n.lui-list__header {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  font-weight: bold;\n  min-height: 23px;\n}\n.lui-list__header:after {\n  content: "";\n  min-height: 23px;\n  display: block;\n}\n.lui-list__item {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  min-height: 37px;\n}\n.lui-list__item:after {\n  content: "";\n  min-height: 37px;\n  display: block;\n}\n.lui-list__text {\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n  -ms-grid-row-align: center;\n  align-self: center;\n  padding: 0 10px;\n}\n.lui-list__aside {\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n  -ms-grid-row-align: center;\n  align-self: center;\n  padding: 0 10px;\n}\n.lui-list__text--ellipsis {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n.lui-list__aside + .lui-list__text {\n  padding-left: 0;\n}\n.lui-list__text + .lui-list__aside {\n  padding-left: 0;\n}\n[dir="rtl"] .lui-list__aside + .lui-list__text {\n  padding-left: 10px;\n  padding-right: 0;\n}\n[dir="rtl"] .lui-list__text + .lui-list__aside {\n  padding-left: 10px;\n  padding-right: 0;\n}\n.lui-list .lui-list__header {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  background-color: rgba(0, 0, 0, 0.05);\n  color: #595959;\n}\n.lui-list .lui-list__item {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.1);\n  background-clip: padding-box;\n  background-color: transparent;\n  color: #595959;\n  -webkit-transition: background-color 50ms ease-out;\n  transition: background-color 50ms ease-out;\n}\n.lui-list .lui-list__item:hover, .lui-list .lui-list__item.lui-hover {\n  background-color: rgba(0, 0, 0, 0.05);\n}\n.lui-list .lui-list__item.lui-disabled {\n  color: rgba(89, 89, 89, 0.3);\n  background-color: transparent;\n}\n.lui-list .lui-list__item.lui-selected {\n  background-color: #F2F2F2;\n}\n.lui-list .lui-list__item.lui-active {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n.lui-list--inverse .lui-list__header {\n  border-bottom: 1px solid rgba(255, 255, 255, 0.15);\n  background-color: rgba(255, 255, 255, 0.1);\n  color: #FFFFFF;\n}\n.lui-list--inverse .lui-list__item {\n  border-bottom: 1px solid rgba(255, 255, 255, 0.15);\n  background-clip: padding-box;\n  background-color: transparent;\n  color: rgba(255, 255, 255, 0.8);\n  -webkit-transition: background-color 50ms ease-out;\n  transition: background-color 50ms ease-out;\n}\n.lui-list--inverse .lui-list__item:hover, .lui-list--inverse .lui-list__item.lui-hover {\n  background-color: rgba(255, 255, 255, 0.05);\n}\n.lui-list--inverse .lui-list__item.lui-disabled {\n  color: rgba(255, 255, 255, 0.4);\n  background-color: transparent;\n}\n.lui-list--inverse .lui-list__item.lui-selected {\n  background-color: #F2F2F2;\n}\n.lui-list--inverse .lui-list__item.lui-active {\n  background-color: rgba(0, 0, 0, 0.1);\n}\n.lui-popover {\n  position: relative;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex-direction: column;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n          flex-direction: column;\n  border-radius: 3px;\n  margin: auto;\n  min-width: 250px;\n  border: 1px solid transparent;\n  -webkit-transition: opacity 200ms ease-out;\n  transition: opacity 200ms ease-out;\n  opacity: 1;\n  z-index: 1021;\n  color: #595959;\n  background-color: #FFFFFF;\n  border-color: #808080;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);\n}\n.lui-popover.lui-fade {\n  opacity: 0;\n}\n.lui-popover .lui-popover__arrow--left:before {\n  border-right-color: #808080;\n}\n.lui-popover .lui-popover__arrow--left:after {\n  border-right-color: #FFFFFF;\n}\n.lui-popover .lui-popover__arrow--right:before {\n  border-left-color: #808080;\n}\n.lui-popover .lui-popover__arrow--right:after {\n  border-left-color: #FFFFFF;\n}\n.lui-popover .lui-popover__arrow--top:before {\n  border-bottom-color: #808080;\n}\n.lui-popover .lui-popover__arrow--top:after {\n  border-bottom-color: #FFFFFF;\n}\n.lui-popover .lui-popover__arrow--bottom:before {\n  border-top-color: #808080;\n}\n.lui-popover .lui-popover__arrow--bottom:after {\n  border-top-color: #FFFFFF;\n}\n.lui-popover .lui-popover__header, .lui-popover .lui-popover__footer {\n  background-color: #FBFBFB;\n}\n.lui-popover .lui-popover__header {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.2);\n}\n.lui-popover .lui-popover__footer {\n  border-top: 1px solid rgba(0, 0, 0, 0.2);\n}\n.lui-popover--inverse {\n  color: #FFFFFF;\n  background-color: #404040;\n  border-color: #333333;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);\n          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);\n}\n.lui-popover--inverse .lui-popover__arrow--left:before {\n  border-right-color: #333333;\n}\n.lui-popover--inverse .lui-popover__arrow--left:after {\n  border-right-color: #404040;\n}\n.lui-popover--inverse .lui-popover__arrow--right:before {\n  border-left-color: #333333;\n}\n.lui-popover--inverse .lui-popover__arrow--right:after {\n  border-left-color: #404040;\n}\n.lui-popover--inverse .lui-popover__arrow--top:before {\n  border-bottom-color: #333333;\n}\n.lui-popover--inverse .lui-popover__arrow--top:after {\n  border-bottom-color: #404040;\n}\n.lui-popover--inverse .lui-popover__arrow--bottom:before {\n  border-top-color: #333333;\n}\n.lui-popover--inverse .lui-popover__arrow--bottom:after {\n  border-top-color: #404040;\n}\n.lui-popover--inverse .lui-popover__header, .lui-popover--inverse .lui-popover__footer {\n  background-color: #474747;\n}\n.lui-popover--inverse .lui-popover__header {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.3);\n}\n.lui-popover--inverse .lui-popover__footer {\n  border-top: 1px solid rgba(0, 0, 0, 0.3);\n}\n.lui-popover__arrow {\n  position: absolute;\n}\n.lui-popover__arrow:before {\n  content: "";\n  position: absolute;\n  width: 0;\n  height: 0;\n}\n.lui-popover__arrow:after {\n  content: "";\n  position: absolute;\n  width: 0;\n  height: 0;\n}\n.lui-popover__arrow--left {\n  left: 0;\n  top: 50%;\n}\n.lui-popover__arrow--left:before {\n  top: -8px;\n  right: 0;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-right: 8px solid transparent;\n}\n.lui-popover__arrow--left:after {\n  top: -8px;\n  right: -1px;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-right: 8px solid transparent;\n}\n.lui-popover__arrow--right {\n  right: 0;\n  top: 50%;\n}\n.lui-popover__arrow--right:before {\n  top: -8px;\n  left: 0;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-left: 8px solid transparent;\n}\n.lui-popover__arrow--right:after {\n  top: -8px;\n  left: -1px;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-left: 8px solid transparent;\n}\n.lui-popover__arrow--top {\n  top: 0;\n  left: 50%;\n}\n.lui-popover__arrow--top:before {\n  left: -8px;\n  bottom: 0;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n}\n.lui-popover__arrow--top:after {\n  left: -8px;\n  bottom: -1px;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n}\n.lui-popover__arrow--bottom {\n  bottom: 0;\n  left: 50%;\n}\n.lui-popover__arrow--bottom:before {\n  left: -8px;\n  top: 0;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-top: 8px solid transparent;\n}\n.lui-popover__arrow--bottom:after {\n  left: -8px;\n  top: -1px;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-top: 8px solid transparent;\n}\n.lui-popover__header {\n  font-size: 14px;\n  font-weight: bold;\n  height: 44px;\n  padding: 8px;\n  line-height: 28px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n}\n.lui-popover__body {\n  -ms-flex: 1 1 auto;\n  -webkit-box-flex: 1;\n          flex: 1 1 auto;\n  padding: 20px;\n}\n.lui-popover__footer {\n  height: 44px;\n  padding: 8px;\n  text-align: right;\n  border-bottom-left-radius: 3px;\n  border-bottom-right-radius: 3px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n}\n.lui-popover__footer .lui-button {\n  margin: 0 3px;\n}\n.lui-popover__footer .lui-button:last-child {\n  margin-right: 0;\n}\n[dir="rtl"] .lui-popover__footer .lui-button:last-child {\n  margin-right: 3px;\n  margin-left: 0;\n}\n[dir="rtl"] .lui-popover__footer {\n  text-align: left;\n}\n.lui-popover__title {\n  margin-left: 12px;\n  margin-right: 12px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.lui-textarea {\n  vertical-align: middle;\n  width: 100%;\n  display: block;\n  outline: none;\n  font-size: 13px;\n  height: inherit;\n  min-height: 28px;\n  padding: 6px 6px 4px 6px;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  -webkit-transition: border-color 200ms ease-out;\n  transition: border-color 200ms ease-out;\n  overflow-y: auto;\n  overflow-x: hidden;\n  resize: vertical;\n  color: #595959;\n  background-color: #FFFFFF;\n  border-color: #B3B3B3;\n}\n.lui-textarea::-webkit-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis !important;\n}\n.lui-textarea::-moz-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis;\n}\n.lui-textarea:-ms-input-placeholder {\n  color: rgba(89, 89, 89, 0.6);\n  font-style: normal;\n}\n.lui-textarea:hover, .lui-textarea.lui-hovered {\n  border-color: #666666;\n}\n.lui-textarea.lui-invalid {\n  border-color: #f05555;\n}\n.lui-textarea:focus, .lui-textarea.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-textarea:focus.lui-invalid, .lui-textarea.lui-focused.lui-invalid {\n  border: 1px solid #f05555;\n}\n.lui-textarea[disabled], .lui-textarea.lui-disabled {\n  color: rgba(89, 89, 89, 0.8);\n  opacity: 1;\n  -webkit-text-fill-color: rgba(89, 89, 89, 0.8);\n  background-color: #E6E6E6;\n  border-color: #B3B3B3;\n}\n.lui-textarea--inverse {\n  color: #FFFFFF;\n  background-color: rgba(255, 255, 255, 0.3);\n  border-color: transparent;\n}\n.lui-textarea--inverse::-webkit-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis !important;\n}\n.lui-textarea--inverse::-moz-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n  text-overflow: ellipsis;\n}\n.lui-textarea--inverse:-ms-input-placeholder {\n  color: rgba(255, 255, 255, 0.6);\n  font-style: normal;\n}\n.lui-textarea--inverse:hover, .lui-textarea--inverse.lui-hovered {\n  border-color: #FFFFFF;\n}\n.lui-textarea--inverse.lui-invalid {\n  border-color: #f05555;\n}\n.lui-textarea--inverse:focus, .lui-textarea--inverse.lui-focused {\n  border: 1px solid #52a2cc;\n  -webkit-transition: none;\n  transition: none;\n  -webkit-box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n          box-shadow: 0 0 1px 1px rgba(82, 162, 204, 0.7);\n}\n.lui-textarea--inverse:focus.lui-invalid, .lui-textarea--inverse.lui-focused.lui-invalid {\n  border: 1px solid #f05555;\n}\n.lui-textarea--inverse[disabled], .lui-textarea--inverse.lui-disabled {\n  color: #BFBFBF;\n  opacity: 1;\n  -webkit-text-fill-color: #BFBFBF;\n  background-color: #B3B3B3;\n  border-color: transparent;\n}\n.lui-toast-container {\n  position: fixed;\n  bottom: 20px;\n  left: 0;\n  right: 0;\n  margin: 0 auto;\n}\n.lui-toast {\n  min-height: 28px;\n  max-width: 400px;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  margin: 10px auto 0 auto;\n  border-radius: 3px;\n  font-size: 13px;\n  position: relative;\n  -webkit-transition: all 200ms ease-out;\n  transition: all 200ms ease-out;\n  opacity: 1;\n  z-index: 1021;\n  -ms-flex-pack: center;\n  -webkit-box-pack: center;\n          justify-content: center;\n  color: rgba(255, 255, 255, 0.8);\n  background-color: #0D0D0D;\n}\n.lui-toast.lui-fade {\n  opacity: 0;\n  bottom: -50px;\n}\n.lui-toast__text {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex: 1 1 100%;\n  -webkit-box-flex: 1;\n          flex: 1 1 100%;\n  -ms-flex-align: center;\n  -webkit-box-align: center;\n          align-items: center;\n  padding: 5px 10px;\n  cursor: default;\n}\n.lui-toast__aside {\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: flex;\n  -ms-flex: 0 0 auto;\n  -webkit-box-flex: 0;\n          flex: 0 0 auto;\n  -ms-flex-align: center;\n  -webkit-box-align: center;\n          align-items: center;\n  border-left: 1px solid rgba(255, 255, 255, 0.15);\n  padding: 5px 10px;\n  cursor: pointer;\n}\n.lui-toast-service {\n  visibility: hidden;\n  position: fixed;\n  bottom: 30px;\n  left: 0;\n  right: 0;\n  margin: 0 auto;\n}\n.lui-toast-show-animation {\n  -webkit-transition: all 500ms ease;\n  transition: all 500ms ease;\n  -webkit-transform: translate(0px, 0px);\n  transform: translate(0px, 0px);\n  opacity: 1;\n  visibility: visible;\n}\n.lui-toast-prepare-animation {\n  -webkit-transition: all 0ms ease;\n  transition: all 0ms ease;\n  -webkit-transform: translate(0px, 100%);\n  transform: translate(0px, 100%);\n  opacity: 0;\n  visibility: hidden;\n}\n.lui-toast-hide-animation {\n  -webkit-transition: all 500ms ease;\n  transition: all 500ms ease;\n  -webkit-transform: translate(0px, 0px);\n  transform: translate(0px, 0px);\n  opacity: 0;\n  visibility: hidden;\n}\n.lui-tooltip__arrow {\n  position: absolute;\n}\n.lui-tooltip__arrow:after {\n  content: "";\n  position: absolute;\n  width: 0;\n  height: 0;\n}\n.lui-tooltip__arrow--left {\n  left: 0;\n  top: 50%;\n}\n.lui-tooltip__arrow--left:after {\n  top: -8px;\n  right: 0;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-right: 8px solid rgba(0, 0, 0, 0.9);\n}\n.lui-tooltip__arrow--right {\n  right: 0;\n  top: 50%;\n}\n.lui-tooltip__arrow--right:after {\n  top: -8px;\n  left: 0;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-left: 8px solid rgba(0, 0, 0, 0.9);\n}\n.lui-tooltip__arrow--top {\n  top: 0;\n  left: 50%;\n}\n.lui-tooltip__arrow--top:after {\n  left: -8px;\n  bottom: 0;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 8px solid rgba(0, 0, 0, 0.9);\n}\n.lui-tooltip__arrow--bottom {\n  bottom: 0;\n  left: 50%;\n}\n.lui-tooltip__arrow--bottom:after {\n  left: -8px;\n  top: 0;\n  border-left: 8px solid transparent;\n  border-right: 8px solid transparent;\n  border-top: 8px solid rgba(0, 0, 0, 0.9);\n}\n.lui-tooltip {\n  min-height: 28px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  padding: 5px 10px;\n  border-radius: 3px;\n  font-size: 13px;\n  position: relative;\n  -webkit-transition: opacity 50ms ease-out;\n  transition: opacity 50ms ease-out;\n  opacity: 1;\n  z-index: 1021;\n  color: #FFFFFF;\n  background-color: rgba(0, 0, 0, 0.9);\n}\n.lui-tooltip.lui-fade {\n  opacity: 0;\n}\n.lui-icon {\n  display: inline-block;\n  font-family: "LUI icons";\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  text-decoration: inherit;\n  text-transform: none;\n  direction: ltr;\n}\n.lui-icon--small {\n  font-size: 12px;\n}\n.lui-icon--large {\n  font-size: 20px;\n}\n.lui-icon--sheet:before {\n  content: "4";\n}\n.lui-icon--object:before {\n  content: "5";\n}\n.lui-icon--image:before {\n  content: "0";\n}\n.lui-icon--clear-selections:before {\n  content: ":";\n}\n.lui-icon--selections-tool:before {\n  content: "9";\n}\n.lui-icon--bookmark:before {\n  content: ">";\n}\n.lui-icon--back:before {\n  content: "B";\n}\n.lui-icon--forward:before {\n  content: "C";\n}\n.lui-icon--history:before {\n  content: "A";\n}\n.lui-icon--help:before {\n  content: "D";\n}\n.lui-icon--info:before {\n  content: "]";\n}\n.lui-icon--toggle-left:before {\n  content: "i";\n}\n.lui-icon--toggle-right:before {\n  content: "h";\n}\n.lui-icon--selections-reload:before {\n  content: ";";\n}\n.lui-icon--text:before {\n  content: "/";\n}\n.lui-icon--group:before {\n  content: "X";\n}\n.lui-icon--search:before {\n  content: "F";\n}\n.lui-icon--zoom-in:before {\n  content: "Y";\n}\n.lui-icon--zoom-out:before {\n  content: "Z";\n}\n.lui-icon--selections-back:before {\n  content: "<";\n}\n.lui-icon--selections-forward:before {\n  content: "=";\n}\n.lui-icon--export:before {\n  content: "I";\n}\n.lui-icon--lock:before {\n  content: "[";\n}\n.lui-icon--unlock:before {\n  content: "\\\\";\n}\n.lui-icon--database:before {\n  content: "H";\n}\n.lui-icon--calendar:before {\n  content: "G";\n}\n.lui-icon--field:before {\n  content: "-";\n}\n.lui-icon--expression:before {\n  content: "3";\n}\n.lui-icon--library:before {\n  content: "\\ED";\n}\n.lui-icon--debug:before {\n  content: "u";\n}\n.lui-icon--script-ok:before {\n  content: "\\DF";\n}\n.lui-icon--grid-large:before {\n  content: "*";\n}\n.lui-icon--star:before {\n  content: "\\EF";\n}\n.lui-icon--print:before {\n  content: "r";\n}\n.lui-icon--remove:before {\n  content: "E";\n}\n.lui-icon--handle:before {\n  content: "o";\n}\n.lui-icon--handle-horizontal:before {\n  content: "\\FB";\n}\n.lui-icon--menu:before {\n  content: "\\D4";\n}\n.lui-icon--list:before {\n  content: "\\EE";\n}\n.lui-icon--unordered-list:before {\n  content: "\\A8";\n}\n.lui-icon--bar-chart:before {\n  content: "!";\n}\n.lui-icon--bar-chart-horizontal:before {\n  content: "\\"";\n}\n.lui-icon--clock:before {\n  content: "\\F5";\n}\n.lui-icon--line-chart:before {\n  content: "%";\n}\n.lui-icon--pie-chart:before {\n  content: "&";\n}\n.lui-icon--gauge-chart:before {\n  content: ")";\n}\n.lui-icon--kpi:before {\n  content: "1";\n}\n.lui-icon--scatter-chart:before {\n  content: "+";\n}\n.lui-icon--map:before {\n  content: ",";\n}\n.lui-icon--puzzle:before {\n  content: "g";\n}\n.lui-icon--table:before {\n  content: "\'";\n}\n.lui-icon--pivot-table:before {\n  content: "(";\n}\n.lui-icon--filterpane:before {\n  content: ".";\n}\n.lui-icon--treemap:before {\n  content: "\\BB";\n}\n.lui-icon--combo-chart:before {\n  content: "\\201A";\n}\n.lui-icon--waterfallchart:before {\n  content: "\\2692";\n}\n.lui-icon--plus:before {\n  content: "P";\n}\n.lui-icon--minus:before {\n  content: "Q";\n}\n.lui-icon--triangle-top:before {\n  content: "R";\n}\n.lui-icon--triangle-bottom:before {\n  content: "S";\n}\n.lui-icon--triangle-left:before {\n  content: "T";\n}\n.lui-icon--triangle-right:before {\n  content: "U";\n}\n.lui-icon--run-script:before {\n  content: "l";\n}\n.lui-icon--tick:before {\n  content: "m";\n}\n.lui-icon--cogwheel:before {\n  content: "V";\n}\n.lui-icon--settings:before {\n  content: "\\A8";\n}\n.lui-icon--data-model:before {\n  content: "7";\n}\n.lui-icon--script:before {\n  content: "8";\n}\n.lui-icon--sense:before {\n  content: "q";\n}\n.lui-icon--cut:before {\n  content: "\\B5";\n}\n.lui-icon--copy:before {\n  content: "\\B6";\n}\n.lui-icon--paste:before {\n  content: "\\2202";\n}\n.lui-icon--align-left:before {\n  content: "M";\n}\n.lui-icon--align-center:before {\n  content: "O";\n}\n.lui-icon--align-right:before {\n  content: "N";\n}\n.lui-icon--bold:before {\n  content: "J";\n}\n.lui-icon--italic:before {\n  content: "K";\n}\n.lui-icon--underline:before {\n  content: "L";\n}\n.lui-icon--select-alternative:before {\n  content: "\\F6";\n}\n.lui-icon--select-possible:before {\n  content: "9";\n}\n.lui-icon--select-excluded:before {\n  content: "x";\n}\n.lui-icon--select-all:before {\n  content: "|";\n}\n.lui-icon--camera:before {\n  content: "\\C5";\n}\n.lui-icon--slide-show:before {\n  content: "\\C7";\n}\n.lui-icon--palette:before {\n  content: "\\DC";\n}\n.lui-icon--shapes:before {\n  content: "\\C9";\n}\n.lui-icon--effects:before {\n  content: "\\D1";\n}\n.lui-icon--file:before {\n  content: "p";\n}\n.lui-icon--expand:before {\n  content: "s";\n}\n.lui-icon--collapse:before {\n  content: "t";\n}\n.lui-icon--bin:before {\n  content: "\\D6";\n}\n.lui-icon--link:before {\n  content: "\\E9";\n}\n.lui-icon--pivot:before {\n  content: "\\2022";\n}\n.lui-icon--reload:before {\n  content: "b";\n}\n.lui-icon--add:before {\n  content: "\\FA";\n}\n.lui-icon--edit:before {\n  content: "@";\n}\n.lui-icon--lasso:before {\n  content: "\\2014";\n}\n.lui-icon--key:before {\n  content: "\\AE";\n}\n.lui-icon--box:before {\n  content: "\\F2";\n}\n.lui-icon--home:before {\n  content: "\\FC";\n}\n.lui-icon--person:before {\n  content: "y";\n}\n.lui-icon--stream:before {\n  content: "\\E3";\n}\n.lui-icon--next:before {\n  content: "\\EB";\n}\n.lui-icon--grid:before {\n  content: "\\EC";\n}\n.lui-icon--cloud:before {\n  content: "\\2021";\n}\n.lui-icon--more:before {\n  content: "\\A5";\n}\n.lui-icon--import:before {\n  content: "\\AB";\n}\n.lui-icon--folder:before {\n  content: "\\F1";\n}\n.lui-icon--auto-layout:before {\n  content: "\\F3";\n}\n.lui-icon--toggle-bottom:before {\n  content: "j";\n}\n.lui-icon--drop:before {\n  content: "\\2211";\n}\n.lui-icon--play:before {\n  content: "\\B0";\n}\n.lui-icon--tag:before {\n  content: "z";\n}\n.lui-icon--close:before {\n  content: "\\2030";\n}\n.lui-icon--direct-discovery:before {\n  content: "\\FF";\n}\n.lui-icon--warning:before {\n  content: "\\F9";\n}\n.lui-icon--warning-triangle:before {\n  content: "\\E8";\n}\n.lui-icon--share:before {\n  content: "\\2D8";\n}\n.lui-icon--top:before {\n  content: "\\2D9";\n}\n.lui-icon--low-resolution:before {\n  content: "^";\n}\n.lui-icon--high-resolution:before {\n  content: "_";\n}\n.lui-icon--view:before {\n  content: "\\2020";\n}\n.lui-icon--control:before {\n  content: "\\DA";\n}\n.lui-icon--code:before {\n  content: "\\2191";\n}\n.lui-icon--upload:before {\n  content: "\\2139";\n}\n.lui-icon--repair:before {\n  content: "\\C2";\n}\n.lui-icon--split:before {\n  content: "\\2192";\n}\n.lui-icon--up-down:before {\n  content: "e";\n}\n.lui-icon--disconnect:before {\n  content: "\\D5";\n}\n.lui-icon--photo-library:before {\n  content: "\\2193";\n}\n.lui-icon--application:before {\n  content: "\\CF";\n}\n.lui-icon--new-tab:before {\n  content: "w";\n}\n.lui-icon--ascending:before {\n  content: "\\2206";\n}\n.lui-icon--descending:before {\n  content: "\\2248";\n}\n.lui-icon--arrow-up:before {\n  content: "\\2DC";\n}\n.lui-icon--arrow-down:before {\n  content: "\\AF";\n}\n.lui-icon--arrow-right:before {\n  content: "\\EB";\n}\n.lui-icon--arrow-left:before {\n  content: "\\EA";\n}\n.lui-icon--sync:before {\n  content: "\\F4";\n}\n.lui-icon--draggable:before {\n  content: "\\21B3";\n}\n.lui-icon--book:before {\n  content: "\\2295";\n}\n.lui-icon--measure:before {\n  content: "\\2296";\n}\n.lui-icon--download:before {\n  content: "\\229E";\n}\n.lui-icon--more-rounded:before {\n  content: "\\229F";\n}\n.lui-icon--align-object-left:before {\n  content: "\\2302";\n}\n.lui-icon--align-object-center:before {\n  content: "\\2328";\n}\n.lui-icon--align-object-right:before {\n  content: "\\232B";\n}\n.lui-icon--submit:before {\n  content: "\\2016";\n}\n.lui-icon--operators:before {\n  content: "\\23E9";\n}\n.lui-icon--general-data-class:before {\n  content: "\\23EA";\n}\n.lui-icon--building:before {\n  content: "\\23ED";\n}\n.lui-icon--bell:before {\n  content: "\\23EE";\n}\n.lui-icon--unlink:before {\n  content: "\\23F3";\n}\n.lui-icon--lightbulb:before {\n  content: "\\23F4";\n}\n.lui-icon--associate:before {\n  content: "\\23F5";\n}\n.lui-icon--break-association:before {\n  content: "\\23F6";\n}\n.lui-icon--log-out:before {\n  content: "\\2264";\n}\n.lui-icon--log-in:before {\n  content: "\\D3";\n}\n.lui-icon--previous:before {\n  content: "\\EA";\n}\n.lui-icon--more-rounded:before {\n  content: "\\229F";\n}\n.lui-icon--mashup:before {\n  content: "\\23F7";\n}\n.lui-icon--widget:before {\n  content: "\\25A0";\n}\n.lui-icon--goto:before {\n  content: "\\DB";\n}\n.lui-icon--paperclip:before {\n  content: "\\E0";\n}\n.lui-icon--save:before {\n  content: "\\CD";\n}\n.lui-icon--compass:before {\n  content: "\\201D";\n}\n.lui-icon--plugin:before {\n  content: "\\2018";\n}\n.lui-icon--dimension-collection:before {\n  content: "\\2019";\n}\n.lui-icon--transfer:before {\n  content: "\\F7";\n}\n.lui-icon--analyze:before {\n  content: "\\25CA";\n}\n.lui-icon--direct-discovery-field:before {\n  content: "\\FF";\n}\n.lui-icon--setup-file:before {\n  content: "\\178";\n}\n.lui-icon--objects:before {\n  content: "\\2044";\n}\n.lui-icon--pause:before {\n  content: "\\20AC";\n}\n.lui-icon--step-over:before {\n  content: "\\2039";\n}\n.lui-icon--collapse-disclosure:before {\n  content: "\\203A";\n}\n.lui-icon--expand-disclosure:before {\n  content: "\\FB01";\n}\n.lui-icon--default:before {\n  content: "\\FB02";\n}\n.lui-icon--idle:before {\n  content: "\\B7";\n}\n.lui-icon--configuration-map:before {\n  content: "\\201E";\n}\n.lui-icon--uninstall:before {\n  content: "\\CA";\n}\n.lui-icon--extract-from-source:before {\n  content: "\\C1";\n}\n.lui-icon--waiting-field:before {\n  content: "\\CB";\n}\n.lui-icon--waiting-sheet:before {\n  content: "\\C8";\n}\n.lui-icon--kpi-object:before {\n  content: "\\CC";\n}\n.lui-icon--disabled:before {\n  content: "\\F8FF";\n}\n.lui-icon--variables:before {\n  content: "\\D2";\n}\n.lui-icon--controls:before {\n  content: "\\DA";\n}\n.lui-icon--directional-arrow-right:before {\n  content: "\\D9";\n}\n.lui-icon--directional-arrow-left:before {\n  content: "\\131";\n}\n.lui-icon--hub-oem:before {\n  content: "\\2C6";\n}\n.lui-icon--embed:before {\n  content: "\\2DA";\n}\n.lui-icon--chart:before {\n  content: "\\2DB";\n}\n.lui-icon--run:before {\n  content: "\\153";\n}\n.lui-icon--step-in:before {\n  content: "\\152";\n}\n.lui-icon--stop:before {\n  content: "\\2013";\n}\n.lui-icon--comment:before {\n  content: "\\2026";\n}\n.lui-icon--indent:before {\n  content: "\\C0";\n}\n.lui-icon--undent:before {\n  content: "\\C3";\n}\n.lui-icon--cancel:before {\n  content: "E";\n}\n.lui-icon--insert:before {\n  content: "\\D8";\n}\n.lui-icon--boxplot:before {\n  content: "\\2605";\n}\n.lui-icon--distributionplot:before {\n  content: "\\2661";\n}\n.lui-icon--histogram:before {\n  content: "\\2691";\n}\n.lui-icon--direction-left:before {\n  content: "\\131";\n}\n.lui-icon--swap:before {\n  content: "\\266B";\n}\n.lui-icon--filter:before {\n  content: "\\263D";\n}\n.lui-icon--clear-filter:before {\n  content: "\\2699";\n}\n.lui-icon--bubbles:before {\n  content: "\\25B6";\n}\n.lui-icon--clipboard:before {\n  content: "c";\n}\n.lui-icon--server:before {\n  content: "v";\n}\n.lui-icon--hand:before {\n  content: "\\A2";\n}\n.lui-icon--flag:before {\n  content: "\\A9";\n}\n.lui-icon--external-link:before {\n  content: "\\25F4";\n}\n.lui-modal-background {\n  position: absolute;\n  top: 0;\n  right: 0;\n  left: 0;\n  height: 100%;\n  opacity: 0.3;\n  background-color: #000000;\n  z-index: 1021;\n  -webkit-transition: opacity 200ms ease-out;\n  transition: opacity 200ms ease-out;\n}\n.lui-modal-background.lui-fade {\n  opacity: 0;\n}\n.lui-tag {\n  position: relative;\n  display: inline-block;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  height: 24px;\n  min-width: 40px;\n  color: #595959;\n  font-size: 13px;\n  border-radius: 12px;\n  background-color: #E6E6E6;\n  border: 1px solid #CCCCCC;\n  padding: 3px 10px;\n  margin: 1px;\n  list-style: none;\n  white-space: nowrap;\n}\n.lui-tag.lui-matched {\n  background-color: #ffce26;\n  color: #595959;\n  border-color: #ffce26;\n}\n.qv-tagCloud .lui-tag {\n  padding-right: 26px;\n}\n.lui-tag .icon-trash {\n  cursor: pointer;\n  font-size: 14px;\n  display: block;\n  position: absolute;\n  right: 5px;\n  top: 1px;\n  color: rgba(89, 89, 89, 0.6);\n}\n.lui-tag .icon-trash:active {\n  color: #595959;\n}\n.lui-tag .icon-trash:hover {\n  color: #595959;\n}\n.lui-texthighlight {\n  background: #ffce26;\n  color: #595959;\n}\n.lui-bg-default {\n  background-color: #FFFFFF;\n  color: #595959;\n}\n.lui-bg-inverse {\n  background-color: #404040;\n  color: #FFFFFF;\n}\n.lui-bg-alt {\n  background-color: #FBFBFB;\n  color: #595959;\n}\n.lui-bg-inverse-alt {\n  background-color: #595959;\n  color: #FFFFFF;\n}\n.lui-bg-success {\n  background-color: #61a729;\n  color: #FFFFFF;\n}\n.lui-bg-danger {\n  background-color: #f05555;\n  color: #FFFFFF;\n}\n.lui-bg-warning {\n  background-color: #f8981d;\n  color: #FFFFFF;\n}\n.lui-bg-info {\n  background-color: #52a2cc;\n  color: #FFFFFF;\n}\n.lui-text-default {\n  color: #595959;\n}\n.lui-text-inverse {\n  color: #FFFFFF;\n}\n.lui-text-success {\n  color: #61a729;\n}\n.lui-text-danger {\n  color: #f05555;\n}\n.lui-text-warning {\n  color: #f8981d;\n}\n.lui-text-info {\n  color: #52a2cc;\n}\n.lui-caret:after {\n  display: inline-block;\n  font-family: "LUI icons";\n  font-size: 16px;\n  direction: ltr;\n  content: "S";\n  font-size: 12px;\n  font-weight: normal;\n  font-style: normal;\n  text-decoration: inherit;\n  text-transform: none;\n}\n.lui-label {\n  display: block;\n  font-size: 14px;\n  margin: 6px 0;\n}\n.lui-nopad {\n  padding: 0;\n}\n.lui-noround {\n  border-radius: 0;\n}\n\n',""])},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var o=e.protocol+"//"+e.host,t=o+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(n,e){var i=e.trim().replace(/^"(.*)"$/,function(n,e){return e}).replace(/^'(.*)'$/,function(n,e){return e});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i))return n;var r;return r=0===i.indexOf("//")?i:0===i.indexOf("/")?o+i:t+i.replace(/^\.\//,""),"url("+JSON.stringify(r)+")"})}},function(n,e,o){var t=o(60);"string"==typeof t&&(t=[[n.i,t,""]]);var i={hmr:!0};i.transform=void 0;o(42)(t,i);t.locals&&(n.exports=t.locals)},function(n,e,o){var t=o(61);e=n.exports=o(41)(!1),e.push([n.i,'@font-face {\n  font-family: "LUI icons";\n  src: url('+t(o(62))+") format('woff'), url("+t(o(63))+") format('truetype');\n}\n.lui-search .lui-icon--close {\n  padding-bottom: 4px;\n}\n*::-webkit-input-placeholder {\n  font-style: normal !important;\n}\n*:-moz-placeholder {\n  font-style: normal !important;\n}\n*::-moz-placeholder {\n  font-style: normal !important;\n}\n*:-ms-input-placeholder {\n  font-style: normal !important;\n}\n",""])},function(n,e){n.exports=function(n){return"string"!=typeof n?n:(/^['"].*['"]$/.test(n)&&(n=n.slice(1,-1)),/["'() \t\n]/.test(n)?'"'+n.replace(/"/g,'\\"').replace(/\n/g,"\\n")+'"':n)}},function(n,e,o){n.exports=o.p+"lui-icons.woff"},function(n,e,o){n.exports=o.p+"lui-icons.ttf"},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children,o=n.type,t=n.dialog,i=n.color,l=n.rounded,u=n.active,a=n.disabled,c=n.block,d=n.size,b=n.onClick;return r.default.createElement("button",{className:"\n        "+(o?"lui-"+o+"-button":"lui-button")+" \n        "+(t?"lui-dialog__button":null)+"\n        "+(i?"lui-button--"+i:null)+"\n        "+(l?"lui-button--rounded":null)+"\n        "+(u?"lui-active":null)+"\n        "+(a?"lui-disabled":null)+"\n        "+(c?"lui-button--block":null)+"\n        "+(d?"lui-button--"+d:null)+"\n      ",onClick:b},e)};a.propTypes={children:u.default.node,type:u.default.oneOf(["overlay","fade"]),dialog:u.default.bool,color:u.default.oneOf(["inverse","gradient","gradient-inverse","info","danger","warning","success"]),rounded:u.default.bool,active:u.default.bool,disabled:u.default.bool,block:u.default.bool,size:u.default.oneOf(["large","x-large"]),onClick:u.default.func},a.defaultProps={children:null,type:null,dialog:!1,color:null,rounded:null,active:null,disabled:null,block:null,size:null,onClick:null},e.default=a},function(n,e,o){"use strict";function t(){}var i=o(66);n.exports=function(){function n(n,e,o,t,r,l){if(l!==i){var u=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw u.name="Invariant Violation",u}}function e(){return n}n.isRequired=n;var o={array:n,bool:n,func:n,number:n,object:n,string:n,symbol:n,any:n,arrayOf:e,element:n,instanceOf:e,node:n,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e};return o.checkPropTypes=t,o.PropTypes=o,o}},function(n,e,o){"use strict";n.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i,r,l=o(22),u=t(l),a=o(28),c=t(a),d=o(29),b=t(d),s=o(30),p=t(s),g=o(39),f=t(g),h=o(0),A=t(h),x=o(1),v=t(x),w=(r=i=function(n){function e(){var n,o,t,i;(0,c.default)(this,e);for(var r=arguments.length,l=Array(r),a=0;a<r;a++)l[a]=arguments[a];return o=t=(0,p.default)(this,(n=e.__proto__||(0,u.default)(e)).call.apply(n,[this].concat(l))),t.handleKeyUp=function(n){27===n.keyCode&&t.props.handleClose(n)},i=o,(0,p.default)(t,i)}return(0,f.default)(e,n),(0,b.default)(e,[{key:"componentDidMount",value:function(){window.addEventListener("keyup",this.handleKeyUp)}},{key:"componentWillUnmount",value:function(){window.removeEventListener("keyup",this.handleKeyUp)}},{key:"render",value:function(){var n=this.props,e=n.children,o=n.isOpen,t=n.width,i=n.handleClose;return A.default.createElement("div",{className:"lui-dialog-container",style:{display:o?"flex":"none"}},A.default.createElement("div",{className:"lui-modal-background",onClick:i,role:"button",tabIndex:0}),A.default.createElement("div",{className:"lui-dialog",style:{width:t}},e))}}]),e}(A.default.Component),i.propTypes={children:v.default.node,width:v.default.string,isOpen:v.default.bool.isRequired,handleClose:v.default.func.isRequired},i.defaultProps={children:null,width:"400px"},r);e.default=w},function(n,e,o){o(69),n.exports=o(2).Object.getPrototypeOf},function(n,e,o){var t=o(16),i=o(43);o(70)("getPrototypeOf",function(){return function(n){return i(t(n))}})},function(n,e,o){var t=o(5),i=o(2),r=o(12);n.exports=function(n,e){var o=(i.Object||{})[n]||Object[n],l={};l[n]=e(o),t(t.S+t.F*r(function(){o(1)}),"Object",l)}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},function(n,e,o){n.exports={default:o(73),__esModule:!0}},function(n,e,o){o(74);var t=o(2).Object;n.exports=function(n,e,o){return t.defineProperty(n,e,o)}},function(n,e,o){var t=o(5);t(t.S+t.F*!o(8),"Object",{defineProperty:o(6).f})},function(n,e,o){n.exports={default:o(76),__esModule:!0}},function(n,e,o){o(47),o(83),n.exports=o(36).f("iterator")},function(n,e,o){var t=o(31),i=o(23);n.exports=function(n){return function(e,o){var r,l,u=String(i(e)),a=t(o),c=u.length;return a<0||a>=c?n?"":void 0:(r=u.charCodeAt(a),r<55296||r>56319||a+1===c||(l=u.charCodeAt(a+1))<56320||l>57343?n?u.charAt(a):r:n?u.slice(a,a+2):l-56320+(r-55296<<10)+65536)}}},function(n,e,o){"use strict";var t=o(32),i=o(14),r=o(35),l={};o(9)(l,o(3)("iterator"),function(){return this}),n.exports=function(n,e,o){n.prototype=t(l,{next:i(1,o)}),r(n,e+" Iterator")}},function(n,e,o){var t=o(6),i=o(10),r=o(19);n.exports=o(8)?Object.defineProperties:function(n,e){i(n);for(var o,l=r(e),u=l.length,a=0;u>a;)t.f(n,o=l[a++],e[o]);return n}},function(n,e,o){var t=o(13),i=o(52),r=o(81);n.exports=function(n){return function(e,o,l){var u,a=t(e),c=i(a.length),d=r(l,c);if(n&&o!=o){for(;c>d;)if((u=a[d++])!=u)return!0}else for(;c>d;d++)if((n||d in a)&&a[d]===o)return n||d||0;return!n&&-1}}},function(n,e,o){var t=o(31),i=Math.max,r=Math.min;n.exports=function(n,e){return n=t(n),n<0?i(n+e,0):r(n,e)}},function(n,e,o){var t=o(4).document;n.exports=t&&t.documentElement},function(n,e,o){o(84);for(var t=o(4),i=o(9),r=o(15),l=o(3)("toStringTag"),u="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),a=0;a<u.length;a++){var c=u[a],d=t[c],b=d&&d.prototype;b&&!b[l]&&i(b,l,c),r[c]=r.Array}},function(n,e,o){"use strict";var t=o(85),i=o(86),r=o(15),l=o(13);n.exports=o(48)(Array,"Array",function(n,e){this._t=l(n),this._i=0,this._k=e},function(){var n=this._t,e=this._k,o=this._i++;return!n||o>=n.length?(this._t=void 0,i(1)):"keys"==e?i(0,o):"values"==e?i(0,n[o]):i(0,[o,n[o]])},"values"),r.Arguments=r.Array,t("keys"),t("values"),t("entries")},function(n,e){n.exports=function(){}},function(n,e){n.exports=function(n,e){return{value:e,done:!!n}}},function(n,e,o){n.exports={default:o(88),__esModule:!0}},function(n,e,o){o(89),o(94),o(95),o(96),n.exports=o(2).Symbol},function(n,e,o){"use strict";var t=o(4),i=o(7),r=o(8),l=o(5),u=o(49),a=o(90).KEY,c=o(12),d=o(25),b=o(35),s=o(18),p=o(3),g=o(36),f=o(37),h=o(91),A=o(92),x=o(10),v=o(11),w=o(13),m=o(27),k=o(14),y=o(32),_=o(93),F=o(54),N=o(6),M=o(19),D=F.f,I=N.f,R=_.f,Z=t.Symbol,G=t.JSON,j=G&&G.stringify,E=p("_hidden"),Y=p("toPrimitive"),J={}.propertyIsEnumerable,z=d("symbol-registry"),U=d("symbols"),S=d("op-symbols"),B=Object.prototype,T="function"==typeof Z,W=t.QObject,L=!W||!W.prototype||!W.prototype.findChild,V=r&&c(function(){return 7!=y(I({},"a",{get:function(){return I(this,"a",{value:7}).a}})).a})?function(n,e,o){var t=D(B,e);t&&delete B[e],I(n,e,o),t&&n!==B&&I(B,e,t)}:I,C=function(n){var e=U[n]=y(Z.prototype);return e._k=n,e},O=T&&"symbol"==typeof Z.iterator?function(n){return"symbol"==typeof n}:function(n){return n instanceof Z},Q=function(n,e,o){return n===B&&Q(S,e,o),x(n),e=m(e,!0),x(o),i(U,e)?(o.enumerable?(i(n,E)&&n[E][e]&&(n[E][e]=!1),o=y(o,{enumerable:k(0,!1)})):(i(n,E)||I(n,E,k(1,{})),n[E][e]=!0),V(n,e,o)):I(n,e,o)},X=function(n,e){x(n);for(var o,t=h(e=w(e)),i=0,r=t.length;r>i;)Q(n,o=t[i++],e[o]);return n},P=function(n,e){return void 0===e?y(n):X(y(n),e)},H=function(n){var e=J.call(this,n=m(n,!0));return!(this===B&&i(U,n)&&!i(S,n))&&(!(e||!i(this,n)||!i(U,n)||i(this,E)&&this[E][n])||e)},K=function(n,e){if(n=w(n),e=m(e,!0),n!==B||!i(U,e)||i(S,e)){var o=D(n,e);return!o||!i(U,e)||i(n,E)&&n[E][e]||(o.enumerable=!0),o}},q=function(n){for(var e,o=R(w(n)),t=[],r=0;o.length>r;)i(U,e=o[r++])||e==E||e==a||t.push(e);return t},$=function(n){for(var e,o=n===B,t=R(o?S:w(n)),r=[],l=0;t.length>l;)!i(U,e=t[l++])||o&&!i(B,e)||r.push(U[e]);return r};T||(Z=function(){if(this instanceof Z)throw TypeError("Symbol is not a constructor!");var n=s(arguments.length>0?arguments[0]:void 0),e=function(o){this===B&&e.call(S,o),i(this,E)&&i(this[E],n)&&(this[E][n]=!1),V(this,n,k(1,o))};return r&&L&&V(B,n,{configurable:!0,set:e}),C(n)},u(Z.prototype,"toString",function(){return this._k}),F.f=K,N.f=Q,o(53).f=_.f=q,o(20).f=H,o(38).f=$,r&&!o(17)&&u(B,"propertyIsEnumerable",H,!0),g.f=function(n){return C(p(n))}),l(l.G+l.W+l.F*!T,{Symbol:Z});for(var nn="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),en=0;nn.length>en;)p(nn[en++]);for(var on=M(p.store),tn=0;on.length>tn;)f(on[tn++]);l(l.S+l.F*!T,"Symbol",{for:function(n){return i(z,n+="")?z[n]:z[n]=Z(n)},keyFor:function(n){if(!O(n))throw TypeError(n+" is not a symbol!");for(var e in z)if(z[e]===n)return e},useSetter:function(){L=!0},useSimple:function(){L=!1}}),l(l.S+l.F*!T,"Object",{create:P,defineProperty:Q,defineProperties:X,getOwnPropertyDescriptor:K,getOwnPropertyNames:q,getOwnPropertySymbols:$}),G&&l(l.S+l.F*(!T||c(function(){var n=Z();return"[null]"!=j([n])||"{}"!=j({a:n})||"{}"!=j(Object(n))})),"JSON",{stringify:function(n){for(var e,o,t=[n],i=1;arguments.length>i;)t.push(arguments[i++]);if(o=e=t[1],(v(e)||void 0!==n)&&!O(n))return A(e)||(e=function(n,e){if("function"==typeof o&&(e=o.call(this,n,e)),!O(e))return e}),t[1]=e,j.apply(G,t)}}),Z.prototype[Y]||o(9)(Z.prototype,Y,Z.prototype.valueOf),b(Z,"Symbol"),b(Math,"Math",!0),b(t.JSON,"JSON",!0)},function(n,e,o){var t=o(18)("meta"),i=o(11),r=o(7),l=o(6).f,u=0,a=Object.isExtensible||function(){return!0},c=!o(12)(function(){return a(Object.preventExtensions({}))}),d=function(n){l(n,t,{value:{i:"O"+ ++u,w:{}}})},b=function(n,e){if(!i(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!r(n,t)){if(!a(n))return"F";if(!e)return"E";d(n)}return n[t].i},s=function(n,e){if(!r(n,t)){if(!a(n))return!0;if(!e)return!1;d(n)}return n[t].w},p=function(n){return c&&g.NEED&&a(n)&&!r(n,t)&&d(n),n},g=n.exports={KEY:t,NEED:!1,fastKey:b,getWeak:s,onFreeze:p}},function(n,e,o){var t=o(19),i=o(38),r=o(20);n.exports=function(n){var e=t(n),o=i.f;if(o)for(var l,u=o(n),a=r.f,c=0;u.length>c;)a.call(n,l=u[c++])&&e.push(l);return e}},function(n,e,o){var t=o(33);n.exports=Array.isArray||function(n){return"Array"==t(n)}},function(n,e,o){var t=o(13),i=o(53).f,r={}.toString,l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],u=function(n){try{return i(n)}catch(n){return l.slice()}};n.exports.f=function(n){return l&&"[object Window]"==r.call(n)?u(n):i(t(n))}},function(n,e){},function(n,e,o){o(37)("asyncIterator")},function(n,e,o){o(37)("observable")},function(n,e,o){n.exports={default:o(98),__esModule:!0}},function(n,e,o){o(99),n.exports=o(2).Object.setPrototypeOf},function(n,e,o){var t=o(5);t(t.S,"Object",{setPrototypeOf:o(100).set})},function(n,e,o){var t=o(11),i=o(10),r=function(n,e){if(i(n),!t(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(n,e,t){try{t=o(26)(Function.call,o(54).f(Object.prototype,"__proto__").set,2),t(n,[]),e=!(n instanceof Array)}catch(n){e=!0}return function(n,o){return r(n,o),e?n.__proto__=o:t(n,o),n}}({},!1):void 0),check:r}},function(n,e,o){n.exports={default:o(102),__esModule:!0}},function(n,e,o){o(103);var t=o(2).Object;n.exports=function(n,e){return t.create(n,e)}},function(n,e,o){var t=o(5);t(t.S,"Object",{create:o(32)})},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children;return r.default.createElement("div",{className:"lui-dialog__body"},e)};a.propTypes={children:u.default.node},a.defaultProps={children:null},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children;return r.default.createElement("div",{className:"lui-dialog__footer"},e)};a.propTypes={children:u.default.node},a.defaultProps={children:null},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children;return r.default.createElement("div",{className:"lui-dialog__header"},r.default.createElement("div",{className:"lui-dialog__title"},e))};a.propTypes={children:u.default.node},a.defaultProps={children:null},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i,r,l=o(21),u=t(l),a=o(112),c=t(a),d=o(22),b=t(d),s=o(28),p=t(s),g=o(29),f=t(g),h=o(30),A=t(h),x=o(39),v=t(x),w=o(0),m=t(w),k=o(1),y=t(k),_=(r=i=function(n){function e(){var n,o,t,i;(0,p.default)(this,e);for(var r=arguments.length,l=Array(r),u=0;u<r;u++)l[u]=arguments[u];return o=t=(0,A.default)(this,(n=e.__proto__||(0,b.default)(e)).call.apply(n,[this].concat(l))),t.handleClick=function(n){var e=!t.node.contains(n.target);t.props.isOpen&&e&&t.handleToggle(n)},t.handleToggle=function(n){t.props.toggle(n)},i=o,(0,A.default)(t,i)}return(0,v.default)(e,n),(0,f.default)(e,[{key:"componentDidMount",value:function(){window.addEventListener("click",this.handleClick)}},{key:"componentWillUnmount",value:function(){window.removeEventListener("click",this.handleClick)}},{key:"render",value:function(){var n=this,e=this.props,o=e.children,t=e.className,i=e.gradient,r=e.inverse,l=e.isOpen,a=e.select,d=e.style,b=(0,c.default)(o),s=b[0],p=b[1],g=b.slice(2);return m.default.createElement("div",{ref:function(e){return n.node=e},className:t,style:(0,u.default)({position:"relative"},d)},m.default.createElement("div",{className:"\n              "+(a?"lui-select":"")+" \n              "+(i?"lui-select--gradient":"")+"\n              "+(r?"lui-select--inverse":"")+"\n              "+(i&&r?"lui-select--gradient-inverse":"")+"\n            ",role:"button",tabIndex:"0",onClick:this.handleToggle},s),m.default.createElement("div",{style:{display:l?"block":"none",position:"absolute",background:"#fff",border:"1px solid #ccc",marginTop:4,zIndex:99999,cursor:"pointer"}},p),g)}}]),e}(m.default.Component),i.propTypes={children:y.default.node,className:y.default.string,gradient:y.default.bool,inverse:y.default.bool,isOpen:y.default.bool,select:y.default.bool,style:y.default.object,toggle:y.default.func},i.defaultProps={children:null,className:null,gradient:null,inverse:null,isOpen:!1,select:!0,style:null,toggle:null},r);e.default=_},function(n,e,o){n.exports={default:o(109),__esModule:!0}},function(n,e,o){o(110),n.exports=o(2).Object.assign},function(n,e,o){var t=o(5);t(t.S+t.F,"Object",{assign:o(111)})},function(n,e,o){"use strict";var t=o(19),i=o(38),r=o(20),l=o(16),u=o(51),a=Object.assign;n.exports=!a||o(12)(function(){var n={},e={},o=Symbol(),t="abcdefghijklmnopqrst";return n[o]=7,t.split("").forEach(function(n){e[n]=n}),7!=a({},n)[o]||Object.keys(a({},e)).join("")!=t})?function(n,e){for(var o=l(n),a=arguments.length,c=1,d=i.f,b=r.f;a>c;)for(var s,p=u(arguments[c++]),g=d?t(p).concat(d(p)):t(p),f=g.length,h=0;f>h;)b.call(p,s=g[h++])&&(o[s]=p[s]);return o}:a},function(n,e,o){"use strict";e.__esModule=!0;var t=o(113),i=function(n){return n&&n.__esModule?n:{default:n}}(t);e.default=function(n){return Array.isArray(n)?n:(0,i.default)(n)}},function(n,e,o){n.exports={default:o(114),__esModule:!0}},function(n,e,o){o(47),o(115),n.exports=o(2).Array.from},function(n,e,o){"use strict";var t=o(26),i=o(5),r=o(16),l=o(116),u=o(117),a=o(52),c=o(118),d=o(119);i(i.S+i.F*!o(121)(function(n){Array.from(n)}),"Array",{from:function(n){var e,o,i,b,s=r(n),p="function"==typeof this?this:Array,g=arguments.length,f=g>1?arguments[1]:void 0,h=void 0!==f,A=0,x=d(s);if(h&&(f=t(f,g>2?arguments[2]:void 0,2)),void 0==x||p==Array&&u(x))for(e=a(s.length),o=new p(e);e>A;A++)c(o,A,h?f(s[A],A):s[A]);else for(b=x.call(s),o=new p;!(i=b.next()).done;A++)c(o,A,h?l(b,f,[i.value,A],!0):i.value);return o.length=A,o}})},function(n,e,o){var t=o(10);n.exports=function(n,e,o,i){try{return i?e(t(o)[0],o[1]):e(o)}catch(e){var r=n.return;throw void 0!==r&&t(r.call(n)),e}}},function(n,e,o){var t=o(15),i=o(3)("iterator"),r=Array.prototype;n.exports=function(n){return void 0!==n&&(t.Array===n||r[i]===n)}},function(n,e,o){"use strict";var t=o(6),i=o(14);n.exports=function(n,e,o){e in n?t.f(n,e,i(0,o)):n[e]=o}},function(n,e,o){var t=o(120),i=o(3)("iterator"),r=o(15);n.exports=o(2).getIteratorMethod=function(n){if(void 0!=n)return n[i]||n["@@iterator"]||r[t(n)]}},function(n,e,o){var t=o(33),i=o(3)("toStringTag"),r="Arguments"==t(function(){return arguments}()),l=function(n,e){try{return n[e]}catch(n){}};n.exports=function(n){var e,o,u;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(o=l(e=Object(n),i))?o:r?t(e):"Object"==(u=t(e))&&"function"==typeof e.callee?"Arguments":u}},function(n,e,o){var t=o(3)("iterator"),i=!1;try{var r=[7][t]();r.return=function(){i=!0},Array.from(r,function(){throw 2})}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var o=!1;try{var r=[7],l=r[t]();l.next=function(){return{done:o=!0}},r[t]=function(){return l},n(r)}catch(n){}return o}},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.type;return r.default.createElement("span",{className:"lui-icon  lui-icon--"+e,"aria-hidden":"true"})};a.propTypes={type:u.default.string.isRequired},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children,o=n.className,t=n.inverse,i=n.style;return r.default.createElement("ul",{className:"\n      lui-list\n      "+(t?"lui-list--inverse":null)+"\n      "+o+"\n    ",style:i},e)};a.propTypes={children:u.default.node,className:u.default.string,inverse:u.default.bool,style:u.default.object},a.defaultProps={children:null,className:null,inverse:null,style:null},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(21),r=t(i),l=o(40),u=t(l),a=o(0),c=t(a),d=o(1),b=t(d),s=function(n){var e=n.children,o=n.className,t=n.onClick,i=(0,u.default)(n,["children","className","onClick"]);return c.default.createElement("li",(0,r.default)({className:"lui-list__item "+o,onClick:t},i),c.default.createElement("span",{className:"lui-list__text"},e))};s.propTypes={children:b.default.node,className:b.default.string,onClick:b.default.func,otherprops:b.default.object},s.defaultProps={children:null,className:null,onClick:null,otherprops:null},e.default=s},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i,r,l=o(21),u=t(l),a=o(40),c=t(a),d=o(22),b=t(d),s=o(28),p=t(s),g=o(29),f=t(g),h=o(30),A=t(h),x=o(39),v=t(x),w=o(0),m=t(w),k=o(1),y=t(k),_=o(126),F=(r=i=function(n){function e(){return(0,p.default)(this,e),(0,A.default)(this,(e.__proto__||(0,b.default)(e)).apply(this,arguments))}return(0,v.default)(e,n),(0,f.default)(e,[{key:"componentDidMount",value:function(){var n=this.element,e=this.props,o=e.tooltipDock,t=e.tooltipContent;if(t){var i=void 0;n.addEventListener("mouseover",function(){var e={alignTo:n,dock:o,content:"<span>"+t+"</span>"};i=(0,_.tooltip)(e)}),n.addEventListener("mouseout",function(){i&&i.close()})}}},{key:"render",value:function(){var n=this,e=this.props,o=e.clear,t=e.inverse,i=e.placeholder,r=e.value,l=(e.tooltipContent,e.onGo),a=(0,c.default)(e,["clear","inverse","placeholder","value","tooltipContent","onGo"]);return m.default.createElement("div",{className:t?"lui-search lui-search--inverse":"lui-search"},m.default.createElement("span",{className:"lui-icon  lui-icon--search  lui-search__search-icon",ref:function(e){return n.element=e},"aria-haspopup":"true"}),m.default.createElement("input",(0,u.default)({className:"lui-search__input",maxLength:"255",type:"text",placeholder:i,value:r},a)),!!r.length&&m.default.createElement("button",{className:"lui-search__clear-button",tabIndex:0,key:"clear",onClick:o},m.default.createElement("span",{className:"lui-icon  lui-icon--small  lui-icon--close",ref:function(e){return n.element=e}})),!!l&&m.default.createElement("button",{className:"lui-button",style:{height:"calc(100% + 2px)"},onClick:l},"Go"))}}]),e}(m.default.Component),i.propTypes={clear:y.default.func.isRequired,inverse:y.default.bool,placeholder:y.default.string,value:y.default.string.isRequired,otherProps:y.default.object,tooltipDock:y.default.oneOf(["top","right","bottom","left"]),tooltipContent:y.default.string,onGo:y.default.func},i.defaultProps={inverse:!1,placeholder:"Search",otherProps:null,tooltipDock:"top",tooltipContent:null,onGo:null},r);e.default=F},function(n,e,o){!function(e,o){n.exports=o()}(0,function(){return function(n){function e(t){if(o[t])return o[t].exports;var i=o[t]={exports:{},id:t,loaded:!1};return n[t].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var o={};return e.m=n,e.c=o,e.p="/leonardo-ui/",e(0)}({0:function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0}),e.tooltip=e.tabset=e.popover=e.dialog=void 0;var i=o(102),r=t(i),l=o(104),u=t(l),a=o(106),c=t(a),d=o(107),b=t(d);o(108),o(110),o(111),o(112),o(113),e.dialog=r.default,e.popover=u.default,e.tabset=c.default,e.tooltip=b.default},102:function(n,e,o){"use strict";function t(n){var e=n.content,o=n.closeOnEscape,t=void 0===o||o,l=n.onClose,u=document.body.style.overflow,a=void 0,c=void 0,d=void 0,b=(0,i.createOverlay)({modal:!0,close:function(n){document.body.contains(c)&&(a.classList.add("lui-fade"),d.classList.add("lui-fade")),setTimeout(function(){n()},r)},closeOnEscape:t,closeOnOutside:!1,onClose:function(){document.body.style.overflow=u,"function"==typeof l&&l()}});if(c=b.element,c.classList.add("lui-dialog-container"),c.setAttribute("role","dialog"),c.style.position="fixed",d=b.modalBackgroundElement,"string"==typeof e){var s=document.createElement("div");s.innerHTML=e,a=s.firstElementChild}else a=e;return c.appendChild(a),a.setAttribute("role","document"),a.classList.add("lui-fade"),d.classList.add("lui-fade"),document.body.style.overflow="hidden",b.show(),setTimeout(function(){a.classList.remove("lui-fade"),d.classList.remove("lui-fade")},0),{element:a,close:function(){b.close()}}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var i=o(103),r=200},103:function(n,e){"use strict";function o(n){for(var e=0;e<i.length;e++)if(n===i[e])return document.body.removeChild(n.element),void i.splice(e,1)}function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};r||l();var e=document.createElement("div");e.style.visibility="hidden",document.body.appendChild(e);var t=n.modal,u=void 0!==t&&t,a=n.onClose,c=n.close,d=n.closeOnEscape,b=void 0!==d&&d,s=n.closeOnOutside,p=void 0!==s&&s,g={closeOnEscape:b,element:e,show:function(){e.style.visibility=""}};g.close=function(){c(function(){o(g),"function"==typeof a&&a(),p&&(document.removeEventListener("mousedown",g.onMouseDown),document.removeEventListener("touchstart",g.onTouchStart))})},p&&(g.onMouseDown=function(n){g.element.contains(n.target)||g.close()},g.onTouchStart=function(n){g.element.contains(n.target)&&g.close()},document.addEventListener("mousedown",g.onMouseDown),document.addEventListener("touchstart",g.onTouchStart)),i.push(g);var f={element:g.element,show:g.show,close:g.close};if(u){var h=document.createElement("div");h.classList.add("lui-modal-background"),e.appendChild(h),f.modalBackgroundElement=h}return f}Object.defineProperty(e,"__esModule",{value:!0}),e.removeOverlay=o,e.createOverlay=t;var i=[],r=null,l=function(){r=function(n){if(27===n.keyCode)for(var e=i.length-1;e>=0&&!1!==i[e].closeOnEscape;e--)if(!0===i[e].closeOnEscape){i[e].close();break}},window.addEventListener("keyup",r)}},104:function(n,e,o){"use strict";function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.closeOnEscape,o=void 0===e||e,t=n.dock,s=void 0===t?"bottom":t,p=n.alignTo,g=n.content,f=n.onClose,h=void 0,A=void 0,x=(0,r.createOverlay)({modal:!1,close:function(n){document.body.contains(A)&&A.classList.add("lui-fade"),setTimeout(function(){n()},l)},closeOnEscape:o,closeOnOutside:!0,onClose:function(){"function"==typeof f&&f(),p instanceof Element&&document.body.contains(p)&&(p.setAttribute("aria-expanded","false"),p.removeAttribute("aria-controls"))}});if(h=x.element,"string"==typeof g){var v=document.createElement("div");v.innerHTML=g,A=v.firstElementChild}else A=g;h.appendChild(A);var w="lui-popover-"+ ++d;A.setAttribute("id",w),A.setAttribute("role","dialog"),A.classList.add("lui-fade");var m=void 0;return p instanceof Element?(m=(0,i.positionToElement)(A,p,s,{offset:u,minWindowOffset:a,minEdgeOffset:c}),p.setAttribute("aria-controls",w),p.setAttribute("aria-expanded","true")):m=(0,i.positionToCoordinate)(A,p.top,p.left,s,{offset:u,minWindowOffset:a,minEdgeOffset:c}),h.style.left=m.position.left+"px",h.style.top=m.position.top+"px",h.style.position="absolute",A.appendChild(b(m)),x.show(),setTimeout(function(){A.classList.remove("lui-fade")},0),{element:A,close:function(){x.close()}}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var i=o(105),r=o(103),l=200,u=10,a=10,c=10,d=0,b=function(n){var e=document.createElement("div");return e.classList.add("lui-popover__arrow"),e.classList.add("lui-popover__arrow--"+(0,i.oppositeDock)(n.dock)),"top"===n.dock||"bottom"===n.dock?e.style.left=n.toPosition.left-n.position.left+"px":e.style.top=n.toPosition.top-n.position.top+"px",e}},105:function(n,e){"use strict";function o(n){return b[n]}function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return{top:n,right:e+o,bottom:n+t,left:e,width:o,height:t}}function i(n,e){var o=void 0,t=void 0;return"top"===e?(o=n.top,t=n.left+n.width/2):"right"===e?(o=n.top+n.height/2,t=n.right):"left"===e?(o=n.top+n.height/2,t=n.left):(o=n.bottom,t=n.left+n.width/2),{top:o,left:t}}function r(n,e){return{left:n.left>=e.left,right:n.right<=e.right,top:n.top>=e.top,bottom:n.bottom<=e.bottom}}function l(n,e,o,i){var r=void 0,l=void 0;return"top"===o?(r=e.top-n.height-i,l=e.left-n.width/2):"right"===o?(r=e.top-n.height/2,l=e.left+i):"left"===o?(r=e.top-n.height/2,l=e.left-n.width-i):(r=e.top+i,l=e.left-n.width/2),t(r,l,n.width,n.height)}function u(n,e,o,u){var a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},c=a.offset,d=void 0===c?0:c,b=a.minWindowOffset,s=void 0===b?0:b,p=a.minEdgeOffset,g=void 0===p?0:p,f=t(o.top+s,o.left+s,o.width-2*s,o.height-2*s),h=i(e,u),A=l(n,h,u,d),x=r(A,f);return"top"===u||"bottom"===u?(x.left||(A.left=Math.min(f.left,h.left-g),A.right=A.left+A.width,x=r(A,f)),x.right||(A.right=Math.max(f.right,h.left+g),A.left=A.right-A.width,x=r(A,f))):(x.top||(A.top=Math.min(f.top,h.top-g),A.bottom=A.top+A.height,x=r(A,f)),x.bottom||(A.bottom=Math.max(f.bottom,h.top+s),A.top=A.bottom-A.height,x=r(A,f))),{fits:x.top&&x.right&&x.bottom&&x.left,dock:u,position:{left:A.left,top:A.top},toPosition:i(e,u)}}function a(n,e){for(var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"bottom",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=n.getBoundingClientRect(),l=t(0,0,document.body.scrollWidth,document.body.scrollHeight),a=Array.isArray(o)?o:[o],c=null,d=0;d<a.length;d++){var b=u(r,e,l,a[d],i);if(b.fits)return b;0===d&&(c=b)}return c}function c(n,e){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"bottom",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=e.getBoundingClientRect(),l=document.body,u=document.documentElement,c=window.pageYOffset||u.scrollTop||l.scrollTop,d=window.pageXOffset||u.scrollLeft||l.scrollLeft,b=u.clientTop||l.clientTop||0,s=u.clientLeft||l.clientLeft||0;return a(n,t(r.top+c-b,r.left+d-s,r.width,r.height),o,i)}function d(n,e,o){return a(n,{top:o,bottom:o,left:e,right:e,width:0,height:0},arguments.length>3&&void 0!==arguments[3]?arguments[3]:"bottom",arguments.length>4&&void 0!==arguments[4]?arguments[4]:{})}Object.defineProperty(e,"__esModule",{value:!0}),e.oppositeDock=o,e.createRect=t,e.getDockCenterPoint=i,e.tryPosition=r,e.createTryRect=l,e.tryDock=u,e.positionToRect=a,e.positionToElement=c,e.positionToCoordinate=d;var b={top:"bottom",right:"left",bottom:"top",left:"right"}},106:function(n,e){"use strict";function o(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.element,o=[],t=function(n){o.forEach(function(e,o){o===n?(e.element.classList.add("lui-active"),e.contentElements.forEach(function(n){n.style.display=e.display})):(e.element.classList.remove("lui-active"),e.contentElements.forEach(function(n){n.style.display="none"}))})},i=function(){o.forEach(function(n){return n.element.removeEventListener("click",n.listener)}),o.splice(0,o.length-1)};return Array.prototype.slice.call(e.querySelectorAll("[data-tab-id]")).forEach(function(n,e){var i=n.getAttribute("data-tab-id"),r=n.addEventListener("click",function(){t(e)});o.push({id:i,index:e,element:n,contentElements:Array.prototype.slice.call(document.querySelectorAll('[data-tab-content="'+i+'"]')),display:n.style.display,listener:r})}),t(0),{element:e,activate:t,close:i}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=o},107:function(n,e,o){"use strict";function t(n){var e=n.alignTo,o=n.dock,t=n.content,s=void 0,p=void 0,g=void 0;if("string"==typeof t){var f=document.createElement("div");f.innerHTML=t,p=f.firstElementChild}else if(t instanceof Element)p=t;else{if(!(s=e.getAttribute("title")))return{element:null,close:function(){}};p=document.createElement("div"),p.appendChild(document.createTextNode(s))}var h="lui-tooltip-"+ ++d,A=(0,r.createOverlay)({closeOnOutside:!1,close:function(n){document.body.contains(p)&&p.classList.add("lui-fade"),setTimeout(function(){e instanceof Element&&document.body.contains(e)&&(s&&e.setAttribute("title",s),e.removeAttribute("aria-describedby")),n()},l)}});g=A.element,p.classList.add("lui-tooltip"),p.classList.add("lui-fade"),p.setAttribute("id",h),p.setAttribute("role","tooltip"),g.appendChild(p);var x=void 0;return x=e instanceof Element?(0,i.positionToElement)(p,e,o,{offset:u,minWindowOffset:a,minEdgeOffset:c}):(0,i.positionToCoordinate)(p,e.top,e.left,o,{offset:u,minWindowOffset:a,minEdgeOffset:c}),g.style.left=x.position.left+"px",g.style.top=x.position.top+"px",g.style.position="absolute",p.appendChild(b(x)),s&&e.setAttribute("title",""),e instanceof Element&&e.setAttribute("aria-describedby",h),A.show(),setTimeout(function(){p.classList.remove("lui-fade")},0),{element:p,close:function(){A.close()}}}Object.defineProperty(e,"__esModule",{value:!0}),e.default=t;var i=o(105),r=o(103),l=50,u=10,a=10,c=10,d=0,b=function(n){var e=document.createElement("div");return e.classList.add("lui-tooltip__arrow"),e.classList.add("lui-tooltip__arrow--"+(0,i.oppositeDock)(n.dock)),"top"===n.dock||"bottom"===n.dock?e.style.left=n.toPosition.left-n.position.left+"px":e.style.top=n.toPosition.top-n.position.top+"px",e}},108:function(n,e){},110:function(n,e,o){n.exports=o.p+"colors.less"},111:function(n,e,o){n.exports=o.p+"variables.less"},112:function(n,e,o){n.exports=o.p+"lui-icons.ttf"},113:function(n,e,o){n.exports=o.p+"lui-icons.woff"}})})},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(0),r=t(i),l=o(1),u=t(l),a=function(n){var e=n.children,o=n.className,t=n.inverse,i=n.style,l=n.fill;return r.default.createElement("ul",{className:"\n      lui-tabset\n      "+(l?"lui-tabset--fill":"")+"\n      "+(t?"lui-tab--inverse":"")+"\n      "+o+"\n    ",style:i},e)};a.propTypes={children:u.default.node,className:u.default.string,inverse:u.default.bool,style:u.default.object,fill:u.default.bool},a.defaultProps={children:null,className:null,inverse:null,style:null,fill:null},e.default=a},function(n,e,o){"use strict";function t(n){return n&&n.__esModule?n:{default:n}}Object.defineProperty(e,"__esModule",{value:!0});var i=o(21),r=t(i),l=o(40),u=t(l),a=o(0),c=t(a),d=o(1),b=t(d),s=function(n){var e=n.children,o=n.className,t=n.onClick,i=(0,u.default)(n,["children","className","onClick"]);return c.default.createElement("li",(0,r.default)({className:"lui-tab "+o,onClick:t},i),c.default.createElement("span",{className:"lui-tab__text"},e))};s.propTypes={children:b.default.node,className:b.default.string,onClick:b.default.func,otherprops:b.default.object},s.defaultProps={children:null,className:null,onClick:null,otherprops:null},e.default=s}])});

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(29);

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(40);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(45)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(47);

var iterableToArray = __webpack_require__(48);

var nonIterableSpread = __webpack_require__(49);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(37);

var iterableToArrayLimit = __webpack_require__(38);

var nonIterableRest = __webpack_require__(39);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(26);
} else {}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Hammer) {var interaction = function interaction() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$scale = _ref.scale,
      scale = _ref$scale === void 0 ? 'x' : _ref$scale;

  var inter = {
    type: 'hammer',
    gestures: [{
      type: 'Pan',
      options: {
        event: 'range',
        direction: scale === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL // Hammer.DIRECTION_ALL

      },
      events: {
        rangestart: function rangestart(e) {
          this.chart.component("".concat(scale, "Range")).emit('rangeStart', e);
        },
        rangemove: function rangemove(e) {
          this.chart.component("".concat(scale, "Range")).emit('rangeMove', e);
        },
        rangeend: function rangeend(e) {
          this.chart.component("".concat(scale, "Range")).emit('rangeEnd', e);
        }
      }
    }]
  };
  return inter;
};

/* harmony default export */ __webpack_exports__["a"] = (interaction);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Hammer) {/*
* picasso-plugin-hammer v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


/* global Hammer */
var translateKnownTypes = {
  click: 'Tap',
  Click: 'Tap',
  tap: 'Tap',
  pan: 'Pan',
  swipe: 'Swipe',
  rotate: 'Rotate',
  press: 'Press',
  pinch: 'Pinch'
};
/**
 * Helper function for translating typical non-hammer gesture to a hammer gesture. Currently only supporting 'click'
 * @param {String} type Gesture type
 * @private
 */

function getGestureType(type) {
  return translateKnownTypes[type] || type;
}
/**
 * Manages event handlers for HammerJS. Assumes Hammer is loaded and added to the global namespace
 */


function hammer(chart, mediator, element) {
  var settings;
  var instance;
  var mc;
  var key;
  var hammerGestures = [];
  var isOn = true;
  /**
   * Set default settings
   * @private
   */

  function setDefaultSettings(newSettings) {
    key = newSettings.key; //eslint-disable-line

    settings = newSettings;
    instance = {
      chart: chart,
      mediator: mediator,
      settings: settings
    };
    settings.gestures = settings.gestures || [];

    if (settings.enable === undefined) {
      settings.enable = true;
    }
  }
  /**
   * @private
   * add hammer recognizers based on settings
   */


  function addRecognizers() {
    if (typeof settings.enable === 'function') {
      settings.enable = settings.enable.bind(instance)();
    }

    if (!settings.enable) {
      return; // interaction is disabled
    }

    settings.gestures.forEach(function (gesture) {
      gesture.options = gesture.options || {}; // handle action enable

      if (gesture.options.enable === undefined) {
        gesture.options.enable = true;
      }

      if (typeof gesture.options.enable === 'function') {
        gesture.options.enable = gesture.options.enable.bind(instance);
      } // setup hammer gestures


      var type = getGestureType(gesture.type);

      if (Hammer && Hammer[type]) {
        gesture.options.event = gesture.options.event || gesture.type.toLowerCase();
        mc = mc || new Hammer.Manager(element);
        mc.add(new Hammer[type](gesture.options));
        Object.keys(gesture.events).forEach(function (eventName) {
          gesture.events[eventName] = gesture.events[eventName].bind(instance);
          mc.on(eventName, gesture.events[eventName]);
        });
        hammerGestures.push(gesture);
      }
    }); // setup mixing hammer gestures

    settings.gestures.forEach(function (gesture) {
      var type = getGestureType(gesture.type);

      if (Hammer && Hammer[type]) {
        if (gesture.recognizeWith) {
          mc.get(gesture.options.event).recognizeWith(gesture.recognizeWith.split(' ').filter(function (e) {
            return e !== '';
          }));
        }

        if (gesture.requireFailure) {
          mc.get(gesture.options.event).requireFailure(gesture.requireFailure.split(' ').filter(function (e) {
            return e !== '';
          }));
        }
      }
    });
  }
  /**
   * @private
   * removes all added hammer recognizers and native events
   */


  function removeAddedEvents() {
    // remove hammer recognizers and registered events
    hammerGestures.forEach(function (gesture) {
      Object.keys(gesture.events).forEach(function (eventName) {
        mc.off(eventName, gesture.events[eventName]);
      });
      mc.remove(gesture.options.event);
    });
    hammerGestures = [];
  }

  return {
    /**
     * Getter for the key.
     */
    get key() {
      return key;
    },

    /**
     * Updates this with new settings
     * @typedef settings
     * @type {object}
     * @property {string} [type] - The interaction type. Is 'hammer' for this component
     * @property {boolean|function} [enable] - Should the interaction be enabled or not.
     * This is only run when adding event handlers. In effect at startup, update or during on/off.
     * It does not run during every event loop.
     * @property {object} [events] - The keys in this object is the names of native events
     * that should be added to the chart element and they should all point to function which
     * will be the corresponding event handler.
     */
    set: function set(newSettings) {
      setDefaultSettings(newSettings);
      removeAddedEvents();

      if (isOn) {
        addRecognizers();
      }
    },

    /**
     * Turns off interactions
     */
    off: function off() {
      isOn = false;
      removeAddedEvents();
    },

    /**
     * Turns off interactions
     */
    on: function on() {
      isOn = true;

      if (hammerGestures.length === 0) {
        addRecognizers();
      }
    },

    /**
     * Destroys and unbinds all event handlers
     */
    destroy: function destroy() {
      removeAddedEvents();

      if (mc) {
        mc.destroy();
      }

      mc = null;
      instance = null;
      settings = null;
    }
  };
}

function initialize(picasso) {
  picasso.interaction('hammer', hammer);
}

/* harmony default export */ __webpack_exports__["a"] = (initialize);
//# sourceMappingURL=picasso-hammer.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21)))

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*
* picasso-plugin-q v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

function getFieldAccessor(field, page, deps) {
  if (!field) {
    return -1;
  }

  var cache = deps.cache;
  var origin = field.origin ? field.origin() : null;

  if (origin) {
    field = origin;
  }

  var fieldIdx = cache.fields.indexOf(field);
  var attrIdx = -1;
  var attrDimIdx = -1;

  if (fieldIdx === -1) {
    for (var i = 0; i < cache.wrappedFields.length; i++) {
      attrDimIdx = cache.wrappedFields[i].attrDims.map(function (v) {
        return v.instance;
      }).indexOf(field);
      attrIdx = cache.wrappedFields[i].attrExps.map(function (v) {
        return v.instance;
      }).indexOf(field);

      if (attrDimIdx !== -1 || attrIdx !== -1) {
        fieldIdx = i;
        break;
      }
    }
  }

  fieldIdx -= page.qArea.qLeft;

  if (fieldIdx < 0 || fieldIdx >= page.qArea.qWidth) {
    // throw new Error('Field out of range');
    return -1;
  }

  if (attrDimIdx >= 0) {
    return function (row) {
      return row[fieldIdx].qAttrDims.qValues[attrDimIdx];
    };
  }

  if (attrIdx >= 0) {
    return function (row) {
      return row[fieldIdx].qAttrExps.qValues[attrIdx];
    };
  }

  return function (row) {
    return row[fieldIdx];
  };
} // TODO - handle 'other' value
// const specialTextValues = {
//   '-3': (meta) => {
//     if ('othersLabel' in meta) {
//       return meta.othersLabel;
//     }
//     return '';
//   }
// };

function datumExtract(propCfg, cell, _ref) {
  var key = _ref.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function cellToValue(_ref2) {
  var cache = _ref2.cache,
      f = _ref2.f,
      mainCell = _ref2.mainCell,
      p = _ref2.p,
      prop = _ref2.prop,
      page = _ref2.page,
      rowIdx = _ref2.rowIdx,
      row = _ref2.row,
      sourceKey = _ref2.sourceKey,
      target = _ref2.target,
      targetProp = _ref2.targetProp;
  var propCell = mainCell;

  if (p.field && p.field !== f) {
    var propCellFn = getFieldAccessor(p.field, page, {
      cache: cache
    });

    if (propCellFn === -1) {
      return;
    }

    propCell = extend({
      qRow: rowIdx
    }, propCellFn(row));
  }

  target[targetProp] = datumExtract(p, propCell, {
    key: sourceKey
  }, prop);
}

function extract(config, dataset, cache, util) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];

  for (var i = 0; i < cfgs.length; i++) {
    if (typeof cfgs[i].field !== 'undefined') {
      var cube = dataset.raw();
      var sourceKey = dataset.key();
      var f = _typeof(cfgs[i].field) === 'object' ? cfgs[i].field : dataset.field(cfgs[i].field);

      var _util$normalizeConfig = util.normalizeConfig(cfgs[i], dataset),
          props = _util$normalizeConfig.props,
          main = _util$normalizeConfig.main;

      var propsArr = Object.keys(props);
      var track = !!cfgs[i].trackBy;

      var trackType = _typeof(cfgs[i].trackBy);

      var tracker = {};
      var trackedItems = [];
      var items = [];

      for (var j = 0; j < cube.qDataPages.length; j++) {
        var fn = getFieldAccessor(f, cube.qDataPages[j], {
          cache: cache
        });

        if (fn === -1) {
          continue;
        }

        for (var k = 0; k < cube.qDataPages[j].qMatrix.length; k++) {
          var rowIdx = cube.qDataPages[j].qArea.qTop + k;
          var mainCell = extend({
            qRow: rowIdx
          }, fn(cube.qDataPages[j].qMatrix[k]));
          var ret = datumExtract(main, mainCell, {
            key: sourceKey
          });
          var exclude = main.filter && !main.filter(mainCell);

          if (exclude) {
            continue;
          }

          for (var l = 0; l < propsArr.length; l++) {
            var p = props[propsArr[l]];
            var arr = p.fields || [p];

            if (p.fields) {
              ret[propsArr[l]] = [];
            } // loop through all props that need to be mapped and
            // assign 'value' and 'source' to each property


            for (var m = 0; m < arr.length; m++) {
              cellToValue({
                cache: cache,
                f: f,
                mainCell: mainCell,
                p: arr[m],
                prop: propsArr[l],
                props: props,
                page: cube.qDataPages[j],
                rowIdx: rowIdx,
                row: cube.qDataPages[j].qMatrix[k],
                sourceKey: sourceKey,
                target: p.fields ? ret[propsArr[l]] : ret,
                targetProp: p.fields ? m : propsArr[l]
              });
            }

            if (p.fields) {
              var fieldValues = ret[propsArr[l]].map(function (v) {
                return v.value;
              });
              var fieldLabels = ret[propsArr[l]].map(function (v) {
                return v.label;
              });
              ret[propsArr[l]] = {
                value: typeof p.value === 'function' ? p.value(fieldValues) : typeof p.value !== 'undefined' ? p.value : fieldValues,
                label: typeof p.label === 'function' ? p.label(fieldLabels) : typeof p.label !== 'undefined' ? String(p.label) : String(ret[propsArr[l]].value)
              };
            }
          } // collect items based on the trackBy value
          // items with the same trackBy value are placed in an array and reduced later


          if (track) {
            util.track({
              cfg: cfgs[i],
              itemData: mainCell,
              obj: ret,
              target: trackedItems,
              tracker: tracker,
              trackType: trackType
            });
          }

          items.push(ret);
        }
      } // reduce if items have been grouped


      if (track) {
        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {
          main: main,
          propsArr: propsArr,
          props: props
        })));
      } else {
        dataItems.push.apply(dataItems, items);
      }
    }
  }

  return dataItems;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

/**
 * Resolves the value at the given JSON path
 * @private
 * @param  {String} path [description]
 * @param  {Object} obj  [description]
 * @return {Object}      [description]
 *
 * @example
 * let path = "/path/to/paradise";
 * let obj = {
 *   path: {
 *     to: { paradise: "heaven"},
 *     from: {...}
 *   }
 * };
 * resolve( path, obj ); // "heaven"
 */
function resolve(path, obj) {
  if (path.charAt(0) === '/') {
    path = path.substring(1);
  }

  var arr = path.split('/');
  var subpath;
  var container = obj;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === '*' && Array.isArray(container)) {
      var carr = [];
      subpath = arr.slice(i + 1).join('/');

      for (var c = 0; c < container.length; c++) {
        var v = resolve(subpath, container[c]); // v.forEach(_ => _._parent = container[c]);

        if (Array.isArray(v)) {
          carr.push.apply(carr, _toConsumableArray(v));
        } else {
          carr.push(v);
        }
      }

      return carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
    }

    if (!arr[i] && Array.isArray(container)) {
      var _carr = new Array(container.length);

      subpath = arr.slice(i + 1).join('/');

      for (var _c = 0; _c < container.length; _c++) {
        _carr[_c] = resolve(subpath, container[_c]);
      }

      return _carr; // return container.map(v => resolve(arr.slice(i + 1).join('/'), v));
    }

    if (arr[i] in container) {
      container = container[arr[i]];
    }
  }

  return container;
}

function flattenTree(children, steps, arrIndexAtTargetDepth) {
  var arr = [];

  if (!children || !children.length) {
    return arr;
  }

  if (steps <= 0) {
    var nodes = arrIndexAtTargetDepth >= 0 ? [children[arrIndexAtTargetDepth]] : children;
    arr.push.apply(arr, _toConsumableArray(nodes));
  } else {
    for (var i = 0; i < children.length; i++) {
      if (children[i].children && children[i].children.length) {
        arr.push.apply(arr, _toConsumableArray(flattenTree(children[i].children, steps - 1, arrIndexAtTargetDepth)));
      }
    }
  }

  return arr;
}

function treeAccessor(sourceDepth, targetDepth, arrIndexAtTargetDepth) {
  if (sourceDepth === targetDepth) {
    return function (d) {
      return d;
    };
  }

  if (sourceDepth > targetDepth) {
    // traverse upwards
    var steps = Math.max(0, Math.min(100, sourceDepth - targetDepth));

    var path = _toConsumableArray(Array(steps)).map(String.prototype.valueOf, 'parent').join('.');

    return Function('node', "return node.".concat(path, ";")); // eslint-disable-line no-new-func
  }

  if (targetDepth > sourceDepth) {
    // flatten descendants
    var _steps = Math.max(0, Math.min(100, targetDepth - sourceDepth));

    return function (node) {
      return flattenTree(node.children, _steps - 1, arrIndexAtTargetDepth);
    };
  }

  return false;
}
function findField(query, _ref) {
  var cache = _ref.cache;

  if (typeof query === 'number') {
    return cache.fields[query];
  }

  var allFields = cache.allFields;

  if (typeof query === 'function') {
    for (var i = 0; i < allFields.length; i++) {
      if (query(allFields[i])) {
        return allFields[i];
      }
    }

    return false;
  }

  if (typeof query === 'string') {
    for (var _i = 0; _i < allFields.length; _i++) {
      if (allFields[_i].key() === query || allFields[_i].title() === query) {
        return allFields[_i];
      }
    }
  } else if (query && allFields.indexOf(query) !== -1) {
    // assume 'query' is a field instance
    return query;
  }

  throw Error("Field not found: ".concat(query));
}

var DIM_RX = /^qDimensionInfo(?:\/(\d+))?/;
var M_RX = /^\/?qMeasureInfo\/(\d+)/;
var ATTR_EXPR_RX = /\/qAttrExprInfo\/(\d+)/;
var ATTR_DIM_RX = /\/qAttrDimInfo\/(\d+)/;

function getColumnOrder(dataset) {
  var qColumnOrder = dataset.raw().qColumnOrder;
  var fields = dataset.fields();
  return qColumnOrder && qColumnOrder.length === fields.length ? qColumnOrder : fields.map(function (f, i) {
    return i;
  });
}

function getDimensionColumnOrder(cube) {
  var order = cube.qColumnOrder && cube.qColumnOrder.length ? cube.qColumnOrder : cube.qDimensionInfo.map(function (d, ii) {
    return ii;
  });
  return order.filter(function (ii) {
    return ii < cube.qDimensionInfo.length;
  });
}

function getFieldDepth(field, _ref) {
  var cube = _ref.cube;

  if (!field) {
    return -1;
  }

  var key = field.origin && field.origin() ? field.origin().key() : field.key();
  var isFieldDimension = false;
  var fieldIdx = -1; // cache.fields.indexOf(field);

  var attrIdx = -1;
  var attrDimIdx = -1;
  var fieldDepth = -1;
  var pseudoMeasureIndex = -1;
  var measureIdx = -1;
  var remainder = key;
  var treeOrder = cube.qEffectiveInterColumnSortOrder;
  var columnOrder = getDimensionColumnOrder(cube);

  if (DIM_RX.test(remainder)) {
    isFieldDimension = true;
    fieldIdx = +DIM_RX.exec(remainder)[1];
    remainder = key.replace(DIM_RX, '');
  }

  if (M_RX.test(remainder)) {
    if (cube.qMode === 'K') {
      pseudoMeasureIndex = +M_RX.exec(remainder)[1];
    } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
      pseudoMeasureIndex = +M_RX.exec(remainder)[1];
      measureIdx = 0;
    } else {
      measureIdx = +M_RX.exec(remainder)[1];
    }

    remainder = remainder.replace(M_RX, '');
  }

  if (remainder) {
    if (ATTR_DIM_RX.exec(remainder)) {
      attrDimIdx = +ATTR_DIM_RX.exec(remainder)[1];
    } else if (ATTR_EXPR_RX.exec(remainder)) {
      attrIdx = +ATTR_EXPR_RX.exec(remainder)[1];
    }
  }

  if (isFieldDimension) {
    if (cube.qMode === 'S') {
      fieldDepth = columnOrder[fieldIdx];
    } else {
      fieldDepth = treeOrder ? treeOrder.indexOf(fieldIdx) : fieldIdx;
    }
  } else if (treeOrder && treeOrder.indexOf(-1) !== -1) {
    // if pseudo dimension exists in sort order
    fieldDepth = treeOrder.indexOf(-1); // depth of pesudodimension
  } else {
    // assume measure is at the bottom of the tree
    fieldDepth = cube.qDimensionInfo.length - (cube.qMode === 'K' ? 0 : 1);
  }

  return {
    fieldDepth: fieldDepth + 1,
    // +1 due to root node
    pseudoMeasureIndex: pseudoMeasureIndex,
    measureIdx: measureIdx,
    attrDimIdx: attrDimIdx,
    attrIdx: attrIdx
  };
}

function getFieldAccessor$1(sourceDepthObject, targetDepthObject) {
  var nodeFn = treeAccessor(sourceDepthObject.fieldDepth, targetDepthObject.fieldDepth, targetDepthObject.pseudoMeasureIndex);
  var valueFn;

  if (targetDepthObject.measureIdx >= 0) {
    valueFn = function valueFn(node) {
      return node.data.qValues[targetDepthObject.measureIdx];
    };
  } else {
    valueFn = function valueFn(node) {
      return node.data;
    };
  }

  var attrFn;

  if (targetDepthObject.attrDimIdx >= 0) {
    attrFn = function attrFn(data) {
      return data.qAttrDims.qValues[targetDepthObject.attrDimIdx];
    };
  } else if (targetDepthObject.attrIdx >= 0) {
    attrFn = function attrFn(data) {
      return data.qAttrExps.qValues[targetDepthObject.attrIdx];
    };
  }

  return {
    nodeFn: nodeFn,
    attrFn: attrFn,
    valueFn: valueFn
  };
}

function datumExtract$1(propCfg, cell, _ref2) {
  var key = _ref2.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function doIt(_ref3) {
  var propsArr = _ref3.propsArr,
      props = _ref3.props,
      item = _ref3.item,
      itemData = _ref3.itemData,
      ret = _ref3.ret,
      sourceKey = _ref3.sourceKey;

  for (var i = 0; i < propsArr.length; i++) {
    var pCfg = props[propsArr[i]];
    var arr = pCfg.fields || [pCfg];
    var coll = void 0;
    var collStr = void 0;

    if (pCfg.fields) {
      coll = [];
      collStr = [];
    }

    var _loop = function _loop(j) {
      var p = arr[j];
      var fn = void 0;
      var str = void 0;
      var value = void 0;
      var nodes = void 0;
      var cells = void 0;
      var label = void 0;

      if (p.type === 'primitive') {
        value = p.value;
        label = String(p.value);
      } else {
        if (typeof p.value === 'function') {
          fn = function fn(v) {
            return p.value(v, item);
          };
        }

        if (typeof p.label === 'function') {
          str = function str(v) {
            return p.label(v, item);
          };
        }

        if (p.accessor) {
          nodes = p.accessor(item);

          if (Array.isArray(nodes)) {
            // propably descendants
            cells = nodes.map(p.valueAccessor);

            if (p.attrAccessor) {
              cells = cells.map(p.attrAccessor);
            }

            if (fn) {
              value = cells.map(fn);
              fn = null;
            }

            if (str) {
              label = cells.map(str);
              str = null;
            }

            value = p.reduce ? p.reduce(value) : value;
            label = p.reduceLabel ? p.reduceLabel(label, value) : String(value);
          } else {
            value = p.attrAccessor ? p.attrAccessor(p.valueAccessor(nodes)) : p.valueAccessor(nodes);
            label = value;
          }
        } else {
          value = itemData;
          label = itemData;
        }
      }

      if (pCfg.fields) {
        var v = fn ? fn(value) : value;
        coll.push(v);
        collStr.push(str && label != null ? str(label) : label != null ? label : String(v));
      } else {
        var _v = fn ? fn(value) : value;

        ret[propsArr[i]] = {
          value: _v,
          label: str ? str(label) : label != null ? label : String(_v)
        };

        if (p.field) {
          ret[propsArr[i]].source = {
            field: p.field.key(),
            key: sourceKey
          };
        }
      }
    };

    for (var j = 0; j < arr.length; j++) {
      _loop(j);
    }

    if (coll) {
      ret[propsArr[i]] = {
        value: typeof pCfg.value === 'function' ? pCfg.value(coll, item) : coll,
        label: typeof pCfg.label === 'function' ? pCfg.label(collStr, item) : collStr
      };
    }
  }
}

var getHierarchy = function getHierarchy(cube, cache, config) {
  var rootPath = cube.qMode === 'K' ? '/qStackedDataPages/*/qData' : '/qTreeDataPages/*';
  var childNodes = cube.qMode === 'K' ? 'qSubNodes' : 'qNodes';
  var root = resolve(rootPath, cube);

  if (!root || !root[0]) {
    return null;
  }

  cache.tree = hierarchy(root[0], config.children || function (node) {
    return node[childNodes];
  });
  return cache.tree;
};

function getHierarchyForSMode(dataset) {
  var matrix = dataset.raw().qDataPages.length ? dataset.raw().qDataPages[0].qMatrix : [];
  var order = getColumnOrder(dataset);
  var fields = dataset.fields();
  var dimensions = dataset.fields().filter(function (f) {
    return f.type() === 'dimension';
  }).map(function (f) {
    return order.indexOf(fields.indexOf(f));
  });
  var measures = dataset.fields().filter(function (f) {
    return f.type() === 'measure';
  }).map(function (f) {
    return order.indexOf(fields.indexOf(f));
  });
  var root = {
    __id: '__root',
    qValues: []
  };
  var keys = {
    __root: root
  };

  for (var r = 0; r < matrix.length; r++) {
    var row = matrix[r];
    var id = '__root'; // let parent = root;

    var isNew = false;

    for (var c = 0; c < dimensions.length; c++) {
      var cell = row[dimensions[c]];
      var key = "".concat(id, "__").concat(cell.qText);

      if (!keys[key]) {
        keys[key] = Object.assign({
          __id: key,
          __parent: id,
          qValues: []
        }, cell);
        isNew = true;
      }

      id = key;
    }

    if (isNew) {
      for (var _c = 0; _c < measures.length; _c++) {
        var _cell = row[measures[_c]];
        keys[id].qValues.push(_cell);
      }
    }
  }

  var nodes = Object.keys(keys).map(function (key) {
    return keys[key];
  });
  var h = stratify().id(function (d) {
    return d.__id;
  }).parentId(function (d) {
    return d.__parent;
  })(nodes);
  return h;
}

var attachPropsAccessors = function attachPropsAccessors(_ref4) {
  var propsArr = _ref4.propsArr,
      props = _ref4.props,
      cube = _ref4.cube,
      cache = _ref4.cache,
      itemDepthObject = _ref4.itemDepthObject,
      f = _ref4.f;

  for (var i = 0; i < propsArr.length; i++) {
    var pCfg = props[propsArr[i]];
    var arr = pCfg.fields ? pCfg.fields : [pCfg];

    for (var j = 0; j < arr.length; j++) {
      var p = arr[j];

      if (p.field !== f) {
        var depthObject = getFieldDepth(p.field, {
          cube: cube,
          cache: cache
        });
        var accessors = getFieldAccessor$1(itemDepthObject, depthObject);
        p.accessor = accessors.nodeFn; // nodes accessor

        p.valueAccessor = accessors.valueFn; // cell accessor

        p.attrAccessor = accessors.attrFn; // attr cell accessor
      }
    }
  }
};

function augment() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var dataset = arguments.length > 1 ? arguments[1] : undefined;
  var cache = arguments.length > 2 ? arguments[2] : undefined;
  var util = arguments.length > 3 ? arguments[3] : undefined;
  var cube = dataset.raw();
  var sourceKey = dataset.key();
  var h = cube.qMode === 'S' ? getHierarchyForSMode(dataset) : getHierarchy(cube, cache, config);

  if (!h) {
    return null;
  }

  var height = h.height;
  var propDefs = [];

  for (var i = 0; i <= height; i++) {
    var f = null;

    if (i > 0) {
      if (cube.qMode === 'S') {
        var order = getDimensionColumnOrder(cube);
        var idx = order[i - 1];
        f = cache.fields[idx];
      } else {
        var _idx = cube.qEffectiveInterColumnSortOrder[i - 1]; // if (idx === -1) { // pseudo
        //   let childIdx = node.parent.children.indexOf(node);
        //   idx = cube.qDimensionInfo.length + childIdx; // measure field
        // }

        if (i > cube.qEffectiveInterColumnSortOrder.length) {
          _idx = cube.qDimensionInfo.length;
        }

        f = cache.fields[_idx];
      }
    }

    var _util$normalizeConfig = util.normalizeConfig(Object.assign({}, config, {
      field: f ? f.key() : undefined
    }), dataset),
        props = _util$normalizeConfig.props,
        main = _util$normalizeConfig.main;

    var propsArr = Object.keys(props);
    propDefs[i] = {
      propsArr: propsArr,
      props: props,
      main: main
    };
    var itemDepthObject = f ? getFieldDepth(f, {
      cube: cube,
      cache: cache
    }) : {
      fieldDepth: 0
    };
    attachPropsAccessors({
      propsArr: propsArr,
      props: props,
      cube: cube,
      cache: cache,
      itemDepthObject: itemDepthObject,
      f: f
    });
  }

  var replica = h.copy();
  var replicaDescendants = replica.descendants();
  var descendants = h.descendants();

  for (var _i = 0; _i < descendants.length; _i++) {
    var _propsArr = propDefs[descendants[_i].depth].propsArr;
    var props = propDefs[descendants[_i].depth].props;
    var main = propDefs[descendants[_i].depth].main;
    var item = replicaDescendants[_i];
    var itemData = item.data; // main.valueAccessor(currentOriginal);

    var ret = datumExtract$1(main, itemData, {
      key: sourceKey
    });
    doIt({
      propsArr: _propsArr,
      props: props,
      item: item,
      itemData: itemData,
      ret: ret,
      sourceKey: sourceKey,
      isTree: true
    });
    descendants[_i].data = ret;
  }

  return h;
}
function extract$1(config, dataset, cache, util) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];

  for (var g = 0; g < cfgs.length; g++) {
    if (typeof cfgs[g].field !== 'undefined') {
      var cube = dataset.raw();
      var sourceKey = dataset.key();
      var h = getHierarchy(cube, cache, config);

      if (!h) {
        continue;
      }

      var f = _typeof(cfgs[g].field) === 'object' ? cfgs[g].field : dataset.field(cfgs[g].field);

      var _util$normalizeConfig2 = util.normalizeConfig(cfgs[g], dataset),
          props = _util$normalizeConfig2.props,
          main = _util$normalizeConfig2.main;

      var propsArr = Object.keys(props);
      var itemDepthObject = getFieldDepth(f, {
        cube: cube,
        cache: cache
      });

      var _getFieldAccessor = getFieldAccessor$1({
        fieldDepth: 0
      }, itemDepthObject),
          nodeFn = _getFieldAccessor.nodeFn,
          attrFn = _getFieldAccessor.attrFn,
          valueFn = _getFieldAccessor.valueFn;

      attachPropsAccessors({
        propsArr: propsArr,
        props: props,
        cube: cube,
        cache: cache,
        itemDepthObject: itemDepthObject,
        f: f
      });
      var track = !!cfgs[g].trackBy;

      var trackType = _typeof(cfgs[g].trackBy);

      var tracker = {};
      var trackedItems = [];
      var items = nodeFn(cache.tree);
      var mapped = [];

      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        var itemData = attrFn ? attrFn(valueFn(item)) : valueFn(item);
        var exclude = main.filter && !main.filter(itemData);

        if (exclude) {
          continue;
        }

        var ret = datumExtract$1(main, itemData, {
          key: sourceKey
        });
        doIt({
          propsArr: propsArr,
          props: props,
          item: item,
          itemData: itemData,
          ret: ret,
          sourceKey: sourceKey
        }); // collect items based on the trackBy value
        // items with the same trackBy value are placed in an array and reduced later

        if (track) {
          util.track({
            cfg: cfgs[g],
            itemData: itemData,
            obj: ret,
            target: trackedItems,
            tracker: tracker,
            trackType: trackType
          });
        }

        mapped.push(ret);
      } // reduce if items have been grouped


      if (track) {
        dataItems.push.apply(dataItems, _toConsumableArray(util.collect(trackedItems, {
          main: main,
          propsArr: propsArr,
          props: props
        })));
      } else {
        dataItems.push.apply(dataItems, mapped);
      }
    }
  }

  return dataItems;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var format_min = createCommonjsModule(function (module) {
/*! javascript-number-formatter - v1.1.11 - http://mottie.github.com/javascript-number-formatter/ * © ecava */
!function(a,b){module.exports=b();}(commonjsGlobal,function(){return function(a,b){if(!a||isNaN(+b))return b;var c,d,e,f,g,h,i,j,k,l,m=a.length,n=a.search(/[0-9\-\+#]/),o=n>0?a.substring(0,n):"",p=a.split("").reverse().join(""),q=p.search(/[0-9\-\+#]/),r=m-q,s=a.substring(r,r+1),t=r+("."===s||","===s?1:0),u=q>0?a.substring(t,m):"";if(a=a.substring(n,t),b="-"===a.charAt(0)?-b:+b,c=b<0?b=-b:0,d=a.match(/[^\d\-\+#]/g),e=d&&d[d.length-1]||".",f=d&&d[1]&&d[0]||",",a=a.split(e),b=b.toFixed(a[1]&&a[1].length),b=+b+"",h=a[1]&&a[1].lastIndexOf("0"),j=b.split("."),(!j[1]||j[1]&&j[1].length<=h)&&(b=(+b).toFixed(h+1)),k=a[0].split(f),a[0]=k.join(""),g=a[0]&&a[0].indexOf("0"),g>-1)for(;j[0].length<a[0].length-g;)j[0]="0"+j[0];else 0===+j[0]&&(j[0]="");if(b=b.split("."),b[0]=j[0],i=k[1]&&k[k.length-1].length){for(l=b[0],p="",r=l.length%i,m=l.length,t=0;t<m;t++)p+=l.charAt(t),!((t-r+1)%i)&&t<m-i&&(p+=f);b[0]=p;}return b[1]=a[1]&&b[1]?e+b[1]:"",d=b.join(""),"0"!==d&&""!==d||(c=!1),o+((c?"-":"")+d)+u}});
});

function escapeRegExp(str) {
  return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}

var SIprefixes = {
  3: 'k',
  6: 'M',
  9: 'G',
  12: 'T',
  15: 'P',
  18: 'E',
  21: 'Z',
  24: 'Y',
  '-3': 'm',
  '-6': 'μ',
  '-9': 'n',
  '-12': 'p',
  '-15': 'f',
  '-18': 'a',
  '-21': 'z',
  '-24': 'y'
},
    percentage = /%$/,
    //    scientific = /e[\+\-][0-9]+/,
radix = /^\(r(0[2-9]|[12]\d|3[0-6])\)/i,
    oct = /^\(oct\)/i,
    dec = /^\(dec\)/i,
    hex = /^\(hex\)/i,
    bin = /^\(bin\)/i,
    rom = /^\(rom\)/i,
    functional = /^(\(rom\)|\(bin\)|\(hex\)|\(dec\)|\(oct\)|\(r(0[2-9]|[12]\d|3[0-6])\))/i,
    prec = /#|0/g;

function formatRadix(value, fradix, pattern, decimal) {
  value = value.toString(fradix);

  if (pattern[1] === pattern[1].toUpperCase()) {
    value = value.toUpperCase();
  }

  if (value.length - value.indexOf('.') > 10) {
    // limit to 10 decimal places
    value = value.slice(0, value.indexOf('.') + 11);
  }

  return value.replace('.', decimal || '.');
} // value must be an integer
// value must not be in scientific notation


function formatRoman(value, pattern) {
  var i,
      s = '',
      v = Number(String(value).slice(-3)),
      nThousands = (value - v) / 1000,
      decimal = [0, 1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900].reverse(),
      numeral = ['0', 'I', 'IV', 'V', 'IX', 'X', 'XL', 'L', 'XC', 'C', 'CD', 'D', 'CM'].reverse();

  while (v > 0) {
    for (i = 0; i < decimal.length; i++) {
      if (decimal[i] <= v) {
        s += numeral[i];
        v -= decimal[i];
        break;
      }
    }
  }

  for (i = 0; i < nThousands; i++) {
    s = "M".concat(s);
  }

  if (pattern[1] !== pattern[1].toUpperCase()) {
    s = s.toLowerCase();
  }

  return s;
}

function formatFunctional(value, pattern, d) {
  var temp;

  if (radix.test(pattern)) {
    value = formatRadix(value, Number(/\d{2}/.exec(pattern)[0]), pattern, d);
  } else if (oct.test(pattern)) {
    value = formatRadix(value, 8, pattern, d);
  } else if (dec.test(pattern)) {
    value = formatRadix(value, 10, pattern, d);
  } else if (hex.test(pattern)) {
    value = formatRadix(value, 16, pattern, d);
  } else if (bin.test(pattern)) {
    value = formatRadix(value, 2, pattern, d);
  } else if (rom.test(pattern)) {
    temp = '';

    if (value < 0) {
      temp = '-';
      value = -value;
    }

    value = Math.floor(value);

    if (value === 0) {
      value = '0';
    } else if (value <= 500000) {
      // limit in engine
      value = formatRoman(value, pattern);
      value = temp + value;
    } else {
      value = pattern + temp + value.toExponential(0); // to return same result as engine
    }
  }

  return value;
}

function escape(value, flags, justStr) {
  var str = escapeRegExp(value);

  if (justStr) {
    return str;
  }

  return new RegExp(str || '', flags);
}

function createRegExp(thousand, decimal) {
  if (decimal) {
    decimal = escapeRegExp(decimal);
  }

  if (thousand) {
    thousand = escapeRegExp(thousand);
  }

  return new RegExp("(?:[#0]+".concat(thousand, ")?[#0]+(?:").concat(decimal, "[#0]+)?"));
}

function getAbbreviations(localeInfo, listSeparator) {
  if (!localeInfo || !localeInfo.qNumericalAbbreviation) {
    return SIprefixes;
  }

  var abbreviations = {};
  var abbrs = localeInfo.qNumericalAbbreviation.split(listSeparator);
  abbrs.forEach(function (abbreviation) {
    var abbreviationTuple = abbreviation.split(':');

    if (abbreviationTuple.length === 2) {
      abbreviations[abbreviationTuple[0]] = abbreviationTuple[1];
    }
  });
  return abbreviations;
}

function preparePattern(o, t, d) {
  var parts,
      lastPart,
      pattern = o.pattern,
      numericPattern,
      prefix,
      postfix,
      groupTemp,
      decTemp,
      temp,
      regex;

  if (pattern.indexOf('A') >= 0) {
    // abbreviate SI
    pattern = pattern.replace('A', '');
    o.abbreviate = true;
  } // extract the numeric part from the pattern


  regex = createRegExp(t, d);
  numericPattern = pattern.match(regex);
  numericPattern = numericPattern ? numericPattern[0] : '';
  prefix = numericPattern ? pattern.substr(0, pattern.indexOf(numericPattern)) : pattern;
  postfix = numericPattern ? pattern.substring(pattern.indexOf(numericPattern) + numericPattern.length) : '';

  if (!numericPattern) {
    numericPattern = pattern ? '#' : '##########';
  }

  if (t && t === d) {
    // ignore grouping if grouping separator is same as decimal separator
    // extract decimal part
    parts = numericPattern.split(d);
    lastPart = parts.pop();
    numericPattern = parts.join('') + d + lastPart;
    t = '';
  } // formatting library does not support multiple characters as separator (nor +-).
  // do a temporary replacement


  groupTemp = t;
  t = /,/.test(d) ? '¤' : ',';

  if (groupTemp) {
    numericPattern = numericPattern.replace(escape(groupTemp, 'g'), t);
  }

  decTemp = d;
  d = '.';

  if (decTemp) {
    numericPattern = numericPattern.replace(escape(decTemp, 'g'), d);
  }

  temp = numericPattern.match(/#/g);
  temp = temp ? temp.length : 0;
  var splitPattern = pattern.split(decTemp);
  var matchPrecisionResult;

  if (splitPattern[1]) {
    matchPrecisionResult = splitPattern[1].match(prec);
  }

  o.prefix = prefix || '';
  o.postfix = postfix || '';
  o.pattern = pattern;
  o.maxPrecision = matchPrecisionResult ? matchPrecisionResult.length : 2;
  o.percentage = percentage.test(pattern);
  o.numericPattern = numericPattern || '';
  o.numericRegex = new RegExp("".concat(escape(t, null, true), "|").concat(escape(d, null, true)), 'g');
  o.groupTemp = groupTemp;
  o.decTemp = decTemp;
  o.t = t;
  o.d = d;
  o.temp = temp;
}

var NumberFormatter =
/*#__PURE__*/
function () {
  /**
   * @name NumberFormatter
   * @constructs
   * @param {Object} localeInfo
   * @param {String} pattern
   * @param {String} [thousand]
   * @param {String} [decimal]
   * @param {String} [type]
   */
  function NumberFormatter(localeInfo, pattern, thousand, decimal, type) {
    _classCallCheck(this, NumberFormatter);

    this.localeInfo = localeInfo;
    this.pattern = pattern;
    this.thousandDelimiter = thousand || ',';
    this.decimalDelimiter = decimal || '.';
    this.type = type || 'numeric'; // FIXME qListSep?
    // this.patternSeparator = this.localeInfo && this.localeInfo.qListSep ? this.localeInfo.qListSep : ';';

    this.patternSeparator = ';';
    this.abbreviations = getAbbreviations(localeInfo, this.patternSeparator);
    this.prepare();
  }

  _createClass(NumberFormatter, [{
    key: "clone",
    value: function clone() {
      var n = new NumberFormatter(this.localeInfo, this.pattern, this.thousandDelimiter, this.decimalDelimiter, this.type);
      n.subtype = this.subtype;
      return n;
    }
    /**
     * Formats a number according to a specific pattern.
     * Use # for optional numbers and 0 for padding.
     * @param {Number} value Number to format.
     * @param {String} [pattern] The pattern to apply.
     * @param {String} [t] Grouping separator.
     * @param {String} [d] Decimal delimiter.
     * @example
     * format(10, "0") // 10;
     * format(10, "#") // 10;
     * format(10, "##.#") // 10;
     * format(10, "##.0") // 10.0;
     * format(10, "000") // 010;
     * format(10.123, "0.0") // 10.1;
     * format(10.123, "0.00##") // 10.123; // at least 2 decimals, never more than 4
     * format(123456789, "#,###") // 123,456,789;
     * format(123456789, "####-####", "-") // 1-2345-6789;
     * format(10000, "#A") // 10k,  A -> SI abbreviation
     * format(1234567, "#.###A") // 1.235M;
     * format(0.0001, "#.#A") // 0.1m;
     *
     * format(0.257, "0.0%") // 25.7%; // will multiply by 100
     * format(9876, "$#,###") // $9,876;
     * format(-9876, "$#,###;$(#,###)") // $(9,876); // use ; for alternative formatting for negative values
     * format(10, "(r16)") // a; // radix 16
     * format(15, "(hex)") // f; // same as (r16)
     * format(15, "(HEX)") // F;
     * format(10, "(bin)") // 1010; // same as (r02)
     * format(10, "(oct)") // 12; // same as (r08)
     */

  }, {
    key: "format",
    value: function format(value, pattern, t, d) {
      this.prepare(pattern, t, d);
      return this.formatValue(value);
    }
  }, {
    key: "prepare",
    value: function prepare(pattern, t, d) {
      var prep;

      if (typeof pattern === 'undefined') {
        pattern = this.pattern;
      }

      if (typeof t === 'undefined') {
        t = this.thousandDelimiter;
      }

      if (typeof d === 'undefined') {
        d = this.decimalDelimiter;
      }

      if (!pattern) {
        this._prepared = {
          pattern: false
        };
        return;
      }

      this._prepared = {
        positive: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        negative: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        },
        zero: {
          d: d,
          t: t,
          abbreviate: false,
          isFunctional: false,
          prefix: '',
          postfix: ''
        }
      };
      prep = this._prepared;
      pattern = pattern.split(this.patternSeparator);
      prep.positive.pattern = pattern[0];
      prep.negative.pattern = pattern[1];
      prep.zero.pattern = pattern[2];

      if (functional.test(pattern[0])) {
        prep.positive.isFunctional = true;
      }

      if (!pattern[1]) {
        prep.negative = false;
      } else if (functional.test(pattern[1])) {
        prep.negative.isFunctional = true;
      }

      if (!pattern[2]) {
        prep.zero = false;
      } else if (functional.test(pattern[2])) {
        prep.zero.isFunctional = true;
      }

      if (!prep.positive.isFunctional) {
        preparePattern(prep.positive, t, d);
      }

      if (prep.negative && !prep.negative.isFunctional) {
        preparePattern(prep.negative, t, d);
      }

      if (prep.zero && !prep.zero.isFunctional) {
        preparePattern(prep.zero, t, d);
      }
    }
  }, {
    key: "formatValue",
    value: function formatValue(value) {
      var prep = this._prepared,
          temp,
          exponent,
          abbr = '',
          absValue,
          num,
          sciValue = '',
          d,
          t,
          i,
          numericPattern,
          decimalPartPattern,
          original = value;

      if (isNaN(value)) {
        return "".concat(original);
      }

      value = +value;

      if (prep.pattern === false) {
        return value.toString();
      }

      if (value === 0 && prep.zero) {
        prep = prep.zero;
        return prep.pattern;
      }

      if (value < 0 && prep.negative) {
        prep = prep.negative;
        value = -value;
      } else {
        prep = prep.positive;
      }

      d = prep.d;
      t = prep.t;

      if (prep.isFunctional) {
        value = formatFunctional(value, prep.pattern, d);
      } else {
        if (prep.percentage) {
          value *= 100;
        }

        if (prep.abbreviate) {
          var abbrArray = Object.keys(this.abbreviations).map(function (key) {
            return parseInt(key, 10);
          }).sort(function (a, b) {
            return a - b;
          });
          var lowerAbbreviation;
          var upperAbbreviation = abbrArray[0];
          i = 0;
          exponent = Number(Number(value).toExponential().split('e')[1]);

          while (upperAbbreviation <= exponent && i < abbrArray.length) {
            i++;
            upperAbbreviation = abbrArray[i];
          }

          if (i > 0) {
            lowerAbbreviation = abbrArray[i - 1];
          }

          var suggestedAbbrExponent; // value and lower abbreviation is for values above 10, use the lower (move to the left <==)

          if (lowerAbbreviation && exponent > 0 && lowerAbbreviation > 0) {
            suggestedAbbrExponent = lowerAbbreviation; // value and lower abbreviation is for values below 0.1 (move to the right ==>)
          } else if (exponent < 0 && lowerAbbreviation < 0 || !lowerAbbreviation) {
            // upper abbreviation is also for values below 0.1 and precision allows for using the upper abbreviation(move to the right ==>)
            if (upperAbbreviation < 0 && upperAbbreviation - exponent <= prep.maxPrecision) {
              suggestedAbbrExponent = upperAbbreviation; // lower abbrevaition is smaller than exponent and we can't get away with not abbreviating
            } else if (lowerAbbreviation <= exponent && !(upperAbbreviation > 0 && -exponent <= prep.maxPrecision)) {
              // (move to left <==)
              suggestedAbbrExponent = lowerAbbreviation;
            }
          }

          if (suggestedAbbrExponent) {
            abbr = this.abbreviations[suggestedAbbrExponent];
            value /= Math.pow(10, suggestedAbbrExponent);
          }
        }

        absValue = Math.abs(value);
        temp = prep.temp;
        numericPattern = prep.numericPattern;
        decimalPartPattern = numericPattern.split(d)[1];

        if (this.type === 'I') {
          value = Math.round(value);
        }

        num = value;

        if (!decimalPartPattern && numericPattern.slice(-1)[0] === '#') {
          if (absValue >= Math.pow(10, temp) || absValue < 1 || absValue < 1e-4) {
            if (value === 0) {
              value = '0';
            } else if (absValue < 1e-4 || absValue >= 1e20) {
              // engine always formats values < 1e-4 in scientific form, values >= 1e20 can only be represented in scientific form
              value = num.toExponential(Math.max(1, Math.min(14, temp)) - 1);
              value = value.replace(/\.?0+(?=e)/, '');
              sciValue = '';
            } else {
              value = value.toPrecision(Math.max(1, Math.min(14, temp)));

              if (value.indexOf('.') >= 0) {
                value = value.replace(value.indexOf('e') < 0 ? /0+$/ : /\.?0+(?=e)/, '');
                value = value.replace('.', d);
              }
            }
          } else {
            numericPattern += d;
            temp = Math.max(0, Math.min(20, temp - Math.ceil(Math.log(absValue) / Math.log(10))));

            for (i = 0; i < temp; i++) {
              numericPattern += '#';
            }

            value = format_min(numericPattern, value);
          }
        } else if (absValue >= 1e15 || absValue > 0 && absValue <= 1e-14) {
          value = absValue ? absValue.toExponential(15).replace(/\.?0+(?=e)/, '') : '0';
        } else {
          var wholePart = Number(value.toFixed(Math.min(20, decimalPartPattern ? decimalPartPattern.length : 0)).split('.')[0]);
          var wholePartPattern = numericPattern.split(d)[0];
          wholePartPattern += d;
          value = format_min(wholePartPattern, wholePart) || '0';

          if (decimalPartPattern) {
            var nDecimals = Math.max(0, Math.min(14, decimalPartPattern.length)); // the length of e.g. 0000#####

            var nZeroes = decimalPartPattern.replace(/#+$/, '').length;
            var decimalPart = (this.type === 'I' ? 0 : absValue % 1).toFixed(nDecimals).slice(2).replace(/0+$/, ''); // remove trailing zeroes

            for (i = decimalPart.length; i < nZeroes; i++) {
              decimalPart += '0';
            }

            if (decimalPart) {
              value += d + decimalPart;
            }
          } else if (wholePart === 0) {
            // to avoid "-" being prefixed to value
            num = 0;
          }
        }

        value = value.replace(prep.numericRegex, function (m) {
          if (m === t) {
            return prep.groupTemp;
          }

          if (m === d) {
            return prep.decTemp;
          }

          return '';
        });

        if (num < 0 && !/^-/.test(value)) {
          value = "-".concat(value);
        }
      }

      return prep.prefix + value + sciValue + abbr + prep.postfix;
    }
  }], [{
    key: "getStaticFormatter",
    value: function getStaticFormatter() {
      return {
        prepare: function prepare() {},
        formatValue: function formatValue(v) {
          return "".concat(v);
        }
      };
    }
  }]);

  return NumberFormatter;
}();

function numberFormatFactory() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(NumberFormatter, args);
}

function memoize(func) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _opts$size = opts.size,
      size = _opts$size === void 0 ? 5000 : _opts$size,
      _opts$multipleArgumen = opts.multipleArguments,
      multipleArguments = _opts$multipleArgumen === void 0 ? false : _opts$multipleArgumen,
      _opts$toKey = opts.toKey,
      toKey = _opts$toKey === void 0 ? function (arg) {
    return arg;
  } : _opts$toKey;
  var cache = Object.create(null);
  var index = Object.create(null);
  var counter = 0;
  var fifo = 0; // First-In-First-Out index

  var _cacher2;

  var k;

  if (multipleArguments) {
    _cacher2 = function cacher() {
      k = toKey.apply(void 0, arguments);

      if (_cacher2.has(k)) {
        return _cacher2.get(k);
      }

      return _cacher2.set(k, func.apply(void 0, arguments));
    };
  } else {
    _cacher2 = function _cacher(arg) {
      k = toKey(arg);

      if (_cacher2.has(k)) {
        return _cacher2.get(k);
      }

      return _cacher2.set(k, func(arg));
    };
  }

  _cacher2.set = function (key, val) {
    if (counter >= size) {
      delete cache[index[fifo]];
      delete index[fifo];
      counter--;
      fifo++;
    }

    cache[key] = val;
    index[counter] = key;
    counter++;
    return val;
  };

  _cacher2.get = function (key) {
    return cache[key];
  };

  _cacher2.has = function (key) {
    return key in cache;
  };

  _cacher2.clear = function () {
    cache = Object.create(null);
    index = Object.create(null);
    counter = 0;
    fifo = 0;
  };

  _cacher2.size = function () {
    return counter;
  };

  return _cacher2;
}

function formatter(pattern, thousand, decimal, qType, localeInfo) {
  var qformat = numberFormatFactory(localeInfo, pattern, thousand, decimal, qType);
  var memoized = memoize(qformat.formatValue.bind(qformat), {
    // Handle NaN and cases where toString yields different result than +operator. Ex. a Date.
    toKey: function toKey(value) {
      return isNaN(value) ? value : +value;
    }
  });
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Number} value   The number to be formatted
   * @return {String}         [description]
   */

  function format(value) {
    return memoized(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Number} v   Value
    * @param  {String} t   Thousand
    * @param  {String} d   Decimal
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v, t, d) {
    memoized.clear();
    return qformat.format(v, p, t, d);
  };
  /**
    * Change the pattern on existing formatter
    *
    * @param  {String} p     Pattern (optional)
    * @return {String}       Returns the pattern
    */


  format.pattern = function patternFn(p) {
    if (p) {
      memoized.clear();
      qformat.pattern = p;
      qformat.prepare();
    }

    return qformat.pattern;
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */

  /* format.locale = function( ...args ) {
    locale = formatLocale( ...args );
    d3format = locale.format( pattern );
     return this;
  }; */


  return format;
}

/* eslint import/prefer-default-export: 0 */
var TYPES = {
  AUTO: 'U',
  INTEGER: 'I',
  NUMBER: 'R',
  FIXED_TO: 'F',
  MONEY: 'M',
  DATE: 'D',
  TIME: 'T',
  DATE_TIME: 'TS',
  INTERVAL: 'IV'
};

var DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
var DAYS_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var MONTHS_ABBR = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var SECONDS_PER_DAY = 86400;

function pad(s, n) {
  for (var i = s.length; i < n; i++) {
    s = "0".concat(s);
  }

  return s;
}

function parseDate(d, twelveFormat) {
  var h = d.getUTCHours();
  var day = d.getUTCDay() - 1;

  if (twelveFormat) {
    h %= 12;

    if (!h) {
      // h == 0 -> 12
      h = 12;
    }
  }

  if (day < 0) {
    day = 6;
  }

  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth(),
    day: day,
    date: d.getUTCDate(),
    h: h,
    m: d.getUTCMinutes(),
    s: d.getUTCSeconds(),
    f: d.getUTCMilliseconds(),
    t: d.getUTCHours() >= 12 ? 'pm' : 'am'
  };
}

function getRemainder(value) {
  var s = value.toString().split('.');

  if (s[1]) {
    s = Number("0.".concat(s[1]));
  } else {
    return 0;
  }

  return s;
}

function parseIntervalDays(days) {
  var d = days;
  var h = 24 * getRemainder(d);
  var m = 60 * getRemainder(h);
  var s = 60 * getRemainder(m);
  var ms = 1000 * getRemainder(s);
  return {
    d: Math.floor(d),
    h: Math.floor(h),
    m: Math.floor(m),
    s: Math.floor(s),
    f: Math.round(ms)
  };
}

function parseInterval(days, pattern) {
  var units = parseIntervalDays(days),
      d = units.d,
      h = units.h,
      m = units.m,
      s = units.s,
      f = units.f,
      w = 0,
      date;

  if (/w+|t+/gi.test(pattern)) {
    date = new Date(Date.UTC(1899, 11, 30 + Math.floor(days), 0, 0, Math.round(SECONDS_PER_DAY * (days - Math.floor(days)))));

    if (isNaN(date.getTime())) {
      date = null;
    }
  }

  if (!/D+/gi.test(pattern)) {
    h += d * 24;
  }

  if (!/h+/gi.test(pattern)) {
    m += h * 60;
  }

  if (!/m+/gi.test(pattern)) {
    s += m * 60;
  }

  if (/w+/gi.test(pattern)) {
    w = date ? date.getDay() - 1 : 0;

    if (w < 0) {
      w = 6;
    }
  }

  var someT = '';

  if (date) {
    someT = date.getUTCHours() >= 12 ? 'pm' : 'am';
  }

  return {
    year: 0,
    month: 0,
    day: w,
    date: d,
    h: h,
    m: m,
    s: s,
    f: f,
    t: someT
  };
}

function getMasks(inst, d) {
  return {
    'Y+|y+': {
      Y: "".concat(Number("".concat(d.year).slice(-2))),
      YY: pad("".concat(d.year).slice(-2), 2),
      YYY: pad("".concat(d.year).slice(-3), 3),
      def: function def(m) {
        // default
        return pad("".concat(d.year), m.length);
      }
    },
    'M+': {
      M: d.month + 1,
      MM: pad("".concat(d.month + 1), 2),
      MMM: inst.locale_months_abbr[d.month],
      def: inst.locale_months[d.month]
    },
    'W+|w+': {
      W: d.day,
      WW: pad("".concat(d.day), 2),
      WWW: inst.locale_days_abbr[d.day],
      def: inst.locale_days[d.day]
    },
    'D+|d+': {
      D: d.date,
      def: function def(m) {
        return pad("".concat(d.date), m.length);
      }
    },
    'h+|H+': {
      h: d.h,
      def: function def(m) {
        return pad("".concat(d.h), m.length);
      }
    },
    'm+': {
      m: d.m,
      def: function def(m) {
        return pad("".concat(d.m), m.length);
      }
    },
    's+|S+': {
      s: d.s,
      def: function def(m) {
        return pad("".concat(d.s), m.length);
      }
    },
    'f+|F+': {
      def: function def(m) {
        var f = "".concat(d.f),
            n = m.length - f.length;

        if (n > 0) {
          for (var i = 0; i < n; i++) {
            f += '0';
          }
        } else if (n < 0) {
          f = f.slice(0, m.length);
        }

        return f;
      }
    },
    't{1,2}|T{1,2}': {
      def: function def(m) {
        var t = d.t;

        if (m[0].toUpperCase() === m[0]) {
          t = t.toUpperCase();
        }

        t = t.slice(0, m.length);
        return t;
      }
    }
  };
}

var DateFormatter =
/*#__PURE__*/
function () {
  /**
   * @name DateFormatter
   * @constructs
   * @param {Object} localeInfo
   * @param {String} pattern
   */
  function DateFormatter(localeInfo, pattern, qtype) {
    _classCallCheck(this, DateFormatter);

    var info = localeInfo || {};

    if (!info.qCalendarStrings) {
      info.qCalendarStrings = {
        qLongDayNames: DAYS,
        qDayNames: DAYS_ABBR,
        qLongMonthNames: MONTHS,
        qMonthNames: MONTHS_ABBR
      };
    }

    this.localeInfo = info;
    this.locale_days = info.qCalendarStrings.qLongDayNames.slice();
    this.locale_days_abbr = info.qCalendarStrings.qDayNames.slice();
    this.locale_months = info.qCalendarStrings.qLongMonthNames.slice();
    this.locale_months_abbr = info.qCalendarStrings.qMonthNames.slice();

    if (!pattern) {
      var _patternMap;

      var patternMap = (_patternMap = {}, _defineProperty(_patternMap, TYPES.TIME, info.qTimeFmt || 'hh:mm:ss'), _defineProperty(_patternMap, TYPES.DATE, info.qDateFmt || 'YYYY-MM-DD'), _defineProperty(_patternMap, TYPES.DATE_TIME, info.qTimestampFmt || 'YYYY-MM-DD hh:mm:ss'), _patternMap);
      pattern = patternMap[qtype];
    }

    this.pattern = pattern;
  }

  _createClass(DateFormatter, [{
    key: "clone",
    value: function clone() {
      var n = new DateFormatter(this.localeInfo, this.pattern);
      n.subtype = this.subtype;
      return n;
    }
    /**
     * Formats a date according to given pattern
     * @param {Date} date The date to format.
     * @param {String} pattern The desired format of the date
     * var d = new Date(2013, 8, 15, 13, 55, 40, 987);
     * var n = new DateFormatter();
     * @example
     * m.format( d, 'YYYY-MM-DD hh:mm:ss.ffff') // 2013-08-15 13:55:40.9870
     * m.format( d, 'h:m:s tt') // 1:55:40 pm
     * m.format( d, 'h:m:s TT') // 1:55:40 PM
     * m.format( d, 'M/D/YYYY') // 8/15/2013
     * m.format( d, 'WWWW DD MMM') // Thursday 15 Aug
     * m.format( d, 'WWW DD MMMM @ hh:mm:ss') // Thu 15 August @ 13:55:40
     */

  }, {
    key: "format",
    value: function format(date, pattern) {
      // Fallback pattern is set in constructor
      if (!pattern) {
        pattern = this.pattern ? this.pattern : 'YYYY-MM-DD hh:mm:ss';
      }

      pattern = pattern.replace(/\[.+]|\[|]/g, '');
      var hasTwelveFlag = /t+/ig.test(pattern);
      var parsedDate;

      if (date instanceof Date) {
        parsedDate = parseDate(date, hasTwelveFlag);
      } else {
        if (date < 0) {
          // parseInterval don't support for negative values
          date = -date;
          pattern = "-".concat(pattern);
        }

        parsedDate = parseInterval(date, pattern);
      } // remove [] and everything inside it


      var masks = getMasks(this, parsedDate);
      var masksArr = [];

      for (var mask in masks) {
        if (Object.prototype.hasOwnProperty.call(masks, mask)) {
          masksArr.push(mask);
        }
      }

      var dateTimeRegex = new RegExp(masksArr.join('|'), 'g');
      var result = pattern.replace(dateTimeRegex, function (m) {
        var r;
        var mask;

        for (mask in masks) {
          if (Object.prototype.hasOwnProperty.call(masks, mask)) {
            r = new RegExp(mask);

            if (r.test(m)) {
              break;
            }
          }
        }

        if (!r) {
          return '';
        }

        var value;

        for (var submask in masks[mask]) {
          if (submask === m || submask.toLowerCase() === m) {
            value = masks[mask][submask];

            if (typeof value === 'undefined') {
              value = masks[mask][submask.toLowerCase()];
            }

            break;
          }
        }

        if (typeof value === 'undefined') {
          value = masks[mask].def;
        }

        if (typeof value === 'function') {
          value = value(m);
        }

        return value;
      });
      return result;
    }
  }]);

  return DateFormatter;
}();

function dateFormatFactory() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(DateFormatter, args);
}

var MS_PER_DAY = 86400000;
function QlikTimeToDate(value) {
  return new Date(Date.UTC(1899, 11, 30 + Math.floor(value), 0, 0, 0, Math.round(MS_PER_DAY * (value - Math.floor(value)))));
}
function formatter$1(pattern) {
  var qtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'TS';
  var localeInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var qformat = dateFormatFactory(localeInfo, pattern, qtype);
  var memoized = memoize(qformat.format.bind(qformat), {
    toKey: function toKey(date) {
      return _typeof(date) === 'object' && typeof date.getTime === 'function' ? date.getTime() : date;
    }
  });
  /**
   * Prepare a value according to the specified qtype
   *
   * @param  {Number} value The value to be formatted
   * @return {Number}       The converted value (if applied)
   */

  function prepare(value) {
    if (qtype !== TYPES.INTERVAL) {
      return QlikTimeToDate(value);
    }

    return value;
  }
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Date} value   The number to be formatted
   * @return {String}         [description]
   */


  function format(value) {
    value = prepare(value);
    return memoized(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Date} v   Value
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v) {
    memoized.clear();
    v = prepare(v);
    return qformat.format(v, p);
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */


  format.locale = function locale(li) {
    qformat = dateFormatFactory(li, pattern, qtype);
    memoized = memoize(qformat.format.bind(qformat), {
      toKey: function toKey(date) {
        return _typeof(date) === 'object' ? date.getTime() : date;
      }
    });
    return this;
  };
  /**
   * Get or set the QType
   *
   * @param  {String} nqt New qType (optional)
   * @return {String}     Current qtype
   */


  format.qtype = function qtypeFn(nqt) {
    if (nqt !== undefined) {
      qtype = nqt;
      memoized.clear();
    }

    return qtype;
  };

  return format;
}

function createFromMetaInfo(meta, localeInfo) {
  if (meta && meta.qNumFormat && ['D', 'T', 'TS', 'IV'].indexOf(meta.qNumFormat.qType) !== -1) {
    return formatter$1(meta.qNumFormat.qFmt, meta.qNumFormat.qType, localeInfo);
  }

  var pattern = '#';
  var thousand = localeInfo && typeof localeInfo.qThousandSep !== 'undefined' ? localeInfo.qThousandSep : ',';
  var decimal = localeInfo && typeof localeInfo.qDecimalSep !== 'undefined' ? localeInfo.qDecimalSep : '.';
  var type = 'U';
  var isAuto = meta && !!meta.qIsAutoFormat;

  if (meta && meta.qNumFormat) {
    pattern = meta.qNumFormat.qFmt || pattern;
    thousand = meta.qNumFormat.qThou || thousand;
    decimal = meta.qNumFormat.qDec || decimal;
    type = meta.qNumFormat.qType || type;
    isAuto = isAuto && ['M'].indexOf(meta.qNumFormat.qType) === -1;
  } else {
    isAuto = true;
  }

  if (isAuto || type === 'U') {
    pattern = "#".concat(decimal, "##A");
    type = 'U';
  }

  return formatter(pattern, thousand, decimal, type, localeInfo);
}

function qField() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      meta = _ref.meta,
      _id = _ref.id,
      _key = _ref.key,
      localeInfo = _ref.localeInfo,
      fieldExtractor = _ref.fieldExtractor,
      value = _ref.value,
      _type = _ref.type,
      sourceField = _ref.sourceField;

  var values;
  var valueFn = value || (_type === 'dimension' ? function (d) {
    return d.qElemNo;
  } : function (d) {
    return d.qValue;
  });

  var labelFn = function labelFn(d) {
    return d.qText || '';
  };

  var reduce = _type === 'dimension' ? 'first' : 'avg';

  var _formatter = createFromMetaInfo(meta, localeInfo);

  var reduceLabel = _type === 'dimension' ? 'first' : function (labels, v) {
    return _formatter(v);
  };
  var f = {
    id: function id() {
      return _id;
    },
    key: function key() {
      return _key;
    },
    raw: function raw() {
      return meta;
    },
    title: function title() {
      return meta.qFallbackTitle || meta.label;
    },
    type: function type() {
      return _type;
    },
    origin: function origin() {
      return sourceField;
    },
    items: function items() {
      if (!values) {
        values = fieldExtractor(f);
      }

      return values;
    },
    min: function min() {
      return meta.qMin;
    },
    max: function max() {
      return meta.qMax;
    },
    value: valueFn,
    label: labelFn,
    reduce: reduce,
    reduceLabel: reduceLabel,
    formatter: function formatter() {
      return _formatter;
    },
    tags: function tags() {
      return meta.qTags;
    }
  };
  return f;
}

function createFields(path, obj, prefix, parentKey, opts) {
  return (obj[path] || []).map(function (meta, i) {
    var fieldKey = "".concat(parentKey ? "".concat(parentKey, "/") : '').concat(path, "/").concat(i);
    var f = {
      instance: qField(extend({
        id: "".concat(prefix ? "".concat(prefix, "/") : '').concat(fieldKey),
        key: fieldKey,
        meta: meta
      }, opts))
    };
    f.attrDims = createFields('qAttrDimInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qElemNo;
      },
      type: 'dimension'
    }));
    f.attrExps = createFields('qAttrExprInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qNum;
      },
      type: 'measure'
    }));
    f.measures = createFields('qMeasureInfo', meta, prefix, fieldKey, extend({}, opts, {
      value: function value(v) {
        return v.qValue;
      },
      type: 'measure'
    }));
    return f;
  });
}

function q() {
  var _cache$wrappedFields, _cache$wrappedFields2, _cache$allFields;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _key = _ref.key,
      data = _ref.data,
      _ref$config = _ref.config,
      config = _ref$config === void 0 ? {} : _ref$config;

  var cache = {
    fields: [],
    wrappedFields: [],
    allFields: [],
    virtualFields: []
  };
  var cube = data;

  if (!cube) {
    throw new Error('Missing "data" input');
  }

  if (!cube.qDimensionInfo) {
    throw new Error('The "data" input is not recognized as a hypercube');
  }

  var deps = q.util;
  var opts = {
    cache: cache,
    cube: cube,
    localeInfo: config.localeInfo,
    fieldExtractor: null,
    pages: null,
    hierarchy: function hierarchy() {
      return null;
    },
    virtualFields: config.virtualFields
  };
  var dataset = {
    key: function key() {
      return _key;
    },
    raw: function raw() {
      return cube;
    },
    field: function field(query) {
      return findField(query, opts);
    },
    fields: function fields() {
      return cache.fields.slice();
    },
    extract: function extract(extractionConfig) {
      return opts.extractor(extractionConfig, dataset, cache, deps);
    },
    hierarchy: function hierarchy(hierarchyConfig) {
      return opts.hierarchy(hierarchyConfig, dataset, cache, deps);
    },
    _cache: function _cache() {
      return cache;
    }
  };

  if (cube.qMode === 'K' || cube.qMode === 'T' || !cube.qMode && cube.qNodesOnDim) {
    opts.extractor = extract$1;
    opts.hierarchy = augment;
    opts.pages = cube.qMode === 'K' ? cube.qStackedDataPages : cube.qTreeDataPages;
  } else if (cube.qMode === 'S') {
    opts.extractor = extract;
    opts.pages = cube.qDataPages;
    opts.hierarchy = augment;
  } else {
    opts.extractor = function () {
      return [];
    }; // TODO - throw unsupported error?

  }

  opts.fieldExtractor = function (f) {
    return opts.extractor({
      field: f
    }, dataset, cache, deps);
  };

  var dimAcc = cube.qMode === 'S' ? function (d) {
    return d.qElemNumber;
  } : undefined;
  var measAcc = cube.qMode === 'S' ? function (d) {
    return d.qNum;
  } : undefined;

  (_cache$wrappedFields = cache.wrappedFields).push.apply(_cache$wrappedFields, _toConsumableArray(createFields('qDimensionInfo', cube, _key, '', extend({}, opts, {
    value: dimAcc,
    type: 'dimension'
  }))));

  (_cache$wrappedFields2 = cache.wrappedFields).push.apply(_cache$wrappedFields2, _toConsumableArray(createFields('qMeasureInfo', cube, _key, '', extend({}, opts, {
    value: measAcc,
    type: 'measure'
  }))));

  cache.fields = cache.wrappedFields.map(function (f) {
    return f.instance;
  });

  var traverse = function traverse(arr) {
    arr.forEach(function (f) {
      cache.allFields.push(f.instance);
      traverse(f.measures);
      traverse(f.attrDims);
      traverse(f.attrExps);
    });
  };

  traverse(cache.wrappedFields);
  (config.virtualFields || []).forEach(function (v) {
    // key: 'temporal',
    // from: 'qDimensionInfo/0',
    // override: {
    //   value: v => v.qNum,
    // },
    var sourceField = dataset.field(v.from);
    var f = qField(_objectSpread({
      meta: sourceField.raw(),
      id: "".concat(_key, "/").concat(v.key),
      sourceField: sourceField,
      fieldExtractor: function fieldExtractor(ff) {
        return opts.extractor({
          field: ff
        }, dataset, cache, deps);
      },
      key: v.key,
      type: sourceField.type(),
      localeInfo: opts.localeInfo,
      value: sourceField.value
    }, v.override || {}));
    cache.virtualFields.push(f);
  });

  (_cache$allFields = cache.allFields).push.apply(_cache$allFields, _toConsumableArray(cache.virtualFields));

  return dataset;
}

var LAYOUT_TO_PROP = [['qHyperCube', 'qHyperCubeDef'], ['qTreeData', 'qTreeDataDef'], ['qDimensionInfo', 'qDimensions'], ['qMeasureInfo', 'qMeasures'], ['qAttrDimInfo', 'qAttributeDimensions'], ['qAttrExprInfo', 'qAttributeExpressions']];
var DIM_RX$1 = /\/qDimensionInfo(?:\/(\d+))?/;
var M_RX$1 = /\/qMeasureInfo\/(\d+)/;
var ATTR_DIM_RX$1 = /\/qAttrDimInfo\/(\d+)(?:\/(\d+))?/;
var ATTR_EXPR_RX$1 = /\/qAttrExprInfo\/(\d+)/;
var HC_RX = /\/?qHyperCube/;
var TD_RX = /\/?qTreeData/;

var SHORTEN_HC = function SHORTEN_HC(path) {
  return "".concat(path.substr(0, path.indexOf('/qHyperCubeDef') + 14));
}; // 14 = length of '/qHyperCubeDef'


var SHORTEN_TD = function SHORTEN_TD(path) {
  return "".concat(path.substr(0, path.indexOf('/qTreeDataDef') + 13));
}; // 13 = length of '/qTreeDataDef'


function extractFieldFromId(id, layout) {
  var path = id;
  var dimensionIdx = -1;
  var measureIdx = -1;
  var pathToCube = '';

  var shortenizer = function shortenizer(p) {
    return p;
  };

  if (HC_RX.test(id)) {
    pathToCube = "".concat(path.substr(0, path.indexOf('qHyperCube') + 10)); // 10 = length of 'qHyperCube'

    shortenizer = SHORTEN_HC;
  } else if (TD_RX.test(id)) {
    pathToCube = "".concat(path.substr(0, path.indexOf('qTreeData') + 9)); // 9 = length of 'qTreeData'

    shortenizer = SHORTEN_TD;
  }

  var shortenPath = true;

  if (DIM_RX$1.test(id)) {
    dimensionIdx = +DIM_RX$1.exec(id)[1];
  }

  if (M_RX$1.test(id)) {
    measureIdx = +M_RX$1.exec(id)[1];
  }

  if (ATTR_DIM_RX$1.test(id)) {
    measureIdx = -1;
    dimensionIdx = 0;
    var attrCol = +ATTR_DIM_RX$1.exec(path)[2];

    if (!isNaN(attrCol)) {
      dimensionIdx = attrCol;
      path = path.replace(/\/\d+$/, '');
    }

    shortenPath = false;
  }

  if (ATTR_EXPR_RX$1.test(id)) {
    // depends on number of measures + number of attr expressions
    // in dimensions and measures before this one
    var offset = measureIdx;

    if (layout) {
      measureIdx = 0;
      var hc = resolve(pathToCube, layout); // offset by number of measures

      measureIdx += (hc.qMeasureInfo || []).length; // offset by total number of attr expr in dimensions
      // (assuming attr expr in dimensions are ordered first)

      if (dimensionIdx > -1) {
        measureIdx = hc.qDimensionInfo.slice(0, dimensionIdx).reduce(function (v, dim) {
          return v + dim.qAttrExprInfo.length;
        }, measureIdx);
        dimensionIdx = -1;
      } else {
        measureIdx = hc.qDimensionInfo.reduce(function (v, dim) {
          return v + dim.qAttrExprInfo.length;
        }, measureIdx); // offset by total number of attr expr in measures before 'index'

        measureIdx = hc.qMeasureInfo.slice(0, offset).reduce(function (v, meas) {
          return v + meas.qAttrExprInfo.length;
        }, measureIdx);
      } // offset by the actual column value for the attribute expression itself


      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1];
    } else if (dimensionIdx > -1) {
      dimensionIdx = -1;
      measureIdx = +ATTR_EXPR_RX$1.exec(path)[1];
    } else {
      measureIdx += +ATTR_EXPR_RX$1.exec(path)[1] + 1;
    }
  }

  LAYOUT_TO_PROP.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        v = _ref2[0],
        prop = _ref2[1];

    path = path.replace(v, prop);
  });

  if (shortenPath) {
    path = shortenizer(path);
  }

  if (path && path[0] !== '/') {
    path = "/".concat(path);
  }

  return {
    measureIdx: measureIdx,
    dimensionIdx: dimensionIdx,
    path: path
  };
}
/**
 * Helper method to generate suitable QIX selection methods and parameters based on a brush instance.
 * @alias brush
 * @memberof picasso.q
 * @param {brush} brush A brush instance
 * @param {object} [opts]
 * @param {boolean} [opts.byCells=false] Whether to prefer selection by row index.
 * @param {string} [opts.primarySource] Field source to extract row indices from. If not specified, indices from first source are used.
 * @param {object} [layout] QIX data layout. Needed only when brushing on attribute expressions, to be able to calculate the measure index.
 * @return {object[]} An array of relevant selections
 */

function qBrush(brush) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var layout = arguments.length > 2 ? arguments[2] : undefined;
  var byCells = opts.byCells;
  var primarySource = opts.primarySource;
  var selections = [];
  var methods = {};
  var isActive = brush.isActive();
  var hasValues = false;
  brush.brushes().forEach(function (b) {
    var info = extractFieldFromId(b.id, layout);

    if (b.type === 'range' && info.measureIdx > -1 && info.dimensionIdx > -1) {
      var ranges = b.brush.ranges();

      if (ranges.length) {
        hasValues = true;

        if (!methods.multiRangeSelectTreeDataValues) {
          methods.multiRangeSelectTreeDataValues = {
            path: info.path,
            ranges: []
          };
        }

        ranges.forEach(function (range) {
          return methods.multiRangeSelectTreeDataValues.ranges.push({
            qMeasureIx: info.measureIdx,
            qDimensionIx: info.dimensionIdx,
            qRange: {
              qMin: range.min,
              qMax: range.max,
              qMinInclEq: true,
              qMaxInclEq: true
            }
          });
        });
      }
    } else {
      if (b.type === 'range' && info.measureIdx > -1) {
        var _ranges = b.brush.ranges();

        if (_ranges.length) {
          hasValues = true;

          if (!methods.rangeSelectHyperCubeValues) {
            methods.rangeSelectHyperCubeValues = {
              path: info.path,
              ranges: []
            };
          }

          _ranges.forEach(function (range) {
            return methods.rangeSelectHyperCubeValues.ranges.push({
              qMeasureIx: info.measureIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: true
              }
            });
          });
        }
      }

      if (b.type === 'range' && info.dimensionIdx > -1) {
        var _ranges2 = b.brush.ranges();

        if (_ranges2.length) {
          hasValues = true;

          if (!methods.selectHyperCubeContinuousRange) {
            methods.selectHyperCubeContinuousRange = {
              path: info.path,
              ranges: []
            };
          }

          _ranges2.forEach(function (range) {
            return methods.selectHyperCubeContinuousRange.ranges.push({
              qDimIx: info.dimensionIdx,
              qRange: {
                qMin: range.min,
                qMax: range.max,
                qMinInclEq: true,
                qMaxInclEq: false
              }
            });
          });
        }
      }

      if (b.type === 'value' && info.dimensionIdx > -1) {
        if (byCells) {
          if (layout && layout.qHyperCube && (layout.qHyperCube.qMode === 'P' || layout.qHyperCube.qMode === 'T' || layout.qHyperCube.qMode === 'K')) {
            var hyperCube = layout.qHyperCube;
            var noOfLeftDims = hyperCube.qNoOfLeftDims;
            var dimInterColSortIdx = hyperCube.qEffectiveInterColumnSortOrder.indexOf(info.dimensionIdx);

            if (!methods.selectPivotCells) {
              methods.selectPivotCells = {
                path: info.path,
                cells: []
              };
            }

            if (b.id === primarySource || !primarySource && methods.selectPivotCells.cells.length === 0) {
              var validValues = b.brush.values().map(function (s) {
                return +s;
              }).filter(function (v) {
                return !isNaN(v);
              });

              if ((noOfLeftDims === 0 || dimInterColSortIdx >= noOfLeftDims) && noOfLeftDims > -1) {
                validValues.forEach(function (val) {
                  methods.selectPivotCells.cells.push({
                    qType: 'T',
                    qCol: val,
                    qRow: dimInterColSortIdx - noOfLeftDims
                  });
                });
              } else {
                validValues.forEach(function (val) {
                  methods.selectPivotCells.cells.push({
                    qType: 'L',
                    qCol: info.dimensionIdx,
                    qRow: val
                  });
                });
              }

              hasValues = !!methods.selectPivotCells.cells.length;
            }
          } else {
            if (!methods.selectHyperCubeCells) {
              methods.selectHyperCubeCells = {
                path: info.path,
                cols: []
              };
            }

            methods.selectHyperCubeCells.cols.push(info.dimensionIdx);

            if (b.id === primarySource || !primarySource && !methods.selectHyperCubeCells.values) {
              methods.selectHyperCubeCells.values = b.brush.values().map(function (s) {
                return +s;
              }).filter(function (v) {
                return !isNaN(v);
              });
              hasValues = !!methods.selectHyperCubeCells.values.length;
            }
          }
        } else {
          var values = b.brush.values().map(function (s) {
            return +s;
          }).filter(function (v) {
            return !isNaN(v);
          });
          hasValues = !!values.length;
          selections.push({
            params: [info.path, info.dimensionIdx, values, false],
            method: 'selectHyperCubeValues'
          });
        }
      }
    }
  });

  if (!hasValues && isActive) {
    return [{
      method: 'resetMadeSelections',
      params: []
    }];
  }

  if (methods.rangeSelectHyperCubeValues) {
    selections.push({
      method: 'rangeSelectHyperCubeValues',
      params: [methods.rangeSelectHyperCubeValues.path, methods.rangeSelectHyperCubeValues.ranges, [], true]
    });
  }

  if (methods.selectHyperCubeContinuousRange) {
    selections.push({
      method: 'selectHyperCubeContinuousRange',
      params: [methods.selectHyperCubeContinuousRange.path, methods.selectHyperCubeContinuousRange.ranges]
    });
  }

  if (methods.selectHyperCubeCells) {
    selections.push({
      method: 'selectHyperCubeCells',
      params: [methods.selectHyperCubeCells.path, methods.selectHyperCubeCells.values, methods.selectHyperCubeCells.cols]
    });
  }

  if (methods.selectPivotCells) {
    selections.push({
      method: 'selectPivotCells',
      params: [methods.selectPivotCells.path, methods.selectPivotCells.cells]
    });
  }

  if (methods.multiRangeSelectTreeDataValues) {
    selections.push({
      method: 'multiRangeSelectTreeDataValues',
      params: [methods.multiRangeSelectTreeDataValues.path, methods.multiRangeSelectTreeDataValues.ranges]
    });
  }

  return selections;
}

function initialize(picasso) {
  q.util = picasso.data('matrix').util;
  picasso.data('q', q);
  picasso.formatter('q-number', formatter);
  picasso.formatter('q-time', formatter$1);
}
initialize.qBrushHelper = qBrush; // deprecated

initialize.selections = qBrush;

/* harmony default export */ __webpack_exports__["a"] = (initialize);
//# sourceMappingURL=picasso-q.esm.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.6
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var k=__webpack_require__(18),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.concurrent_mode"):60111,y=n?Symbol.for("react.forward_ref"):60112,z=n?Symbol.for("react.suspense"):60113,aa=n?Symbol.for("react.memo"):
60115,ba=n?Symbol.for("react.lazy"):60116,A="function"===typeof Symbol&&Symbol.iterator;function ca(a,b,d,c,e,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[d,c,e,g,h,f],m=0;a=Error(b.replace(/%s/g,function(){return l[m++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}
function B(a){for(var b=arguments.length-1,d="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)d+="&args[]="+encodeURIComponent(arguments[c+1]);ca(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",d)}var C={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},D={};
function E(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}E.prototype.isReactComponent={};E.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?B("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C}var H=G.prototype=new F;
H.constructor=G;k(H,E.prototype);H.isPureReactComponent=!0;var I={current:null},J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,d){var c=void 0,e={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];e.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:h,props:e,_owner:J.current}}
function da(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return{result:a,keyPrefix:b,func:d,context:c,count:0}}
function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}
function S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){e=a[h];var f=b+T(e,h);g+=S(e,f,d,c)}else if(null===a||"object"!==typeof a?f=null:(f=A&&a[A]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),h=
0;!(e=a.next()).done;)e=e.value,f=b+T(e,h++),g+=S(e,f,d,c);else"object"===e&&(d=""+a,B("31","[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,""));return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ea(a,b){a.func.call(a.context,b,a.count++)}
function fa(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=da(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a))}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,fa,b);R(b)}function W(){var a=I.current;null===a?B("321"):void 0;return a}
var X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,ea,b);R(b)},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){N(a)?void 0:B("143");return a}},createRef:function(){return{current:null}},Component:E,PureComponent:G,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,
_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:y,render:a}},lazy:function(a){return{$$typeof:ba,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:aa,type:a,compare:void 0===b?null:b}},useCallback:function(a,b){return W().useCallback(a,b)},useContext:function(a,b){return W().useContext(a,b)},useEffect:function(a,b){return W().useEffect(a,b)},useImperativeHandle:function(a,
b,d){return W().useImperativeHandle(a,b,d)},useDebugValue:function(){},useLayoutEffect:function(a,b){return W().useLayoutEffect(a,b)},useMemo:function(a,b){return W().useMemo(a,b)},useReducer:function(a,b,d){return W().useReducer(a,b,d)},useRef:function(a){return W().useRef(a)},useState:function(a){return W().useState(a)},Fragment:r,StrictMode:t,Suspense:z,createElement:M,cloneElement:function(a,b,d){null===a||void 0===a?B("267",a):void 0;var c=void 0,e=k({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=
b){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];e.children=l}return{$$typeof:p,type:a.type,key:g,ref:h,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.8.6",
unstable_ConcurrentMode:x,unstable_Profiler:u,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:I,ReactCurrentOwner:J,assign:k}},Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.6
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(1),n=__webpack_require__(18),r=__webpack_require__(27);function ba(a,b,c,d,e,f,g,h){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[c,d,e,f,g,h],k=0;a=Error(b.replace(/%s/g,function(){return l[k++]}));a.name="Invariant Violation"}a.framesToPop=1;throw a;}}
function x(a){for(var b=arguments.length-1,c="https://reactjs.org/docs/error-decoder.html?invariant="+a,d=0;d<b;d++)c+="&args[]="+encodeURIComponent(arguments[d+1]);ba(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",c)}aa?void 0:x("227");function ca(a,b,c,d,e,f,g,h,l){var k=Array.prototype.slice.call(arguments,3);try{b.apply(c,k)}catch(m){this.onError(m)}}
var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a}};function ja(a,b,c,d,e,f,g,h,l){da=!1;ea=null;ca.apply(ia,arguments)}function ka(a,b,c,d,e,f,g,h,l){ja.apply(this,arguments);if(da){if(da){var k=ea;da=!1;ea=null}else x("198"),k=void 0;fa||(fa=!0,ha=k)}}var la=null,ma={};
function na(){if(la)for(var a in ma){var b=ma[a],c=la.indexOf(a);-1<c?void 0:x("96",a);if(!oa[c]){b.extractEvents?void 0:x("97",a);oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;pa.hasOwnProperty(h)?x("99",h):void 0;pa[h]=f;var l=f.phasedRegistrationNames;if(l){for(e in l)l.hasOwnProperty(e)&&qa(l[e],g,h);e=!0}else f.registrationName?(qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:x("98",d,a)}}}}
function qa(a,b,c){ra[a]?x("100",a):void 0;ra[a]=b;sa[a]=b.eventTypes[c].dependencies}var oa=[],pa={},ra={},sa={},ta=null,ua=null,va=null;function wa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=va(c);ka(d,b,void 0,a);a.currentTarget=null}function xa(a,b){null==b?x("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}
function ya(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var za=null;function Aa(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)wa(a,b[d],c[d]);else b&&wa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}
var Ba={injectEventPluginOrder:function(a){la?x("101"):void 0;la=Array.prototype.slice.call(a);na()},injectEventPluginsByName:function(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];ma.hasOwnProperty(c)&&ma[c]===d||(ma[c]?x("102",c):void 0,ma[c]=d,b=!0)}b&&na()}};
function Ca(a,b){var c=a.stateNode;if(!c)return null;var d=ta(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?x("231",b,typeof c):void 0;
return c}function Da(a){null!==a&&(za=xa(za,a));a=za;za=null;if(a&&(ya(a,Aa),za?x("95"):void 0,fa))throw a=ha,fa=!1,ha=null,a;}var Ea=Math.random().toString(36).slice(2),Fa="__reactInternalInstance$"+Ea,Ga="__reactEventHandlers$"+Ea;function Ha(a){if(a[Fa])return a[Fa];for(;!a[Fa];)if(a.parentNode)a=a.parentNode;else return null;a=a[Fa];return 5===a.tag||6===a.tag?a:null}function Ia(a){a=a[Fa];return!a||5!==a.tag&&6!==a.tag?null:a}
function Ja(a){if(5===a.tag||6===a.tag)return a.stateNode;x("33")}function Ka(a){return a[Ga]||null}function La(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function Ma(a,b,c){if(b=Ca(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a)}
function Na(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=La(b);for(b=c.length;0<b--;)Ma(c[b],"captured",a);for(b=0;b<c.length;b++)Ma(c[b],"bubbled",a)}}function Oa(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Ca(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a))}function Pa(a){a&&a.dispatchConfig.registrationName&&Oa(a._targetInst,null,a)}
function Qa(a){ya(a,Na)}var Ra=!("undefined"===typeof window||!window.document||!window.document.createElement);function Sa(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ta={animationend:Sa("Animation","AnimationEnd"),animationiteration:Sa("Animation","AnimationIteration"),animationstart:Sa("Animation","AnimationStart"),transitionend:Sa("Transition","TransitionEnd")},Ua={},Va={};
Ra&&(Va=document.createElement("div").style,"AnimationEvent"in window||(delete Ta.animationend.animation,delete Ta.animationiteration.animation,delete Ta.animationstart.animation),"TransitionEvent"in window||delete Ta.transitionend.transition);function Wa(a){if(Ua[a])return Ua[a];if(!Ta[a])return a;var b=Ta[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Va)return Ua[a]=b[c];return a}
var Xa=Wa("animationend"),Ya=Wa("animationiteration"),Za=Wa("animationstart"),$a=Wa("transitionend"),ab="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bb=null,cb=null,db=null;
function eb(){if(db)return db;var a,b=cb,c=b.length,d,e="value"in bb?bb.value:bb.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return db=e.slice(a,1<d?1-d:void 0)}function fb(){return!0}function gb(){return!1}
function y(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?fb:gb;this.isPropagationStopped=gb;return this}
n(y.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=fb)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=fb)},persist:function(){this.isPersistent=fb},isPersistent:gb,destructor:function(){var a=this.constructor.Interface,
b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=gb;this._dispatchInstances=this._dispatchListeners=null}});y.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
y.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;hb(c);return c};hb(y);function ib(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function jb(a){a instanceof this?void 0:x("279");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}
function hb(a){a.eventPool=[];a.getPooled=ib;a.release=jb}var kb=y.extend({data:null}),lb=y.extend({data:null}),mb=[9,13,27,32],nb=Ra&&"CompositionEvent"in window,ob=null;Ra&&"documentMode"in document&&(ob=document.documentMode);
var pb=Ra&&"TextEvent"in window&&!ob,qb=Ra&&(!nb||ob&&8<ob&&11>=ob),rb=String.fromCharCode(32),sb={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},tb=!1;
function ub(a,b){switch(a){case "keyup":return-1!==mb.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function vb(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var wb=!1;function xb(a,b){switch(a){case "compositionend":return vb(b);case "keypress":if(32!==b.which)return null;tb=!0;return rb;case "textInput":return a=b.data,a===rb&&tb?null:a;default:return null}}
function yb(a,b){if(wb)return"compositionend"===a||!nb&&ub(a,b)?(a=eb(),db=cb=bb=null,wb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return qb&&"ko"!==b.locale?null:b.data;default:return null}}
var zb={eventTypes:sb,extractEvents:function(a,b,c,d){var e=void 0;var f=void 0;if(nb)b:{switch(a){case "compositionstart":e=sb.compositionStart;break b;case "compositionend":e=sb.compositionEnd;break b;case "compositionupdate":e=sb.compositionUpdate;break b}e=void 0}else wb?ub(a,c)&&(e=sb.compositionEnd):"keydown"===a&&229===c.keyCode&&(e=sb.compositionStart);e?(qb&&"ko"!==c.locale&&(wb||e!==sb.compositionStart?e===sb.compositionEnd&&wb&&(f=eb()):(bb=d,cb="value"in bb?bb.value:bb.textContent,wb=
!0)),e=kb.getPooled(e,b,c,d),f?e.data=f:(f=vb(c),null!==f&&(e.data=f)),Qa(e),f=e):f=null;(a=pb?xb(a,c):yb(a,c))?(b=lb.getPooled(sb.beforeInput,b,c,d),b.data=a,Qa(b)):b=null;return null===f?b:null===b?f:[f,b]}},Ab=null,Bb=null,Cb=null;function Db(a){if(a=ua(a)){"function"!==typeof Ab?x("280"):void 0;var b=ta(a.stateNode);Ab(a.stateNode,a.type,b)}}function Eb(a){Bb?Cb?Cb.push(a):Cb=[a]:Bb=a}function Fb(){if(Bb){var a=Bb,b=Cb;Cb=Bb=null;Db(a);if(b)for(a=0;a<b.length;a++)Db(b[a])}}
function Gb(a,b){return a(b)}function Hb(a,b,c){return a(b,c)}function Ib(){}var Jb=!1;function Kb(a,b){if(Jb)return a(b);Jb=!0;try{return Gb(a,b)}finally{if(Jb=!1,null!==Bb||null!==Cb)Ib(),Fb()}}var Lb={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Mb(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Lb[a.type]:"textarea"===b?!0:!1}
function Nb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function Ob(a){if(!Ra)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Pb(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Qb(a){var b=Pb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Rb(a){a._valueTracker||(a._valueTracker=Qb(a))}function Sb(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Pb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Tb=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Tb.hasOwnProperty("ReactCurrentDispatcher")||(Tb.ReactCurrentDispatcher={current:null});
var Ub=/^(.*)[\\\/]/,z="function"===typeof Symbol&&Symbol.for,Vb=z?Symbol.for("react.element"):60103,Wb=z?Symbol.for("react.portal"):60106,Xb=z?Symbol.for("react.fragment"):60107,Yb=z?Symbol.for("react.strict_mode"):60108,Zb=z?Symbol.for("react.profiler"):60114,$b=z?Symbol.for("react.provider"):60109,ac=z?Symbol.for("react.context"):60110,bc=z?Symbol.for("react.concurrent_mode"):60111,cc=z?Symbol.for("react.forward_ref"):60112,dc=z?Symbol.for("react.suspense"):60113,ec=z?Symbol.for("react.memo"):
60115,fc=z?Symbol.for("react.lazy"):60116,gc="function"===typeof Symbol&&Symbol.iterator;function hc(a){if(null===a||"object"!==typeof a)return null;a=gc&&a[gc]||a["@@iterator"];return"function"===typeof a?a:null}
function ic(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case bc:return"ConcurrentMode";case Xb:return"Fragment";case Wb:return"Portal";case Zb:return"Profiler";case Yb:return"StrictMode";case dc:return"Suspense"}if("object"===typeof a)switch(a.$$typeof){case ac:return"Context.Consumer";case $b:return"Context.Provider";case cc:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+
")":"ForwardRef");case ec:return ic(a.type);case fc:if(a=1===a._status?a._result:null)return ic(a)}return null}function jc(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=ic(a.type);c=null;d&&(c=ic(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ub,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}
var kc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,lc=Object.prototype.hasOwnProperty,mc={},nc={};
function oc(a){if(lc.call(nc,a))return!0;if(lc.call(mc,a))return!1;if(kc.test(a))return nc[a]=!0;mc[a]=!0;return!1}function pc(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function qc(a,b,c,d){if(null===b||"undefined"===typeof b||pc(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function C(a,b,c,d,e){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b}var D={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new C(a,0,!1,a,null)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new C(b,1,!1,a[1],null)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new C(a,2,!1,a.toLowerCase(),null)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new C(a,2,!1,a,null)});"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new C(a,3,!1,a.toLowerCase(),null)});["checked","multiple","muted","selected"].forEach(function(a){D[a]=new C(a,3,!0,a,null)});
["capture","download"].forEach(function(a){D[a]=new C(a,4,!1,a,null)});["cols","rows","size","span"].forEach(function(a){D[a]=new C(a,6,!1,a,null)});["rowSpan","start"].forEach(function(a){D[a]=new C(a,5,!1,a.toLowerCase(),null)});var rc=/[\-:]([a-z])/g;function sc(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(rc,
sc);D[b]=new C(b,1,!1,a,null)});"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(rc,sc);D[b]=new C(b,1,!1,a,"http://www.w3.org/1999/xlink")});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(rc,sc);D[b]=new C(b,1,!1,a,"http://www.w3.org/XML/1998/namespace")});["tabIndex","crossOrigin"].forEach(function(a){D[a]=new C(a,1,!1,a.toLowerCase(),null)});
function tc(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qc(b,c,e,d)&&(c=null),d||null===e?oc(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
function uc(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function vc(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
function wc(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=uc(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function xc(a,b){b=b.checked;null!=b&&tc(a,"checked",b,!1)}
function yc(a,b){xc(a,b);var c=uc(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?zc(a,b.type,c):b.hasOwnProperty("defaultValue")&&zc(a,b.type,uc(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Ac(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function zc(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}var Bc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function Cc(a,b,c){a=y.getPooled(Bc.change,a,b,c);a.type="change";Eb(c);Qa(a);return a}var Dc=null,Ec=null;function Fc(a){Da(a)}
function Gc(a){var b=Ja(a);if(Sb(b))return a}function Hc(a,b){if("change"===a)return b}var Ic=!1;Ra&&(Ic=Ob("input")&&(!document.documentMode||9<document.documentMode));function Jc(){Dc&&(Dc.detachEvent("onpropertychange",Kc),Ec=Dc=null)}function Kc(a){"value"===a.propertyName&&Gc(Ec)&&(a=Cc(Ec,a,Nb(a)),Kb(Fc,a))}function Lc(a,b,c){"focus"===a?(Jc(),Dc=b,Ec=c,Dc.attachEvent("onpropertychange",Kc)):"blur"===a&&Jc()}function Mc(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return Gc(Ec)}
function Nc(a,b){if("click"===a)return Gc(b)}function Oc(a,b){if("input"===a||"change"===a)return Gc(b)}
var Pc={eventTypes:Bc,_isInputEventSupported:Ic,extractEvents:function(a,b,c,d){var e=b?Ja(b):window,f=void 0,g=void 0,h=e.nodeName&&e.nodeName.toLowerCase();"select"===h||"input"===h&&"file"===e.type?f=Hc:Mb(e)?Ic?f=Oc:(f=Mc,g=Lc):(h=e.nodeName)&&"input"===h.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(f=Nc);if(f&&(f=f(a,b)))return Cc(f,c,d);g&&g(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&zc(e,"number",e.value)}},Qc=y.extend({view:null,detail:null}),Rc={Alt:"altKey",
Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sc(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Rc[a])?!!b[a]:!1}function Tc(){return Sc}
var Uc=0,Vc=0,Wc=!1,Xc=!1,Yc=Qc.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Tc,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Uc;Uc=a.screenX;return Wc?"mousemove"===a.type?a.screenX-b:0:(Wc=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
var b=Vc;Vc=a.screenY;return Xc?"mousemove"===a.type?a.screenY-b:0:(Xc=!0,0)}}),Zc=Yc.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),$c={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
dependencies:["pointerout","pointerover"]}},ad={eventTypes:$c,extractEvents:function(a,b,c,d){var e="mouseover"===a||"pointerover"===a,f="mouseout"===a||"pointerout"===a;if(e&&(c.relatedTarget||c.fromElement)||!f&&!e)return null;e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;f?(f=b,b=(b=c.relatedTarget||c.toElement)?Ha(b):null):f=null;if(f===b)return null;var g=void 0,h=void 0,l=void 0,k=void 0;if("mouseout"===a||"mouseover"===a)g=Yc,h=$c.mouseLeave,l=$c.mouseEnter,k="mouse";
else if("pointerout"===a||"pointerover"===a)g=Zc,h=$c.pointerLeave,l=$c.pointerEnter,k="pointer";var m=null==f?e:Ja(f);e=null==b?e:Ja(b);a=g.getPooled(h,f,c,d);a.type=k+"leave";a.target=m;a.relatedTarget=e;c=g.getPooled(l,b,c,d);c.type=k+"enter";c.target=e;c.relatedTarget=m;d=b;if(f&&d)a:{b=f;e=d;k=0;for(g=b;g;g=La(g))k++;g=0;for(l=e;l;l=La(l))g++;for(;0<k-g;)b=La(b),k--;for(;0<g-k;)e=La(e),g--;for(;k--;){if(b===e||b===e.alternate)break a;b=La(b);e=La(e)}b=null}else b=null;e=b;for(b=[];f&&f!==e;){k=
f.alternate;if(null!==k&&k===e)break;b.push(f);f=La(f)}for(f=[];d&&d!==e;){k=d.alternate;if(null!==k&&k===e)break;f.push(d);d=La(d)}for(d=0;d<b.length;d++)Oa(b[d],"bubbled",a);for(d=f.length;0<d--;)Oa(f[d],"captured",c);return[a,c]}};function bd(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var cd=Object.prototype.hasOwnProperty;
function dd(a,b){if(bd(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!cd.call(b,c[d])||!bd(a[c[d]],b[c[d]]))return!1;return!0}function ed(a){var b=a;if(a.alternate)for(;b.return;)b=b.return;else{if(0!==(b.effectTag&2))return 1;for(;b.return;)if(b=b.return,0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function fd(a){2!==ed(a)?x("188"):void 0}
function gd(a){var b=a.alternate;if(!b)return b=ed(a),3===b?x("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c.return,f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return fd(e),a;if(g===d)return fd(e),b;g=g.sibling}x("188")}if(c.return!==d.return)c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:x("189")}}c.alternate!==d?x("190"):void 0}3!==c.tag?x("188"):void 0;return c.stateNode.current===c?a:b}function hd(a){a=gd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
var id=y.extend({animationName:null,elapsedTime:null,pseudoElement:null}),jd=y.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),kd=Qc.extend({relatedTarget:null});function ld(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
var md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},od=Qc.extend({key:function(a){if(a.key){var b=md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=ld(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?nd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Tc,charCode:function(a){return"keypress"===
a.type?ld(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?ld(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),pd=Yc.extend({dataTransfer:null}),qd=Qc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Tc}),rd=y.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),sd=Yc.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in
a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),td=[["abort","abort"],[Xa,"animationEnd"],[Ya,"animationIteration"],[Za,"animationStart"],["canplay","canPlay"],["canplaythrough","canPlayThrough"],["drag","drag"],["dragenter","dragEnter"],["dragexit","dragExit"],["dragleave","dragLeave"],["dragover","dragOver"],["durationchange","durationChange"],["emptied","emptied"],["encrypted","encrypted"],
["ended","ended"],["error","error"],["gotpointercapture","gotPointerCapture"],["load","load"],["loadeddata","loadedData"],["loadedmetadata","loadedMetadata"],["loadstart","loadStart"],["lostpointercapture","lostPointerCapture"],["mousemove","mouseMove"],["mouseout","mouseOut"],["mouseover","mouseOver"],["playing","playing"],["pointermove","pointerMove"],["pointerout","pointerOut"],["pointerover","pointerOver"],["progress","progress"],["scroll","scroll"],["seeking","seeking"],["stalled","stalled"],
["suspend","suspend"],["timeupdate","timeUpdate"],["toggle","toggle"],["touchmove","touchMove"],[$a,"transitionEnd"],["waiting","waiting"],["wheel","wheel"]],ud={},vd={};function wd(a,b){var c=a[0];a=a[1];var d="on"+(a[0].toUpperCase()+a.slice(1));b={phasedRegistrationNames:{bubbled:d,captured:d+"Capture"},dependencies:[c],isInteractive:b};ud[a]=b;vd[c]=b}
[["blur","blur"],["cancel","cancel"],["click","click"],["close","close"],["contextmenu","contextMenu"],["copy","copy"],["cut","cut"],["auxclick","auxClick"],["dblclick","doubleClick"],["dragend","dragEnd"],["dragstart","dragStart"],["drop","drop"],["focus","focus"],["input","input"],["invalid","invalid"],["keydown","keyDown"],["keypress","keyPress"],["keyup","keyUp"],["mousedown","mouseDown"],["mouseup","mouseUp"],["paste","paste"],["pause","pause"],["play","play"],["pointercancel","pointerCancel"],
["pointerdown","pointerDown"],["pointerup","pointerUp"],["ratechange","rateChange"],["reset","reset"],["seeked","seeked"],["submit","submit"],["touchcancel","touchCancel"],["touchend","touchEnd"],["touchstart","touchStart"],["volumechange","volumeChange"]].forEach(function(a){wd(a,!0)});td.forEach(function(a){wd(a,!1)});
var xd={eventTypes:ud,isInteractiveTopLevelEventType:function(a){a=vd[a];return void 0!==a&&!0===a.isInteractive},extractEvents:function(a,b,c,d){var e=vd[a];if(!e)return null;switch(a){case "keypress":if(0===ld(c))return null;case "keydown":case "keyup":a=od;break;case "blur":case "focus":a=kd;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=Yc;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
pd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=qd;break;case Xa:case Ya:case Za:a=id;break;case $a:a=rd;break;case "scroll":a=Qc;break;case "wheel":a=sd;break;case "copy":case "cut":case "paste":a=jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=Zc;break;default:a=y}b=a.getPooled(e,b,c,d);Qa(b);return b}},yd=xd.isInteractiveTopLevelEventType,
zd=[];function Ad(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d;for(d=c;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;if(!d)break;a.ancestors.push(c);c=Ha(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Nb(a.nativeEvent);d=a.topLevelType;for(var f=a.nativeEvent,g=null,h=0;h<oa.length;h++){var l=oa[h];l&&(l=l.extractEvents(d,b,f,e))&&(g=xa(g,l))}Da(g)}}var Bd=!0;
function E(a,b){if(!b)return null;var c=(yd(a)?Cd:Dd).bind(null,a);b.addEventListener(a,c,!1)}function Ed(a,b){if(!b)return null;var c=(yd(a)?Cd:Dd).bind(null,a);b.addEventListener(a,c,!0)}function Cd(a,b){Hb(Dd,a,b)}
function Dd(a,b){if(Bd){var c=Nb(b);c=Ha(c);null===c||"number"!==typeof c.tag||2===ed(c)||(c=null);if(zd.length){var d=zd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{Kb(Ad,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>zd.length&&zd.push(a)}}}var Fd={},Gd=0,Hd="_reactListenersID"+(""+Math.random()).slice(2);
function Id(a){Object.prototype.hasOwnProperty.call(a,Hd)||(a[Hd]=Gd++,Fd[a[Hd]]={});return Fd[a[Hd]]}function Jd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function Kd(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ld(a,b){var c=Kd(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Kd(c)}}function Md(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Md(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Nd(){for(var a=window,b=Jd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Jd(a.document)}return b}function Od(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Pd(){var a=Nd();if(Od(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{b=(b=a.ownerDocument)&&b.defaultView||window;var c=b.getSelection&&b.getSelection();if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(A){b=null;break a}var f=0,g=-1,h=-1,l=0,k=0,m=a,p=null;b:for(;;){for(var t;;){m!==b||0!==d&&3!==m.nodeType||(g=f+d);m!==e||0!==c&&3!==m.nodeType||(h=f+c);3===m.nodeType&&(f+=m.nodeValue.length);
if(null===(t=m.firstChild))break;p=m;m=t}for(;;){if(m===a)break b;p===b&&++l===d&&(g=f);p===e&&++k===c&&(h=f);if(null!==(t=m.nextSibling))break;m=p;p=m.parentNode}m=t}b=-1===g||-1===h?null:{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;return{focusedElem:a,selectionRange:b}}
function Qd(a){var b=Nd(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Md(c.ownerDocument.documentElement,c)){if(null!==d&&Od(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ld(c,f);var g=Ld(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}
var Rd=Ra&&"documentMode"in document&&11>=document.documentMode,Sd={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},Td=null,Ud=null,Vd=null,Wd=!1;
function Xd(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(Wd||null==Td||Td!==Jd(c))return null;c=Td;"selectionStart"in c&&Od(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Vd&&dd(Vd,c)?null:(Vd=c,a=y.getPooled(Sd.select,Ud,a,b),a.type="select",a.target=Td,Qa(a),a)}
var Yd={eventTypes:Sd,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Id(e);f=sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?Ja(b):window;switch(a){case "focus":if(Mb(e)||"true"===e.contentEditable)Td=e,Ud=b,Vd=null;break;case "blur":Vd=Ud=Td=null;break;case "mousedown":Wd=!0;break;case "contextmenu":case "mouseup":case "dragend":return Wd=!1,Xd(c,d);case "selectionchange":if(Rd)break;
case "keydown":case "keyup":return Xd(c,d)}return null}};Ba.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ta=Ka;ua=Ia;va=Ja;Ba.injectEventPluginsByName({SimpleEventPlugin:xd,EnterLeaveEventPlugin:ad,ChangeEventPlugin:Pc,SelectEventPlugin:Yd,BeforeInputEventPlugin:zb});function Zd(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}
function $d(a,b){a=n({children:void 0},b);if(b=Zd(b.children))a.children=b;return a}function ae(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+uc(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function be(a,b){null!=b.dangerouslySetInnerHTML?x("91"):void 0;return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function ce(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?x("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:x("93"),b=b[0]),c=b),null==c&&(c=""));a._wrapperState={initialValue:uc(c)}}
function de(a,b){var c=uc(b.value),d=uc(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function ee(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var fe={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function ge(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function he(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?ge(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ie=void 0,je=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==fe.svg||"innerHTML"in a)a.innerHTML=b;else{ie=ie||document.createElement("div");ie.innerHTML="<svg>"+b+"</svg>";for(b=ie.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function ke(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var le={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},me=["Webkit","ms","Moz","O"];Object.keys(le).forEach(function(a){me.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);le[b]=le[a]})});function ne(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||le.hasOwnProperty(a)&&le[a]?(""+b).trim():b+"px"}
function oe(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ne(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var pe=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function qe(a,b){b&&(pe[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?x("137",a,""):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?x("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:x("61")),null!=b.style&&"object"!==typeof b.style?x("62",""):void 0)}
function re(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}
function se(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Id(a);b=sa[b];for(var d=0;d<b.length;d++){var e=b[d];if(!c.hasOwnProperty(e)||!c[e]){switch(e){case "scroll":Ed("scroll",a);break;case "focus":case "blur":Ed("focus",a);Ed("blur",a);c.blur=!0;c.focus=!0;break;case "cancel":case "close":Ob(e)&&Ed(e,a);break;case "invalid":case "submit":case "reset":break;default:-1===ab.indexOf(e)&&E(e,a)}c[e]=!0}}}function te(){}var ue=null,ve=null;
function we(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function xe(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var ye="function"===typeof setTimeout?setTimeout:void 0,ze="function"===typeof clearTimeout?clearTimeout:void 0,Ae=r.unstable_scheduleCallback,Be=r.unstable_cancelCallback;
function Ce(a,b,c,d,e){a[Ga]=e;"input"===c&&"radio"===e.type&&null!=e.name&&xc(a,e);re(c,d);d=re(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?oe(a,h):"dangerouslySetInnerHTML"===g?je(a,h):"children"===g?ke(a,h):tc(a,g,h,d)}switch(c){case "input":yc(a,e);break;case "textarea":de(a,e);break;case "select":b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?ae(a,!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?ae(a,!!e.multiple,e.defaultValue,
!0):ae(a,!!e.multiple,e.multiple?[]:"",!1))}}function De(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}function Ee(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}new Set;var Fe=[],Ge=-1;function F(a){0>Ge||(a.current=Fe[Ge],Fe[Ge]=null,Ge--)}function G(a,b){Ge++;Fe[Ge]=a.current;a.current=b}var He={},H={current:He},I={current:!1},Ie=He;
function Je(a,b){var c=a.type.contextTypes;if(!c)return He;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function J(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Ke(a){F(I,a);F(H,a)}function Le(a){F(I,a);F(H,a)}
function Me(a,b,c){H.current!==He?x("168"):void 0;G(H,b,a);G(I,c,a)}function Ne(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)e in a?void 0:x("108",ic(b)||"Unknown",e);return n({},c,d)}function Oe(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||He;Ie=H.current;G(H,b,a);G(I,I.current,a);return!0}
function Pe(a,b,c){var d=a.stateNode;d?void 0:x("169");c?(b=Ne(a,b,Ie),d.__reactInternalMemoizedMergedChildContext=b,F(I,a),F(H,a),G(H,b,a)):F(I,a);G(I,c,a)}var Qe=null,Re=null;function Se(a){return function(b){try{return a(b)}catch(c){}}}
function Te(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);Qe=Se(function(a){return b.onCommitFiberRoot(c,a)});Re=Se(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}
function Ue(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.contextDependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function K(a,b,c,d){return new Ue(a,b,c,d)}
function Ve(a){a=a.prototype;return!(!a||!a.isReactComponent)}function We(a){if("function"===typeof a)return Ve(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===cc)return 11;if(a===ec)return 14}return 2}
function Xe(a,b){var c=a.alternate;null===c?(c=K(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;c.contextDependencies=a.contextDependencies;c.sibling=a.sibling;
c.index=a.index;c.ref=a.ref;return c}
function Ye(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ve(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case Xb:return Ze(c.children,e,f,b);case bc:return $e(c,e|3,f,b);case Yb:return $e(c,e|2,f,b);case Zb:return a=K(12,c,b,e|4),a.elementType=Zb,a.type=Zb,a.expirationTime=f,a;case dc:return a=K(13,c,b,e),a.elementType=dc,a.type=dc,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case $b:g=10;break a;case ac:g=9;break a;case cc:g=11;break a;case ec:g=
14;break a;case fc:g=16;d=null;break a}x("130",null==a?a:typeof a,"")}b=K(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ze(a,b,c,d){a=K(7,a,d,b);a.expirationTime=c;return a}function $e(a,b,c,d){a=K(8,a,d,b);b=0===(b&1)?Yb:bc;a.elementType=b;a.type=b;a.expirationTime=c;return a}function af(a,b,c){a=K(6,a,null,b);a.expirationTime=c;return a}
function bf(a,b,c){b=K(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function cf(a,b){a.didError=!1;var c=a.earliestPendingTime;0===c?a.earliestPendingTime=a.latestPendingTime=b:c<b?a.earliestPendingTime=b:a.latestPendingTime>b&&(a.latestPendingTime=b);df(b,a)}
function ef(a,b){a.didError=!1;if(0===b)a.earliestPendingTime=0,a.latestPendingTime=0,a.earliestSuspendedTime=0,a.latestSuspendedTime=0,a.latestPingedTime=0;else{b<a.latestPingedTime&&(a.latestPingedTime=0);var c=a.latestPendingTime;0!==c&&(c>b?a.earliestPendingTime=a.latestPendingTime=0:a.earliestPendingTime>b&&(a.earliestPendingTime=a.latestPendingTime));c=a.earliestSuspendedTime;0===c?cf(a,b):b<a.latestSuspendedTime?(a.earliestSuspendedTime=0,a.latestSuspendedTime=0,a.latestPingedTime=0,cf(a,b)):
b>c&&cf(a,b)}df(0,a)}function ff(a,b){a.didError=!1;a.latestPingedTime>=b&&(a.latestPingedTime=0);var c=a.earliestPendingTime,d=a.latestPendingTime;c===b?a.earliestPendingTime=d===b?a.latestPendingTime=0:d:d===b&&(a.latestPendingTime=c);c=a.earliestSuspendedTime;d=a.latestSuspendedTime;0===c?a.earliestSuspendedTime=a.latestSuspendedTime=b:c<b?a.earliestSuspendedTime=b:d>b&&(a.latestSuspendedTime=b);df(b,a)}
function gf(a,b){var c=a.earliestPendingTime;a=a.earliestSuspendedTime;c>b&&(b=c);a>b&&(b=a);return b}function df(a,b){var c=b.earliestSuspendedTime,d=b.latestSuspendedTime,e=b.earliestPendingTime,f=b.latestPingedTime;e=0!==e?e:f;0===e&&(0===a||d<a)&&(e=d);a=e;0!==a&&c>a&&(a=c);b.nextExpirationTimeToWorkOn=e;b.expirationTime=a}function L(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}
function hf(a){var b=a._result;switch(a._status){case 1:return b;case 2:throw b;case 0:throw b;default:a._status=0;b=a._ctor;b=b();b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)});switch(a._status){case 1:return a._result;case 2:throw a._result;}a._result=b;throw b;}}var jf=(new aa.Component).refs;
function kf(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c)}
var tf={isMounted:function(a){return(a=a._reactInternalFiber)?2===ed(a):!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=lf();d=mf(d,a);var e=nf(d);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);of();pf(a,e);qf(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=lf();d=mf(d,a);var e=nf(d);e.tag=rf;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);of();pf(a,e);qf(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=lf();c=mf(c,a);var d=nf(c);d.tag=
sf;void 0!==b&&null!==b&&(d.callback=b);of();pf(a,d);qf(a,c)}};function uf(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!dd(c,d)||!dd(e,f):!0}
function vf(a,b,c){var d=!1,e=He;var f=b.contextType;"object"===typeof f&&null!==f?f=M(f):(e=J(b)?Ie:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Je(a,e):He);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=tf;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function wf(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&tf.enqueueReplaceState(b,b.state,null)}
function xf(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jf;var f=b.contextType;"object"===typeof f&&null!==f?e.context=M(f):(f=J(b)?Ie:H.current,e.context=Je(a,f));f=a.updateQueue;null!==f&&(yf(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(kf(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==
typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&tf.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(yf(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var zf=Array.isArray;
function Af(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;var d=void 0;c&&(1!==c.tag?x("309"):void 0,d=c.stateNode);d?void 0:x("147",a);var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===jf&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}"string"!==typeof a?x("284"):void 0;c._owner?void 0:x("290",a)}return a}
function Bf(a,b){"textarea"!==a.type&&x("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function Cf(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=Xe(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=af(c,a.mode,d),b.return=a,b;b=e(b,c,d);b.return=a;return b}function l(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props,d),d.ref=Af(a,b,c),d.return=a,d;d=Ye(c.type,c.key,c.props,null,a.mode,d);d.ref=Af(a,b,c);d.return=a;return d}function k(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
c.implementation)return b=bf(c,a.mode,d),b.return=a,b;b=e(b,c.children||[],d);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ze(c,a.mode,d,f),b.return=a,b;b=e(b,c,d);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=af(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Vb:return c=Ye(b.type,b.key,b.props,null,a.mode,c),c.ref=Af(a,null,b),c.return=a,c;case Wb:return b=bf(b,a.mode,c),b.return=a,b}if(zf(b)||
hc(b))return b=Ze(b,a.mode,c,null),b.return=a,b;Bf(a,b)}return null}function t(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Vb:return c.key===e?c.type===Xb?m(a,b,c.props.children,d,e):l(a,b,c,d):null;case Wb:return c.key===e?k(a,b,c,d):null}if(zf(c)||hc(c))return null!==e?null:m(a,b,c,d,null);Bf(a,c)}return null}function A(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Vb:return a=a.get(null===d.key?c:d.key)||null,d.type===Xb?m(b,a,d.props.children,e,d.key):l(b,a,d,e);case Wb:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e)}if(zf(d)||hc(d))return a=a.get(c)||null,m(b,a,d,e,null);Bf(b,d)}return null}function v(e,g,h,k){for(var l=null,m=null,q=g,u=g=0,B=null;null!==q&&u<h.length;u++){q.index>u?(B=q,q=null):B=q.sibling;var w=t(e,q,h[u],k);if(null===w){null===q&&(q=B);break}a&&
q&&null===w.alternate&&b(e,q);g=f(w,g,u);null===m?l=w:m.sibling=w;m=w;q=B}if(u===h.length)return c(e,q),l;if(null===q){for(;u<h.length;u++)if(q=p(e,h[u],k))g=f(q,g,u),null===m?l=q:m.sibling=q,m=q;return l}for(q=d(e,q);u<h.length;u++)if(B=A(q,e,u,h[u],k))a&&null!==B.alternate&&q.delete(null===B.key?u:B.key),g=f(B,g,u),null===m?l=B:m.sibling=B,m=B;a&&q.forEach(function(a){return b(e,a)});return l}function R(e,g,h,k){var l=hc(h);"function"!==typeof l?x("150"):void 0;h=l.call(h);null==h?x("151"):void 0;
for(var m=l=null,q=g,u=g=0,B=null,w=h.next();null!==q&&!w.done;u++,w=h.next()){q.index>u?(B=q,q=null):B=q.sibling;var v=t(e,q,w.value,k);if(null===v){q||(q=B);break}a&&q&&null===v.alternate&&b(e,q);g=f(v,g,u);null===m?l=v:m.sibling=v;m=v;q=B}if(w.done)return c(e,q),l;if(null===q){for(;!w.done;u++,w=h.next())w=p(e,w.value,k),null!==w&&(g=f(w,g,u),null===m?l=w:m.sibling=w,m=w);return l}for(q=d(e,q);!w.done;u++,w=h.next())w=A(q,e,u,w.value,k),null!==w&&(a&&null!==w.alternate&&q.delete(null===w.key?u:
w.key),g=f(w,g,u),null===m?l=w:m.sibling=w,m=w);a&&q.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===Xb&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Vb:a:{l=f.key;for(k=d;null!==k;){if(k.key===l)if(7===k.tag?f.type===Xb:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===Xb?f.props.children:f.props,h);d.ref=Af(a,k,f);d.return=a;a=d;break a}else{c(a,k);break}else b(a,k);k=
k.sibling}f.type===Xb?(d=Ze(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ye(f.type,f.key,f.props,null,a.mode,h),h.ref=Af(a,d,f),h.return=a,a=h)}return g(a);case Wb:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=bf(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=
""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h),d.return=a,a=d):(c(a,d),d=af(f,a.mode,h),d.return=a,a=d),g(a);if(zf(f))return v(a,d,f,h);if(hc(f))return R(a,d,f,h);l&&Bf(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:h=a.type,x("152",h.displayName||h.name||"Component")}return c(a,d)}}var Df=Cf(!0),Ef=Cf(!1),Ff={},N={current:Ff},Gf={current:Ff},Hf={current:Ff};function If(a){a===Ff?x("174"):void 0;return a}
function Jf(a,b){G(Hf,b,a);G(Gf,a,a);G(N,Ff,a);var c=b.nodeType;switch(c){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:he(null,"");break;default:c=8===c?b.parentNode:b,b=c.namespaceURI||null,c=c.tagName,b=he(b,c)}F(N,a);G(N,b,a)}function Kf(a){F(N,a);F(Gf,a);F(Hf,a)}function Lf(a){If(Hf.current);var b=If(N.current);var c=he(b,a.type);b!==c&&(G(Gf,a,a),G(N,c,a))}function Mf(a){Gf.current===a&&(F(N,a),F(Gf,a))}
var Nf=0,Of=2,Pf=4,Qf=8,Rf=16,Sf=32,Tf=64,Uf=128,Vf=Tb.ReactCurrentDispatcher,Wf=0,Xf=null,O=null,P=null,Yf=null,Q=null,Zf=null,$f=0,ag=null,bg=0,cg=!1,dg=null,eg=0;function fg(){x("321")}function gg(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!bd(a[c],b[c]))return!1;return!0}
function hg(a,b,c,d,e,f){Wf=f;Xf=b;P=null!==a?a.memoizedState:null;Vf.current=null===P?ig:jg;b=c(d,e);if(cg){do cg=!1,eg+=1,P=null!==a?a.memoizedState:null,Zf=Yf,ag=Q=O=null,Vf.current=jg,b=c(d,e);while(cg);dg=null;eg=0}Vf.current=kg;a=Xf;a.memoizedState=Yf;a.expirationTime=$f;a.updateQueue=ag;a.effectTag|=bg;a=null!==O&&null!==O.next;Wf=0;Zf=Q=Yf=P=O=Xf=null;$f=0;ag=null;bg=0;a?x("300"):void 0;return b}function lg(){Vf.current=kg;Wf=0;Zf=Q=Yf=P=O=Xf=null;$f=0;ag=null;bg=0;cg=!1;dg=null;eg=0}
function mg(){var a={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};null===Q?Yf=Q=a:Q=Q.next=a;return Q}function ng(){if(null!==Zf)Q=Zf,Zf=Q.next,O=P,P=null!==O?O.next:null;else{null===P?x("310"):void 0;O=P;var a={memoizedState:O.memoizedState,baseState:O.baseState,queue:O.queue,baseUpdate:O.baseUpdate,next:null};Q=null===Q?Yf=a:Q.next=a;P=O.next}return Q}function og(a,b){return"function"===typeof b?b(a):b}
function pg(a){var b=ng(),c=b.queue;null===c?x("311"):void 0;c.lastRenderedReducer=a;if(0<eg){var d=c.dispatch;if(null!==dg){var e=dg.get(c);if(void 0!==e){dg.delete(c);var f=b.memoizedState;do f=a(f,e.action),e=e.next;while(null!==e);bd(f,b.memoizedState)||(qg=!0);b.memoizedState=f;b.baseUpdate===c.last&&(b.baseState=f);c.lastRenderedState=f;return[f,d]}}return[b.memoizedState,d]}d=c.last;var g=b.baseUpdate;f=b.baseState;null!==g?(null!==d&&(d.next=null),d=g.next):d=null!==d?d.next:null;if(null!==
d){var h=e=null,l=d,k=!1;do{var m=l.expirationTime;m<Wf?(k||(k=!0,h=g,e=f),m>$f&&($f=m)):f=l.eagerReducer===a?l.eagerState:a(f,l.action);g=l;l=l.next}while(null!==l&&l!==d);k||(h=g,e=f);bd(f,b.memoizedState)||(qg=!0);b.memoizedState=f;b.baseUpdate=h;b.baseState=e;c.lastRenderedState=f}return[b.memoizedState,c.dispatch]}
function rg(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};null===ag?(ag={lastEffect:null},ag.lastEffect=a.next=a):(b=ag.lastEffect,null===b?ag.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,ag.lastEffect=a));return a}function sg(a,b,c,d){var e=mg();bg|=a;e.memoizedState=rg(b,c,void 0,void 0===d?null:d)}
function tg(a,b,c,d){var e=ng();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&gg(d,g.deps)){rg(Nf,c,f,d);return}}bg|=a;e.memoizedState=rg(b,c,f,d)}function ug(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function vg(){}
function wg(a,b,c){25>eg?void 0:x("301");var d=a.alternate;if(a===Xf||null!==d&&d===Xf)if(cg=!0,a={expirationTime:Wf,action:c,eagerReducer:null,eagerState:null,next:null},null===dg&&(dg=new Map),c=dg.get(b),void 0===c)dg.set(b,a);else{for(b=c;null!==b.next;)b=b.next;b.next=a}else{of();var e=lf();e=mf(e,a);var f={expirationTime:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.last;if(null===g)f.next=f;else{var h=g.next;null!==h&&(f.next=h);g.next=f}b.last=f;if(0===a.expirationTime&&(null===
d||0===d.expirationTime)&&(d=b.lastRenderedReducer,null!==d))try{var l=b.lastRenderedState,k=d(l,c);f.eagerReducer=d;f.eagerState=k;if(bd(k,l))return}catch(m){}finally{}qf(a,e)}}
var kg={readContext:M,useCallback:fg,useContext:fg,useEffect:fg,useImperativeHandle:fg,useLayoutEffect:fg,useMemo:fg,useReducer:fg,useRef:fg,useState:fg,useDebugValue:fg},ig={readContext:M,useCallback:function(a,b){mg().memoizedState=[a,void 0===b?null:b];return a},useContext:M,useEffect:function(a,b){return sg(516,Uf|Tf,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return sg(4,Pf|Sf,ug.bind(null,b,a),c)},useLayoutEffect:function(a,b){return sg(4,Pf|Sf,a,b)},
useMemo:function(a,b){var c=mg();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=mg();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={last:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=wg.bind(null,Xf,a);return[d.memoizedState,a]},useRef:function(a){var b=mg();a={current:a};return b.memoizedState=a},useState:function(a){var b=mg();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={last:null,dispatch:null,
lastRenderedReducer:og,lastRenderedState:a};a=a.dispatch=wg.bind(null,Xf,a);return[b.memoizedState,a]},useDebugValue:vg},jg={readContext:M,useCallback:function(a,b){var c=ng();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&gg(b,d[1]))return d[0];c.memoizedState=[a,b];return a},useContext:M,useEffect:function(a,b){return tg(516,Uf|Tf,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return tg(4,Pf|Sf,ug.bind(null,b,a),c)},useLayoutEffect:function(a,
b){return tg(4,Pf|Sf,a,b)},useMemo:function(a,b){var c=ng();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&gg(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a},useReducer:pg,useRef:function(){return ng().memoizedState},useState:function(a){return pg(og,a)},useDebugValue:vg},xg=null,yg=null,zg=!1;
function Ag(a,b){var c=K(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function Bg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}
function Cg(a){if(zg){var b=yg;if(b){var c=b;if(!Bg(a,b)){b=De(c);if(!b||!Bg(a,b)){a.effectTag|=2;zg=!1;xg=a;return}Ag(xg,c)}xg=a;yg=Ee(b)}else a.effectTag|=2,zg=!1,xg=a}}function Dg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&18!==a.tag;)a=a.return;xg=a}function Eg(a){if(a!==xg)return!1;if(!zg)return Dg(a),zg=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!xe(b,a.memoizedProps))for(b=yg;b;)Ag(a,b),b=De(b);Dg(a);yg=xg?De(a.stateNode):null;return!0}function Fg(){yg=xg=null;zg=!1}
var Gg=Tb.ReactCurrentOwner,qg=!1;function S(a,b,c,d){b.child=null===a?Ef(b,null,c,d):Df(b,a.child,c,d)}function Hg(a,b,c,d,e){c=c.render;var f=b.ref;Ig(b,e);d=hg(a,b,c,d,f,e);if(null!==a&&!qg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Jg(a,b,e);b.effectTag|=1;S(a,b,d,e);return b.child}
function Kg(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ve(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,Lg(a,b,g,d,e,f);a=Ye(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:dd,c(e,d)&&a.ref===b.ref))return Jg(a,b,f);b.effectTag|=1;a=Xe(g,d,f);a.ref=b.ref;a.return=b;return b.child=a}
function Lg(a,b,c,d,e,f){return null!==a&&dd(a.memoizedProps,d)&&a.ref===b.ref&&(qg=!1,e<f)?Jg(a,b,f):Mg(a,b,c,d,f)}function Ng(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function Mg(a,b,c,d,e){var f=J(c)?Ie:H.current;f=Je(b,f);Ig(b,e);c=hg(a,b,c,d,f,e);if(null!==a&&!qg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Jg(a,b,e);b.effectTag|=1;S(a,b,c,e);return b.child}
function Og(a,b,c,d,e){if(J(c)){var f=!0;Oe(b)}else f=!1;Ig(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),vf(b,c,d,e),xf(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var l=g.context,k=c.contextType;"object"===typeof k&&null!==k?k=M(k):(k=J(c)?Ie:H.current,k=Je(b,k));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(h!==d||l!==k)&&wf(b,g,d,k);Pg=!1;var t=b.memoizedState;l=g.state=t;var A=b.updateQueue;null!==A&&(yf(b,A,d,g,e),l=b.memoizedState);h!==d||t!==l||I.current||Pg?("function"===typeof m&&(kf(b,c,m,d),l=b.memoizedState),(h=Pg||uf(b,c,h,d,t,l,k))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&
g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=l),g.props=d,g.state=l,g.context=k,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,h=b.memoizedProps,g.props=b.type===b.elementType?h:L(b.type,h),l=g.context,k=c.contextType,"object"===typeof k&&null!==k?k=M(k):(k=J(c)?Ie:H.current,k=Je(b,k)),m=c.getDerivedStateFromProps,(p="function"===
typeof m||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||l!==k)&&wf(b,g,d,k),Pg=!1,l=b.memoizedState,t=g.state=l,A=b.updateQueue,null!==A&&(yf(b,A,d,g,e),t=b.memoizedState),h!==d||l!==t||I.current||Pg?("function"===typeof m&&(kf(b,c,m,d),t=b.memoizedState),(m=Pg||uf(b,c,h,d,l,t,k))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===
typeof g.componentWillUpdate&&g.componentWillUpdate(d,t,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,t,k)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=
t),g.props=d,g.state=t,g.context=k,d=m):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=256),d=!1);return Qg(a,b,c,d,f,e)}
function Qg(a,b,c,d,e,f){Ng(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Pe(b,c,!1),Jg(a,b,f);d=b.stateNode;Gg.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Df(b,a.child,null,f),b.child=Df(b,null,h,f)):S(a,b,h,f);b.memoizedState=d.state;e&&Pe(b,c,!0);return b.child}function Rg(a){var b=a.stateNode;b.pendingContext?Me(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Me(a,b.context,!1);Jf(a,b.containerInfo)}
function Sg(a,b,c){var d=b.mode,e=b.pendingProps,f=b.memoizedState;if(0===(b.effectTag&64)){f=null;var g=!1}else f={timedOutAt:null!==f?f.timedOutAt:0},g=!0,b.effectTag&=-65;if(null===a)if(g){var h=e.fallback;a=Ze(null,d,0,null);0===(b.mode&1)&&(a.child=null!==b.memoizedState?b.child.child:b.child);d=Ze(h,d,c,null);a.sibling=d;c=a;c.return=d.return=b}else c=d=Ef(b,null,e.children,c);else null!==a.memoizedState?(d=a.child,h=d.sibling,g?(c=e.fallback,e=Xe(d,d.pendingProps,0),0===(b.mode&1)&&(g=null!==
b.memoizedState?b.child.child:b.child,g!==d.child&&(e.child=g)),d=e.sibling=Xe(h,c,h.expirationTime),c=e,e.childExpirationTime=0,c.return=d.return=b):c=d=Df(b,d.child,e.children,c)):(h=a.child,g?(g=e.fallback,e=Ze(null,d,0,null),e.child=h,0===(b.mode&1)&&(e.child=null!==b.memoizedState?b.child.child:b.child),d=e.sibling=Ze(g,d,c,null),d.effectTag|=2,c=e,e.childExpirationTime=0,c.return=d.return=b):d=c=Df(b,h,e.children,c)),b.stateNode=a.stateNode;b.memoizedState=f;b.child=c;return d}
function Jg(a,b,c){null!==a&&(b.contextDependencies=a.contextDependencies);if(b.childExpirationTime<c)return null;null!==a&&b.child!==a.child?x("153"):void 0;if(null!==b.child){a=b.child;c=Xe(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Xe(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null}return b.child}
function Tg(a,b,c){var d=b.expirationTime;if(null!==a)if(a.memoizedProps!==b.pendingProps||I.current)qg=!0;else{if(d<c){qg=!1;switch(b.tag){case 3:Rg(b);Fg();break;case 5:Lf(b);break;case 1:J(b.type)&&Oe(b);break;case 4:Jf(b,b.stateNode.containerInfo);break;case 10:Ug(b,b.memoizedProps.value);break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;if(0!==d&&d>=c)return Sg(a,b,c);b=Jg(a,b,c);return null!==b?b.sibling:null}}return Jg(a,b,c)}}else qg=!1;b.expirationTime=0;switch(b.tag){case 2:d=
b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;var e=Je(b,H.current);Ig(b,c);e=hg(null,b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;lg();if(J(d)){var f=!0;Oe(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;var g=d.getDerivedStateFromProps;"function"===typeof g&&kf(b,d,g,a);e.updater=tf;b.stateNode=e;e._reactInternalFiber=b;xf(b,d,a,c);b=Qg(null,b,d,!0,f,
c)}else b.tag=0,S(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);f=b.pendingProps;a=hf(e);b.type=a;e=b.tag=We(a);f=L(a,f);g=void 0;switch(e){case 0:g=Mg(null,b,a,f,c);break;case 1:g=Og(null,b,a,f,c);break;case 11:g=Hg(null,b,a,f,c);break;case 14:g=Kg(null,b,a,L(a.type,f),d,c);break;default:x("306",a,"")}return g;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:L(d,e),Mg(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,
e=b.elementType===d?e:L(d,e),Og(a,b,d,e,c);case 3:Rg(b);d=b.updateQueue;null===d?x("282"):void 0;e=b.memoizedState;e=null!==e?e.element:null;yf(b,d,b.pendingProps,null,c);d=b.memoizedState.element;if(d===e)Fg(),b=Jg(a,b,c);else{e=b.stateNode;if(e=(null===a||null===a.child)&&e.hydrate)yg=Ee(b.stateNode.containerInfo),xg=b,e=zg=!0;e?(b.effectTag|=2,b.child=Ef(b,null,d,c)):(S(a,b,d,c),Fg());b=b.child}return b;case 5:return Lf(b),null===a&&Cg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,
g=e.children,xe(d,e)?g=null:null!==f&&xe(d,f)&&(b.effectTag|=16),Ng(a,b),1!==c&&b.mode&1&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(S(a,b,g,c),b=b.child),b;case 6:return null===a&&Cg(b),null;case 13:return Sg(a,b,c);case 4:return Jf(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Df(b,null,d,c):S(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:L(d,e),Hg(a,b,d,e,c);case 7:return S(a,b,b.pendingProps,c),b.child;case 8:return S(a,b,b.pendingProps.children,
c),b.child;case 12:return S(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;Ug(b,f);if(null!==g){var h=g.value;f=bd(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0;if(0===f){if(g.children===e.children&&!I.current){b=Jg(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var l=h.contextDependencies;if(null!==l){g=h.child;for(var k=l.first;null!==k;){if(k.context===d&&0!==
(k.observedBits&f)){1===h.tag&&(k=nf(c),k.tag=sf,pf(h,k));h.expirationTime<c&&(h.expirationTime=c);k=h.alternate;null!==k&&k.expirationTime<c&&(k.expirationTime=c);k=c;for(var m=h.return;null!==m;){var p=m.alternate;if(m.childExpirationTime<k)m.childExpirationTime=k,null!==p&&p.childExpirationTime<k&&(p.childExpirationTime=k);else if(null!==p&&p.childExpirationTime<k)p.childExpirationTime=k;else break;m=m.return}l.expirationTime<c&&(l.expirationTime=c);break}k=k.next}}else g=10===h.tag?h.type===b.type?
null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}}S(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,Ig(b,c),e=M(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,S(a,b,d,c),b.child;case 14:return e=b.type,f=L(e,b.pendingProps),f=L(e.type,f),Kg(a,b,e,f,d,c);case 15:return Lg(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===
d?e:L(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,J(d)?(a=!0,Oe(b)):a=!1,Ig(b,c),vf(b,d,e,c),xf(b,d,e,c),Qg(null,b,d,!0,a,c)}x("156")}var Vg={current:null},Wg=null,Xg=null,Yg=null;function Ug(a,b){var c=a.type._context;G(Vg,c._currentValue,a);c._currentValue=b}function Zg(a){var b=Vg.current;F(Vg,a);a.type._context._currentValue=b}function Ig(a,b){Wg=a;Yg=Xg=null;var c=a.contextDependencies;null!==c&&c.expirationTime>=b&&(qg=!0);a.contextDependencies=null}
function M(a,b){if(Yg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Yg=a,b=1073741823;b={context:a,observedBits:b,next:null};null===Xg?(null===Wg?x("308"):void 0,Xg=b,Wg.contextDependencies={first:b,expirationTime:0}):Xg=Xg.next=b}return a._currentValue}var $g=0,rf=1,sf=2,ah=3,Pg=!1;function bh(a){return{baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
function ch(a){return{baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function nf(a){return{expirationTime:a,tag:$g,payload:null,callback:null,next:null,nextEffect:null}}function dh(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b)}
function pf(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=bh(a.memoizedState))}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=bh(a.memoizedState),e=c.updateQueue=bh(c.memoizedState)):d=a.updateQueue=ch(e):null===e&&(e=c.updateQueue=ch(d));null===e||d===e?dh(d,b):null===d.lastUpdate||null===e.lastUpdate?(dh(d,b),dh(e,b)):(dh(d,b),e.lastUpdate=b)}
function eh(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=bh(a.memoizedState):fh(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b)}function fh(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=ch(b));return b}
function gh(a,b,c,d,e,f){switch(c.tag){case rf:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case ah:a.effectTag=a.effectTag&-2049|64;case $g:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return n({},d,e);case sf:Pg=!0}return d}
function yf(a,b,c,d,e){Pg=!1;b=fh(a,b);for(var f=b.baseState,g=null,h=0,l=b.firstUpdate,k=f;null!==l;){var m=l.expirationTime;m<e?(null===g&&(g=l,f=k),h<m&&(h=m)):(k=gh(a,b,l,k,c,d),null!==l.callback&&(a.effectTag|=32,l.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=l:(b.lastEffect.nextEffect=l,b.lastEffect=l)));l=l.next}m=null;for(l=b.firstCapturedUpdate;null!==l;){var p=l.expirationTime;p<e?(null===m&&(m=l,null===g&&(f=k)),h<p&&(h=p)):(k=gh(a,b,l,k,c,d),null!==l.callback&&(a.effectTag|=
32,l.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=l:(b.lastCapturedEffect.nextEffect=l,b.lastCapturedEffect=l)));l=l.next}null===g&&(b.lastUpdate=null);null===m?b.lastCapturedUpdate=null:a.effectTag|=32;null===g&&null===m&&(f=k);b.baseState=f;b.firstUpdate=g;b.firstCapturedUpdate=m;a.expirationTime=h;a.memoizedState=k}
function hh(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);ih(b.firstEffect,c);b.firstEffect=b.lastEffect=null;ih(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null}function ih(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;"function"!==typeof c?x("191",c):void 0;c.call(d)}a=a.nextEffect}}
function jh(a,b){return{value:a,source:b,stack:jc(b)}}function kh(a){a.effectTag|=4}var lh=void 0,mh=void 0,nh=void 0,oh=void 0;lh=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};mh=function(){};
nh=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;If(N.current);a=null;switch(c){case "input":f=vc(g,f);d=vc(g,d);a=[];break;case "option":f=$d(g,f);d=$d(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=be(g,f);d=be(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=te)}qe(c,d);g=c=void 0;var h=null;for(c in f)if(!d.hasOwnProperty(c)&&f.hasOwnProperty(c)&&null!=f[c])if("style"===
c){var l=f[c];for(g in l)l.hasOwnProperty(g)&&(h||(h={}),h[g]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(ra.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in d){var k=d[c];l=null!=f?f[c]:void 0;if(d.hasOwnProperty(c)&&k!==l&&(null!=k||null!=l))if("style"===c)if(l){for(g in l)!l.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(h||(h={}),h[g]="");for(g in k)k.hasOwnProperty(g)&&l[g]!==k[g]&&(h||
(h={}),h[g]=k[g])}else h||(a||(a=[]),a.push(c,h)),h=k;else"dangerouslySetInnerHTML"===c?(k=k?k.__html:void 0,l=l?l.__html:void 0,null!=k&&l!==k&&(a=a||[]).push(c,""+k)):"children"===c?l===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(c,""+k):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(ra.hasOwnProperty(c)?(null!=k&&se(e,c),a||l===k||(a=[])):(a=a||[]).push(c,k))}h&&(a=a||[]).push("style",h);e=a;(b.updateQueue=e)&&kh(b)}};oh=function(a,b,c,d){c!==d&&kh(b)};
var ph="function"===typeof WeakSet?WeakSet:Set;function qh(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=jc(c));null!==c&&ic(c.type);b=b.value;null!==a&&1===a.tag&&ic(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function rh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){sh(a,c)}else b.current=null}
function th(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if((d.tag&a)!==Nf){var e=d.destroy;d.destroy=void 0;void 0!==e&&e()}(d.tag&b)!==Nf&&(e=d.create,d.destroy=e());d=d.next}while(d!==c)}}
function uh(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d.style.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=ne("display",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if(13===c.tag&&null!==c.memoizedState){d=c.child.sibling;d.return=c;c=d;continue}else if(null!==c.child){c.child.return=c;c=c.child;continue}if(c===a)break;for(;null===c.sibling;){if(null===c.return||
c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}
function vh(a){"function"===typeof Re&&Re(a);switch(a.tag){case 0:case 11:case 14:case 15:var b=a.updateQueue;if(null!==b&&(b=b.lastEffect,null!==b)){var c=b=b.next;do{var d=c.destroy;if(void 0!==d){var e=a;try{d()}catch(f){sh(e,f)}}c=c.next}while(c!==b)}break;case 1:rh(a);b=a.stateNode;if("function"===typeof b.componentWillUnmount)try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(f){sh(a,f)}break;case 5:rh(a);break;case 4:wh(a)}}
function xh(a){return 5===a.tag||3===a.tag||4===a.tag}
function yh(a){a:{for(var b=a.return;null!==b;){if(xh(b)){var c=b;break a}b=b.return}x("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:x("161")}c.effectTag&16&&(ke(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||xh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&
2)continue b;if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)if(c)if(d){var f=b,g=e.stateNode,h=c;8===f.nodeType?f.parentNode.insertBefore(g,h):f.insertBefore(g,h)}else b.insertBefore(e.stateNode,c);else d?(g=b,h=e.stateNode,8===g.nodeType?(f=g.parentNode,f.insertBefore(h,g)):(f=g,f.appendChild(h)),g=g._reactRootContainer,null!==g&&void 0!==g||null!==f.onclick||(f.onclick=te)):b.appendChild(e.stateNode);
else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return}e.sibling.return=e.return;e=e.sibling}}
function wh(a){for(var b=a,c=!1,d=void 0,e=void 0;;){if(!c){c=b.return;a:for(;;){null===c?x("160"):void 0;switch(c.tag){case 5:d=c.stateNode;e=!1;break a;case 3:d=c.stateNode.containerInfo;e=!0;break a;case 4:d=c.stateNode.containerInfo;e=!0;break a}c=c.return}c=!0}if(5===b.tag||6===b.tag){a:for(var f=b,g=f;;)if(vh(g),null!==g.child&&4!==g.tag)g.child.return=g,g=g.child;else{if(g===f)break;for(;null===g.sibling;){if(null===g.return||g.return===f)break a;g=g.return}g.sibling.return=g.return;g=g.sibling}e?
(f=d,g=b.stateNode,8===f.nodeType?f.parentNode.removeChild(g):f.removeChild(g)):d.removeChild(b.stateNode)}else if(4===b.tag){if(null!==b.child){d=b.stateNode.containerInfo;e=!0;b.child.return=b;b=b.child;continue}}else if(vh(b),null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return;b=b.return;4===b.tag&&(c=!1)}b.sibling.return=b.return;b=b.sibling}}
function zh(a,b){switch(b.tag){case 0:case 11:case 14:case 15:th(Pf,Qf,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&Ce(c,f,e,a,d,b)}break;case 6:null===b.stateNode?x("162"):void 0;b.stateNode.nodeValue=b.memoizedProps;break;case 3:break;case 12:break;case 13:c=b.memoizedState;d=void 0;a=b;null===c?d=!1:(d=!0,a=b.child,0===c.timedOutAt&&(c.timedOutAt=lf()));null!==a&&uh(a,d);c=
b.updateQueue;if(null!==c){b.updateQueue=null;var g=b.stateNode;null===g&&(g=b.stateNode=new ph);c.forEach(function(a){var c=Ah.bind(null,b,a);g.has(a)||(g.add(a),a.then(c,c))})}break;case 17:break;default:x("163")}}var Bh="function"===typeof WeakMap?WeakMap:Map;function Ch(a,b,c){c=nf(c);c.tag=ah;c.payload={element:null};var d=b.value;c.callback=function(){Dh(d);qh(a,b)};return c}
function Eh(a,b,c){c=nf(c);c.tag=ah;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Fh?Fh=new Set([this]):Fh.add(this));var c=b.value,e=b.stack;qh(a,b);this.componentDidCatch(c,{componentStack:null!==e?e:""})});return c}
function Gh(a){switch(a.tag){case 1:J(a.type)&&Ke(a);var b=a.effectTag;return b&2048?(a.effectTag=b&-2049|64,a):null;case 3:return Kf(a),Le(a),b=a.effectTag,0!==(b&64)?x("285"):void 0,a.effectTag=b&-2049|64,a;case 5:return Mf(a),null;case 13:return b=a.effectTag,b&2048?(a.effectTag=b&-2049|64,a):null;case 18:return null;case 4:return Kf(a),null;case 10:return Zg(a),null;default:return null}}
var Hh=Tb.ReactCurrentDispatcher,Ih=Tb.ReactCurrentOwner,Jh=1073741822,Kh=!1,T=null,Lh=null,U=0,Mh=-1,Nh=!1,V=null,Oh=!1,Ph=null,Qh=null,Rh=null,Fh=null;function Sh(){if(null!==T)for(var a=T.return;null!==a;){var b=a;switch(b.tag){case 1:var c=b.type.childContextTypes;null!==c&&void 0!==c&&Ke(b);break;case 3:Kf(b);Le(b);break;case 5:Mf(b);break;case 4:Kf(b);break;case 10:Zg(b)}a=a.return}Lh=null;U=0;Mh=-1;Nh=!1;T=null}
function Th(){for(;null!==V;){var a=V.effectTag;a&16&&ke(V.stateNode,"");if(a&128){var b=V.alternate;null!==b&&(b=b.ref,null!==b&&("function"===typeof b?b(null):b.current=null))}switch(a&14){case 2:yh(V);V.effectTag&=-3;break;case 6:yh(V);V.effectTag&=-3;zh(V.alternate,V);break;case 4:zh(V.alternate,V);break;case 8:a=V,wh(a),a.return=null,a.child=null,a.memoizedState=null,a.updateQueue=null,a=a.alternate,null!==a&&(a.return=null,a.child=null,a.memoizedState=null,a.updateQueue=null)}V=V.nextEffect}}
function Uh(){for(;null!==V;){if(V.effectTag&256)a:{var a=V.alternate,b=V;switch(b.tag){case 0:case 11:case 15:th(Of,Nf,b);break a;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:L(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}break a;case 3:case 5:case 6:case 4:case 17:break a;default:x("163")}}V=V.nextEffect}}
function Vh(a,b){for(;null!==V;){var c=V.effectTag;if(c&36){var d=V.alternate,e=V,f=b;switch(e.tag){case 0:case 11:case 15:th(Rf,Sf,e);break;case 1:var g=e.stateNode;if(e.effectTag&4)if(null===d)g.componentDidMount();else{var h=e.elementType===e.type?d.memoizedProps:L(e.type,d.memoizedProps);g.componentDidUpdate(h,d.memoizedState,g.__reactInternalSnapshotBeforeUpdate)}d=e.updateQueue;null!==d&&hh(e,d,g,f);break;case 3:d=e.updateQueue;if(null!==d){g=null;if(null!==e.child)switch(e.child.tag){case 5:g=
e.child.stateNode;break;case 1:g=e.child.stateNode}hh(e,d,g,f)}break;case 5:f=e.stateNode;null===d&&e.effectTag&4&&we(e.type,e.memoizedProps)&&f.focus();break;case 6:break;case 4:break;case 12:break;case 13:break;case 17:break;default:x("163")}}c&128&&(e=V.ref,null!==e&&(f=V.stateNode,"function"===typeof e?e(f):e.current=f));c&512&&(Ph=a);V=V.nextEffect}}
function Wh(a,b){Rh=Qh=Ph=null;var c=W;W=!0;do{if(b.effectTag&512){var d=!1,e=void 0;try{var f=b;th(Uf,Nf,f);th(Nf,Tf,f)}catch(g){d=!0,e=g}d&&sh(b,e)}b=b.nextEffect}while(null!==b);W=c;c=a.expirationTime;0!==c&&Xh(a,c);X||W||Yh(1073741823,!1)}function of(){null!==Qh&&Be(Qh);null!==Rh&&Rh()}
function Zh(a,b){Oh=Kh=!0;a.current===b?x("177"):void 0;var c=a.pendingCommitExpirationTime;0===c?x("261"):void 0;a.pendingCommitExpirationTime=0;var d=b.expirationTime,e=b.childExpirationTime;ef(a,e>d?e:d);Ih.current=null;d=void 0;1<b.effectTag?null!==b.lastEffect?(b.lastEffect.nextEffect=b,d=b.firstEffect):d=b:d=b.firstEffect;ue=Bd;ve=Pd();Bd=!1;for(V=d;null!==V;){e=!1;var f=void 0;try{Uh()}catch(h){e=!0,f=h}e&&(null===V?x("178"):void 0,sh(V,f),null!==V&&(V=V.nextEffect))}for(V=d;null!==V;){e=!1;
f=void 0;try{Th()}catch(h){e=!0,f=h}e&&(null===V?x("178"):void 0,sh(V,f),null!==V&&(V=V.nextEffect))}Qd(ve);ve=null;Bd=!!ue;ue=null;a.current=b;for(V=d;null!==V;){e=!1;f=void 0;try{Vh(a,c)}catch(h){e=!0,f=h}e&&(null===V?x("178"):void 0,sh(V,f),null!==V&&(V=V.nextEffect))}if(null!==d&&null!==Ph){var g=Wh.bind(null,a,d);Qh=r.unstable_runWithPriority(r.unstable_NormalPriority,function(){return Ae(g)});Rh=g}Kh=Oh=!1;"function"===typeof Qe&&Qe(b.stateNode);c=b.expirationTime;b=b.childExpirationTime;b=
b>c?b:c;0===b&&(Fh=null);$h(a,b)}
function ai(a){for(;;){var b=a.alternate,c=a.return,d=a.sibling;if(0===(a.effectTag&1024)){T=a;a:{var e=b;b=a;var f=U;var g=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:J(b.type)&&Ke(b);break;case 3:Kf(b);Le(b);g=b.stateNode;g.pendingContext&&(g.context=g.pendingContext,g.pendingContext=null);if(null===e||null===e.child)Eg(b),b.effectTag&=-3;mh(b);break;case 5:Mf(b);var h=If(Hf.current);f=b.type;if(null!==e&&null!=b.stateNode)nh(e,b,f,g,h),e.ref!==b.ref&&(b.effectTag|=
128);else if(g){var l=If(N.current);if(Eg(b)){g=b;e=g.stateNode;var k=g.type,m=g.memoizedProps,p=h;e[Fa]=g;e[Ga]=m;f=void 0;h=k;switch(h){case "iframe":case "object":E("load",e);break;case "video":case "audio":for(k=0;k<ab.length;k++)E(ab[k],e);break;case "source":E("error",e);break;case "img":case "image":case "link":E("error",e);E("load",e);break;case "form":E("reset",e);E("submit",e);break;case "details":E("toggle",e);break;case "input":wc(e,m);E("invalid",e);se(p,"onChange");break;case "select":e._wrapperState=
{wasMultiple:!!m.multiple};E("invalid",e);se(p,"onChange");break;case "textarea":ce(e,m),E("invalid",e),se(p,"onChange")}qe(h,m);k=null;for(f in m)m.hasOwnProperty(f)&&(l=m[f],"children"===f?"string"===typeof l?e.textContent!==l&&(k=["children",l]):"number"===typeof l&&e.textContent!==""+l&&(k=["children",""+l]):ra.hasOwnProperty(f)&&null!=l&&se(p,f));switch(h){case "input":Rb(e);Ac(e,m,!0);break;case "textarea":Rb(e);ee(e,m);break;case "select":case "option":break;default:"function"===typeof m.onClick&&
(e.onclick=te)}f=k;g.updateQueue=f;g=null!==f?!0:!1;g&&kh(b)}else{m=b;p=f;e=g;k=9===h.nodeType?h:h.ownerDocument;l===fe.html&&(l=ge(p));l===fe.html?"script"===p?(e=k.createElement("div"),e.innerHTML="<script>\x3c/script>",k=e.removeChild(e.firstChild)):"string"===typeof e.is?k=k.createElement(p,{is:e.is}):(k=k.createElement(p),"select"===p&&(p=k,e.multiple?p.multiple=!0:e.size&&(p.size=e.size))):k=k.createElementNS(l,p);e=k;e[Fa]=m;e[Ga]=g;lh(e,b,!1,!1);p=e;k=f;m=g;var t=h,A=re(k,m);switch(k){case "iframe":case "object":E("load",
p);h=m;break;case "video":case "audio":for(h=0;h<ab.length;h++)E(ab[h],p);h=m;break;case "source":E("error",p);h=m;break;case "img":case "image":case "link":E("error",p);E("load",p);h=m;break;case "form":E("reset",p);E("submit",p);h=m;break;case "details":E("toggle",p);h=m;break;case "input":wc(p,m);h=vc(p,m);E("invalid",p);se(t,"onChange");break;case "option":h=$d(p,m);break;case "select":p._wrapperState={wasMultiple:!!m.multiple};h=n({},m,{value:void 0});E("invalid",p);se(t,"onChange");break;case "textarea":ce(p,
m);h=be(p,m);E("invalid",p);se(t,"onChange");break;default:h=m}qe(k,h);l=void 0;var v=k,R=p,u=h;for(l in u)if(u.hasOwnProperty(l)){var q=u[l];"style"===l?oe(R,q):"dangerouslySetInnerHTML"===l?(q=q?q.__html:void 0,null!=q&&je(R,q)):"children"===l?"string"===typeof q?("textarea"!==v||""!==q)&&ke(R,q):"number"===typeof q&&ke(R,""+q):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ra.hasOwnProperty(l)?null!=q&&se(t,l):null!=q&&tc(R,l,q,A))}switch(k){case "input":Rb(p);
Ac(p,m,!1);break;case "textarea":Rb(p);ee(p,m);break;case "option":null!=m.value&&p.setAttribute("value",""+uc(m.value));break;case "select":h=p;h.multiple=!!m.multiple;p=m.value;null!=p?ae(h,!!m.multiple,p,!1):null!=m.defaultValue&&ae(h,!!m.multiple,m.defaultValue,!0);break;default:"function"===typeof h.onClick&&(p.onclick=te)}(g=we(f,g))&&kh(b);b.stateNode=e}null!==b.ref&&(b.effectTag|=128)}else null===b.stateNode?x("166"):void 0;break;case 6:e&&null!=b.stateNode?oh(e,b,e.memoizedProps,g):("string"!==
typeof g&&(null===b.stateNode?x("166"):void 0),e=If(Hf.current),If(N.current),Eg(b)?(g=b,f=g.stateNode,e=g.memoizedProps,f[Fa]=g,(g=f.nodeValue!==e)&&kh(b)):(f=b,g=(9===e.nodeType?e:e.ownerDocument).createTextNode(g),g[Fa]=b,f.stateNode=g));break;case 11:break;case 13:g=b.memoizedState;if(0!==(b.effectTag&64)){b.expirationTime=f;T=b;break a}g=null!==g;f=null!==e&&null!==e.memoizedState;null!==e&&!g&&f&&(e=e.child.sibling,null!==e&&(h=b.firstEffect,null!==h?(b.firstEffect=e,e.nextEffect=h):(b.firstEffect=
b.lastEffect=e,e.nextEffect=null),e.effectTag=8));if(g||f)b.effectTag|=4;break;case 7:break;case 8:break;case 12:break;case 4:Kf(b);mh(b);break;case 10:Zg(b);break;case 9:break;case 14:break;case 17:J(b.type)&&Ke(b);break;case 18:break;default:x("156")}T=null}b=a;if(1===U||1!==b.childExpirationTime){g=0;for(f=b.child;null!==f;)e=f.expirationTime,h=f.childExpirationTime,e>g&&(g=e),h>g&&(g=h),f=f.sibling;b.childExpirationTime=g}if(null!==T)return T;null!==c&&0===(c.effectTag&1024)&&(null===c.firstEffect&&
(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a))}else{a=Gh(a,U);if(null!==a)return a.effectTag&=1023,a;null!==c&&(c.firstEffect=c.lastEffect=null,c.effectTag|=1024)}if(null!==d)return d;if(null!==c)a=c;else break}return null}
function bi(a){var b=Tg(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=ai(a));Ih.current=null;return b}
function ci(a,b){Kh?x("243"):void 0;of();Kh=!0;var c=Hh.current;Hh.current=kg;var d=a.nextExpirationTimeToWorkOn;if(d!==U||a!==Lh||null===T)Sh(),Lh=a,U=d,T=Xe(Lh.current,null,U),a.pendingCommitExpirationTime=0;var e=!1;do{try{if(b)for(;null!==T&&!di();)T=bi(T);else for(;null!==T;)T=bi(T)}catch(u){if(Yg=Xg=Wg=null,lg(),null===T)e=!0,Dh(u);else{null===T?x("271"):void 0;var f=T,g=f.return;if(null===g)e=!0,Dh(u);else{a:{var h=a,l=g,k=f,m=u;g=U;k.effectTag|=1024;k.firstEffect=k.lastEffect=null;if(null!==
m&&"object"===typeof m&&"function"===typeof m.then){var p=m;m=l;var t=-1,A=-1;do{if(13===m.tag){var v=m.alternate;if(null!==v&&(v=v.memoizedState,null!==v)){A=10*(1073741822-v.timedOutAt);break}v=m.pendingProps.maxDuration;if("number"===typeof v)if(0>=v)t=0;else if(-1===t||v<t)t=v}m=m.return}while(null!==m);m=l;do{if(v=13===m.tag)v=void 0===m.memoizedProps.fallback?!1:null===m.memoizedState;if(v){l=m.updateQueue;null===l?(l=new Set,l.add(p),m.updateQueue=l):l.add(p);if(0===(m.mode&1)){m.effectTag|=
64;k.effectTag&=-1957;1===k.tag&&(null===k.alternate?k.tag=17:(g=nf(1073741823),g.tag=sf,pf(k,g)));k.expirationTime=1073741823;break a}k=h;l=g;var R=k.pingCache;null===R?(R=k.pingCache=new Bh,v=new Set,R.set(p,v)):(v=R.get(p),void 0===v&&(v=new Set,R.set(p,v)));v.has(l)||(v.add(l),k=ei.bind(null,k,p,l),p.then(k,k));-1===t?h=1073741823:(-1===A&&(A=10*(1073741822-gf(h,g))-5E3),h=A+t);0<=h&&Mh<h&&(Mh=h);m.effectTag|=2048;m.expirationTime=g;break a}m=m.return}while(null!==m);m=Error((ic(k.type)||"A React component")+
" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+jc(k))}Nh=!0;m=jh(m,k);h=l;do{switch(h.tag){case 3:h.effectTag|=2048;h.expirationTime=g;g=Ch(h,m,g);eh(h,g);break a;case 1:if(t=m,A=h.type,k=h.stateNode,0===(h.effectTag&64)&&("function"===typeof A.getDerivedStateFromError||null!==k&&"function"===typeof k.componentDidCatch&&(null===Fh||!Fh.has(k)))){h.effectTag|=2048;
h.expirationTime=g;g=Eh(h,t,g);eh(h,g);break a}}h=h.return}while(null!==h)}T=ai(f);continue}}}break}while(1);Kh=!1;Hh.current=c;Yg=Xg=Wg=null;lg();if(e)Lh=null,a.finishedWork=null;else if(null!==T)a.finishedWork=null;else{c=a.current.alternate;null===c?x("281"):void 0;Lh=null;if(Nh){e=a.latestPendingTime;f=a.latestSuspendedTime;g=a.latestPingedTime;if(0!==e&&e<d||0!==f&&f<d||0!==g&&g<d){ff(a,d);fi(a,c,d,a.expirationTime,-1);return}if(!a.didError&&b){a.didError=!0;d=a.nextExpirationTimeToWorkOn=d;
b=a.expirationTime=1073741823;fi(a,c,d,b,-1);return}}b&&-1!==Mh?(ff(a,d),b=10*(1073741822-gf(a,d)),b<Mh&&(Mh=b),b=10*(1073741822-lf()),b=Mh-b,fi(a,c,d,a.expirationTime,0>b?0:b)):(a.pendingCommitExpirationTime=d,a.finishedWork=c)}}
function sh(a,b){for(var c=a.return;null!==c;){switch(c.tag){case 1:var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Fh||!Fh.has(d))){a=jh(b,a);a=Eh(c,a,1073741823);pf(c,a);qf(c,1073741823);return}break;case 3:a=jh(b,a);a=Ch(c,a,1073741823);pf(c,a);qf(c,1073741823);return}c=c.return}3===a.tag&&(c=jh(b,a),c=Ch(a,c,1073741823),pf(a,c),qf(a,1073741823))}
function mf(a,b){var c=r.unstable_getCurrentPriorityLevel(),d=void 0;if(0===(b.mode&1))d=1073741823;else if(Kh&&!Oh)d=U;else{switch(c){case r.unstable_ImmediatePriority:d=1073741823;break;case r.unstable_UserBlockingPriority:d=1073741822-10*(((1073741822-a+15)/10|0)+1);break;case r.unstable_NormalPriority:d=1073741822-25*(((1073741822-a+500)/25|0)+1);break;case r.unstable_LowPriority:case r.unstable_IdlePriority:d=1;break;default:x("313")}null!==Lh&&d===U&&--d}c===r.unstable_UserBlockingPriority&&
(0===gi||d<gi)&&(gi=d);return d}function ei(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);if(null!==Lh&&U===c)Lh=null;else if(b=a.earliestSuspendedTime,d=a.latestSuspendedTime,0!==b&&c<=b&&c>=d){a.didError=!1;b=a.latestPingedTime;if(0===b||b>c)a.latestPingedTime=c;df(c,a);c=a.expirationTime;0!==c&&Xh(a,c)}}function Ah(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=lf();b=mf(b,a);a=hi(a,b);null!==a&&(cf(a,b),b=a.expirationTime,0!==b&&Xh(a,b))}
function hi(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}return e}
function qf(a,b){a=hi(a,b);null!==a&&(!Kh&&0!==U&&b>U&&Sh(),cf(a,b),Kh&&!Oh&&Lh===a||Xh(a,a.expirationTime),ii>ji&&(ii=0,x("185")))}function ki(a,b,c,d,e){return r.unstable_runWithPriority(r.unstable_ImmediatePriority,function(){return a(b,c,d,e)})}var li=null,Y=null,mi=0,ni=void 0,W=!1,oi=null,Z=0,gi=0,pi=!1,qi=null,X=!1,ri=!1,si=null,ti=r.unstable_now(),ui=1073741822-(ti/10|0),vi=ui,ji=50,ii=0,wi=null;function xi(){ui=1073741822-((r.unstable_now()-ti)/10|0)}
function yi(a,b){if(0!==mi){if(b<mi)return;null!==ni&&r.unstable_cancelCallback(ni)}mi=b;a=r.unstable_now()-ti;ni=r.unstable_scheduleCallback(zi,{timeout:10*(1073741822-b)-a})}function fi(a,b,c,d,e){a.expirationTime=d;0!==e||di()?0<e&&(a.timeoutHandle=ye(Ai.bind(null,a,b,c),e)):(a.pendingCommitExpirationTime=c,a.finishedWork=b)}function Ai(a,b,c){a.pendingCommitExpirationTime=c;a.finishedWork=b;xi();vi=ui;Bi(a,c)}function $h(a,b){a.expirationTime=b;a.finishedWork=null}
function lf(){if(W)return vi;Ci();if(0===Z||1===Z)xi(),vi=ui;return vi}function Xh(a,b){null===a.nextScheduledRoot?(a.expirationTime=b,null===Y?(li=Y=a,a.nextScheduledRoot=a):(Y=Y.nextScheduledRoot=a,Y.nextScheduledRoot=li)):b>a.expirationTime&&(a.expirationTime=b);W||(X?ri&&(oi=a,Z=1073741823,Di(a,1073741823,!1)):1073741823===b?Yh(1073741823,!1):yi(a,b))}
function Ci(){var a=0,b=null;if(null!==Y)for(var c=Y,d=li;null!==d;){var e=d.expirationTime;if(0===e){null===c||null===Y?x("244"):void 0;if(d===d.nextScheduledRoot){li=Y=d.nextScheduledRoot=null;break}else if(d===li)li=e=d.nextScheduledRoot,Y.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===Y){Y=c;Y.nextScheduledRoot=li;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{e>a&&(a=e,b=d);if(d===Y)break;if(1073741823===
a)break;c=d;d=d.nextScheduledRoot}}oi=b;Z=a}var Ei=!1;function di(){return Ei?!0:r.unstable_shouldYield()?Ei=!0:!1}function zi(){try{if(!di()&&null!==li){xi();var a=li;do{var b=a.expirationTime;0!==b&&ui<=b&&(a.nextExpirationTimeToWorkOn=ui);a=a.nextScheduledRoot}while(a!==li)}Yh(0,!0)}finally{Ei=!1}}
function Yh(a,b){Ci();if(b)for(xi(),vi=ui;null!==oi&&0!==Z&&a<=Z&&!(Ei&&ui>Z);)Di(oi,Z,ui>Z),Ci(),xi(),vi=ui;else for(;null!==oi&&0!==Z&&a<=Z;)Di(oi,Z,!1),Ci();b&&(mi=0,ni=null);0!==Z&&yi(oi,Z);ii=0;wi=null;if(null!==si)for(a=si,si=null,b=0;b<a.length;b++){var c=a[b];try{c._onComplete()}catch(d){pi||(pi=!0,qi=d)}}if(pi)throw a=qi,qi=null,pi=!1,a;}function Bi(a,b){W?x("253"):void 0;oi=a;Z=b;Di(a,b,!1);Yh(1073741823,!1)}
function Di(a,b,c){W?x("245"):void 0;W=!0;if(c){var d=a.finishedWork;null!==d?Fi(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,ze(d)),ci(a,c),d=a.finishedWork,null!==d&&(di()?a.finishedWork=d:Fi(a,d,b)))}else d=a.finishedWork,null!==d?Fi(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,ze(d)),ci(a,c),d=a.finishedWork,null!==d&&Fi(a,d,b));W=!1}
function Fi(a,b,c){var d=a.firstBatch;if(null!==d&&d._expirationTime>=c&&(null===si?si=[d]:si.push(d),d._defer)){a.finishedWork=b;a.expirationTime=0;return}a.finishedWork=null;a===wi?ii++:(wi=a,ii=0);r.unstable_runWithPriority(r.unstable_ImmediatePriority,function(){Zh(a,b)})}function Dh(a){null===oi?x("246"):void 0;oi.expirationTime=0;pi||(pi=!0,qi=a)}function Gi(a,b){var c=X;X=!0;try{return a(b)}finally{(X=c)||W||Yh(1073741823,!1)}}
function Hi(a,b){if(X&&!ri){ri=!0;try{return a(b)}finally{ri=!1}}return a(b)}function Ii(a,b,c){X||W||0===gi||(Yh(gi,!1),gi=0);var d=X;X=!0;try{return r.unstable_runWithPriority(r.unstable_UserBlockingPriority,function(){return a(b,c)})}finally{(X=d)||W||Yh(1073741823,!1)}}
function Ji(a,b,c,d,e){var f=b.current;a:if(c){c=c._reactInternalFiber;b:{2===ed(c)&&1===c.tag?void 0:x("170");var g=c;do{switch(g.tag){case 3:g=g.stateNode.context;break b;case 1:if(J(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break b}}g=g.return}while(null!==g);x("171");g=void 0}if(1===c.tag){var h=c.type;if(J(h)){c=Ne(c,h,g);break a}}c=g}else c=He;null===b.context?b.context=c:b.pendingContext=c;b=e;e=nf(d);e.payload={element:a};b=void 0===b?null:b;null!==b&&(e.callback=b);
of();pf(f,e);qf(f,d);return d}function Ki(a,b,c,d){var e=b.current,f=lf();e=mf(f,e);return Ji(a,b,c,e,d)}function Li(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Mi(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Wb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
Ab=function(a,b,c){switch(b){case "input":yc(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Ka(d);e?void 0:x("90");Sb(d);yc(d,e)}}}break;case "textarea":de(a,c);break;case "select":b=c.value,null!=b&&ae(a,!!c.multiple,b,!1)}};
function Ni(a){var b=1073741822-25*(((1073741822-lf()+500)/25|0)+1);b>=Jh&&(b=Jh-1);this._expirationTime=Jh=b;this._root=a;this._callbacks=this._next=null;this._hasChildren=this._didComplete=!1;this._children=null;this._defer=!0}Ni.prototype.render=function(a){this._defer?void 0:x("250");this._hasChildren=!0;this._children=a;var b=this._root._internalRoot,c=this._expirationTime,d=new Oi;Ji(a,b,null,c,d._onCommit);return d};
Ni.prototype.then=function(a){if(this._didComplete)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Ni.prototype.commit=function(){var a=this._root._internalRoot,b=a.firstBatch;this._defer&&null!==b?void 0:x("251");if(this._hasChildren){var c=this._expirationTime;if(b!==this){this._hasChildren&&(c=this._expirationTime=b._expirationTime,this.render(this._children));for(var d=null,e=b;e!==this;)d=e,e=e._next;null===d?x("251"):void 0;d._next=e._next;this._next=b;a.firstBatch=this}this._defer=!1;Bi(a,c);b=this._next;this._next=null;b=a.firstBatch=b;null!==b&&b._hasChildren&&b.render(b._children)}else this._next=
null,this._defer=!1};Ni.prototype._onComplete=function(){if(!this._didComplete){this._didComplete=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++)(0,a[b])()}};function Oi(){this._callbacks=null;this._didCommit=!1;this._onCommit=this._onCommit.bind(this)}Oi.prototype.then=function(a){if(this._didCommit)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a)}};
Oi.prototype._onCommit=function(){if(!this._didCommit){this._didCommit=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++){var c=a[b];"function"!==typeof c?x("191",c):void 0;c()}}};
function Pi(a,b,c){b=K(3,null,null,b?3:0);a={current:b,containerInfo:a,pendingChildren:null,pingCache:null,earliestPendingTime:0,latestPendingTime:0,earliestSuspendedTime:0,latestSuspendedTime:0,latestPingedTime:0,didError:!1,pendingCommitExpirationTime:0,finishedWork:null,timeoutHandle:-1,context:null,pendingContext:null,hydrate:c,nextExpirationTimeToWorkOn:0,expirationTime:0,firstBatch:null,nextScheduledRoot:null};this._internalRoot=b.stateNode=a}
Pi.prototype.render=function(a,b){var c=this._internalRoot,d=new Oi;b=void 0===b?null:b;null!==b&&d.then(b);Ki(a,c,null,d._onCommit);return d};Pi.prototype.unmount=function(a){var b=this._internalRoot,c=new Oi;a=void 0===a?null:a;null!==a&&c.then(a);Ki(null,b,null,c._onCommit);return c};Pi.prototype.legacy_renderSubtreeIntoContainer=function(a,b,c){var d=this._internalRoot,e=new Oi;c=void 0===c?null:c;null!==c&&e.then(c);Ki(b,d,a,e._onCommit);return e};
Pi.prototype.createBatch=function(){var a=new Ni(this),b=a._expirationTime,c=this._internalRoot,d=c.firstBatch;if(null===d)c.firstBatch=a,a._next=null;else{for(c=null;null!==d&&d._expirationTime>=b;)c=d,d=d._next;a._next=d;null!==c&&(c._next=a)}return a};function Qi(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}Gb=Gi;Hb=Ii;Ib=function(){W||0===gi||(Yh(gi,!1),gi=0)};
function Ri(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new Pi(a,!1,b)}
function Si(a,b,c,d,e){var f=c._reactRootContainer;if(f){if("function"===typeof e){var g=e;e=function(){var a=Li(f._internalRoot);g.call(a)}}null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)}else{f=c._reactRootContainer=Ri(c,d);if("function"===typeof e){var h=e;e=function(){var a=Li(f._internalRoot);h.call(a)}}Hi(function(){null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e)})}return Li(f._internalRoot)}
function Ti(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Qi(b)?void 0:x("200");return Mi(a,b,null,c)}
var Vi={createPortal:Ti,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;void 0===b&&("function"===typeof a.render?x("188"):x("268",Object.keys(a)));a=hd(b);a=null===a?null:a.stateNode;return a},hydrate:function(a,b,c){Qi(b)?void 0:x("200");return Si(null,a,b,!0,c)},render:function(a,b,c){Qi(b)?void 0:x("200");return Si(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){Qi(c)?void 0:x("200");null==a||void 0===a._reactInternalFiber?
x("38"):void 0;return Si(a,b,c,!1,d)},unmountComponentAtNode:function(a){Qi(a)?void 0:x("40");return a._reactRootContainer?(Hi(function(){Si(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:function(){return Ti.apply(void 0,arguments)},unstable_batchedUpdates:Gi,unstable_interactiveUpdates:Ii,flushSync:function(a,b){W?x("187"):void 0;var c=X;X=!0;try{return ki(a,b)}finally{X=c,Yh(1073741823,!1)}},unstable_createRoot:Ui,unstable_flushControlled:function(a){var b=
X;X=!0;try{ki(a)}finally{(X=b)||W||Yh(1073741823,!1)}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{Events:[Ia,Ja,Ka,Ba.injectEventPluginsByName,pa,Qa,function(a){ya(a,Pa)},Eb,Fb,Dd,Da]}};function Ui(a,b){Qi(a)?void 0:x("299","unstable_createRoot");return new Pi(a,!0,null!=b&&!0===b.hydrate)}
(function(a){var b=a.findFiberByHostInstance;return Te(n({},a,{overrideProps:null,currentDispatcherRef:Tb.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hd(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null}}))})({findFiberByHostInstance:Ha,bundleType:0,version:"16.8.6",rendererPackageName:"react-dom"});var Wi={default:Vi},Xi=Wi&&Vi||Wi;module.exports=Xi.default||Xi;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(28);
} else {}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** @license React v0.13.6
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

Object.defineProperty(exports,"__esModule",{value:!0});var d=null,e=!1,g=3,k=-1,l=-1,m=!1,n=!1;function p(){if(!m){var a=d.expirationTime;n?q():n=!0;r(t,a)}}
function u(){var a=d,b=d.next;if(d===b)d=null;else{var c=d.previous;d=c.next=b;b.previous=c}a.next=a.previous=null;c=a.callback;b=a.expirationTime;a=a.priorityLevel;var f=g,Q=l;g=a;l=b;try{var h=c()}finally{g=f,l=Q}if("function"===typeof h)if(h={callback:h,priorityLevel:a,expirationTime:b,next:null,previous:null},null===d)d=h.next=h.previous=h;else{c=null;a=d;do{if(a.expirationTime>=b){c=a;break}a=a.next}while(a!==d);null===c?c=d:c===d&&(d=h,p());b=c.previous;b.next=c.previous=h;h.next=c;h.previous=
b}}function v(){if(-1===k&&null!==d&&1===d.priorityLevel){m=!0;try{do u();while(null!==d&&1===d.priorityLevel)}finally{m=!1,null!==d?p():n=!1}}}function t(a){m=!0;var b=e;e=a;try{if(a)for(;null!==d;){var c=exports.unstable_now();if(d.expirationTime<=c){do u();while(null!==d&&d.expirationTime<=c)}else break}else if(null!==d){do u();while(null!==d&&!w())}}finally{m=!1,e=b,null!==d?p():n=!1,v()}}
var x=Date,y="function"===typeof setTimeout?setTimeout:void 0,z="function"===typeof clearTimeout?clearTimeout:void 0,A="function"===typeof requestAnimationFrame?requestAnimationFrame:void 0,B="function"===typeof cancelAnimationFrame?cancelAnimationFrame:void 0,C,D;function E(a){C=A(function(b){z(D);a(b)});D=y(function(){B(C);a(exports.unstable_now())},100)}
if("object"===typeof performance&&"function"===typeof performance.now){var F=performance;exports.unstable_now=function(){return F.now()}}else exports.unstable_now=function(){return x.now()};var r,q,w,G=null;"undefined"!==typeof window?G=window:"undefined"!==typeof global&&(G=global);
if(G&&G._schedMock){var H=G._schedMock;r=H[0];q=H[1];w=H[2];exports.unstable_now=H[3]}else if("undefined"===typeof window||"function"!==typeof MessageChannel){var I=null,J=function(a){if(null!==I)try{I(a)}finally{I=null}};r=function(a){null!==I?setTimeout(r,0,a):(I=a,setTimeout(J,0,!1))};q=function(){I=null};w=function(){return!1}}else{"undefined"!==typeof console&&("function"!==typeof A&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof B&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));var K=null,L=!1,M=-1,N=!1,O=!1,P=0,R=33,S=33;w=function(){return P<=exports.unstable_now()};var T=new MessageChannel,U=T.port2;T.port1.onmessage=function(){L=!1;var a=K,b=M;K=null;M=-1;var c=exports.unstable_now(),f=!1;if(0>=P-c)if(-1!==b&&b<=c)f=!0;else{N||(N=!0,E(V));K=a;M=b;return}if(null!==a){O=!0;try{a(f)}finally{O=!1}}};
var V=function(a){if(null!==K){E(V);var b=a-P+S;b<S&&R<S?(8>b&&(b=8),S=b<R?R:b):R=b;P=a+S;L||(L=!0,U.postMessage(void 0))}else N=!1};r=function(a,b){K=a;M=b;O||0>b?U.postMessage(void 0):N||(N=!0,E(V))};q=function(){K=null;L=!1;M=-1}}exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;
exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=g,f=k;g=a;k=exports.unstable_now();try{return b()}finally{g=c,k=f,v()}};exports.unstable_next=function(a){switch(g){case 1:case 2:case 3:var b=3;break;default:b=g}var c=g,f=k;g=b;k=exports.unstable_now();try{return a()}finally{g=c,k=f,v()}};
exports.unstable_scheduleCallback=function(a,b){var c=-1!==k?k:exports.unstable_now();if("object"===typeof b&&null!==b&&"number"===typeof b.timeout)b=c+b.timeout;else switch(g){case 1:b=c+-1;break;case 2:b=c+250;break;case 5:b=c+1073741823;break;case 4:b=c+1E4;break;default:b=c+5E3}a={callback:a,priorityLevel:g,expirationTime:b,next:null,previous:null};if(null===d)d=a.next=a.previous=a,p();else{c=null;var f=d;do{if(f.expirationTime>b){c=f;break}f=f.next}while(f!==d);null===c?c=d:c===d&&(d=a,p());
b=c.previous;b.next=c.previous=a;a.next=c;a.previous=b}return a};exports.unstable_cancelCallback=function(a){var b=a.next;if(null!==b){if(b===a)d=null;else{a===d&&(d=b);var c=a.previous;c.next=b;b.previous=c}a.next=a.previous=null}};exports.unstable_wrapCallback=function(a){var b=g;return function(){var c=g,f=k;g=b;k=exports.unstable_now();try{return a.apply(this,arguments)}finally{g=c,k=f,v()}}};exports.unstable_getCurrentPriorityLevel=function(){return g};
exports.unstable_shouldYield=function(){return!e&&(null!==d&&d.expirationTime<l||w())};exports.unstable_continueExecution=function(){null!==d&&p()};exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return d};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19)))

/***/ }),
/* 29 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * enigma.js v2.4.0
 * Copyright (c) 2018 QlikTech International AB
 * This library is licensed under MIT - See the LICENSE file for full details
 */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  /**
   * Utility functions
   */

  var util = {};

  util.isObject = function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  };

  util.isNumber = function isNumber(arg) {
    return typeof arg === 'number';
  };

  util.isUndefined = function isUndefined(arg) {
    return arg === void 0;
  };

  util.isFunction = function isFunction(arg){
    return typeof arg === 'function';
  };


  /**
   * EventEmitter class
   */

  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  var nodeEventEmitter = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!util.isNumber(n) || n < 0 || isNaN(n))
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };

  EventEmitter.prototype.emit = function(type) {
    var er, handler, len, args, i, listeners;

    if (!this._events)
      this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error' && !this._events.error) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw Error('Uncaught, unspecified "error" event.');
      }
      return false;
    }

    handler = this._events[type];

    if (util.isUndefined(handler))
      return false;

    if (util.isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (util.isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];

      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }

    return true;
  };

  EventEmitter.prototype.addListener = function(type, listener) {
    var m;

    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events)
      this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener)
      this.emit('newListener', type,
                util.isFunction(listener.listener) ?
                listener.listener : listener);

    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    else if (util.isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);
    else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (util.isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!util.isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;

        if (util.isFunction(console.error)) {
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
        }
        if (util.isFunction(console.trace))
          console.trace();
      }
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function(type, listener) {
    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    var fired = false;

    function g() {
      this.removeListener(type, g);

      if (!fired) {
        fired = true;
        listener.apply(this, arguments);
      }
    }

    g.listener = listener;
    this.on(type, g);

    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list, position, length, i;

    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events || !this._events[type])
      return this;

    list = this._events[type];
    length = list.length;
    position = -1;

    if (list === listener ||
        (util.isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);

    } else if (util.isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener ||
            (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }

      if (position < 0)
        return this;

      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }

      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function(type) {
    var key, listeners;

    if (!this._events)
      return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }

    listeners = this._events[type];

    if (util.isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else if (Array.isArray(listeners)) {
      // LIFO order
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];

    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (util.isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (util.isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };

  /**
  * @module EventEmitter
  * @private
  */

  var Events = {
    /**
    * Function used to add event handling to objects passed in.
    * @param {Object} obj Object instance that will get event handling.
    */
    mixin: function mixin(obj) {
      Object.keys(nodeEventEmitter.prototype).forEach(function (key) {
        obj[key] = nodeEventEmitter.prototype[key];
      });
      nodeEventEmitter.init(obj);
    }
  };

  var RPC_CLOSE_NORMAL = 1000;
  var RPC_CLOSE_MANUAL_SUSPEND = 4000;
  var cacheId = 0;
  /**
   * The QIX Engine session object
   */

  var Session =
  /*#__PURE__*/
  function () {
    /**
     * Handle opened state. This event is triggered whenever the websocket is connected and ready for
     * communication.
     * @event Session#opened
     * @type {Object}
     */

    /**
     * Handle closed state. This event is triggered when the underlying websocket is closed and
     * config.suspendOnClose is false.
     * @event Session#closed
     * @type {Object}
     */

    /**
     * Handle suspended state. This event is triggered in two cases (listed below). It is useful
     * in scenarios where you for example want to block interaction in your application until you
     * are resumed again. If config.suspendOnClose is true and there was a network disconnect
     * (socked closed) or if you ran session.suspend().
     * @event Session#suspended
     * @type {Object}
     * @param {Object} evt Event object.
     * @param {String} evt.initiator String indication what triggered the suspended state. Possible
     * values network, manual.
     */

    /**
     * Handle resumed state. This event is triggered when the session was properly resumed. It is
     * useful in scenarios where you for example can close blocking modal dialogs and allow the user
     * to interact with your application again.
     * @event Session#resumed
     * @type {Object}
     */

    /**
     * Handle all JSON-RPC notification event, 'notification:*. Or handle a specific JSON-RPC
     * notification event, 'notification:OnConnected'. These events depend on the product you use QIX
     * Engine from.
     * @event Session#notification
     * @type {Object}
     */

    /**
    * Handle websocket messages. Generally used in debugging purposes. traffic:* will handle all
    * websocket messages, traffic:sent will handle outgoing messages and traffic:received will handle
    * incoming messages.
    * @event Session#traffic
    * @type {Object}
    */
    function Session(options) {
      _classCallCheck(this, Session);

      var session = this;
      Object.assign(session, options);
      this.Promise = this.config.Promise;
      this.definition = this.config.definition;
      Events.mixin(session);
      cacheId += 1;
      session.id = cacheId;
      session.rpc.on('socket-error', session.onRpcError.bind(session));
      session.rpc.on('closed', session.onRpcClosed.bind(session));
      session.rpc.on('message', session.onRpcMessage.bind(session));
      session.rpc.on('notification', session.onRpcNotification.bind(session));
      session.rpc.on('traffic', session.onRpcTraffic.bind(session));
      session.on('closed', function () {
        return session.onSessionClosed();
      });
    }
    /**
    * Event handler for re-triggering error events from RPC.
    * @private
    * @emits socket-error
    * @param {Error} err Webocket error event.
    */


    _createClass(Session, [{
      key: "onRpcError",
      value: function onRpcError(err) {
        if (this.suspendResume.isSuspended) {
          return;
        }

        this.emit('socket-error', err);
      }
      /**
      * Event handler for the RPC close event.
      * @private
      * @emits Session#suspended
      * @emits Session#closed
      * @param {Event} evt WebSocket close event.
      */

    }, {
      key: "onRpcClosed",
      value: function onRpcClosed(evt) {
        var _this = this;

        if (this.suspendResume.isSuspended) {
          return;
        }

        if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND) {
          return;
        }

        if (this.config.suspendOnClose) {
          this.suspendResume.suspend().then(function () {
            return _this.emit('suspended', {
              initiator: 'network'
            });
          });
        } else {
          this.emit('closed', evt);
        }
      }
      /**
      * Event handler for the RPC message event.
      * @private
      * @param {Object} response JSONRPC response.
      */

    }, {
      key: "onRpcMessage",
      value: function onRpcMessage(response) {
        var _this2 = this;

        if (this.suspendResume.isSuspended) {
          return;
        }

        if (response.change) {
          response.change.forEach(function (handle) {
            return _this2.emitHandleChanged(handle);
          });
        }

        if (response.close) {
          response.close.forEach(function (handle) {
            return _this2.emitHandleClosed(handle);
          });
        }
      }
      /**
      * Event handler for the RPC notification event.
      * @private
      * @emits Session#notification
      * @param {Object} response The JSONRPC notification.
      */

    }, {
      key: "onRpcNotification",
      value: function onRpcNotification(response) {
        this.emit('notification:*', response.method, response.params);
        this.emit("notification:".concat(response.method), response.params);
      }
      /**
      * Event handler for the RPC traffic event.
      * @private
      * @emits Session#traffic
      * @param {String} dir The traffic direction, sent or received.
      * @param {Object} data JSONRPC request/response/WebSocket message.
      * @param {Number} handle The associated handle.
      */

    }, {
      key: "onRpcTraffic",
      value: function onRpcTraffic(dir, data, handle) {
        this.emit('traffic:*', dir, data);
        this.emit("traffic:".concat(dir), data);
        var api = this.apis.getApi(handle);

        if (api) {
          api.emit('traffic:*', dir, data);
          api.emit("traffic:".concat(dir), data);
        }
      }
      /**
      * Event handler for cleaning up API instances when a session has been closed.
      * @private
      * @emits API#closed
      */

    }, {
      key: "onSessionClosed",
      value: function onSessionClosed() {
        this.apis.getApis().forEach(function (entry) {
          entry.api.emit('closed');
          entry.api.removeAllListeners();
        });
        this.apis.clear();
      }
      /**
       * Function used to get an API for a backend object.
       * @private
       * @param {Object} args Arguments used to create object API.
       * @param {Number} args.handle Handle of the backend object.
       * @param {String} args.id ID of the backend object.
       * @param {String} args.type QIX type of the backend object. Can for example
       *                           be "Doc" or "GenericVariable".
       * @param {String} args.genericType Custom type of the backend object, if defined in qInfo.
       * @returns {*} Returns the generated and possibly augmented API.
       */

    }, {
      key: "getObjectApi",
      value: function getObjectApi(args) {
        var handle = args.handle,
            id = args.id,
            type = args.type,
            genericType = args.genericType;
        var api = this.apis.getApi(handle);

        if (api) {
          return api;
        }

        var factory = this.definition.generate(type);
        api = factory(this, handle, id, genericType);
        this.apis.add(handle, api);
        return api;
      }
      /**
      * Establishes the websocket against the configured URL and returns the Global instance.
      * @emits Session#opened
      * @returns {Promise<Object>} Eventually resolved if the connection was successful.
      */

    }, {
      key: "open",
      value: function open() {
        var _this3 = this;

        if (!this.globalPromise) {
          var args = {
            handle: -1,
            id: 'Global',
            type: 'Global',
            genericType: 'Global'
          };
          this.globalPromise = this.rpc.open().then(function () {
            return _this3.getObjectApi(args);
          }).then(function (global) {
            _this3.emit('opened');

            return global;
          });
        }

        return this.globalPromise;
      }
      /**
      * Function used to send data on the RPC socket.
      * @param {Object} request The request to be sent. (data and some meta info)
      * @returns {Object} Returns a promise instance.
      */

    }, {
      key: "send",
      value: function send(request) {
        var _this4 = this;

        if (this.suspendResume.isSuspended) {
          return this.Promise.reject(new Error('Session suspended'));
        }

        request.id = this.rpc.createRequestId();
        var promise = this.intercept.executeRequests(this, this.Promise.resolve(request)).then(function (augmentedRequest) {
          var data = Object.assign({}, _this4.config.protocol, augmentedRequest); // the outKey value is used by multiple-out interceptor, at some point
          // we need to refactor that implementation and figure out how to transport
          // this value without hijacking the JSONRPC request object:

          delete data.outKey;

          var response = _this4.rpc.send(data);

          augmentedRequest.retry = function () {
            return _this4.send(request);
          };

          return _this4.intercept.executeResponses(_this4, response, augmentedRequest);
        });
        Session.addToPromiseChain(promise, 'requestId', request.id);
        return promise;
      }
      /**
      * Suspends the enigma.js session by closing the websocket and rejecting all method calls
      * until is has been resumed again.
      * @emits Session#suspended
      * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.
      */

    }, {
      key: "suspend",
      value: function suspend() {
        var _this5 = this;

        return this.suspendResume.suspend().then(function () {
          return _this5.emit('suspended', {
            initiator: 'manual'
          });
        });
      }
      /**
      * Resumes a previously suspended enigma.js session by re-creating the websocket and,
      * if possible, re-open the document as well as refreshing the internal cashes. If successful,
      * changed events will be triggered on all generated APIs, and on the ones it was unable to
      * restore, the closed event will be triggered.
      * @emits Session#resumed
      * @param {Boolean} onlyIfAttached If true, resume only if the session was re-attached properly.
      * @returns {Promise<Object>} Eventually resolved when the websocket (and potentially the
      * previously opened document, and generated APIs) has been restored, rejected when it fails any
      * of those steps, or when onlyIfAttached is true and a new session was created.
      */

    }, {
      key: "resume",
      value: function resume(onlyIfAttached) {
        var _this6 = this;

        return this.suspendResume.resume(onlyIfAttached).then(function (value) {
          _this6.emit('resumed');

          return value;
        });
      }
      /**
      * Closes the websocket and cleans up internal caches, also triggers the closed event
      * on all generated APIs. Note that you have to manually invoke this when you want to
      * close a session and config.suspendOnClose is true.
      * @emits Session#closed
      * @returns {Promise<Object>} Eventually resolved when the websocket has been closed.
      */

    }, {
      key: "close",
      value: function close() {
        var _this7 = this;

        this.globalPromise = undefined;
        return this.rpc.close().then(function (evt) {
          return _this7.emit('closed', evt);
        });
      }
      /**
      * Given a handle, this function will emit the 'changed' event on the
      * corresponding API instance.
      * @private
      * @param {Number} handle The handle of the API instance.
      * @emits API#changed
      */

    }, {
      key: "emitHandleChanged",
      value: function emitHandleChanged(handle) {
        var api = this.apis.getApi(handle);

        if (api) {
          api.emit('changed');
        }
      }
      /**
      * Given a handle, this function will emit the 'closed' event on the
      * corresponding API instance.
      * @private
      * @param {Number} handle The handle of the API instance.
      * @emits API#closed
      */

    }, {
      key: "emitHandleClosed",
      value: function emitHandleClosed(handle) {
        var api = this.apis.getApi(handle);

        if (api) {
          api.emit('closed');
          api.removeAllListeners();
        }
      }
      /**
      * Function used to add info on the promise chain.
      * @private
      * @param {Promise<Object>} promise The promise to add info on.
      * @param {String} name The property to add info on.
      * @param {Any} value The info to add.
      */

    }], [{
      key: "addToPromiseChain",
      value: function addToPromiseChain(promise, name, value) {
        promise[name] = value;
        var then = promise.then;

        promise.then = function patchedThen() {
          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
            params[_key] = arguments[_key];
          }

          var chain = then.apply(this, params);
          Session.addToPromiseChain(chain, name, value);
          return chain;
        };
      }
    }]);

    return Session;
  }();

  /**
  * Key-value cache
  * @private
  */
  var KeyValueCache =
  /*#__PURE__*/
  function () {
    function KeyValueCache() {
      _classCallCheck(this, KeyValueCache);

      this.entries = {};
    }
    /**
    * Adds an entry.
    * @private
    * @function KeyValueCache#add
    * @param {String} key The key representing an entry.
    * @param {*} entry The entry to be added.
    */


    _createClass(KeyValueCache, [{
      key: "add",
      value: function add(key, entry) {
        key += '';

        if (typeof this.entries[key] !== 'undefined') {
          throw new Error("Entry already defined with key ".concat(key));
        }

        this.entries[key] = entry;
      }
      /**
      * Sets an entry.
      * @private
      * @function KeyValueCache#set
      * @param {String} key The key representing an entry.
      * @param {*} entry The entry.
      */

    }, {
      key: "set",
      value: function set(key, entry) {
        key += '';
        this.entries[key] = entry;
      }
      /**
      * Removes an entry.
      * @private
      * @function KeyValueCache#remove
      * @param {String} key The key representing an entry.
      */

    }, {
      key: "remove",
      value: function remove(key) {
        delete this.entries[key];
      }
      /**
      * Gets an entry.
      * @private
      * @function KeyValueCache#get
      * @param {String} key The key representing an entry.
      * @returns {*} The entry for the key.
      */

    }, {
      key: "get",
      value: function get(key) {
        return this.entries[key];
      }
      /**
      * Gets a list of all entries.
      * @private
      * @function KeyValueCache#getAll
      * @returns {Array} The list of entries including its `key` and `value` properties.
      */

    }, {
      key: "getAll",
      value: function getAll() {
        var _this = this;

        return Object.keys(this.entries).map(function (key) {
          return {
            key: key,
            value: _this.entries[key]
          };
        });
      }
      /**
      * Gets a key for an entry.
      * @private
      * @function KeyValueCache#getKey
      * @param {*} entry The entry to locate the key for.
      * @returns {String} The key representing an entry.
      */

    }, {
      key: "getKey",
      value: function getKey(entry) {
        var _this2 = this;

        return Object.keys(this.entries).filter(function (key) {
          return _this2.entries[key] === entry;
        })[0];
      }
      /**
      * Clears the cache of all entries.
      * @private
      * @function KeyValueCache#clear
      */

    }, {
      key: "clear",
      value: function clear() {
        this.entries = {};
      }
    }]);

    return KeyValueCache;
  }();

  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  /**
  * Returns the camelCase counterpart of a symbol.
  * @private
  * @param {String} symbol The symbol.
  * @return the camelCase counterpart.
  */

  function toCamelCase(symbol) {
    return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);
  }
  /**
   * A facade function that allows parameters to be passed either by name
   * (through an object), or by position (through an array).
   * @private
   * @param {Function} base The function that is being overriden. Will be
   *                        called with parameters in array-form.
   * @param {Object} defaults Parameter list and it's default values.
   * @param {*} params The parameters.
   */


  function namedParamFacade(base, defaults) {
    for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      params[_key - 2] = arguments[_key];
    }

    if (params.length === 1 && _typeof(params[0]) === 'object' && !Array.isArray(params[0])) {
      var valid = Object.keys(params[0]).every(function (key) {
        return hasOwnProperty$1.call(defaults, key);
      });

      if (valid) {
        params = Object.keys(defaults).map(function (key) {
          return params[0][key] || defaults[key];
        });
      }
    }

    return base.apply(this, params);
  }
  /**
  * Qix schema definition.
  * @private
  */


  var Schema =
  /*#__PURE__*/
  function () {
    /**
    * Create a new schema instance.
    * @private
    * @param {Configuration} config The configuration for QIX.
    */
    function Schema(config) {
      _classCallCheck(this, Schema);

      this.config = config;
      this.Promise = config.Promise;
      this.schema = config.schema;
      this.mixins = new KeyValueCache();
      this.types = new KeyValueCache();
    }

    _createClass(Schema, [{
      key: "registerMixin",
      value: function registerMixin(_ref) {
        var _this = this;

        var types = _ref.types,
            type = _ref.type,
            extend = _ref.extend,
            override = _ref.override,
            init = _ref.init;

        if (!Array.isArray(types)) {
          types = [types];
        } // to support a single type


        if (type) {
          types.push(type);
        }

        var cached = {
          extend: extend,
          override: override,
          init: init
        };
        types.forEach(function (typeKey) {
          var entryList = _this.mixins.get(typeKey);

          if (entryList) {
            entryList.push(cached);
          } else {
            _this.mixins.add(typeKey, [cached]);
          }
        });
      }
      /**
      * Function used to generate a type definition.
      * @private
      * @param {String} type The type.
      * @returns {{create: Function, def: Object}} Returns an object with a definition
      *          of the type and a create factory.
      */

    }, {
      key: "generate",
      value: function generate(type) {
        var entry = this.types.get(type);

        if (entry) {
          return entry;
        }

        if (!this.schema.structs[type]) {
          throw new Error("".concat(type, " not found"));
        }

        var factory = this.generateApi(type, this.schema.structs[type]);
        this.types.add(type, factory);
        return factory;
      }
      /**
      * Function used to generate an API definition for a given type.
      * @private
      * @param {String} type The type to generate.
      * @param {Object} schema The schema describing the type.
      * @returns {{create: (function(session:Object, handle:Number, id:String,
      *          customKey:String)), def: Object}} Returns the API definition.
      */

    }, {
      key: "generateApi",
      value: function generateApi(type, schema) {
        var api = Object.create({});
        this.generateDefaultApi(api, schema); // Generate default

        this.mixinType(type, api); // Mixin default type

        this.mixinNamedParamFacade(api, schema); // Mixin named parameter support

        return function create(session, handle, id, customKey) {
          var _this2 = this;

          var instance = Object.create(api);
          Events.mixin(instance); // Always mixin event-emitter per instance

          Object.defineProperties(instance, {
            session: {
              enumerable: true,
              value: session
            },
            handle: {
              enumerable: true,
              value: handle,
              writable: true
            },
            id: {
              enumerable: true,
              value: id
            },
            type: {
              enumerable: true,
              value: type
            },
            genericType: {
              enumerable: true,
              value: customKey
            }
          });
          var mixinList = this.mixins.get(type) || [];

          if (customKey !== type) {
            this.mixinType(customKey, instance); // Mixin custom types

            mixinList = mixinList.concat(this.mixins.get(customKey) || []);
          }

          mixinList.forEach(function (mixin) {
            if (typeof mixin.init === 'function') {
              mixin.init({
                config: _this2.config,
                api: instance
              });
            }
          });
          return instance;
        }.bind(this);
      }
      /**
      * Function used to generate the methods with the right handlers to the object
      * API that is being generated.
      * @private
      * @param {Object} api The object API that is currently being generated.
      * @param {Object} schema The API definition.
      */

    }, {
      key: "generateDefaultApi",
      value: function generateDefaultApi(api, schema) {
        Object.keys(schema).forEach(function (method) {
          var out = schema[method].Out;
          var outKey = out.length === 1 ? out[0].Name : -1;
          var fnName = toCamelCase(method);

          api[fnName] = function generatedMethod() {
            for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              params[_key2] = arguments[_key2];
            }

            return this.session.send({
              handle: this.handle,
              method: method,
              params: params,
              outKey: outKey
            });
          };
        });
      }
      /**
      * Function used to add mixin methods to a specified API.
      * @private
      * @param {String} type Used to specify which mixin should be woven in.
      * @param {Object} api The object that will be woven.
      */

    }, {
      key: "mixinType",
      value: function mixinType(type, api) {
        var mixinList = this.mixins.get(type);

        if (mixinList) {
          mixinList.forEach(function (_ref2) {
            var _ref2$extend = _ref2.extend,
                extend = _ref2$extend === void 0 ? {} : _ref2$extend,
                _ref2$override = _ref2.override,
                override = _ref2$override === void 0 ? {} : _ref2$override;
            Object.keys(override).forEach(function (key) {
              if (typeof api[key] === 'function' && typeof override[key] === 'function') {
                var baseFn = api[key];

                api[key] = function wrappedFn() {
                  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                    args[_key3] = arguments[_key3];
                  }

                  return override[key].apply(this, [baseFn.bind(this)].concat(args));
                };
              } else {
                throw new Error("No function to override. Type: ".concat(type, " function: ").concat(key));
              }
            });
            Object.keys(extend).forEach(function (key) {
              // handle overrides
              if (typeof api[key] === 'function' && typeof extend[key] === 'function') {
                throw new Error("Extend is not allowed for this mixin. Type: ".concat(type, " function: ").concat(key));
              } else {
                api[key] = extend[key];
              }
            });
          });
        }
      }
      /**
      * Function used to mixin the named parameter facade.
      * @private
      * @param {Object} api The object API that is currently being generated.
      * @param {Object} schema The API definition.
      */

    }, {
      key: "mixinNamedParamFacade",
      value: function mixinNamedParamFacade(api, schema) {
        Object.keys(schema).forEach(function (key) {
          var fnName = toCamelCase(key);
          var base = api[fnName];
          var defaults = schema[key].In.reduce(function (result, item) {
            result[item.Name] = item.DefaultValue;
            return result;
          }, {});

          api[fnName] = function namedParamWrapper() {
            for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              params[_key4] = arguments[_key4];
            }

            return namedParamFacade.apply(this, [base, defaults].concat(params));
          };
        });
      }
    }]);

    return Schema;
  }();

  /**
   * Helper class for handling RPC calls
   * @private
   */

  var RPCResolver =
  /*#__PURE__*/
  function () {
    function RPCResolver(id, handle, resolve, reject) {
      _classCallCheck(this, RPCResolver);

      Events.mixin(this);
      this.id = id;
      this.handle = handle;
      this.resolve = resolve;
      this.reject = reject;
    }

    _createClass(RPCResolver, [{
      key: "resolveWith",
      value: function resolveWith(data) {
        this.resolve(data);
        this.emit('resolved', this.id);
      }
    }, {
      key: "rejectWith",
      value: function rejectWith(err) {
        this.reject(err);
        this.emit('rejected', this.id);
      }
    }]);

    return RPCResolver;
  }();

  /**
  * This class handles remote procedure calls on a web socket.
  * @private
  */

  var RPC =
  /*#__PURE__*/
  function () {
    /**
    * Create a new RPC instance.
    * @private
    * @param {Object} options The configuration options for this class.
    * @param {Function} options.Promise The promise constructor to use.
    * @param {String} options.url The complete websocket URL used to connect.
    * @param {Function} options.createSocket The function callback to create a WebSocket.
    */
    function RPC(options) {
      _classCallCheck(this, RPC);

      Object.assign(this, options);
      Events.mixin(this);
      this.resolvers = {};
      this.requestId = 0;
      this.openedPromise = undefined;
    }
    /**
    * Opens a connection to the configured endpoint.
    * @private
    * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.
    * @returns {Object} A promise instance.
    */


    _createClass(RPC, [{
      key: "open",
      value: function open() {
        var _this = this;

        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!force && this.openedPromise) {
          return this.openedPromise;
        }

        try {
          this.socket = this.createSocket(this.url);
        } catch (err) {
          return this.Promise.reject(err);
        }

        this.socket.onopen = this.onOpen.bind(this);
        this.socket.onclose = this.onClose.bind(this);
        this.socket.onerror = this.onError.bind(this);
        this.socket.onmessage = this.onMessage.bind(this);
        this.openedPromise = new this.Promise(function (resolve, reject) {
          return _this.registerResolver('opened', null, resolve, reject);
        });
        this.closedPromise = new this.Promise(function (resolve, reject) {
          return _this.registerResolver('closed', null, resolve, reject);
        });
        return this.openedPromise;
      }
      /**
      * Resolves the open promise when a connection is successfully established.
      * @private
      */

    }, {
      key: "onOpen",
      value: function onOpen() {
        var _this2 = this;

        this.resolvers.opened.resolveWith(function () {
          return _this2.closedPromise;
        });
      }
      /**
      * Resolves the close promise when a connection is closed.
      * @private
      * @param {Object} event - The event describing close.
      */

    }, {
      key: "onClose",
      value: function onClose(event) {
        this.emit('closed', event);
        this.resolvers.closed.resolveWith(event);
        this.rejectAllOutstandingResolvers({
          code: -1,
          message: 'Socket closed'
        });
      }
      /**
      * Closes a connection.
      * @private
      * @param {Number} [code=1000] - The reason code for closing the connection.
      * @param {String} [reason=""] - The human readable string describing why the connection is closed.
      * @returns {Object} Returns a promise instance.
      */

    }, {
      key: "close",
      value: function close() {
        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        if (this.socket) {
          this.socket.close(code, reason);
          this.socket = null;
        }

        return this.closedPromise;
      }
      /**
      * Emits an error event and rejects the open promise if an error is raised on the connection.
      * @private
      * @param {Object} event - The event describing the error.
      */

    }, {
      key: "onError",
      value: function onError(event) {
        if (this.resolvers.opened) {
          this.resolvers.opened.rejectWith(event);
        } else {
          // only emit errors after the initial open promise has been resolved,
          // this makes it possible to catch early websocket errors as well
          // as run-time ones:
          this.emit('socket-error', event);
        }

        this.rejectAllOutstandingResolvers({
          code: -1,
          message: 'Socket error'
        });
      }
      /**
      * Parses the onMessage event on the connection and resolve the promise for the request.
      * @private
      * @param {Object} event - The event describing the message.
      */

    }, {
      key: "onMessage",
      value: function onMessage(event) {
        var data = JSON.parse(event.data);
        var resolver = this.resolvers[data.id] || {};
        this.emit('traffic', 'received', data, resolver.handle);

        if (typeof data.id !== 'undefined') {
          this.emit('message', data);
          this.resolvers[data.id].resolveWith(data);
        } else {
          this.emit(data.params ? 'notification' : 'message', data);
        }
      }
      /**
      * Rejects all outstanding resolvers.
      * @private
      * @param {Object} reason - The reject reason.
      */

    }, {
      key: "rejectAllOutstandingResolvers",
      value: function rejectAllOutstandingResolvers(reason) {
        var _this3 = this;

        Object.keys(this.resolvers).forEach(function (id) {
          if (id === 'opened' || id === 'closed') {
            return; // "opened" and "closed" should not be handled here
          }

          var resolver = _this3.resolvers[id];
          resolver.rejectWith(reason);
        });
      }
      /**
      * Unregisters a resolver.
      * @private
      * @param {Number|String} id - The ID to unregister the resolver with.
      */

    }, {
      key: "unregisterResolver",
      value: function unregisterResolver(id) {
        var resolver = this.resolvers[id];
        resolver.removeAllListeners();
        delete this.resolvers[id];
      }
      /**
      * Registers a resolver.
      * @private
      * @param {Number|String} id - The ID to register the resolver with.
      * @param {Number} handle - The associated handle.
      * @returns {Function} The promise executor function.
      */

    }, {
      key: "registerResolver",
      value: function registerResolver(id, handle, resolve, reject) {
        var _this4 = this;

        var resolver = new RPCResolver(id, handle, resolve, reject);
        this.resolvers[id] = resolver;
        resolver.on('resolved', function (resolvedId) {
          return _this4.unregisterResolver(resolvedId);
        });
        resolver.on('rejected', function (rejectedId) {
          return _this4.unregisterResolver(rejectedId);
        });
      }
      /**
      * Sends data on the socket.
      * @private
      * @param {Object} data - The data to send.
      * @returns {Object} A promise instance.
      */

    }, {
      key: "send",
      value: function send(data) {
        var _this5 = this;

        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {
          var error = new Error('Not connected');
          error.code = -1;
          return this.Promise.reject(error);
        }

        if (!data.id) {
          data.id = this.createRequestId();
        }

        data.jsonrpc = '2.0';
        return new this.Promise(function (resolve, reject) {
          _this5.socket.send(JSON.stringify(data));

          _this5.emit('traffic', 'sent', data, data.handle);

          return _this5.registerResolver(data.id, data.handle, resolve, reject);
        });
      }
    }, {
      key: "createRequestId",
      value: function createRequestId() {
        this.requestId += 1;
        return this.requestId;
      }
    }]);

    return RPC;
  }();

  var ON_ATTACHED_TIMEOUT_MS = 5000;
  var RPC_CLOSE_MANUAL_SUSPEND$1 = 4000;

  var SuspendResume =
  /*#__PURE__*/
  function () {
    /**
    * Creates a new SuspendResume instance.
    * @private
    * @param {Object} options The configuration option for this class.
    * @param {Promise<Object>} options.Promise The promise constructor to use.
    * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.
    * @param {ApiCache} options.apis The ApiCache instance to use.
    */
    function SuspendResume(options) {
      var _this = this;

      _classCallCheck(this, SuspendResume);

      Object.assign(this, options);
      this.isSuspended = false;
      this.rpc.on('traffic', function (dir, data) {
        if (dir === 'sent' && data.method === 'OpenDoc') {
          _this.openDocParams = data.params;
        }
      });
    }
    /**
    * Function used to restore the rpc connection.
    * @private
    * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve
    *                                   only if the session can be re-attached.
    * @returns {Object} Returns a promise instance.
    */


    _createClass(SuspendResume, [{
      key: "restoreRpcConnection",
      value: function restoreRpcConnection(onlyIfAttached) {
        var _this2 = this;

        return this.reopen(ON_ATTACHED_TIMEOUT_MS).then(function (sessionState) {
          if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {
            return _this2.Promise.reject(new Error('Not attached'));
          }

          return _this2.Promise.resolve();
        });
      }
      /**
      * Function used to restore the global API.
      * @private
      * @param {Object} changed - A list where the restored APIs will be added.
      * @returns {Object} Returns a promise instance.
      */

    }, {
      key: "restoreGlobal",
      value: function restoreGlobal(changed) {
        var global = this.apis.getApisByType('Global').pop();
        changed.push(global.api);
        return this.Promise.resolve();
      }
      /**
      * Function used to restore the doc API.
      * @private
      * @param {String} sessionState - The state of the session, attached or created.
      * @param {Array} closed - A list where the closed of APIs APIs will be added.
      * @param {Object} changed - A list where the restored APIs will be added.
      * @returns {Object} Returns a promise instance.
      */

    }, {
      key: "restoreDoc",
      value: function restoreDoc(closed, changed) {
        var _this3 = this;

        var doc = this.apis.getApisByType('Doc').pop();

        if (!doc) {
          return this.Promise.resolve();
        }

        return this.rpc.send({
          method: 'GetActiveDoc',
          handle: -1,
          params: []
        }).then(function (response) {
          if (response.error && _this3.openDocParams) {
            return _this3.rpc.send({
              method: 'OpenDoc',
              handle: -1,
              params: _this3.openDocParams
            });
          }

          return response;
        }).then(function (response) {
          if (response.error) {
            closed.push(doc.api);
            return _this3.Promise.resolve();
          }

          var handle = response.result.qReturn.qHandle;
          doc.api.handle = handle;
          changed.push(doc.api);
          return _this3.Promise.resolve(doc.api);
        });
      }
      /**
      * Function used to restore the APIs on the doc.
      * @private
      * @param {Object} doc - The doc API on which the APIs we want to restore exist.
      * @param {Array} closed - A list where the closed of APIs APIs will be added.
      * @param {Object} changed - A list where the restored APIs will be added.
      * @returns {Object} Returns a promise instance.
      */

    }, {
      key: "restoreDocObjects",
      value: function restoreDocObjects(doc, closed, changed) {
        var _this4 = this;

        var tasks = [];
        var apis = this.apis.getApis().map(function (entry) {
          return entry.api;
        }).filter(function (api) {
          return api.type !== 'Global' && api.type !== 'Doc';
        });

        if (!doc) {
          apis.forEach(function (api) {
            return closed.push(api);
          });
          return this.Promise.resolve();
        }

        apis.forEach(function (api) {
          var method = SuspendResume.buildGetMethodName(api.type);

          if (!method) {
            closed.push(api);
          } else {
            var request = _this4.rpc.send({
              method: method,
              handle: doc.handle,
              params: [api.id]
            }).then(function (response) {
              if (response.error || !response.result.qReturn.qHandle) {
                closed.push(api);
              } else {
                api.handle = response.result.qReturn.qHandle;
                changed.push(api);
              }
            });

            tasks.push(request);
          }
        });
        return this.Promise.all(tasks);
      }
      /**
      * Set the instance as suspended.
      * @private
      */

    }, {
      key: "suspend",
      value: function suspend() {
        this.isSuspended = true;
        return this.rpc.close(RPC_CLOSE_MANUAL_SUSPEND$1);
      }
      /**
      * Resumes a previously suspended RPC connection, and refreshes the API cache.
      *                                APIs unabled to be restored has their 'closed'
      *                                event triggered, otherwise 'changed'.
      * @private
      * @emits API#changed
      * @emits APIfunction@#closed
      * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.
      * @returns {Promise<Object>} Eventually resolved if the RPC connection was successfully resumed,
      *                    otherwise rejected.
      */

    }, {
      key: "resume",
      value: function resume(onlyIfAttached) {
        var _this5 = this;

        var changed = [];
        var closed = [];
        return this.restoreRpcConnection(onlyIfAttached).then(function () {
          return _this5.restoreGlobal(changed);
        }).then(function () {
          return _this5.restoreDoc(closed, changed);
        }).then(function (doc) {
          return _this5.restoreDocObjects(doc, closed, changed);
        }).then(function () {
          _this5.isSuspended = false;

          _this5.apis.clear();

          closed.forEach(function (api) {
            api.emit('closed');
            api.removeAllListeners();
          });
          changed.forEach(function (api) {
            _this5.apis.add(api.handle, api);

            if (api.type !== 'Global') {
              api.emit('changed');
            }
          });
        }).catch(function (err) {
          return _this5.rpc.close().then(function () {
            return _this5.Promise.reject(err);
          });
        });
      }
      /**
      * Reopens the connection and waits for the OnConnected notification.
      * @private
      * @param {Number} timeout - The time to wait for the OnConnected notification.
      * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).
      */

    }, {
      key: "reopen",
      value: function reopen(timeout) {
        var _this6 = this;

        var timer;
        var notificationResolve;
        var notificationReceived = false;
        var notificationPromise = new this.Promise(function (resolve) {
          notificationResolve = resolve;
        });

        var waitForNotification = function waitForNotification() {
          if (!notificationReceived) {
            timer = setTimeout(function () {
              return notificationResolve('SESSION_CREATED');
            }, timeout);
          }

          return notificationPromise;
        };

        var onNotification = function onNotification(data) {
          if (data.method !== 'OnConnected') return;
          clearTimeout(timer);
          notificationResolve(data.params.qSessionState);
          notificationReceived = true;
        };

        this.rpc.on('notification', onNotification);
        return this.rpc.open(true).then(waitForNotification).then(function (state) {
          _this6.rpc.removeListener('notification', onNotification);

          return state;
        }).catch(function (err) {
          _this6.rpc.removeListener('notification', onNotification);

          return _this6.Promise.reject(err);
        });
      }
      /**
      * Function used to build the get method names for Doc APIs.
      * @private
      * @param {String} type - The API type.
      * @returns {String} Returns the get method name, or undefined if the type cannot be restored.
      */

    }], [{
      key: "buildGetMethodName",
      value: function buildGetMethodName(type) {
        if (type === 'Field' || type === 'Variable') {
          return null;
        }

        if (type === 'GenericVariable') {
          return 'GetVariableById';
        }

        return type.replace('Generic', 'Get');
      }
    }]);

    return SuspendResume;
  }();

  var SUCCESS_KEY = 'qSuccess';
  function deltaRequestInterceptor(session, request) {
    var delta = session.config.protocol.delta && request.outKey !== -1 && request.outKey !== SUCCESS_KEY;

    if (delta) {
      request.delta = delta;
    }

    return request;
  }

  /**
  * Response interceptor for generating APIs. Handles the quirks of engine not
  * returning an error when an object is missing.
  * @private
  * @param {Session} session - The session the intercept is being executed on.
  * @param {Object} request - The JSON-RPC request.
  * @param {Object} response - The response.
  * @returns {Object} - Returns the generated API
  */
  function apiInterceptor(session, request, response) {
    if (response.qHandle && response.qType) {
      return session.getObjectApi({
        handle: response.qHandle,
        type: response.qType,
        id: response.qGenericId,
        genericType: response.qGenericType
      });
    }

    if (response.qHandle === null && response.qType === null) {
      return session.config.Promise.reject(new Error('Object not found'));
    }

    return response;
  }

  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;

  var isArray = function isArray(arr) {
  	if (typeof Array.isArray === 'function') {
  		return Array.isArray(arr);
  	}

  	return toStr.call(arr) === '[object Array]';
  };

  var isPlainObject = function isPlainObject(obj) {
  	if (!obj || toStr.call(obj) !== '[object Object]') {
  		return false;
  	}

  	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
  	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  	// Not own constructor property must be Object
  	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
  		return false;
  	}

  	// Own properties are enumerated firstly, so to speed up,
  	// if last one is own, then all properties are own.
  	var key;
  	for (key in obj) { /**/ }

  	return typeof key === 'undefined' || hasOwn.call(obj, key);
  };

  // If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
  var setProperty = function setProperty(target, options) {
  	if (defineProperty && options.name === '__proto__') {
  		defineProperty(target, options.name, {
  			enumerable: true,
  			configurable: true,
  			value: options.newValue,
  			writable: true
  		});
  	} else {
  		target[options.name] = options.newValue;
  	}
  };

  // Return undefined instead of __proto__ if '__proto__' is not an own property
  var getProperty = function getProperty(obj, name) {
  	if (name === '__proto__') {
  		if (!hasOwn.call(obj, name)) {
  			return void 0;
  		} else if (gOPD) {
  			// In early versions of node, obj['__proto__'] is buggy when obj has
  			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
  			return gOPD(obj, name).value;
  		}
  	}

  	return obj[name];
  };

  var extend = function extend() {
  	var options, name, src, copy, copyIsArray, clone;
  	var target = arguments[0];
  	var i = 1;
  	var length = arguments.length;
  	var deep = false;

  	// Handle a deep copy situation
  	if (typeof target === 'boolean') {
  		deep = target;
  		target = arguments[1] || {};
  		// skip the boolean and the target
  		i = 2;
  	}
  	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
  		target = {};
  	}

  	for (; i < length; ++i) {
  		options = arguments[i];
  		// Only deal with non-null/undefined values
  		if (options != null) {
  			// Extend the base object
  			for (name in options) {
  				src = getProperty(target, name);
  				copy = getProperty(options, name);

  				// Prevent never-ending loop
  				if (target !== copy) {
  					// Recurse if we're merging plain objects or arrays
  					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
  						if (copyIsArray) {
  							copyIsArray = false;
  							clone = src && isArray(src) ? src : [];
  						} else {
  							clone = src && isPlainObject(src) ? src : {};
  						}

  						// Never move original objects, clone them
  						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

  					// Don't bring in undefined values
  					} else if (typeof copy !== 'undefined') {
  						setProperty(target, { name: name, newValue: copy });
  					}
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  var extend$1 = extend.bind(null, true);
  var JSONPatch = {};
  var isArray$1 = Array.isArray;

  function isObject(v) {
    return v != null && !Array.isArray(v) && _typeof(v) === 'object';
  }

  function isUndef(v) {
    return typeof v === 'undefined';
  }

  function isFunction(v) {
    return typeof v === 'function';
  }
  /**
  * Generate an exact duplicate (with no references) of a specific value.
  *
  * @private
  * @param {Object} The value to duplicate
  * @returns {Object} a unique, duplicated value
  */


  function generateValue(val) {
    if (val) {
      return extend$1({}, {
        val: val
      }).val;
    }

    return val;
  }
  /**
  * An additional type checker used to determine if the property is of internal
  * use or not a type that can be translated into JSON (like functions).
  *
  * @private
  * @param {Object} obj The object which has the property to check
  * @param {String} The property name to check
  * @returns {Boolean} Whether the property is deemed special or not
  */


  function isSpecialProperty(obj, key) {
    return isFunction(obj[key]) || key.substring(0, 2) === '$$' || key.substring(0, 1) === '_';
  }
  /**
  * Finds the parent object from a JSON-Pointer ("/foo/bar/baz" = "bar" is "baz" parent),
  * also creates the object structure needed.
  *
  * @private
  * @param {Object} data The root object to traverse through
  * @param {String} The JSON-Pointer string to use when traversing
  * @returns {Object} The parent object
  */


  function getParent(data, str) {
    var seperator = '/';
    var parts = str.substring(1).split(seperator).slice(0, -1);
    var numPart;
    parts.forEach(function (part, i) {
      if (i === parts.length) {
        return;
      }

      numPart = +part;
      var newPart = !isNaN(numPart) ? [] : {};
      data[numPart || part] = isUndef(data[numPart || part]) ? newPart : data[part];
      data = data[numPart || part];
    });
    return data;
  }
  /**
  * Cleans an object of all its properties, unless they're deemed special or
  * cannot be removed by configuration.
  *
  * @private
  * @param {Object} obj The object to clean
  */


  function emptyObject(obj) {
    Object.keys(obj).forEach(function (key) {
      var config = Object.getOwnPropertyDescriptor(obj, key);

      if (config.configurable && !isSpecialProperty(obj, key)) {
        delete obj[key];
      }
    });
  }
  /**
  * Compare an object with another, could be object, array, number, string, bool.
  * @private
  * @param {Object} a The first object to compare
  * @param {Object} a The second object to compare
  * @returns {Boolean} Whether the objects are identical
  */


  function compare(a, b) {
    var isIdentical = true;

    if (isObject(a) && isObject(b)) {
      if (Object.keys(a).length !== Object.keys(b).length) {
        return false;
      }

      Object.keys(a).forEach(function (key) {
        if (!compare(a[key], b[key])) {
          isIdentical = false;
        }
      });
      return isIdentical;
    }

    if (isArray$1(a) && isArray$1(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0, l = a.length; i < l; i += 1) {
        if (!compare(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    return a === b;
  }
  /**
  * Generates patches by comparing two arrays.
  *
  * @private
  * @param {Array} oldA The old (original) array, which will be patched
  * @param {Array} newA The new array, which will be used to compare against
  * @returns {Array} An array of patches (if any)
  */


  function patchArray(original, newA, basePath) {
    var patches = [];
    var oldA = original.slice();
    var tmpIdx = -1;

    function findIndex(a, id, idx) {
      if (a[idx] && isUndef(a[idx].qInfo)) {
        return null;
      }

      if (a[idx] && a[idx].qInfo.qId === id) {
        // shortcut if identical
        return idx;
      }

      for (var ii = 0, ll = a.length; ii < ll; ii += 1) {
        if (a[ii] && a[ii].qInfo.qId === id) {
          return ii;
        }
      }

      return -1;
    }

    if (compare(newA, oldA)) {
      // array is unchanged
      return patches;
    }

    if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {
      // we cannot create patches without unique identifiers, replace array...
      patches.push({
        op: 'replace',
        path: basePath,
        value: newA
      });
      return patches;
    }

    for (var i = oldA.length - 1; i >= 0; i -= 1) {
      tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);

      if (tmpIdx === -1) {
        patches.push({
          op: 'remove',
          path: "".concat(basePath, "/").concat(i)
        });
        oldA.splice(i, 1);
      } else {
        patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], "".concat(basePath, "/").concat(i)));
      }
    }

    for (var _i = 0, l = newA.length; _i < l; _i += 1) {
      tmpIdx = findIndex(oldA, newA[_i].qInfo && newA[_i].qInfo.qId);

      if (tmpIdx === -1) {
        patches.push({
          op: 'add',
          path: "".concat(basePath, "/").concat(_i),
          value: newA[_i]
        });
        oldA.splice(_i, 0, newA[_i]);
      } else if (tmpIdx !== _i) {
        patches.push({
          op: 'move',
          path: "".concat(basePath, "/").concat(_i),
          from: "".concat(basePath, "/").concat(tmpIdx)
        });
        oldA.splice(_i, 0, oldA.splice(tmpIdx, 1)[0]);
      }
    }

    return patches;
  }
  /**
  * Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.
  *
  * See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)
  *
  * Does NOT currently generate patches for arrays (will replace them)
  * @private
  * @param {Object} original The object to patch to
  * @param {Object} newData The object to patch from
  * @param {String} [basePath] The base path to use when generating the paths for
  *                            the patches (normally not used)
  * @returns {Array} An array of patches
  */


  JSONPatch.generate = function generate(original, newData, basePath) {
    basePath = basePath || '';
    var patches = [];
    Object.keys(newData).forEach(function (key) {
      var val = generateValue(newData[key]);
      var oldVal = original[key];
      var tmpPath = "".concat(basePath, "/").concat(key);

      if (compare(val, oldVal) || isSpecialProperty(newData, key)) {
        return;
      }

      if (isUndef(oldVal)) {
        // property does not previously exist
        patches.push({
          op: 'add',
          path: tmpPath,
          value: val
        });
      } else if (isObject(val) && isObject(oldVal)) {
        // we need to generate sub-patches for this, since it already exist
        patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));
      } else if (isArray$1(val) && isArray$1(oldVal)) {
        patches = patches.concat(patchArray(oldVal, val, tmpPath));
      } else {
        // it's a simple property (bool, string, number)
        patches.push({
          op: 'replace',
          path: "".concat(basePath, "/").concat(key),
          value: val
        });
      }
    });
    Object.keys(original).forEach(function (key) {
      if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {
        // this property does not exist anymore
        patches.push({
          op: 'remove',
          path: "".concat(basePath, "/").concat(key)
        });
      }
    });
    return patches;
  };
  /**
  * Apply a list of patches to an object.
  * @private
  * @param {Object} original The object to patch
  * @param {Array} patches The list of patches to apply
  */


  JSONPatch.apply = function apply(original, patches) {
    patches.forEach(function (patch) {
      var parent = getParent(original, patch.path);
      var key = patch.path.split('/').splice(-1)[0];
      var target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;
      var from = patch.from ? patch.from.split('/').splice(-1)[0] : null;

      if (patch.path === '/') {
        parent = null;
        target = original;
      }

      if (patch.op === 'add' || patch.op === 'replace') {
        if (isArray$1(parent)) {
          // trust indexes from patches, so don't replace the index if it's an add
          if (key === '-') {
            key = parent.length;
          }

          parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);
        } else if (isArray$1(target) && isArray$1(patch.value)) {
          var _target;

          var newValues = patch.value.slice(); // keep array reference if possible...

          target.length = 0;

          (_target = target).push.apply(_target, _toConsumableArray(newValues));
        } else if (isObject(target) && isObject(patch.value)) {
          // keep object reference if possible...
          emptyObject(target);
          extend$1(target, patch.value);
        } else if (!parent) {
          throw new Error('Patchee is not an object we can patch');
        } else {
          // simple value
          parent[key] = patch.value;
        }
      } else if (patch.op === 'move') {
        var oldParent = getParent(original, patch.from);

        if (isArray$1(parent)) {
          parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);
        } else {
          parent[key] = oldParent[from];
          delete oldParent[from];
        }
      } else if (patch.op === 'remove') {
        if (isArray$1(parent)) {
          parent.splice(+key, 1);
        } else {
          delete parent[key];
        }
      }
    });
  };
  /**
  * Deep clone an object.
  * @private
  * @param {Object} obj The object to clone
  * @returns {Object} A new object identical to the `obj`
  */


  JSONPatch.clone = function clone(obj) {
    return extend$1({}, obj);
  };
  /**
  * Creates a JSON-patch.
  * @private
  * @param {String} op The operation of the patch. Available values: "add", "remove", "move"
  * @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`
  *                       is the "from JSON-path" path
  * @param {String} path The JSON-path for the property to change (e.g. "/qHyperCubeDef/columnOrder")
  * @returns {Object} A patch following the JSON-patch specification
  */


  JSONPatch.createPatch = function createPatch(op, val, path) {
    var patch = {
      op: op.toLowerCase(),
      path: path
    };

    if (patch.op === 'move') {
      patch.from = val;
    } else if (typeof val !== 'undefined') {
      patch.value = val;
    }

    return patch;
  };
  /**
  * Apply the differences of two objects (keeping references if possible).
  * Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`
  * @private
  * @param {Object} original The object to update/patch
  * @param {Object} newData the object to diff against
  *
  * @example
  * var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };
  * var obj2 = { foo: [4,5,6], bar: { baz: false } };
  * JSONPatch.updateObject(obj1, obj2);
  * // => { foo: [4,5,6], bar: { baz: false } };
  */


  JSONPatch.updateObject = function updateObject(original, newData) {
    if (!Object.keys(original).length) {
      extend$1(original, newData);
      return;
    }

    JSONPatch.apply(original, JSONPatch.generate(original, newData));
  };

  var sessions = {};
  /**
  * Function to make sure we release handle caches when they are closed.
  * @private
  * @param {Session} session The session instance to listen on.
  */

  var bindSession = function bindSession(session) {
    if (!sessions[session.id]) {
      var cache = {};
      sessions[session.id] = cache;
      session.on('traffic:received', function (data) {
        return data.close && data.close.forEach(function (handle) {
          return delete cache[handle];
        });
      });
      session.on('closed', function () {
        return delete sessions[session.id];
      });
    }
  };
  /**
  * Simple function that ensures the session events has been bound, and returns
  * either an existing key-value cache or creates one for the specified handle.
  * @private
  * @param {Session} session The session that owns the handle.
  * @param {Number} handle The object handle to retrieve the cache for.
  * @returns {KeyValueCache} The cache instance.
  */


  var getHandleCache = function getHandleCache(session, handle) {
    bindSession(session);
    var cache = sessions[session.id];

    if (!cache[handle]) {
      cache[handle] = new KeyValueCache();
    }

    return cache[handle];
  };
  /**
  * Function used to apply a list of patches and return the patched value.
  * @private
  * @param {Session} session The session.
  * @param {Number} handle The object handle.
  * @param {String} cacheId The cacheId.
  * @param {Array} patches The patches.
  * @returns {Object} Returns the patched value.
  */


  var patchValue = function patchValue(session, handle, cacheId, patches) {
    var cache = getHandleCache(session, handle);
    var entry = cache.get(cacheId);

    if (typeof entry === 'undefined') {
      entry = Array.isArray(patches[0].value) ? [] : {};
    }

    if (patches.length) {
      if (patches[0].path === '/' && _typeof(patches[0].value) !== 'object') {
        // 'plain' values on root path is not supported (no object reference),
        // so we simply store the value directly:
        entry = patches[0].value;
      } else {
        JSONPatch.apply(entry, patches);
      }

      cache.set(cacheId, entry);
    }

    return entry;
  };
  /**
  * Process delta interceptor.
  * @private
  * @param {Session} session The session the intercept is being executed on.
  * @param {Object} request The JSON-RPC request.
  * @param {Object} response The response.
  * @returns {Object} Returns the patched response
  */


  function deltaInterceptor(session, request, response) {
    var delta = response.delta,
        result = response.result;

    if (delta) {
      // when delta is on the response data is expected to be an array of patches:
      Object.keys(result).forEach(function (key) {
        if (!Array.isArray(result[key])) {
          throw new Error('Unexpected RPC response, expected array of patches');
        }

        result[key] = patchValue(session, request.handle, "".concat(request.method, "-").concat(key), result[key]);
      }); // return a cloned response object to avoid patched object references:

      return JSON.parse(JSON.stringify(response));
    }

    return response;
  } // export object reference for testing purposes:

  deltaInterceptor.sessions = sessions;

  /**
  * Process error interceptor.
  * @private
  * @param {Session} session - The session the intercept is being executed on.
  * @param {Object} request - The JSON-RPC request.
  * @param {Object} response - The response.
  * @returns {Object} - Returns the defined error for an error, else the response.
  */
  function errorInterceptor(session, request, response) {
    if (typeof response.error !== 'undefined') {
      var data = response.error;
      var error = new Error(data.message);
      error.code = data.code;
      error.parameter = data.parameter;
      return session.config.Promise.reject(error);
    }

    return response;
  }

  var RETURN_KEY = 'qReturn';
  /**
  * Picks out the result "out" parameter based on the QIX method+schema, with
  * some specific handling for some methods that breaks the predictable protocol.
  * @private
  * @param {Session} session - The session the intercept is being executed on.
  * @param {Object} request - The JSON-RPC request.
  * @param {Object} response - The response.
  * @returns {Object} - Returns the result property on the response
  */

  function outParamInterceptor(session, request, response) {
    if (request.method === 'CreateSessionApp' || request.method === 'CreateSessionAppFromApp') {
      // this method returns multiple out params that we need
      // to normalize before processing the response further:
      response[RETURN_KEY].qGenericId = response[RETURN_KEY].qGenericId || response.qSessionAppId;
    } else if (request.method === 'GetInteract') {
      // this method returns a qReturn value when it should only return
      // meta.outKey:
      delete response[RETURN_KEY];
    }

    if (hasOwnProperty.call(response, RETURN_KEY)) {
      return response[RETURN_KEY];
    }

    if (request.outKey !== -1) {
      return response[request.outKey];
    }

    return response;
  }

  /**
  * Process result interceptor.
  * @private
  * @param {Session} session - The session the intercept is being executed on.
  * @param {Object} request - The JSON-RPC request.
  * @param {Object} response - The response.
  * @returns {Object} - Returns the result property on the response
  */
  function resultInterceptor(session, request, response) {
    return response.result;
  }

  /**
   * Interceptors is a concept similar to mixins, but run on a lower level. The interceptor concept
   * can augment either the requests (i.e. before sent to QIX Engine), or the responses (i.e. after
   * QIX Engine has sent a response). The interceptor promises runs in parallel to the regular
   * promises used in enigma.js, which means that it can be really useful when you want to normalize
   * behaviors in your application.
   * @interface Interceptor
   */

  /**
    * @class InterceptorRequest
    * @implements {Interceptor}
    */

  /**
   * @class InterceptorResponse
   * @implements {Interceptor}
   */

  /**
   * This method is invoked when a request is about to be sent to QIX Engine.
   * @function InterceptorRequest#onFulfilled
   * @param {Session} session The session executing the interceptor.
   * @param {Object} request The JSON-RPC request that will be sent.
   */

  /**
   * This method is invoked when a previous interceptor has rejected the
   * promise, use this to handle for example errors before they are sent into mixins.
   * @function InterceptorResponse#onRejected
   * @param {Session} session The session executing the interceptor. You may use .retry() to retry
   * sending it to QIX Engine.
   * @param {Object} request The JSON-RPC request resulting in this error.
   * @param {Object} error Whatever the previous interceptor is rejected with.
   */

  /**
   * This method is invoked when a promise has been successfully resolved,
   * use this to modify the result or reject the promise chain before it is sent
   * to mixins.
   * @function InterceptorResponse#onFulfilled
   * @param {Session} session The session executing the interceptor.
   * @param {Object} request The JSON-RPC request resulting in this response.
   * @param {Object} result Whatever the previous interceptor is resolved with.
   */

  var Intercept =
  /*#__PURE__*/
  function () {
    /**
    * Create a new Intercept instance.
    * @private
    * @param {Object} options The configuration options for this class.
    * @param {Promise<Object>} options.Promise The promise constructor to use.
    * @param {ApiCache} options.apis The ApiCache instance to use.
    * @param {Array<Object>} [options.request] The additional request interceptors to use.
    * @param {Array<Object>} [options.response] The additional response interceptors to use.
    */
    function Intercept(options) {
      _classCallCheck(this, Intercept);

      Object.assign(this, options);
      this.request = [{
        onFulfilled: deltaRequestInterceptor
      }].concat(_toConsumableArray(this.request || []));
      this.response = [{
        onFulfilled: errorInterceptor
      }, {
        onFulfilled: deltaInterceptor
      }, {
        onFulfilled: resultInterceptor
      }, {
        onFulfilled: outParamInterceptor
      }].concat(_toConsumableArray(this.response || []), [{
        onFulfilled: apiInterceptor
      }]);
    }
    /**
    * Execute the request interceptor queue, each interceptor will get the result from
    * the previous interceptor.
    * @private
    * @param {Session} session The session instance to execute against.
    * @param {Promise<Object>} promise The promise to chain on to.
    * @returns {Promise<Object>}
    */


    _createClass(Intercept, [{
      key: "executeRequests",
      value: function executeRequests(session, promise) {
        var _this = this;

        return this.request.reduce(function (interception, interceptor) {
          var intercept = interceptor.onFulfilled && interceptor.onFulfilled.bind(_this, session);
          return interception.then(intercept);
        }, promise);
      }
      /**
      * Execute the response interceptor queue, each interceptor will get the result from
      * the previous interceptor.
      * @private
      * @param {Session} session The session instance to execute against.
      * @param {Promise<Object>} promise The promise to chain on to.
      * @param {Object} request The JSONRPC request object for the intercepted response.
      * @returns {Promise<Object>}
      */

    }, {
      key: "executeResponses",
      value: function executeResponses(session, promise, request) {
        var _this2 = this;

        return this.response.reduce(function (interception, interceptor) {
          return interception.then(interceptor.onFulfilled && interceptor.onFulfilled.bind(_this2, session, request), interceptor.onRejected && interceptor.onRejected.bind(_this2, session, request));
        }, promise);
      }
    }]);

    return Intercept;
  }();

  /**
  * API cache for instances of QIX types, e.g. GenericObject.
  * @private
  * @extends KeyValueCache
  */

  var ApiCache =
  /*#__PURE__*/
  function (_KeyValueCache) {
    _inherits(ApiCache, _KeyValueCache);

    function ApiCache() {
      _classCallCheck(this, ApiCache);

      return _possibleConstructorReturn(this, _getPrototypeOf(ApiCache).apply(this, arguments));
    }

    _createClass(ApiCache, [{
      key: "add",

      /**
      * Adds an API.
      * @private
      * @function ApiCache#add
      * @param {Number} handle - The handle for the API.
      * @param {*} api - The API.
      * @returns {{api: *}} The entry.
      */
      value: function add(handle, api) {
        var _this = this;

        var entry = {
          api: api
        };

        _get(_getPrototypeOf(ApiCache.prototype), "add", this).call(this, handle.toString(), entry);

        api.on('closed', function () {
          return _this.remove(handle);
        });
        return entry;
      }
      /**
      * Gets an API.
      * @private
      * @function ApiCache#getApi
      * @param {Number} handle - The handle for the API.
      * @returns {*} The API for the handle.
      */

    }, {
      key: "getApi",
      value: function getApi(handle) {
        var entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;
        return entry && entry.api;
      }
      /**
      * Gets a list of APIs.
      * @private
      * @function ApiCache#getApis
      * @returns {Array} The list of entries including `handle` and `api` properties for each entry.
      */

    }, {
      key: "getApis",
      value: function getApis() {
        return _get(_getPrototypeOf(ApiCache.prototype), "getAll", this).call(this).map(function (entry) {
          return {
            handle: entry.key,
            api: entry.value.api
          };
        });
      }
      /**
      * Gets a list of APIs with a given type.
      * @private
      * @function ApiCache#getApisByType
      * @param {String} type - The type of APIs to get.
      * @returns {Array} The list of entries including `handle` and `api` properties for each entry.
      */

    }, {
      key: "getApisByType",
      value: function getApisByType(type) {
        return this.getApis().filter(function (entry) {
          return entry.api.type === type;
        });
      }
    }]);

    return ApiCache;
  }(KeyValueCache);

  /**
   * The enigma.js configuration object.
   * @interface Configuration
   * @property {Object} schema Object containing the specification for the API to generate.
   * Corresponds to a specific version of the QIX Engine API.
   * @property {String} url String containing a proper websocker URL to QIX Engine.
   * @property {Function} [createSocket] A function to use when instantiating the WebSocket,
   * mandatory for Node.js.
   * @property {Object} [Promise] ES6-compatible Promise library.
   * @property {Boolean} [suspendOnClose=false] Set to true if the session should be suspended
   * instead of closed when the websocket is closed.
   * @property {Array<Mixin>} [mixins=[]] Mixins to extend/augment the QIX Engine API. Mixins
   * are applied in the array order.
   * @property {Array} [requestInterceptors=[]] Interceptors for augmenting requests before they
   * are sent to QIX Engine. Interceptors are applied in the array order.
   * @property {Array} [responseInterceptors=[]] Interceptors for augmenting responses before they
   * are passed into mixins and end-users. Interceptors are applied in the array order.
   * @property {Object} [protocol={}] An object containing additional JSON-RPC request parameters.
   * @property {Boolean} [protocol.delta=true] Set to false to disable the use of the
   * bandwidth-reducing delta protocol.
   */

  /**
   * Mixin object to extend/augment the QIX Engine API
   * @interface Mixin
   * @property {String|Array<String>} types String or array of strings containing the API-types that
   * will be mixed in.
   * @property {Object} [extend] Object literal containing the methods that will be extended on the
   * specified API.
   * @property {Object} [override] Object literal containing the methods to override existing methods.
   * @property {Function} [init] Init function that, if defined, will run when an API is instantiated.
   * It runs with Promise and API object as parameters
   */

  /**
   * The API for generated APIs depends on the QIX Engine schema you pass into your Configuration,
   * and on what QIX struct the API has.
   * @interface API
   * @property {String} id Contains the unique identifier for this API.
   * @property {String} type Contains the schema class name for this API.
   * @property {String} genericType Corresponds to the qInfo.qType property on the generic object's
   * properties object.
   * @property {Session} session Contains a reference to the session that this API belongs to.
   * @property {Number} handle Contains the handle QIX Engine assigned to the API. Used interally in
   * enigma.js for caches and JSON-RPC requests.
   */

  /**
   * Handle changes on the API. The changed event is triggered whenever enigma.js or QIX Engine has
   * identified potential changes on the underlying properties or hypercubes and you should re-fetch
   * your data.
   * @event API#changed
   * @type {Object}
   */

  /**
   * Handle closed API. The closed event is triggered whenever QIX Engine considers an API closed.
   * It usually means that it no longer exist in the QIX Engine document or session.
   * @event API#closed
   * @type {Object}
   */

  /**
   * Handle JSON-RPC requests/responses for this API. Generally used in debugging purposes.
   * traffic:* will handle all websocket messages, traffic:sent will handle outgoing messages
   * and traffic:received will handle incoming messages.
   * @event API#traffic
   * @type {Object}
   */

  /**
  * Qix service.
  */

  var Qix =
  /*#__PURE__*/
  function () {
    function Qix() {
      _classCallCheck(this, Qix);
    }

    _createClass(Qix, null, [{
      key: "getSession",

      /**
      * Function used to get a session.
      * @private
      * @param {Configuration} config The configuration object for this session.
      * @returns {Session} Returns a session instance.
      */
      value: function getSession(config) {
        var createSocket = config.createSocket,
            Promise = config.Promise,
            requestInterceptors = config.requestInterceptors,
            responseInterceptors = config.responseInterceptors,
            url = config.url;
        var apis = new ApiCache();
        var intercept = new Intercept({
          apis: apis,
          Promise: Promise,
          request: requestInterceptors,
          response: responseInterceptors
        });
        var rpc = new RPC({
          createSocket: createSocket,
          Promise: Promise,
          url: url
        });
        var suspendResume = new SuspendResume({
          apis: apis,
          Promise: Promise,
          rpc: rpc
        });
        var session = new Session({
          apis: apis,
          config: config,
          intercept: intercept,
          rpc: rpc,
          suspendResume: suspendResume
        });
        return session;
      }
      /**
      * Function used to create a QIX session.
      * @param {Configuration} config The configuration object for the QIX session.
      * @returns {Session} Returns a new QIX session.
      */

    }, {
      key: "create",
      value: function create(config) {
        Qix.configureDefaults(config);
        config.mixins.forEach(function (mixin) {
          config.definition.registerMixin(mixin);
        });
        return Qix.getSession(config);
      }
      /**
      * Function used to configure defaults.
      * @private
      * @param {Configuration} config The configuration object for how to connect
      *                               and retrieve end QIX APIs.
      */

    }, {
      key: "configureDefaults",
      value: function configureDefaults(config) {
        if (!config) {
          throw new Error('You need to supply a configuration.');
        } // eslint-disable-next-line no-restricted-globals


        if (!config.Promise && typeof Promise === 'undefined') {
          throw new Error('Your environment has no Promise implementation. You must provide a Promise implementation in the config.');
        }

        if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {
          // eslint-disable-next-line no-undef
          config.createSocket = function (url) {
            return new WebSocket(url);
          };
        }

        if (typeof config.suspendOnClose === 'undefined') {
          config.suspendOnClose = false;
        }

        config.protocol = config.protocol || {};
        config.protocol.delta = typeof config.protocol.delta !== 'undefined' ? config.protocol.delta : true; // eslint-disable-next-line no-restricted-globals

        config.Promise = config.Promise || Promise;
        config.mixins = config.mixins || [];
        config.definition = config.definition || new Schema(config);
      }
    }]);

    return Qix;
  }();

  return Qix;

})));
//# sourceMappingURL=enigma.js.map


/***/ }),
/* 31 */
/***/ (function(module) {

module.exports = {"structs":{"Field":{"GetCardinal":{"In":[],"Out":[]},"GetAndMode":{"In":[],"Out":[]},"SelectValues":{"In":[{"Name":"qFieldValues","DefaultValue":[{"qText":"","qIsNumeric":false,"qNumber":0}]},{"Name":"qToggleMode","DefaultValue":false,"Optional":true},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"Select":{"In":[{"Name":"qMatch","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true},{"Name":"qExcludedValuesMode","DefaultValue":0,"Optional":true}],"Out":[]},"ToggleSelect":{"In":[{"Name":"qMatch","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true},{"Name":"qExcludedValuesMode","DefaultValue":0,"Optional":true}],"Out":[]},"ClearAllButThis":{"In":[{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"SelectPossible":{"In":[{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"SelectExcluded":{"In":[{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"SelectAll":{"In":[{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"Lock":{"In":[],"Out":[]},"Unlock":{"In":[],"Out":[]},"GetNxProperties":{"In":[],"Out":[{"Name":"qProperties"}]},"SetNxProperties":{"In":[{"Name":"qProperties","DefaultValue":{"qOneAndOnlyOne":false}}],"Out":[]},"SetAndMode":{"In":[{"Name":"qAndMode","DefaultValue":false}],"Out":[]},"SelectAlternative":{"In":[{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"LowLevelSelect":{"In":[{"Name":"qValues","DefaultValue":[0]},{"Name":"qToggleMode","DefaultValue":false},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"Clear":{"In":[],"Out":[]}},"Variable":{"GetContent":{"In":[],"Out":[{"Name":"qContent"}]},"GetRawContent":{"In":[],"Out":[]},"SetContent":{"In":[{"Name":"qContent","DefaultValue":""},{"Name":"qUpdateMRU","DefaultValue":false}],"Out":[]},"ForceContent":{"In":[{"Name":"qs","DefaultValue":""},{"Name":"qd","DefaultValue":0}],"Out":[]},"GetNxProperties":{"In":[],"Out":[{"Name":"qProperties"}]},"SetNxProperties":{"In":[{"Name":"qProperties","DefaultValue":{"qName":"","qNumberPresentation":{"qType":0,"qnDec":0,"qUseThou":0,"qFmt":"","qDec":"","qThou":""},"qIncludeInBookmark":false,"qUsePredefListedValues":false,"qPreDefinedList":[""]}}],"Out":[]}},"GenericObject":{"GetLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"GetListObjectData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]}],"Out":[{"Name":"qDataPages"}]},"GetHyperCubeData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]}],"Out":[{"Name":"qDataPages"}]},"GetHyperCubeReducedData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]},{"Name":"qZoomFactor","DefaultValue":0},{"Name":"qReductionMode","DefaultValue":0}],"Out":[{"Name":"qDataPages"}]},"GetHyperCubePivotData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]}],"Out":[{"Name":"qDataPages"}]},"GetHyperCubeStackData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]},{"Name":"qMaxNbrCells","DefaultValue":0,"Optional":true}],"Out":[{"Name":"qDataPages"}]},"GetHyperCubeContinuousData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qOptions","DefaultValue":{"qStart":0,"qEnd":0,"qNbrPoints":0,"qMaxNbrTicks":0,"qMaxNumberLines":0}},{"Name":"qReverseSort","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qDataPages"},{"Name":"qAxisData"}]},"GetHyperCubeBinnedData":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qPages","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]},{"Name":"qViewport","DefaultValue":{"qWidth":0,"qHeight":0,"qZoomLevel":0}},{"Name":"qDataRanges","DefaultValue":[{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0}]},{"Name":"qMaxNbrCells","DefaultValue":0},{"Name":"qQueryLevel","DefaultValue":0},{"Name":"qBinningMethod","DefaultValue":0}],"Out":[{"Name":"qDataPages"}]},"ApplyPatches":{"In":[{"Name":"qPatches","DefaultValue":[{"qOp":0,"qPath":"","qValue":""}]},{"Name":"qSoftPatch","DefaultValue":false,"Optional":true}],"Out":[]},"ClearSoftPatches":{"In":[],"Out":[]},"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qExtendsId":"","qMetaDef":{}}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetEffectiveProperties":{"In":[],"Out":[{"Name":"qProp"}]},"SetFullPropertyTree":{"In":[{"Name":"qPropEntry","DefaultValue":{"qProperty":{"qInfo":{"qId":"","qType":""},"qExtendsId":"","qMetaDef":{}},"qChildren":[],"qEmbeddedSnapshotRef":null}}],"Out":[]},"GetFullPropertyTree":{"In":[],"Out":[{"Name":"qPropEntry"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"ClearSelections":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qColIndices","DefaultValue":[0],"Optional":true}],"Out":[]},"ExportData":{"In":[{"Name":"qFileType","DefaultValue":0},{"Name":"qPath","DefaultValue":"","Optional":true},{"Name":"qFileName","DefaultValue":"","Optional":true},{"Name":"qExportState","DefaultValue":0,"Optional":true}],"Out":[{"Name":"qUrl"},{"Name":"qWarnings"}]},"SelectListObjectValues":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qValues","DefaultValue":[0]},{"Name":"qToggleMode","DefaultValue":false},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectListObjectPossible":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectListObjectExcluded":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectListObjectAlternative":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectListObjectAll":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectListObjectContinuousRange":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRanges","DefaultValue":[{"qMin":0,"qMax":0,"qMinInclEq":false,"qMaxInclEq":false}]},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SearchListObjectFor":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qMatch","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"AbortListObjectSearch":{"In":[{"Name":"qPath","DefaultValue":""}],"Out":[]},"AcceptListObjectSearch":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qToggleMode","DefaultValue":false},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[]},"ExpandLeft":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRow","DefaultValue":0},{"Name":"qCol","DefaultValue":0},{"Name":"qAll","DefaultValue":false}],"Out":[]},"ExpandTop":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRow","DefaultValue":0},{"Name":"qCol","DefaultValue":0},{"Name":"qAll","DefaultValue":false}],"Out":[]},"CollapseLeft":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRow","DefaultValue":0},{"Name":"qCol","DefaultValue":0},{"Name":"qAll","DefaultValue":false}],"Out":[]},"CollapseTop":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRow","DefaultValue":0},{"Name":"qCol","DefaultValue":0},{"Name":"qAll","DefaultValue":false}],"Out":[]},"DrillUp":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qDimNo","DefaultValue":0},{"Name":"qNbrSteps","DefaultValue":0}],"Out":[]},"Lock":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qColIndices","DefaultValue":[0],"Optional":true}],"Out":[]},"Unlock":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qColIndices","DefaultValue":[0],"Optional":true}],"Out":[]},"SelectHyperCubeValues":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qDimNo","DefaultValue":0},{"Name":"qValues","DefaultValue":[0]},{"Name":"qToggleMode","DefaultValue":false}],"Out":[{"Name":"qSuccess"}]},"SelectHyperCubeCells":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRowIndices","DefaultValue":[0]},{"Name":"qColIndices","DefaultValue":[0]},{"Name":"qSoftLock","DefaultValue":false,"Optional":true},{"Name":"qDeselectOnlyOneSelected","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectPivotCells":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qSelections","DefaultValue":[{"qType":0,"qCol":0,"qRow":0}]},{"Name":"qSoftLock","DefaultValue":false,"Optional":true},{"Name":"qDeselectOnlyOneSelected","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"RangeSelectHyperCubeValues":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRanges","DefaultValue":[{"qRange":{"qMin":0,"qMax":0,"qMinInclEq":false,"qMaxInclEq":false},"qMeasureIx":0}]},{"Name":"qColumnsToSelect","DefaultValue":[0],"Optional":true},{"Name":"qOrMode","DefaultValue":false,"Optional":true},{"Name":"qDeselectOnlyOneSelected","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"MultiRangeSelectHyperCubeValues":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRanges","DefaultValue":[{"qRanges":[{"qRange":{"qMin":0,"qMax":0,"qMinInclEq":false,"qMaxInclEq":false},"qMeasureIx":0}],"qColumnsToSelect":[0]}]},{"Name":"qOrMode","DefaultValue":false,"Optional":true},{"Name":"qDeselectOnlyOneSelected","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"SelectHyperCubeContinuousRange":{"In":[{"Name":"qPath","DefaultValue":""},{"Name":"qRanges","DefaultValue":[{"qRange":{"qMin":0,"qMax":0,"qMinInclEq":false,"qMaxInclEq":false},"qDimIx":0}]},{"Name":"qSoftLock","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"GetChild":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"GetChildInfos":{"In":[],"Out":[{"Name":"qInfos"}]},"CreateChild":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qExtendsId":"","qMetaDef":{}}},{"Name":"qPropForThis","DefaultValue":null,"Optional":true}],"Out":[{"Name":"qInfo"}]},"DestroyChild":{"In":[{"Name":"qId","DefaultValue":""},{"Name":"qPropForThis","DefaultValue":null,"Optional":true}],"Out":[{"Name":"qSuccess"}]},"DestroyAllChildren":{"In":[{"Name":"qPropForThis","DefaultValue":null,"Optional":true}],"Out":[]},"SetChildArrayOrder":{"In":[{"Name":"qIds","DefaultValue":[""]}],"Out":[]},"GetLinkedObjects":{"In":[],"Out":[{"Name":"qItems"}]},"CopyFrom":{"In":[{"Name":"qFromId","DefaultValue":""}],"Out":[]},"BeginSelections":{"In":[{"Name":"qPaths","DefaultValue":[""]}],"Out":[]},"EndSelections":{"In":[{"Name":"qAccept","DefaultValue":false}],"Out":[]},"ResetMadeSelections":{"In":[],"Out":[]},"EmbedSnapshotObject":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"GetSnapshotObject":{"In":[],"Out":[]},"Publish":{"In":[],"Out":[]},"UnPublish":{"In":[],"Out":[]}},"GenericDimension":{"GetLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"ApplyPatches":{"In":[{"Name":"qPatches","DefaultValue":[{"qOp":0,"qPath":"","qValue":""}]}],"Out":[]},"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qDim":{"qGrouping":0,"qFieldDefs":[""],"qFieldLabels":[""],"qLabelExpression":""},"qMetaDef":{}}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"GetDimension":{"In":[],"Out":[{"Name":"qDim"}]},"GetLinkedObjects":{"In":[],"Out":[{"Name":"qItems"}]},"Publish":{"In":[],"Out":[]},"UnPublish":{"In":[],"Out":[]}},"GenericBookmark":{"GetFieldValues":{"In":[{"Name":"qField","DefaultValue":""},{"Name":"qGetExcludedValues","DefaultValue":false},{"Name":"qDataPage","DefaultValue":{"qStartIndex":0,"qEndIndex":0}}],"Out":[{"Name":"qFieldValues"}]},"GetLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"ApplyPatches":{"In":[{"Name":"qPatches","DefaultValue":[{"qOp":0,"qPath":"","qValue":""}]}],"Out":[]},"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMetaDef":{}}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"Apply":{"In":[],"Out":[{"Name":"qSuccess"}]},"Publish":{"In":[],"Out":[]},"UnPublish":{"In":[],"Out":[]}},"GenericVariable":{"GetLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"ApplyPatches":{"In":[{"Name":"qPatches","DefaultValue":[{"qOp":0,"qPath":"","qValue":""}]}],"Out":[]},"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMetaDef":{},"qName":"","qComment":"","qNumberPresentation":{"qType":0,"qnDec":0,"qUseThou":0,"qFmt":"","qDec":"","qThou":""},"qIncludeInBookmark":false,"qDefinition":""}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"SetStringValue":{"In":[{"Name":"qVal","DefaultValue":""}],"Out":[]},"SetNumValue":{"In":[{"Name":"qVal","DefaultValue":0}],"Out":[]},"SetDualValue":{"In":[{"Name":"qText","DefaultValue":""},{"Name":"qNum","DefaultValue":0}],"Out":[]}},"GenericMeasure":{"GetLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"ApplyPatches":{"In":[{"Name":"qPatches","DefaultValue":[{"qOp":0,"qPath":"","qValue":""}]}],"Out":[]},"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMeasure":{"qLabel":"","qDef":"","qGrouping":0,"qExpressions":[""],"qActiveExpression":0,"qLabelExpression":""},"qMetaDef":{}}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"GetMeasure":{"In":[],"Out":[{"Name":"qMeasure"}]},"GetLinkedObjects":{"In":[],"Out":[{"Name":"qItems"}]},"Publish":{"In":[],"Out":[]},"UnPublish":{"In":[],"Out":[]}},"GenericDerivedFields":{"SetProperties":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qDerivedDefinitionId":"","qFieldName":[""],"qMetaDef":{}}}],"Out":[]},"GetProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetInfo":{"In":[],"Out":[{"Name":"qInfo"}]},"GetDerivedFieldData":{"In":[],"Out":[{"Name":"qData"}]},"GetDerivedField":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qFields"}]},"GetListData":{"In":[],"Out":[{"Name":"qListData"}]},"GetDerivedFields":{"In":[],"Out":[{"Name":"qFields"}]},"GetDerivedGroups":{"In":[],"Out":[{"Name":"qGroups"}]}},"Doc":{"GetField":{"In":[{"Name":"qFieldName","DefaultValue":""},{"Name":"qStateName","DefaultValue":"","Optional":true}],"Out":[]},"GetFieldDescription":{"In":[{"Name":"qFieldName","DefaultValue":""}],"Out":[]},"GetVariable":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[]},"GetLooselyCoupledVector":{"In":[],"Out":[{"Name":"qv"}]},"SetLooselyCoupledVector":{"In":[{"Name":"qv","DefaultValue":[0]}],"Out":[]},"Evaluate":{"In":[{"Name":"qExpression","DefaultValue":""}],"Out":[]},"EvaluateEx":{"In":[{"Name":"qExpression","DefaultValue":""}],"Out":[{"Name":"qValue"}]},"ClearAll":{"In":[{"Name":"qLockedAlso","DefaultValue":false,"Optional":true},{"Name":"qStateName","DefaultValue":"","Optional":true}],"Out":[]},"LockAll":{"In":[{"Name":"qStateName","DefaultValue":"","Optional":true}],"Out":[]},"UnlockAll":{"In":[{"Name":"qStateName","DefaultValue":"","Optional":true}],"Out":[]},"Back":{"In":[],"Out":[]},"Forward":{"In":[],"Out":[]},"CreateVariable":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[]},"RemoveVariable":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[]},"GetLocaleInfo":{"In":[],"Out":[]},"GetTablesAndKeys":{"In":[{"Name":"qWindowSize","DefaultValue":{"qcx":0,"qcy":0}},{"Name":"qNullSize","DefaultValue":{"qcx":0,"qcy":0}},{"Name":"qCellHeight","DefaultValue":0},{"Name":"qSyntheticMode","DefaultValue":false},{"Name":"qIncludeSysVars","DefaultValue":false}],"Out":[{"Name":"qtr"},{"Name":"qk"}]},"GetViewDlgSaveInfo":{"In":[],"Out":[]},"SetViewDlgSaveInfo":{"In":[{"Name":"qInfo","DefaultValue":{"qPos":{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0},"qCtlInfo":{"qInternalView":{"qTables":[{"qPos":{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0},"qCaption":""}],"qBroomPoints":[{"qPos":{"qx":0,"qy":0},"qTable":"","qFields":[""]}],"qConnectionPoints":[{"qPos":{"qx":0,"qy":0},"qFields":[""]}],"qZoomFactor":0},"qSourceView":{"qTables":[{"qPos":{"qLeft":0,"qTop":0,"qWidth":0,"qHeight":0},"qCaption":""}],"qBroomPoints":[{"qPos":{"qx":0,"qy":0},"qTable":"","qFields":[""]}],"qConnectionPoints":[{"qPos":{"qx":0,"qy":0},"qFields":[""]}],"qZoomFactor":0}},"qMode":0}}],"Out":[]},"GetEmptyScript":{"In":[{"Name":"qLocalizedMainSection","DefaultValue":"","Optional":true}],"Out":[]},"DoReload":{"In":[{"Name":"qMode","DefaultValue":0,"Optional":true},{"Name":"qPartial","DefaultValue":false,"Optional":true},{"Name":"qDebug","DefaultValue":false,"Optional":true}],"Out":[]},"GetScriptBreakpoints":{"In":[],"Out":[{"Name":"qBreakpoints"}]},"SetScriptBreakpoints":{"In":[{"Name":"qBreakpoints","DefaultValue":[{"qbufferName":"","qlineIx":0,"qEnabled":false}]}],"Out":[]},"GetScript":{"In":[],"Out":[{"Name":"qScript"}]},"GetTextMacros":{"In":[],"Out":[{"Name":"qMacros"}]},"SetFetchLimit":{"In":[{"Name":"qLimit","DefaultValue":0}],"Out":[]},"DoSave":{"In":[{"Name":"qFileName","DefaultValue":"","Optional":true}],"Out":[]},"GetTableData":{"In":[{"Name":"qOffset","DefaultValue":0},{"Name":"qRows","DefaultValue":0},{"Name":"qSyntheticMode","DefaultValue":false},{"Name":"qTableName","DefaultValue":""}],"Out":[{"Name":"qData"}]},"GetAppLayout":{"In":[],"Out":[{"Name":"qLayout"}]},"SetAppProperties":{"In":[{"Name":"qProp","DefaultValue":{"qTitle":"","qLastReloadTime":"","qMigrationHash":"","qSavedInProductVersion":"","qThumbnail":{"qUrl":""}}}],"Out":[]},"GetAppProperties":{"In":[],"Out":[{"Name":"qProp"}]},"GetLineage":{"In":[],"Out":[{"Name":"qLineage"}]},"CreateSessionObject":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qExtendsId":"","qMetaDef":{}}}],"Out":[]},"DestroySessionObject":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"CreateObject":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qExtendsId":"","qMetaDef":{}}}],"Out":[{"Name":"qInfo"}]},"DestroyObject":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetObject":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"GetObjects":{"In":[{"Name":"qOptions","DefaultValue":{"qTypes":[""],"qIncludeSessionObjects":false,"qData":{}}}],"Out":[{"Name":"qList"}]},"GetBookmarks":{"In":[{"Name":"qOptions","DefaultValue":{"qTypes":[""],"qData":{}}}],"Out":[{"Name":"qList"}]},"CloneObject":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qCloneId"}]},"CreateDraft":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qDraftId"}]},"CommitDraft":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"DestroyDraft":{"In":[{"Name":"qId","DefaultValue":""},{"Name":"qSourceId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"Undo":{"In":[],"Out":[{"Name":"qSuccess"}]},"Redo":{"In":[],"Out":[{"Name":"qSuccess"}]},"ClearUndoBuffer":{"In":[],"Out":[]},"CreateDimension":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qDim":{"qGrouping":0,"qFieldDefs":[""],"qFieldLabels":[""],"qLabelExpression":""},"qMetaDef":{}}}],"Out":[{"Name":"qInfo"}]},"DestroyDimension":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetDimension":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"CloneDimension":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qCloneId"}]},"CreateMeasure":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMeasure":{"qLabel":"","qDef":"","qGrouping":0,"qExpressions":[""],"qActiveExpression":0,"qLabelExpression":""},"qMetaDef":{}}}],"Out":[{"Name":"qInfo"}]},"DestroyMeasure":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetMeasure":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"CloneMeasure":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qCloneId"}]},"CreateSessionVariable":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMetaDef":{},"qName":"","qComment":"","qNumberPresentation":{"qType":0,"qnDec":0,"qUseThou":0,"qFmt":"","qDec":"","qThou":""},"qIncludeInBookmark":false,"qDefinition":""}}],"Out":[]},"DestroySessionVariable":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"CreateVariableEx":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMetaDef":{},"qName":"","qComment":"","qNumberPresentation":{"qType":0,"qnDec":0,"qUseThou":0,"qFmt":"","qDec":"","qThou":""},"qIncludeInBookmark":false,"qDefinition":""}}],"Out":[{"Name":"qInfo"}]},"DestroyVariableById":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"DestroyVariableByName":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetVariableById":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"GetVariableByName":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[]},"MigrateVariables":{"In":[],"Out":[]},"MigrateDerivedFields":{"In":[],"Out":[]},"CheckExpression":{"In":[{"Name":"qExpr","DefaultValue":""},{"Name":"qLabels","DefaultValue":[""],"Optional":true}],"Out":[{"Name":"qErrorMsg"},{"Name":"qBadFieldNames"},{"Name":"qDangerousFieldNames"}]},"CheckNumberOrExpression":{"In":[{"Name":"qExpr","DefaultValue":""}],"Out":[{"Name":"qErrorMsg"},{"Name":"qBadFieldNames"}]},"AddAlternateState":{"In":[{"Name":"qStateName","DefaultValue":""}],"Out":[]},"RemoveAlternateState":{"In":[{"Name":"qStateName","DefaultValue":""}],"Out":[]},"CreateBookmark":{"In":[{"Name":"qProp","DefaultValue":{"qInfo":{"qId":"","qType":""},"qMetaDef":{}}}],"Out":[{"Name":"qInfo"}]},"DestroyBookmark":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetBookmark":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[]},"ApplyBookmark":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"CloneBookmark":{"In":[{"Name":"qId","DefaultValue":""}],"Out":[{"Name":"qCloneId"}]},"AddFieldFromExpression":{"In":[{"Name":"qName","DefaultValue":""},{"Name":"qExpr","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"GetAllInfos":{"In":[],"Out":[{"Name":"qInfos"}]},"Resume":{"In":[],"Out":[]},"AbortModal":{"In":[{"Name":"qAccept","DefaultValue":false}],"Out":[]},"Publish":{"In":[{"Name":"qStreamId","DefaultValue":""},{"Name":"qName","DefaultValue":"","Optional":true}],"Out":[]},"UnPublish":{"In":[],"Out":[]},"GetMatchingFields":{"In":[{"Name":"qTags","DefaultValue":[""]},{"Name":"qMatchingFieldMode","DefaultValue":0,"Optional":true}],"Out":[{"Name":"qFieldNames"}]},"FindMatchingFields":{"In":[{"Name":"qFieldName","DefaultValue":""},{"Name":"qTags","DefaultValue":[""]}],"Out":[{"Name":"qFieldNames"}]},"Scramble":{"In":[{"Name":"qFieldName","DefaultValue":""}],"Out":[]},"SaveObjects":{"In":[],"Out":[]},"GetAssociationScores":{"In":[{"Name":"qTable1","DefaultValue":""},{"Name":"qTable2","DefaultValue":""}],"Out":[{"Name":"qScore"}]},"GetMediaList":{"In":[],"Out":[{"Name":"qList"}]},"GetContentLibraries":{"In":[],"Out":[{"Name":"qList"}]},"GetLibraryContent":{"In":[{"Name":"qName","DefaultValue":""}],"Out":[{"Name":"qList"}]},"DoReloadEx":{"In":[{"Name":"qParams","DefaultValue":{"qMode":0,"qPartial":false,"qDebug":false},"Optional":true}],"Out":[{"Name":"qResult"}]},"BackCount":{"In":[],"Out":[]},"ForwardCount":{"In":[],"Out":[]},"ExportReducedData":{"In":[{"Name":"qOptions","DefaultValue":{"qBookmarkId":"","qExpires":0},"Optional":true}],"Out":[{"Name":"qDownloadInfo"}]},"SetScript":{"In":[{"Name":"qScript","DefaultValue":""}],"Out":[]},"CheckScriptSyntax":{"In":[],"Out":[{"Name":"qErrors"}]},"GetFavoriteVariables":{"In":[],"Out":[{"Name":"qNames"}]},"SetFavoriteVariables":{"In":[{"Name":"qNames","DefaultValue":[""]}],"Out":[]},"GetIncludeFileContent":{"In":[{"Name":"qPath","DefaultValue":""}],"Out":[{"Name":"qContent"}]},"CreateConnection":{"In":[{"Name":"qConnection","DefaultValue":{"qId":"","qName":"","qConnectionString":"","qType":"","qUserName":"","qPassword":"","qModifiedDate":"","qMeta":{"qName":""},"qLogOn":0}}],"Out":[{"Name":"qConnectionId"}]},"ModifyConnection":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qConnection","DefaultValue":{"qId":"","qName":"","qConnectionString":"","qType":"","qUserName":"","qPassword":"","qModifiedDate":"","qMeta":{"qName":""},"qLogOn":0}},{"Name":"qOverrideCredentials","DefaultValue":false,"Optional":true}],"Out":[]},"DeleteConnection":{"In":[{"Name":"qConnectionId","DefaultValue":""}],"Out":[]},"GetConnection":{"In":[{"Name":"qConnectionId","DefaultValue":""}],"Out":[{"Name":"qConnection"}]},"GetConnections":{"In":[],"Out":[{"Name":"qConnections"}]},"GetDatabaseInfo":{"In":[{"Name":"qConnectionId","DefaultValue":""}],"Out":[{"Name":"qInfo"}]},"GetDatabases":{"In":[{"Name":"qConnectionId","DefaultValue":""}],"Out":[{"Name":"qDatabases"}]},"GetDatabaseOwners":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qDatabase","DefaultValue":"","Optional":true}],"Out":[{"Name":"qOwners"}]},"GetDatabaseTables":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qDatabase","DefaultValue":"","Optional":true},{"Name":"qOwner","DefaultValue":"","Optional":true}],"Out":[{"Name":"qTables"}]},"GetDatabaseTableFields":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qDatabase","DefaultValue":"","Optional":true},{"Name":"qOwner","DefaultValue":"","Optional":true},{"Name":"qTable","DefaultValue":""}],"Out":[{"Name":"qFields"}]},"GetDatabaseTablePreview":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qDatabase","DefaultValue":"","Optional":true},{"Name":"qOwner","DefaultValue":"","Optional":true},{"Name":"qTable","DefaultValue":""},{"Name":"qConditions","DefaultValue":{"qType":0,"qWherePredicate":""},"Optional":true}],"Out":[{"Name":"qPreview"},{"Name":"qRowCount"}]},"GetFolderItemsForConnection":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true}],"Out":[{"Name":"qFolderItems"}]},"GuessFileType":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true}],"Out":[{"Name":"qDataFormat"}]},"GetFileTables":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true},{"Name":"qDataFormat","DefaultValue":{"qType":0,"qLabel":"","qQuote":"","qComment":"","qDelimiter":{"qName":"","qScriptCode":"","qNumber":0,"qIsMultiple":false},"qCodePage":0,"qHeaderSize":0,"qRecordSize":0,"qTabSize":0,"qIgnoreEOF":false,"qFixedWidthDelimiters":""}}],"Out":[{"Name":"qTables"}]},"GetFileTableFields":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true},{"Name":"qDataFormat","DefaultValue":{"qType":0,"qLabel":"","qQuote":"","qComment":"","qDelimiter":{"qName":"","qScriptCode":"","qNumber":0,"qIsMultiple":false},"qCodePage":0,"qHeaderSize":0,"qRecordSize":0,"qTabSize":0,"qIgnoreEOF":false,"qFixedWidthDelimiters":""}},{"Name":"qTable","DefaultValue":""}],"Out":[{"Name":"qFields"},{"Name":"qFormatSpec"}]},"GetFileTablePreview":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true},{"Name":"qDataFormat","DefaultValue":{"qType":0,"qLabel":"","qQuote":"","qComment":"","qDelimiter":{"qName":"","qScriptCode":"","qNumber":0,"qIsMultiple":false},"qCodePage":0,"qHeaderSize":0,"qRecordSize":0,"qTabSize":0,"qIgnoreEOF":false,"qFixedWidthDelimiters":""}},{"Name":"qTable","DefaultValue":""}],"Out":[{"Name":"qPreview"},{"Name":"qFormatSpec"}]},"GetFileTablesEx":{"In":[{"Name":"qConnectionId","DefaultValue":""},{"Name":"qRelativePath","DefaultValue":"","Optional":true},{"Name":"qDataFormat","DefaultValue":{"qType":0,"qLabel":"","qQuote":"","qComment":"","qDelimiter":{"qName":"","qScriptCode":"","qNumber":0,"qIsMultiple":false},"qCodePage":0,"qHeaderSize":0,"qRecordSize":0,"qTabSize":0,"qIgnoreEOF":false,"qFixedWidthDelimiters":""}}],"Out":[{"Name":"qTables"}]},"SendGenericCommandToCustomConnector":{"In":[{"Name":"qProvider","DefaultValue":""},{"Name":"qCommand","DefaultValue":""},{"Name":"qMethod","DefaultValue":""},{"Name":"qParameters","DefaultValue":[""]},{"Name":"qAppendConnection","DefaultValue":""}],"Out":[{"Name":"qResult"}]},"SearchSuggest":{"In":[{"Name":"qOptions","DefaultValue":{"qSearchFields":[""],"qContext":0,"qCharEncoding":0,"qAttributes":[""]}},{"Name":"qTerms","DefaultValue":[""]}],"Out":[{"Name":"qResult"}]},"SearchAssociations":{"In":[{"Name":"qOptions","DefaultValue":{"qSearchFields":[""],"qContext":0,"qCharEncoding":0,"qAttributes":[""]}},{"Name":"qTerms","DefaultValue":[""]},{"Name":"qPage","DefaultValue":{"qOffset":0,"qCount":0,"qMaxNbrFieldMatches":0,"qGroupOptions":[{"qGroupType":0,"qOffset":0,"qCount":0}],"qGroupItemOptions":[{"qGroupItemType":0,"qOffset":0,"qCount":0}]}}],"Out":[{"Name":"qResults"}]},"SelectAssociations":{"In":[{"Name":"qOptions","DefaultValue":{"qSearchFields":[""],"qContext":0,"qCharEncoding":0,"qAttributes":[""]}},{"Name":"qTerms","DefaultValue":[""]},{"Name":"qMatchIx","DefaultValue":0},{"Name":"qSoftLock","DefaultValue":null,"Optional":true}],"Out":[]},"SearchResults":{"In":[{"Name":"qOptions","DefaultValue":{"qSearchFields":[""],"qContext":0,"qCharEncoding":0,"qAttributes":[""]}},{"Name":"qTerms","DefaultValue":[""]},{"Name":"qPage","DefaultValue":{"qOffset":0,"qCount":0,"qMaxNbrFieldMatches":0,"qGroupOptions":[{"qGroupType":0,"qOffset":0,"qCount":0}],"qGroupItemOptions":[{"qGroupItemType":0,"qOffset":0,"qCount":0}]}}],"Out":[{"Name":"qResult"}]},"SearchObjects":{"In":[{"Name":"qOptions","DefaultValue":{"qAttributes":[""],"qCharEncoding":0}},{"Name":"qTerms","DefaultValue":[""]},{"Name":"qPage","DefaultValue":{"qOffset":0,"qCount":0,"qMaxNbrFieldMatches":0,"qGroupOptions":[{"qGroupType":0,"qOffset":0,"qCount":0}],"qGroupItemOptions":[{"qGroupItemType":0,"qOffset":0,"qCount":0}]}}],"Out":[{"Name":"qResult"}]}},"Global":{"AbortRequest":{"In":[{"Name":"qRequestId","DefaultValue":0}],"Out":[]},"AbortAll":{"In":[],"Out":[]},"GetProgress":{"In":[{"Name":"qRequestId","DefaultValue":0}],"Out":[{"Name":"qProgressData"}]},"QvVersion":{"In":[],"Out":[]},"OSVersion":{"In":[],"Out":[]},"OSName":{"In":[],"Out":[]},"QTProduct":{"In":[],"Out":[]},"GetDocList":{"In":[],"Out":[{"Name":"qDocList"}]},"GetInteract":{"In":[{"Name":"qRequestId","DefaultValue":0}],"Out":[{"Name":"qDef"}]},"InteractDone":{"In":[{"Name":"qRequestId","DefaultValue":0},{"Name":"qDef","DefaultValue":{"qType":0,"qTitle":"","qMsg":"","qButtons":0,"qLine":"","qOldLineNr":0,"qNewLineNr":0,"qPath":"","qHidden":false,"qResult":0,"qInput":""}}],"Out":[]},"GetAuthenticatedUser":{"In":[],"Out":[]},"CreateDocEx":{"In":[{"Name":"qDocName","DefaultValue":""},{"Name":"qUserName","DefaultValue":"","Optional":true},{"Name":"qPassword","DefaultValue":"","Optional":true},{"Name":"qSerial","DefaultValue":"","Optional":true},{"Name":"qLocalizedScriptMainSection","DefaultValue":"","Optional":true}],"Out":[{"Name":"qDocId"}]},"GetActiveDoc":{"In":[],"Out":[]},"AllowCreateApp":{"In":[],"Out":[]},"CreateApp":{"In":[{"Name":"qAppName","DefaultValue":""},{"Name":"qLocalizedScriptMainSection","DefaultValue":"","Optional":true}],"Out":[{"Name":"qSuccess"},{"Name":"qAppId"}]},"DeleteApp":{"In":[{"Name":"qAppId","DefaultValue":""}],"Out":[{"Name":"qSuccess"}]},"IsDesktopMode":{"In":[],"Out":[]},"GetConfiguration":{"In":[],"Out":[{"Name":"qConfig"}]},"CancelRequest":{"In":[{"Name":"qRequestId","DefaultValue":0}],"Out":[]},"ShutdownProcess":{"In":[],"Out":[]},"ReloadExtensionList":{"In":[],"Out":[]},"ReplaceAppFromID":{"In":[{"Name":"qTargetAppId","DefaultValue":""},{"Name":"qSrcAppID","DefaultValue":""},{"Name":"qIds","DefaultValue":[""]}],"Out":[{"Name":"qSuccess"}]},"CopyApp":{"In":[{"Name":"qTargetAppId","DefaultValue":""},{"Name":"qSrcAppId","DefaultValue":""},{"Name":"qIds","DefaultValue":[""]}],"Out":[{"Name":"qSuccess"}]},"ImportApp":{"In":[{"Name":"qAppId","DefaultValue":""},{"Name":"qSrcPath","DefaultValue":""},{"Name":"qIds","DefaultValue":[""]}],"Out":[{"Name":"qSuccess"}]},"ImportAppEx":{"In":[{"Name":"qAppId","DefaultValue":""},{"Name":"qSrcPath","DefaultValue":""},{"Name":"qIds","DefaultValue":[""]},{"Name":"qExcludeConnections","DefaultValue":false}],"Out":[]},"ExportApp":{"In":[{"Name":"qTargetPath","DefaultValue":""},{"Name":"qSrcAppId","DefaultValue":""},{"Name":"qIds","DefaultValue":[""]}],"Out":[{"Name":"qSuccess"}]},"PublishApp":{"In":[{"Name":"qAppId","DefaultValue":""},{"Name":"qName","DefaultValue":""},{"Name":"qStreamId","DefaultValue":""}],"Out":[]},"IsPersonalMode":{"In":[],"Out":[]},"GetUniqueID":{"In":[],"Out":[{"Name":"qUniqueID"}]},"OpenDoc":{"In":[{"Name":"qDocName","DefaultValue":""},{"Name":"qUserName","DefaultValue":"","Optional":true},{"Name":"qPassword","DefaultValue":"","Optional":true},{"Name":"qSerial","DefaultValue":"","Optional":true},{"Name":"qNoData","DefaultValue":false,"Optional":true}],"Out":[]},"CreateSessionApp":{"In":[],"Out":[{"Name":"qSessionAppId"}]},"CreateSessionAppFromApp":{"In":[{"Name":"qSrcAppId","DefaultValue":""}],"Out":[{"Name":"qSessionAppId"}]},"ProductVersion":{"In":[],"Out":[]},"GetAppEntry":{"In":[{"Name":"qAppID","DefaultValue":""}],"Out":[{"Name":"qEntry"}]},"ConfigureReload":{"In":[{"Name":"qCancelOnScriptError","DefaultValue":false},{"Name":"qUseErrorData","DefaultValue":false},{"Name":"qInteractOnError","DefaultValue":false}],"Out":[]},"CancelReload":{"In":[],"Out":[]},"GetBNF":{"In":[{"Name":"qBnfType","DefaultValue":0}],"Out":[{"Name":"qBnfDefs"}]},"GetFunctions":{"In":[{"Name":"qGroup","DefaultValue":0,"Optional":true}],"Out":[{"Name":"qFunctions"}]},"GetOdbcDsns":{"In":[],"Out":[{"Name":"qOdbcDsns"}]},"GetOleDbProviders":{"In":[],"Out":[{"Name":"qOleDbProviders"}]},"GetDatabasesFromConnectionString":{"In":[{"Name":"qConnection","DefaultValue":{"qId":"","qName":"","qConnectionString":"","qType":"","qUserName":"","qPassword":"","qModifiedDate":"","qMeta":{"qName":""},"qLogOn":0}}],"Out":[{"Name":"qDatabases"}]},"IsValidConnectionString":{"In":[{"Name":"qConnection","DefaultValue":{"qId":"","qName":"","qConnectionString":"","qType":"","qUserName":"","qPassword":"","qModifiedDate":"","qMeta":{"qName":""},"qLogOn":0}}],"Out":[]},"GetDefaultAppFolder":{"In":[],"Out":[{"Name":"qPath"}]},"GetMyDocumentsFolder":{"In":[],"Out":[{"Name":"qFolder"}]},"GetLogicalDriveStrings":{"In":[],"Out":[{"Name":"qDrives"}]},"GetFolderItemsForPath":{"In":[{"Name":"qPath","DefaultValue":""}],"Out":[{"Name":"qFolderItems"}]},"GetSupportedCodePages":{"In":[],"Out":[{"Name":"qCodePages"}]},"GetCustomConnectors":{"In":[{"Name":"qReloadList","DefaultValue":false,"Optional":true}],"Out":[{"Name":"qConnectors"}]},"GetStreamList":{"In":[],"Out":[{"Name":"qStreamList"}]},"UploadToContentService":{"In":[{"Name":"qDirectory","DefaultValue":""},{"Name":"qAppId","DefaultValue":""},{"Name":"qQrsObjects","DefaultValue":[{"qEngineObjectID":"","qItemID":""}]}],"Out":[{"Name":"qUploadedObjects"}]},"EngineVersion":{"In":[],"Out":[{"Name":"qVersion"}]},"GetBaseBNF":{"In":[{"Name":"qBnfType","DefaultValue":0}],"Out":[{"Name":"qBnfDefs"},{"Name":"qBnfHash"}]},"GetBaseBNFHash":{"In":[{"Name":"qBnfType","DefaultValue":0}],"Out":[{"Name":"qBnfHash"}]}}},"enums":{"LocalizedMessageCode":{"LOCMSG_SCRIPTEDITOR_EMPTY_MESSAGE":0,"LOCMSG_SCRIPTEDITOR_PROGRESS_SAVING_STARTED":1,"LOCMSG_SCRIPTEDITOR_PROGRESS_BYTES_LEFT":2,"LOCMSG_SCRIPTEDITOR_PROGRESS_STORING_TABLES":3,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVD_ROWS_SO_FAR":4,"LOCMSG_SCRIPTEDITOR_PROGRESS_CONNECTED":5,"LOCMSG_SCRIPTEDITOR_PROGRESS_CONNECTING_TO":6,"LOCMSG_SCRIPTEDITOR_PROGRESS_CONNECT_FAILED":7,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVD_ROWISH":8,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVD_COLUMNAR":9,"LOCMSG_SCRIPTEDITOR_ERROR":10,"LOCMSG_SCRIPTEDITOR_DONE":11,"LOCMSG_SCRIPTEDITOR_LOAD_EXTERNAL_DATA":12,"LOCMSG_SCRIPTEDITOR_PROGRESS_OLD_QVD_ISLOADING":13,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVC_LOADING":14,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVD_BUFFERED":15,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVC_PREPARING":16,"LOCMSG_SCRIPTEDITOR_PROGRESS_QVC_APPENDING":17,"LOCMSG_SCRIPTEDITOR_REMOVE_SYNTHETIC":18,"LOCMSG_SCRIPTEDITOR_PENDING_LINKEDTABLE_FETCHING":19,"LOCMSG_SCRIPTEDITOR_RELOAD":20,"LOCMSG_SCRIPTEDITOR_LINES_FETCHED":21,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_START":22,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_FIELD":23,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_SUCCESS":24,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_FAILURE":25,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_STARTABORT":26,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_ENDABORT":27,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_TIMEOUT":28,"LOCMSG_SCRIPTEDITOR_SEARCHINDEX_OUTOFMEMORY":29},"LocalizedErrorCode":{"LOCERR_INTERNAL_ERROR":-128,"LOCERR_GENERIC_UNKNOWN":-1,"LOCERR_GENERIC_OK":0,"LOCERR_GENERIC_NOT_SET":1,"LOCERR_GENERIC_NOT_FOUND":2,"LOCERR_GENERIC_ALREADY_EXISTS":3,"LOCERR_GENERIC_INVALID_PATH":4,"LOCERR_GENERIC_ACCESS_DENIED":5,"LOCERR_GENERIC_OUT_OF_MEMORY":6,"LOCERR_GENERIC_NOT_INITIALIZED":7,"LOCERR_GENERIC_INVALID_PARAMETERS":8,"LOCERR_GENERIC_EMPTY_PARAMETERS":9,"LOCERR_GENERIC_INTERNAL_ERROR":10,"LOCERR_GENERIC_CORRUPT_DATA":11,"LOCERR_GENERIC_MEMORY_INCONSISTENCY":12,"LOCERR_GENERIC_INVISIBLE_OWNER_ABORT":13,"LOCERR_GENERIC_PROHIBIT_VALIDATE":14,"LOCERR_GENERIC_ABORTED":15,"LOCERR_GENERIC_CONNECTION_LOST":16,"LOCERR_GENERIC_UNSUPPORTED_IN_PRODUCT_VERSION":17,"LOCERR_GENERIC_REST_CONNECTION_FAILURE":18,"LOCERR_HTTP_400":400,"LOCERR_HTTP_401":401,"LOCERR_HTTP_402":402,"LOCERR_HTTP_403":403,"LOCERR_HTTP_404":404,"LOCERR_HTTP_405":405,"LOCERR_HTTP_406":406,"LOCERR_HTTP_407":407,"LOCERR_HTTP_408":408,"LOCERR_HTTP_409":409,"LOCERR_HTTP_410":410,"LOCERR_HTTP_411":411,"LOCERR_HTTP_412":412,"LOCERR_HTTP_413":413,"LOCERR_HTTP_414":414,"LOCERR_HTTP_415":415,"LOCERR_HTTP_416":416,"LOCERR_HTTP_417":417,"LOCERR_HTTP_500":500,"LOCERR_HTTP_501":501,"LOCERR_HTTP_502":502,"LOCERR_HTTP_503":503,"LOCERR_HTTP_504":504,"LOCERR_HTTP_505":505,"LOCERR_HTTP_509":509,"LOCERR_HTTP_COULD_NOT_RESOLVE_HOST":700,"LOCERR_APP_ALREADY_EXISTS":1000,"LOCERR_APP_INVALID_NAME":1001,"LOCERR_APP_ALREADY_OPEN":1002,"LOCERR_APP_NOT_FOUND":1003,"LOCERR_APP_IMPORT_FAILED":1004,"LOCERR_APP_SAVE_FAILED":1005,"LOCERR_APP_CREATE_FAILED":1006,"LOCERR_APP_INVALID":1007,"LOCERR_APP_CONNECT_FAILED":1008,"LOCERR_APP_ALREADY_OPEN_IN_DIFFERENT_MODE":1009,"LOCERR_APP_MIGRATION_COULD_NOT_CONTACT_MIGRATION_SERVICE":1010,"LOCERR_APP_MIGRATION_COULD_NOT_START_MIGRATION":1011,"LOCERR_APP_MIGRATION_FAILURE":1012,"LOCERR_APP_SCRIPT_MISSING":1013,"LOCERR_CONNECTION_ALREADY_EXISTS":2000,"LOCERR_CONNECTION_NOT_FOUND":2001,"LOCERR_CONNECTION_FAILED_TO_LOAD":2002,"LOCERR_CONNECTION_FAILED_TO_IMPORT":2003,"LOCERR_CONNECTION_NAME_IS_INVALID":2004,"LOCERR_CONNECTOR_NO_FILE_STREAMING_SUPPORT":2300,"LOCERR_FILE_ACCESS_DENIED":3000,"LOCERR_FILE_NAME_INVALID":3001,"LOCERR_FILE_CORRUPT":3002,"LOCERR_FILE_NOT_FOUND":3003,"LOCERR_FILE_FORMAT_UNSUPPORTED":3004,"LOCERR_FILE_OPENED_IN_UNSUPPORTED_MODE":3005,"LOCERR_FILE_TABLE_NOT_FOUND":3006,"LOCERR_USER_ACCESS_DENIED":4000,"LOCERR_USER_IMPERSONATION_FAILED":4001,"LOCERR_SERVER_OUT_OF_SESSION_AND_USER_CALS":5000,"LOCERR_SERVER_OUT_OF_SESSION_CALS":5001,"LOCERR_SERVER_OUT_OF_USAGE_CALS":5002,"LOCERR_SERVER_OUT_OF_CALS":5003,"LOCERR_SERVER_OUT_OF_NAMED_CALS":5004,"LOCERR_SERVER_OFF_DUTY":5005,"LOCERR_SERVER_BUSY":5006,"LOCERR_SERVER_LICENSE_EXPIRED":5007,"LOCERR_SERVER_AJAX_DISABLED":5008,"LOCERR_HC_INVALID_OBJECT":6000,"LOCERR_HC_RESULT_TOO_LARGE":6001,"LOCERR_HC_INVALID_OBJECT_STATE":6002,"LOCERR_HC_MODAL_OBJECT_ERROR":6003,"LOCERR_CALC_INVALID_DEF":7000,"LOCERR_CALC_NOT_IN_LIB":7001,"LOCERR_CALC_HEAP_ERROR":7002,"LOCERR_CALC_TOO_LARGE":7003,"LOCERR_CALC_TIMEOUT":7004,"LOCERR_CALC_EVAL_CONDITION_FAILED":7005,"LOCERR_CALC_MIXED_LINKED_AGGREGATION":7006,"LOCERR_CALC_MISSING_LINKED":7007,"LOCERR_CALC_INVALID_COL_SORT":7008,"LOCERR_CALC_PAGES_TOO_LARGE":7009,"LOCERR_CALC_SEMANTIC_FIELD_NOT_ALLOWED":7010,"LOCERR_CALC_VALIDATION_STATE_INVALID":7011,"LOCERR_CALC_PIVOT_DIMENSIONS_ALREADY_EXISTS":7012,"LOCERR_CALC_MISSING_LINKED_FIELD":7013,"LOCERR_CALC_NOT_CALCULATED":7014,"LOCERR_LAYOUT_EXTENDS_INVALID_ID":8000,"LOCERR_LAYOUT_LINKED_OBJECT_NOT_FOUND":8001,"LOCERR_LAYOUT_LINKED_OBJECT_INVALID":8002,"LOCERR_PERSISTENCE_WRITE_FAILED":9000,"LOCERR_PERSISTENCE_READ_FAILED":9001,"LOCERR_PERSISTENCE_DELETE_FAILED":9002,"LOCERR_PERSISTENCE_NOT_FOUND":9003,"LOCERR_PERSISTENCE_UNSUPPORTED_VERSION":9004,"LOCERR_PERSISTENCE_MIGRATION_FAILED_READ_ONLY":9005,"LOCERR_PERSISTENCE_MIGRATION_CANCELLED":9006,"LOCERR_PERSISTENCE_MIGRATION_BACKUP_FAILED":9007,"LOCERR_PERSISTENCE_DISK_FULL":9008,"LOCERR_PERSISTENCE_NOT_SUPPORTED_FOR_SESSION_APP":9009,"LOCERR_PERSISTENCE_SYNC_SET_CHUNK_INVALID_PARAMETERS":9510,"LOCERR_PERSISTENCE_SYNC_GET_CHUNK_INVALID_PARAMETERS":9511,"LOCERR_SCRIPT_DATASOURCE_ACCESS_DENIED":10000,"LOCERR_RELOAD_IN_PROGRESS":11000,"LOCERR_RELOAD_TABLE_X_NOT_FOUND":11001,"LOCERR_RELOAD_UNKNOWN_STATEMENT":11002,"LOCERR_RELOAD_EXPECTED_SOMETHING_FOUND_UNKNOWN":11003,"LOCERR_RELOAD_EXPECTED_NOTHING_FOUND_UNKNOWN":11004,"LOCERR_RELOAD_EXPECTED_ONE_OF_1_TOKENS_FOUND_UNKNOWN":11005,"LOCERR_RELOAD_EXPECTED_ONE_OF_2_TOKENS_FOUND_UNKNOWN":11006,"LOCERR_RELOAD_EXPECTED_ONE_OF_3_TOKENS_FOUND_UNKNOWN":11007,"LOCERR_RELOAD_EXPECTED_ONE_OF_4_TOKENS_FOUND_UNKNOWN":11008,"LOCERR_RELOAD_EXPECTED_ONE_OF_5_TOKENS_FOUND_UNKNOWN":11009,"LOCERR_RELOAD_EXPECTED_ONE_OF_6_TOKENS_FOUND_UNKNOWN":11010,"LOCERR_RELOAD_EXPECTED_ONE_OF_7_TOKENS_FOUND_UNKNOWN":11011,"LOCERR_RELOAD_EXPECTED_ONE_OF_8_OR_MORE_TOKENS_FOUND_UNKNOWN":11012,"LOCERR_RELOAD_FIELD_X_NOT_FOUND":11013,"LOCERR_RELOAD_MAPPING_TABLE_X_NOT_FOUND":11014,"LOCERR_RELOAD_LIB_CONNECTION_X_NOT_FOUND":11015,"LOCERR_RELOAD_NAME_ALREADY_TAKEN":11016,"LOCERR_RELOAD_WRONG_FILE_FORMAT_DIF":11017,"LOCERR_RELOAD_WRONG_FILE_FORMAT_BIFF":11018,"LOCERR_RELOAD_WRONG_FILE_FORMAT_ENCRYPTED":11019,"LOCERR_RELOAD_OPEN_FILE_ERROR":11020,"LOCERR_RELOAD_AUTO_GENERATE_COUNT":11021,"LOCERR_RELOAD_PE_ILLEGAL_PREFIX_COMB":11022,"LOCERR_RELOAD_MATCHING_CONTROL_STATEMENT_ERROR":11023,"LOCERR_RELOAD_MATCHING_LIBPATH_X_NOT_FOUND":11024,"LOCERR_RELOAD_MATCHING_LIBPATH_X_INVALID":11025,"LOCERR_RELOAD_MATCHING_LIBPATH_X_OUTSIDE":11026,"LOCERR_RELOAD_NO_QUALIFIED_PATH_FOR_FILE":11027,"LOCERR_RELOAD_MODE_STATEMENT_ONLY_FOR_LIB_PATHS":11028,"LOCERR_RELOAD_INCONSISTENT_USE_OF_SEMANTIC_FIELDS":11029,"LOCERR_RELOAD_NO_OPEN_DATABASE":11030,"LOCERR_RELOAD_AGGREGATION_REQUIRED_BY_GROUP_BY":11031,"LOCERR_RELOAD_CONNECT_MUST_USE_LIB_PREFIX_IN_THIS_MODE":11032,"LOCERR_RELOAD_ODBC_CONNECT_FAILED":11033,"LOCERR_RELOAD_OLEDB_CONNECT_FAILED":11034,"LOCERR_RELOAD_CUSTOM_CONNECT_FAILED":11035,"LOCERR_RELOAD_ODBC_READ_FAILED":11036,"LOCERR_RELOAD_OLEDB_READ_FAILED":11037,"LOCERR_RELOAD_CUSTOM_READ_FAILED":11038,"LOCERR_RELOAD_BINARY_LOAD_PROHIBITED":11039,"LOCERR_RELOAD_CONNECTOR_START_FAILED":11040,"LOCERR_RELOAD_CONNECTOR_NOT_RESPONDING":11041,"LOCERR_RELOAD_CONNECTOR_REPLY_ERROR":11042,"LOCERR_RELOAD_CONNECTOR_CONNECT_ERROR":11043,"LOCERR_RELOAD_CONNECTOR_NOT_FOUND_ERROR":11044,"LOCERR_PERSONAL_NEW_VERSION_AVAILABLE":12000,"LOCERR_PERSONAL_VERSION_EXPIRED":12001,"LOCERR_PERSONAL_SECTION_ACCESS_DETECTED":12002,"LOCERR_PERSONAL_APP_DELETION_FAILED":12003,"LOCERR_USER_AUTHENTICATION_FAILURE":12004,"LOCERR_EXPORT_OUT_OF_MEMORY":13000,"LOCERR_EXPORT_NO_DATA":13001,"LOCERR_SYNC_INVALID_OFFSET":14000,"LOCERR_SEARCH_TIMEOUT":15000,"LOCERR_DIRECT_DISCOVERY_LINKED_EXPRESSION_FAIL":16000,"LOCERR_DIRECT_DISCOVERY_ROWCOUNT_OVERFLOW":16001,"LOCERR_DIRECT_DISCOVERY_EMPTY_RESULT":16002,"LOCERR_DIRECT_DISCOVERY_DB_CONNECTION_FAILED":16003,"LOCERR_DIRECT_DISCOVERY_MEASURE_NOT_ALLOWED":16004,"LOCERR_DIRECT_DISCOVERY_DETAIL_NOT_ALLOWED":16005,"LOCERR_DIRECT_DISCOVERY_NOT_SYNTH_CIRCULAR_ALLOWED":16006,"LOCERR_DIRECT_DISCOVERY_ONLY_ONE_DD_TABLE_ALLOWED":16007,"LOCERR_DIRECT_DISCOVERY_DB_AUTHORIZATION_FAILED":16008,"LOCERR_SMART_LOAD_TABLE_NOT_FOUND":17000,"LOCERR_SMART_LOAD_TABLE_DUPLICATED":17001,"LOCERR_VARIABLE_NO_NAME":18000,"LOCERR_VARIABLE_DUPLICATE_NAME":18001,"LOCERR_VARIABLE_INCONSISTENCY":18002,"LOCERR_MEDIA_LIBRARY_LIST_FAILED":19000,"LOCERR_MEDIA_LIBRARY_CONTENT_FAILED":19001,"LOCERR_MEDIA_BUNDLING_FAILED":19002,"LOCERR_MEDIA_UNBUNDLING_FAILED":19003,"LOCERR_MEDIA_LIBRARY_NOT_FOUND":19004,"LOCERR_FEATURE_DISABLED":20000,"LOCERR_JSON_RPC_INVALID_REQUEST":-32600,"LOCERR_JSON_RPC_METHOD_NOT_FOUND":-32601,"LOCERR_JSON_RPC_INVALID_PARAMETERS":-32602,"LOCERR_JSON_RPC_INTERNAL_ERROR":-32603,"LOCERR_JSON_RPC_PARSE_ERROR":-32700,"LOCERR_MQ_SOCKET_CONNECT_FAILURE":33000,"LOCERR_MQ_SOCKET_OPEN_FAILURE":33001,"LOCERR_MQ_PROTOCOL_NO_RESPONE":33002,"LOCERR_MQ_PROTOCOL_LIBRARY_EXCEPTION":33003,"LOCERR_MQ_PROTOCOL_CONNECTION_CLOSED":33004,"LOCERR_MQ_PROTOCOL_CHANNEL_CLOSED":33005,"LOCERR_MQ_PROTOCOL_UNKNOWN_ERROR":33006,"LOCERR_MQ_PROTOCOL_INVALID_STATUS":33007,"LOCERR_EXTENGINE_GRPC_STATUS_OK":22000,"LOCERR_EXTENGINE_GRPC_STATUS_CANCELLED":22001,"LOCERR_EXTENGINE_GRPC_STATUS_UNKNOWN":22002,"LOCERR_EXTENGINE_GRPC_STATUS_INVALID_ARGUMENT":22003,"LOCERR_EXTENGINE_GRPC_STATUS_DEADLINE_EXCEEDED":22004,"LOCERR_EXTENGINE_GRPC_STATUS_NOT_FOUND":22005,"LOCERR_EXTENGINE_GRPC_STATUS_ALREADY_EXISTS":22006,"LOCERR_EXTENGINE_GRPC_STATUS_PERMISSION_DENIED":22007,"LOCERR_EXTENGINE_GRPC_STATUS_UNAUTHENTICATED":220016,"LOCERR_EXTENGINE_GRPC_STATUS_RESOURCE_EXHAUSTED":22008,"LOCERR_EXTENGINE_GRPC_STATUS_FAILED_PRECONDITION":22009,"LOCERR_EXTENGINE_GRPC_STATUS_ABORTED":22010,"LOCERR_EXTENGINE_GRPC_STATUS_OUT_OF_RANGE":22011,"LOCERR_EXTENGINE_GRPC_STATUS_UNIMPLEMENTED":22012,"LOCERR_EXTENGINE_GRPC_STATUS_INTERNAL":22013,"LOCERR_EXTENGINE_GRPC_STATUS_UNAVAILABLE":22014,"LOCERR_EXTENGINE_GRPC_STATUS_DATA_LOSS":22015},"LocalizedWarningCode":{"LOCWARN_PERSONAL_RELOAD_REQUIRED":0,"LOCWARN_PERSONAL_VERSION_EXPIRES_SOON":1,"LOCWARN_EXPORT_DATA_TRUNCATED":1000,"LOCWARN_COULD_NOT_OPEN_ALL_OBJECTS":2000},"GrpType":{"GRP_NX_NONE":0,"GRP_NX_HIEARCHY":1,"GRP_NX_COLLECTION":2},"ExportFileType":{"EXPORT_CSV_C":0,"EXPORT_CSV_T":1,"EXPORT_OOXML":2},"ExportState":{"EXPORT_POSSIBLE":0,"EXPORT_ALL":1},"DimCellType":{"NX_DIM_CELL_VALUE":0,"NX_DIM_CELL_EMPTY":1,"NX_DIM_CELL_NORMAL":2,"NX_DIM_CELL_TOTAL":3,"NX_DIM_CELL_OTHER":4,"NX_DIM_CELL_AGGR":5,"NX_DIM_CELL_PSEUDO":6,"NX_DIM_CELL_ROOT":7,"NX_DIM_CELL_NULL":8},"StackElemType":{"NX_STACK_CELL_NORMAL":0,"NX_STACK_CELL_TOTAL":1,"NX_STACK_CELL_OTHER":2,"NX_STACK_CELL_SUM":3,"NX_STACK_CELL_VALUE":4,"NX_STACK_CELL_PSEUDO":5},"SortIndicatorType":{"NX_SORT_INDICATE_NONE":0,"NX_SORT_INDICATE_ASC":1,"NX_SORT_INDICATE_DESC":2},"DimensionType":{"NX_DIMENSION_TYPE_DISCRETE":0,"NX_DIMENSION_TYPE_NUMERIC":1,"NX_DIMENSION_TYPE_TIME":2},"FieldSelectionMode":{"SELECTION_MODE_NORMAL":0,"SELECTION_MODE_AND":1,"SELECTION_MODE_NOT":2},"FrequencyMode":{"NX_FREQUENCY_NONE":0,"NX_FREQUENCY_VALUE":1,"NX_FREQUENCY_PERCENT":2,"NX_FREQUENCY_RELATIVE":3},"DataReductionMode":{"DATA_REDUCTION_NONE":0,"DATA_REDUCTION_ONEDIM":1,"DATA_REDUCTION_SCATTERED":2,"DATA_REDUCTION_CLUSTERED":3,"DATA_REDUCTION_STACKED":4},"HypercubeMode":{"DATA_MODE_STRAIGHT":0,"DATA_MODE_PIVOT":1,"DATA_MODE_PIVOT_STACK":2},"PatchOperationType":{"Add":0,"Remove":1,"Replace":2},"SelectionCellType":{"NX_CELL_DATA":0,"NX_CELL_TOP":1,"NX_CELL_LEFT":2},"MatchingFieldMode":{"MATCHINGFIELDMODE_MATCH_ALL":0,"MATCHINGFIELDMODE_MATCH_ONE":1},"SessionState":{"SESSION_CREATED":0,"SESSION_ATTACHED":1},"QrsChangeType":{"QRS_CHANGE_UNDEFINED":0,"QRS_CHANGE_ADD":1,"QRS_CHANGE_UPDATE":2,"QRS_CHANGE_DELETE":3},"ExtEngineDataType":{"NX_EXT_DATATYPE_STRING":0,"NX_EXT_DATATYPE_DOUBLE":1,"NX_EXT_DATATYPE_BOTH":2},"ExtEngineFunctionType":{"NX_EXT_FUNCTIONTYPE_SCALAR":0,"NX_EXT_FUNCTIONTYPE_AGGR":1,"NX_EXT_FUNCTIONTYPE_TENSOR":2},"ExtEngineMsgType":{"NX_EXT_MSGTYPE_FUNCTION_CALL":1,"NX_EXT_MSGTYPE_SCRIPT_CALL":2,"NX_EXT_MSGTYPE_RETURN_VALUE":3,"NX_EXT_MSGTYPE_RETURN_MULTIPLE":4,"NX_EXT_MSGTYPE_RETURN_ERROR":5}},"version":"12.20.0"};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * enigma.js v2.4.0
 * Copyright (c) 2018 QlikTech International AB
 * This library is licensed under MIT - See the LICENSE file for full details
 */

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.


  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  function stringifyPrimitive(v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  }

  function stringify (obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return map(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray(obj[k])) {
          return map(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);

    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq +
           encodeURIComponent(stringifyPrimitive(obj));
  }
  function map (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }

  var objectKeys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
  };

  function parse(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  }var QueryString = {
    encode: stringify,
    stringify: stringify,
    decode: parse,
    parse: parse
  };

  /**
  * The Qlik Sense configuration object.
  * @typedef {Object} SenseConfiguration
  * @property {String} [appId] The app id. If omitted, only the global object is returned.
  *                            Otherwise both global and app object are returned.
  * @property {Boolean} [noData=false] Whether to open the app without data.
  * @property {Boolean} [secure=true] Set to false if an unsecure WebSocket should be used.
  * @property {String} [host] Host address.
  * @property {Number} [port] Port to connect to.
  * @property {String} [prefix="/"] The absolute base path to use when connecting.
  *                             Used for proxy prefixes.
  * @property {String} [subpath=""] The subpath.
  * @property {String} [route=""] Used to instruct Proxy to route to the correct receiver.
  * @property {String} [identity=""] Identity to use.
  * @property {Object} [urlParams={}] Used to add parameters to the WebSocket URL.
  * @property {Number} [ttl] A value in seconds that QIX Engine should keep the session
  *                             alive after socket disconnect (only works if QIX Engine supports it).
  */

  function replaceLeadingAndTrailingSlashes(str) {
    return str.replace(/(^[/]+)|([/]+$)/g, '');
  }

  var SenseUtilities =
  /*#__PURE__*/
  function () {
    function SenseUtilities() {
      _classCallCheck(this, SenseUtilities);
    }

    _createClass(SenseUtilities, null, [{
      key: "configureDefaults",

      /**
      * Ensures that the configuration has defaults set.
      *
      * @private
      * @param {SenseConfiguration} senseConfig The configuration to ensure defaults on.
      */
      value: function configureDefaults(senseConfig) {
        if (!senseConfig.host) {
          senseConfig.host = 'localhost';
        }

        if (typeof senseConfig.secure === 'undefined') {
          senseConfig.secure = true;
        }

        if (!senseConfig.appId && !senseConfig.route) {
          senseConfig.route = 'app/engineData';
        }

        if (typeof senseConfig.noData === 'undefined') {
          senseConfig.noData = false;
        }
      }
      /**
      * Function used to build an URL.
      * @param {SenseConfiguration} urlConfig - The URL configuration object.
      * @returns {String} Returns the websocket URL.
      */

    }, {
      key: "buildUrl",
      value: function buildUrl(urlConfig) {
        SenseUtilities.configureDefaults(urlConfig);
        var secure = urlConfig.secure,
            host = urlConfig.host,
            port = urlConfig.port,
            prefix = urlConfig.prefix,
            subpath = urlConfig.subpath,
            route = urlConfig.route,
            identity = urlConfig.identity,
            urlParams = urlConfig.urlParams,
            ttl = urlConfig.ttl,
            appId = urlConfig.appId;
        var url = '';
        url += "".concat(secure ? 'wss' : 'ws', "://");
        url += host || 'localhost';

        if (port) {
          url += ":".concat(port);
        }

        if (prefix) {
          url += "/".concat(replaceLeadingAndTrailingSlashes(prefix));
        }

        if (subpath) {
          url += "/".concat(replaceLeadingAndTrailingSlashes(subpath));
        }

        if (route) {
          url += "/".concat(replaceLeadingAndTrailingSlashes(route));
        } else if (appId && appId !== '') {
          url += "/app/".concat(encodeURIComponent(appId));
        }

        if (identity) {
          url += "/identity/".concat(encodeURIComponent(identity));
        }

        if (ttl) {
          url += "/ttl/".concat(ttl);
        }

        if (urlParams) {
          url += "?".concat(QueryString.stringify(urlParams));
        }

        return url;
      }
    }]);

    return SenseUtilities;
  }();

  return SenseUtilities;

})));
//# sourceMappingURL=sense-utilities.js.map


/***/ }),
/* 33 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 34 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(36);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(41)(false);
// Imports
var getUrl = __webpack_require__(42);
var ___CSS_LOADER_URL___0___ = getUrl(__webpack_require__(43));
var ___CSS_LOADER_URL___1___ = getUrl(__webpack_require__(44));
// Module
exports.push([module.i, "@font-face {\n  font-family: \"LUI icons\";\n  src: url(" + ___CSS_LOADER_URL___0___ + ") format(\"woff\"), url(" + ___CSS_LOADER_URL___1___ + ") format(\"truetype\"); }\n\n/****************\n * QdtFilter\n*****************/\n.lui-select {\n  border-color: #ced4da !important; }\n\n.qdt-filter-state-counts-bar {\n  position: relative;\n  height: 0.25rem;\n  background-color: #dee2e6;\n  border-left: 1px solid #dee2e6;\n  border-right: 1px solid #dee2e6; }\n\n.O {\n  color: #212529 !important; }\n\n.S {\n  color: #f8f9fa !important;\n  background-color: #009845 !important; }\n\n.A {\n  color: #212529 !important;\n  background-color: #dddddd !important; }\n\n.X {\n  color: #f8f9fa !important;\n  background-color: #A9A9A9 !important; }\n\n.XS {\n  color: #f8f9fa !important;\n  background-color: #A9A9A9 !important; }\n\n.lui-list .lui-list__item {\n  cursor: pointer; }\n\n.lui-list .lui-list__item.S,\n.lui-list .lui-list__item.A,\n.lui-list .lui-list__item.X,\n.lui-list .lui-list__item.XS {\n  border-bottom: 1px solid #fff; }\n\n.fixed-table {\n  table-layout: fixed; }\n\nth {\n  position: relative;\n  cursor: pointer; }\n\nth, td {\n  overflow: hidden; }\n\nth.active:after {\n  position: absolute;\n  top: calc(50% - 0.125rem);\n  margin-left: 0.5rem;\n  content: \"\";\n  width: 0;\n  height: 0;\n  border-left: 0.5rem solid transparent;\n  border-right: 0.5rem solid transparent;\n  border-top: 0.5rem solid #666; }\n\n.lui-select {\n  border-radius: 0 !important; }\n\n.lui-tab.lui-active, .lui-tab:focus, .lui-tab.lui-focused {\n  border-bottom: 2px solid #52CC52; }\n\n/****************\n * QdtButton \n*****************/\n.qtd-button {\n  display: inline-block;\n  cursor: pointer; }\n\n/****************\n * QdtTable \n*****************/\n.qtd-table-header {\n  width: 100%;\n  width: calc(100% - 18px);\n  width: -moz-calc(100% - 18px);\n  width: -webkit-calc(100% - 18px); }\n\n.qtd-table-body {\n  width: 100%; }\n  .qtd-table-body tr:nth-child(even) {\n    background: #e9ecef; }\n\n/**********************\n * QdtSelectionToolbar\n**********************/\n.qdt-selection-toolbar ul {\n  padding: 0;\n  font-size: 13px; }\n  .qdt-selection-toolbar ul li {\n    display: inline-block;\n    padding-right: 5px; }\n    .qdt-selection-toolbar ul li .dropdown-item {\n      font-size: 13px;\n      padding-top: 5px;\n      padding-bottom: 5px;\n      padding-left: 10px;\n      padding-right: 25px; }\n    .qdt-selection-toolbar ul li lui-button {\n      border: 1px solid #ced4da;\n      padding: 5px 10px;\n      cursor: pointer;\n      position: relative;\n      display: inline-block; }\n    .qdt-selection-toolbar ul li .btn-secondary {\n      color: #212529 !important;\n      background-color: #FFFFFF !important;\n      font-size: 13px;\n      border: 0;\n      padding: 5px 10px; }\n      .qdt-selection-toolbar ul li .btn-secondary:focus {\n        box-shadow: 0; }\n    .qdt-selection-toolbar ul li .clear-all {\n      padding-left: 15px; }\n\n.qdt-selection-toolbar .lui-icon {\n  font-size: 13px;\n  padding-left: 2px; }\n\n.qdt-selection-toolbar .lui-icon--remove {\n  color: #dc3545;\n  cursor: pointer; }\n  .qdt-selection-toolbar .lui-icon--remove:hover {\n    color: #fd7e14; }\n  .qdt-selection-toolbar .lui-icon--remove.pull-right {\n    position: absolute;\n    right: 0;\n    padding-right: 5px; }\n\n/**********************\n * QdtChart\n**********************/\n.qtd-chart .qdt-chart-header {\n  height: 30px; }\n  .qtd-chart .qdt-chart-header .qdt-chart-selection {\n    text-align: right; }\n    .qtd-chart .qdt-chart-header .qdt-chart-selection .lui-button {\n      border: 0;\n      padding: 0;\n      margin-left: 5px; }\n      .qtd-chart .qdt-chart-header .qdt-chart-selection .lui-button .lui-icon--remove {\n        color: #F37777; }\n\n.qtd-chart .qdt-chart-svg {\n  position: relative; }\n  .qtd-chart .qdt-chart-svg rect:hover {\n    fill: #77b62a !important; }\n  .qtd-chart .qdt-chart-svg circle,\n  .qtd-chart .qdt-chart-svg rect,\n  .qtd-chart .qdt-chart-svg path {\n    cursor: pointer; }\n\n.qtd-chart::-webkit-scrollbar {\n  width: 10px;\n  height: 10px; }\n\n.qtd-chart::-webkit-scrollbar-track {\n  -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);\n  border-radius: 5px; }\n\n.qtd-chart::-webkit-scrollbar-thumb {\n  background-color: darkgrey;\n  outline: 1px solid slategrey;\n  border-radius: 5px; }\n\n.qdt-tooltip {\n  position: relative;\n  background: #000000;\n  border: 1px solid #d1d1d1;\n  color: white;\n  padding: 15px;\n  display: none;\n  z-index: 9999999; }\n  .qdt-tooltip:after, .qdt-tooltip:before {\n    top: 100%;\n    left: 50%;\n    border: solid transparent;\n    content: \" \";\n    height: 0;\n    width: 0;\n    position: absolute;\n    pointer-events: none; }\n  .qdt-tooltip:after {\n    border-color: rgba(0, 0, 0, 0);\n    border-top-color: #000000;\n    border-width: 10px;\n    margin-left: -10px; }\n  .qdt-tooltip:before {\n    border-color: rgba(209, 209, 209, 0);\n    border-top-color: #d1d1d1;\n    border-width: 11px;\n    margin-left: -11px; }\n\n/**********************\n * Preloader\n**********************/\n.qtd-preloader-bg {\n  background-color: black; }\n\n.qtd-preloader .qtd-preloader-ball1 {\n  background-color: rgba(0, 0, 0, 0);\n  border: 5px solid rgba(0, 183, 229, 0.9);\n  opacity: .9;\n  border-top: 5px solid rgba(0, 0, 0, 0);\n  border-left: 5px solid rgba(0, 0, 0, 0);\n  border-radius: 50px;\n  width: 50px;\n  height: 50px;\n  margin: 0 auto;\n  -moz-animation: spin .5s infinite linear;\n  -webkit-animation: spin .5s infinite linear; }\n\n.qtd-preloader .qtd-preloader-ball2 {\n  background-color: rgba(0, 0, 0, 0);\n  border: 5px solid rgba(0, 183, 229, 0.9);\n  opacity: .9;\n  border-top: 5px solid rgba(0, 0, 0, 0);\n  border-left: 5px solid rgba(0, 0, 0, 0);\n  border-radius: 50px;\n  width: 30px;\n  height: 30px;\n  margin: 0 auto;\n  position: relative;\n  top: -50px;\n  -moz-animation: spinoff .5s infinite linear;\n  -webkit-animation: spinoff .5s infinite linear; }\n\n.qtd-preloader .qtd-preloader-dots:after {\n  content: ' .';\n  animation: dots 500ms steps(5, end) infinite; }\n\n@-moz-keyframes spin {\n  0% {\n    -moz-transform: rotate(0deg); }\n  100% {\n    -moz-transform: rotate(360deg); } }\n\n@-moz-keyframes spinoff {\n  0% {\n    -moz-transform: rotate(0deg); }\n  100% {\n    -moz-transform: rotate(-360deg); } }\n\n@-webkit-keyframes spin {\n  0% {\n    -webkit-transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(360deg); } }\n\n@-webkit-keyframes spinoff {\n  0% {\n    -webkit-transform: rotate(0deg); }\n  100% {\n    -webkit-transform: rotate(-360deg); } }\n\n@keyframes dots {\n  0%, 20% {\n    color: rgba(0, 0, 0, 0);\n    text-shadow: 0.25em 0 0 rgba(0, 0, 0, 0), 0.5em 0 0 rgba(0, 0, 0, 0); }\n  40% {\n    color: white;\n    text-shadow: 0.25em 0 0 rgba(0, 0, 0, 0), 0.5em 0 0 rgba(0, 0, 0, 0); }\n  60% {\n    text-shadow: 0.25em 0 0 white, 0.5em 0 0 rgba(0, 0, 0, 0); }\n  80%, 100% {\n    text-shadow: .25em 0 0 white, .5em 0 0 white; } }\n\n/**********************\n * QdtSearch\n**********************/\n.lui-search {\n  border: 1px solid #dee2e6; }\n  .lui-search .lui-list.lui-list__item {\n    text-align: left; }\n\n/**********************\n * PICASSO\n**********************/\n.pic-tooltip-content {\n  padding: 8px 15px !important; }\n  .pic-tooltip-content .qdt-tooltip-header .qdt-tooltip-header-box {\n    position: relative;\n    display: inline-block;\n    width: 10px;\n    height: 12px;\n    left: -14px;\n    bottom: -2px; }\n  .pic-tooltip-content .qdt-tooltip-header .qdt-tooltip-header-title {\n    display: inline-block;\n    position: relative;\n    left: -10px; }\n  .pic-tooltip-content .qdt-tooltip-header .qdt-tooltip-header-measure {\n    display: inline-block;\n    text-align: right; }\n  .pic-tooltip-content .text-right {\n    text-align: right; }\n  .pic-tooltip-content .qdt-tooltip-row {\n    display: block; }\n    .pic-tooltip-content .qdt-tooltip-row .qdt-tooltip-col-label,\n    .pic-tooltip-content .qdt-tooltip-row .qdt-tooltip-col-value {\n      display: inline-block;\n      width: 50%;\n      padding-left: 5px; }\n    .pic-tooltip-content .qdt-tooltip-row .qdt-tooltip-col-value {\n      text-align: right; }\n", ""]);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], "{").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      // eslint-disable-next-line prefer-destructuring
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = modules[_i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (url, needQuotes) {
  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    // eslint-disable-next-line no-param-reassign
    url = url.slice(1, -1);
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, '\\n'), "\"");
  }

  return url;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "lui-icons.woff";

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "lui-icons.ttf";

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(46);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 46 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 49 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, "domPointLabel", function() { return domPointLabel; });
__webpack_require__.d(components_namespaceObject, "axis", function() { return axis; });
__webpack_require__.d(components_namespaceObject, "legend", function() { return legend; });
__webpack_require__.d(components_namespaceObject, "point", function() { return point; });
__webpack_require__.d(components_namespaceObject, "box", function() { return box; });
__webpack_require__.d(components_namespaceObject, "labels", function() { return components_labels; });
__webpack_require__.d(components_namespaceObject, "tooltip", function() { return tooltip; });
__webpack_require__.d(components_namespaceObject, "range", function() { return range; });
__webpack_require__.d(components_namespaceObject, "pie", function() { return pie; });
__webpack_require__.d(components_namespaceObject, "line", function() { return line; });
var interactions_namespaceObject = {};
__webpack_require__.r(interactions_namespaceObject);
__webpack_require__.d(interactions_namespaceObject, "itooltip", function() { return interactions_tooltip; });
__webpack_require__.d(interactions_namespaceObject, "pan", function() { return pan["a" /* default */]; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(2);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/extends.js
var helpers_extends = __webpack_require__(12);
var extends_default = /*#__PURE__*/__webpack_require__.n(helpers_extends);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(3);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(5);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(1);
var react_default = /*#__PURE__*/__webpack_require__.n(react);

// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(17);
var react_dom_default = /*#__PURE__*/__webpack_require__.n(react_dom);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectSpread.js
var objectSpread = __webpack_require__(11);
var objectSpread_default = /*#__PURE__*/__webpack_require__.n(objectSpread);

// CONCATENATED MODULE: ./src/utilities/Uid.js
function uid(length) {
  var ALPHABET = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  var ID_LENGTH = length || 8;
  var rtn = '';

  for (var i = 0; i < ID_LENGTH; i += 1) {
    rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));
  }

  return rtn;
}

/* harmony default export */ var Uid = (uid);
// CONCATENATED MODULE: ./src/utilities/RoundNum.js
function roundNumber(numb, precision) {
  var num = numb; // check if the string passed is number or contains formatting like 13%

  if (/^[0-9.]+$/.test(num)) {
    num = precision && num > 1000 ? parseFloat(num).toFixed(2) : Math.round(num);

    if (num >= 1000 && num < 1000000) {
      num = precision ? parseFloat(num / 1000).toFixed(2) : Math.round(num / 1000);

      if (/\.00$/.test(num)) {
        num = num.replace(/\.00$/, ''); // Remove .00
      }

      num += 'K'; // Add the abbreviation
    } else if (num >= 1000000 && num < 1000000000) {
      num = precision ? parseFloat(num / 1000000).toFixed(2) : Math.round(num / 1000000);

      if (/\.00$/.test(num)) {
        num = num.replace(/\.00$/, ''); // Remove .00
      }

      num += 'M'; // Add the abbreviation
    } else if (num >= 1000000000 && num < 1000000000000) {
      num = precision ? parseFloat(num / 1000000000).toFixed(2) : Math.round(num / 1000000000);

      if (/\.00$/.test(num)) {
        num = num.replace(/\.00$/, ''); // Remove .00
      }

      num += 'G'; // Add the abbreviation
    } else if (num >= 1000000000000) {
      num = precision ? parseFloat(num / 1000000000000).toFixed(2) : Math.round(num / 1000000000000);

      if (/\.00$/.test(num)) {
        num = num.replace(/\.00$/, ''); // Remove .00
      }

      num += 'T'; // Add the abbreviation
      // Change to B and add T
    }
  }

  return num;
}

/* harmony default export */ var RoundNum = (roundNumber);
// CONCATENATED MODULE: ./src/utilities/index.js


var globals = {
  qlik: null,
  resize: null
};
/* harmony default export */ var utilities = ({
  Uid: Uid,
  RoundNum: RoundNum,
  globals: globals
});
// CONCATENATED MODULE: ./src/qApp.js



 // let qlik;
// let { qlik } = utility.qlobals;

var capabilityApisPromise;

var loadCapabilityApis =
/*#__PURE__*/
function () {
  var _ref = asyncToGenerator_default()(
  /*#__PURE__*/
  regenerator_default.a.mark(function _callee(config) {
    var capabilityApisJS, prefix, capabilityApisCSS;
    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            if (!capabilityApisPromise) {
              _context.next = 5;
              break;
            }

            _context.next = 4;
            return capabilityApisPromise;

          case 4:
            return _context.abrupt("return");

          case 5:
            capabilityApisJS = document.createElement('script');
            prefix = config.prefix !== '' ? "/".concat(config.prefix) : '';
            capabilityApisJS.src = "".concat((config.secure ? 'https://' : 'http://') + config.host + (config.port ? ":".concat(config.port) : '') + prefix, "/resources/assets/external/requirejs/require.js");
            document.head.appendChild(capabilityApisJS);
            capabilityApisJS.loaded = new Promise(function (resolve) {
              capabilityApisJS.onload = function () {
                resolve();
              };
            });
            capabilityApisCSS = document.createElement('link');
            capabilityApisCSS.href = "".concat((config.secure ? 'https://' : 'http://') + config.host + (config.port ? ":".concat(config.port) : '') + prefix, "/resources/autogenerated/qlik-styles.css");
            capabilityApisCSS.type = 'text/css';
            capabilityApisCSS.rel = 'stylesheet';
            document.head.appendChild(capabilityApisCSS);
            capabilityApisCSS.loaded = new Promise(function (resolve) {
              capabilityApisCSS.onload = function () {
                resolve();
              };
            });
            capabilityApisPromise = Promise.all([capabilityApisJS.loaded, capabilityApisCSS.loaded]);
            _context.next = 19;
            return capabilityApisPromise;

          case 19:
            _context.next = 24;
            break;

          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](0);
            throw new Error(_context.t0);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 21]]);
  }));

  return function loadCapabilityApis(_x) {
    return _ref.apply(this, arguments);
  };
}();

var qApp_qApp =
/*#__PURE__*/
function () {
  var _ref2 = asyncToGenerator_default()(
  /*#__PURE__*/
  regenerator_default.a.mark(function _callee2(config) {
    var prefix;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return loadCapabilityApis(config);

          case 3:
            prefix = config.prefix !== '' ? "/".concat(config.prefix, "/") : '/';

            window.require.config({
              baseUrl: "".concat((config.secure ? 'https://' : 'http://') + config.host + (config.port ? ":".concat(config.port) : '') + prefix, "resources"),
              paths: {
                qlik: "".concat((config.secure ? 'https://' : 'http://') + config.host + (config.port ? ":".concat(config.port) : '') + prefix, "resources/js/qlik")
              },
              config: {
                text: {
                  useXhr: function useXhr() {
                    return true;
                  }
                }
              }
            });

            return _context2.abrupt("return", new Promise(function (resolve) {
              if (utilities.globals.qlik) {
                var app = utilities.globals.qlik.openApp(config.appId, objectSpread_default()({}, config, {
                  isSecure: config.secure,
                  prefix: prefix
                }));
                resolve(app);
              } else {
                window.require(['js/qlik'], function (q) {
                  utilities.globals.qlik = q;

                  utilities.globals.resize = function () {
                    q.resize();
                  };

                  var app = q.openApp(config.appId, objectSpread_default()({}, config, {
                    isSecure: config.secure,
                    prefix: prefix
                  }));
                  resolve(app);
                });
              }
            }));

          case 8:
            _context2.prev = 8;
            _context2.t0 = _context2["catch"](0);
            throw new Error(_context2.t0);

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 8]]);
  }));

  return function qApp(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

/* harmony default export */ var src_qApp = (qApp_qApp);
// CONCATENATED MODULE: ./src/qDoc.js



var enigma = __webpack_require__(30);

var schema = __webpack_require__(31);

var SenseUtilities = __webpack_require__(32);

var MAX_RETRIES = 3;
var responseInterceptors = [{
  // We only want to handle failed responses from QIX Engine:
  onRejected: function retryAbortedError(sessionReference, request, error) {
    // We only want to handle aborted QIX errors:
    if (error.code === schema.enums.LocalizedErrorCode.LOCERR_GENERIC_ABORTED) {
      // We keep track of how many consecutive times we have tried to do this call:
      request.tries = (request.tries || 0) + 1; // We do not want to get stuck in an infinite loop here if something has gone
      // awry, so we only retry until we have reached MAX_RETRIES:

      if (request.tries <= MAX_RETRIES) {
        return request.retry();
      }
    } // If it was not an aborted QIX call, or if we reached MAX_RETRIES, we let the error
    // trickle down to potential other interceptors, and finally down to resolving/rejecting
    // the initial promise that the user got when invoking the QIX method:


    return this.Promise.reject(error);
  }
}];

var qDoc_qDoc =
/*#__PURE__*/
function () {
  var _ref = asyncToGenerator_default()(
  /*#__PURE__*/
  regenerator_default.a.mark(function _callee(config) {
    var myConfig, url, session, global;
    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            myConfig = config; // Make it work for Qlik Core scaling https://github.com/qlik-oss/core-scaling
            // qlikcore/engine:12.248.0

            if (myConfig.core) {
              myConfig.subpath = myConfig.prefix ? "".concat(myConfig.prefix, "/app") : 'app';
              myConfig.route = "doc/".concat(myConfig.appId);
            }

            url = SenseUtilities.buildUrl(myConfig);
            session = enigma.create({
              schema: schema,
              url: url,
              responseInterceptors: responseInterceptors
            });
            _context.next = 6;
            return session.open();

          case 6:
            global = _context.sent;

            if (!myConfig.core) {
              _context.next = 9;
              break;
            }

            return _context.abrupt("return", global.getActiveDoc());

          case 9:
            return _context.abrupt("return", global.openDoc(myConfig.appId));

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function qDoc(_x) {
    return _ref.apply(this, arguments);
  };
}();

/* harmony default export */ var src_qDoc = (qDoc_qDoc);
// CONCATENATED MODULE: ./src/picasso/settings/components/domPointLabel.js
var component = {
  key: 'domPointLabel',
  type: 'domPointLabel',
  displayOrder: 1,
  data: {
    extract: {
      field: 'qDimensionInfo/0',
      props: {
        x: {
          field: 'qMeasureInfo/1'
        },
        y: {
          field: 'qMeasureInfo/0'
        }
      }
    }
  },
  settings: {
    x: {
      scale: 'x'
    },
    y: {
      scale: 'y'
    },
    fontSize: '10px',
    color: '#000000',
    offset: 30,
    width: 50,
    height: 10
  }
};
/* harmony default export */ var domPointLabel = (component);
// CONCATENATED MODULE: ./src/picasso/settings/components/axis.js
// https://picassojs.com/docs/component-axis.html
var axis_component = function component() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$scale = _ref.scale,
      scale = _ref$scale === void 0 ? 'x' : _ref$scale;

  var comp = {
    type: 'axis',
    key: "".concat(scale, "-axis"),
    scale: scale,
    dock: scale === 'x' ? 'bottom' : 'left',
    // formatter,
    settings: {
      labels: {
        show: true,
        mode: 'auto',
        align: 0.5,
        // invert: true,
        justify: 0
      },
      ticks: {
        show: true,
        // Toggle ticks on/off // Optional
        margin: 0,
        // Space in pixels between the ticks and the line. // Optional
        tickSize: 4 // Size of the ticks in pixels. // Optional

      },
      line: {
        show: true // Toggle line on/off // Optional

      },
      paddingStart: 0,
      // Optional

      /* Padding in direction perpendicular to the axis */
      paddingEnd: 10,
      // Optional

      /* Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right` */
      align: 'auto' // Optional
      //   align: 'left', // auto

    }
  }; // if (formatter) comp.formatter = formatter;

  return comp;
};

/* harmony default export */ var axis = (axis_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/legend.js
var legend_component = {
  type: 'legend-cat',
  key: 'legend',
  dock: 'right',
  scale: 'c',
  brush: {
    trigger: [{
      on: 'tap',
      contexts: ['select']
    }],
    consume: [{
      context: 'select',
      style: {
        active: {
          opacity: 1
        },
        inactive: {
          opacity: 0.5
        }
      }
    }]
  }
};
/* harmony default export */ var legend = (legend_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/point.js
var point_component = function component() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$key = _ref.key,
      key = _ref$key === void 0 ? 'point' : _ref$key,
      _ref$displayOrder = _ref.displayOrder,
      displayOrder = _ref$displayOrder === void 0 ? 1 : _ref$displayOrder,
      _ref$field = _ref.field,
      field = _ref$field === void 0 ? 'qDimensionInfo/0' : _ref$field,
      _ref$x = _ref.x,
      x = _ref$x === void 0 ? {
    field: 'qDimensionInfo/0'
  } : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? {
    field: 'qMeasureInfo/0'
  } : _ref$y,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0.5 : _ref$size,
      _ref$strokeWidth = _ref.strokeWidth,
      strokeWidth = _ref$strokeWidth === void 0 ? 2 : _ref$strokeWidth,
      _ref$stroke = _ref.stroke,
      stroke = _ref$stroke === void 0 ? '#fff' : _ref$stroke,
      _ref$fill = _ref.fill,
      fill = _ref$fill === void 0 ? {
    scale: 'c'
  } : _ref$fill;

  var comp = {
    type: 'point',
    key: key,
    displayOrder: displayOrder,
    data: {
      extract: {
        field: field,
        props: {
          x: x,
          y: y,
          num: {
            field: 'qMeasureInfo/0'
          }
        }
      }
    },
    settings: {
      x: {
        scale: 'x'
      },
      y: {
        scale: 'y'
      },
      shape: 'circle',
      size: size,
      strokeWidth: strokeWidth,
      stroke: stroke,
      opacity: 0.8,
      fill: fill
    },
    brush: {
      trigger: [{
        on: 'tap',
        contexts: ['select']
      }],
      consume: [{
        context: 'select',
        style: {
          active: {
            opacity: 1
          },
          inactive: {
            opacity: 0.5
          }
        }
      }]
    }
  };
  return comp;
};

/* harmony default export */ var point = (point_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/box.js
var box_component = function component() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$key = _ref.key,
      key = _ref$key === void 0 ? 'bar' : _ref$key,
      _ref$displayOrder = _ref.displayOrder,
      displayOrder = _ref$displayOrder === void 0 ? 1 : _ref$displayOrder,
      _ref$field = _ref.field,
      field = _ref$field === void 0 ? 'qDimensionInfo/0' : _ref$field,
      _ref$collection = _ref.collection,
      collection = _ref$collection === void 0 ? null : _ref$collection,
      _ref$orientation = _ref.orientation,
      orientation = _ref$orientation === void 0 ? 'vertical' : _ref$orientation,
      _ref$fill = _ref.fill,
      fill = _ref$fill === void 0 ? '#4477AA' : _ref$fill,
      _ref$strokeWidth = _ref.strokeWidth,
      strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth,
      _ref$stroke = _ref.stroke,
      stroke = _ref$stroke === void 0 ? '#D2D2D2' : _ref$stroke,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? 0 : _ref$start,
      _ref$end = _ref.end,
      end = _ref$end === void 0 ? {
    field: 'qMeasureInfo/0'
  } : _ref$end,
      _ref$measures = _ref.measures,
      measures = _ref$measures === void 0 ? 1 : _ref$measures;

  var comp = {
    type: 'box',
    key: key,
    displayOrder: displayOrder,
    data: {
      extract: {
        field: field,
        props: {
          start: start,
          end: end
        }
      }
    },
    settings: {
      major: {
        scale: orientation === 'vertical' ? 'x' : 'y'
      },
      minor: {
        scale: orientation === 'vertical' ? 'y' : 'x'
      },
      orientation: orientation,
      box: {
        fill: fill,
        strokeWidth: strokeWidth,
        stroke: stroke,
        width: 1 / measures
      }
    },
    brush: {
      trigger: [{
        on: 'tap',
        contexts: ['select']
      }],
      consume: [{
        context: 'select',
        style: {
          active: {
            opacity: 1
          },
          inactive: {
            opacity: 0.5
          }
        }
      }]
    }
  }; // If we initiate connection in the schema, we get errors

  if (collection) {
    comp.data = {
      collection: collection
    };
    comp.minor = {
      scale: 'y',
      ref: 'end'
    };
  }

  return comp;
};

/* harmony default export */ var box = (box_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/labels.js
var labels_labels = function labels() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$key = _ref.key,
      key = _ref$key === void 0 ? 'labels' : _ref$key,
      _ref$component = _ref.component,
      component = _ref$component === void 0 ? 'bar' : _ref$component,
      _ref$selector = _ref.selector,
      selector = _ref$selector === void 0 ? 'rect' : _ref$selector,
      _ref$displayOrder = _ref.displayOrder,
      displayOrder = _ref$displayOrder === void 0 ? 2 : _ref$displayOrder,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'down' : _ref$direction,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'bar' : _ref$type,
      _ref$insideFill = _ref.insideFill,
      insideFill = _ref$insideFill === void 0 ? '#FFFFFF' : _ref$insideFill,
      _ref$outsideFill = _ref.outsideFill,
      outsideFill = _ref$outsideFill === void 0 ? '#666666' : _ref$outsideFill;

  var comp = {
    type: 'labels',
    key: key,
    displayOrder: displayOrder,
    settings: {
      sources: [{
        component: component,
        selector: selector,
        strategy: {
          type: type,
          settings: {
            direction: direction,
            align: 0.5,
            justify: 0,
            fontSize: fontSize,
            labels: [{
              label: function label(_ref2) {
                var data = _ref2.data;
                var myLabel = '';
                if (data && component === 'bar') myLabel = data.end.label ? data.end.label : data.end.value; // Stacked barchar has only value

                if (data && component === 'pie') myLabel = "".concat(data.label, ": ").concat(data.num.label);
                if (data && component === 'line') myLabel = data.label;
                return myLabel;
              },
              placements: [{
                position: 'inside',
                fill: insideFill,
                justify: direction === 'down' ? 0 : 1
              }, {
                position: 'outside',
                fill: outsideFill
              }]
            }]
          }
        }
      }]
    }
  };
  return comp;
};

/* harmony default export */ var components_labels = (labels_labels);
// CONCATENATED MODULE: ./src/picasso/settings/components/tooltip.js
var tooltip_component = {
  key: 'tooltip',
  type: 'tooltip',
  displayOrder: 10,
  settings: {
    // Since we only want to target the point marker
    filter: function filter(nodes) {
      return nodes.filter(function (node) {
        return node.key === 'bar' || node.key === 'range' || node.key === 'point' || node.key === 'point2' || node.key === 'pie';
      });
    },
    //   node.key === 'legend');
    // Create the data model
    extract: function extract(_ref) {
      var node = _ref.node,
          resources = _ref.resources;
      var formatterFn = resources.formatter({
        type: 'd3-number',
        format: '.2s'
      });
      var dataProps = Object.keys(node.data).filter(function (key) {
        return key !== 'value' && key !== 'label' && key !== 'source' //   key !== 'legend' &&
        && key !== 'x' && key !== 'y' && key !== 'start';
      }).map(function (key) {
        var _node$data$key = node.data[key],
            label = _node$data$key.label,
            end = _node$data$key.end,
            value = _node$data$key.value; // Series for Stacked Barchart

        var myValue = label || value; // Value si for the Stacked bar

        var myLabel = node.data[key].source && node.data[key].source.field ? node.data[key].source.field : '';

        if (end) {
          var evalue = end.value;
          if (evalue) myValue = evalue;
        }

        if (Number.isNaN(myValue)) myValue = formatterFn(myValue);
        return {
          label: myLabel,
          value: myValue
        };
      });
      return {
        title: node.data.label,
        color: node.attrs.fill,
        props: dataProps
      };
    },
    // Generate virtual nodes
    content: function content(_ref2) {
      var h = _ref2.h,
          data = _ref2.data;
      var html = '';

      if (data.length && data[0].props.length === 1) {
        // Single Barchart
        html = h('div.qdt-tooltip-header', {}, [h('div.qdt-tooltip-header-box', {
          style: {
            backgroundColor: data[0].color
          }
        }, ''), h('div.qdt-tooltip-header-title', {}, "".concat(data[0].title, ": ")), h('div.qdt-tooltip-header-measure', {}, "".concat(data[0].props[0].value))]);
      } else if (data.length && data[0].props.length === 2) {
        html = h('div.qdt-tooltip-header', {}, [h('div.qdt-tooltip-header-box', {
          style: {
            backgroundColor: data[0].color
          }
        }, ''), h('div.qdt-tooltip-header-title', {}, "".concat(data[0].props[0].value, ": ")), h('div.qdt-tooltip-header-measure', {}, "".concat(data[0].props[1].value))]);
      }

      return h('div', {
        display: 'table'
      }, html);
    },
    afterShow: function afterShow(_ref3) {
      var element = _ref3.element;
      var e = element;
      e.children[0].style.opacity = 1;
      e.children[1].style.opacity = 1; // debugger;
    },
    onHide: function onHide(_ref4) {
      var element = _ref4.element;
      var e = element;
      e.children[0].style.opacity = 0;
      e.children[1].style.opacity = 0;
    },
    placement: {
      type: 'pointer',
      area: 'target'
    }
  },
  style: {
    content: {
      'border-spacing': '4px',
      opacity: 0,
      transition: 'opacity 150ms ease-in'
    },
    arrow: {
      opacity: 0,
      transition: 'opacity 150ms ease-in'
    }
  }
};
/* harmony default export */ var tooltip = (tooltip_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/range.js
var range_component = function component() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$scale = _ref.scale,
      scale = _ref$scale === void 0 ? 'x' : _ref$scale;

  var comp = {
    key: "".concat(scale, "Range"),
    type: 'brush-range',
    settings: {
      brush: 'select',
      direction: scale === 'x' ? 'horizontal' : 'vertical',
      scale: scale,
      target: {
        component: "".concat(scale, "-axis")
      },
      bubbles: {
        align: 'start'
      }
    }
  };
  return comp;
};

/* harmony default export */ var range = (range_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/pie.js
var pie_component = {
  key: 'pie',
  type: 'pie',
  displayOrder: 1,
  data: {
    extract: {
      field: 'qDimensionInfo/0',
      props: {
        num: {
          field: 'qMeasureInfo/0'
        }
      }
    }
  },
  settings: {
    slice: {
      arc: {
        ref: 'num'
      },
      fill: {
        scale: 'color'
      },
      outerRadius: function outerRadius() {
        return 0.9;
      },
      strokeWidth: 1,
      stroke: 'rgba(255, 255, 255, 0.5)'
    }
  } //   brush: {
  //     trigger: [{
  //       on: 'tap',
  //       // action: 'toggle',
  //       contexts: ['select'],
  //       // data: ['qDimension'],
  //       // propagation: 'stop', // 'stop' => prevent trigger from propagating further than the first shape
  //       // globalPropagation: 'stop', // 'stop' => prevent trigger of same type to be triggered on other components
  //       touchRadius: 24,
  //     }],
  //     consume: [{
  //       context: 'select',
  //       style: {
  //         active: {
  //           opacity: 1,
  //         },
  //         inactive: {
  //           opacity: 0.5,
  //         },
  //       },
  //     }],
  //   },

};
/* harmony default export */ var pie = (pie_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/line.js
var line_component = function component() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$key = _ref.key,
      key = _ref$key === void 0 ? 'line' : _ref$key,
      _ref$displayOrder = _ref.displayOrder,
      displayOrder = _ref$displayOrder === void 0 ? 1 : _ref$displayOrder,
      _ref$field = _ref.field,
      field = _ref$field === void 0 ? 'qDimensionInfo/0' : _ref$field,
      _ref$strokeWidth = _ref.strokeWidth,
      strokeWidth = _ref$strokeWidth === void 0 ? 2 : _ref$strokeWidth,
      _ref$stroke = _ref.stroke,
      stroke = _ref$stroke === void 0 ? '#4477AA' : _ref$stroke,
      _ref$fill = _ref.fill,
      fill = _ref$fill === void 0 ? '#4477AA' : _ref$fill,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? {
    field: 'qMeasureInfo/0'
  } : _ref$y,
      _ref$y2 = _ref.y0,
      y0 = _ref$y2 === void 0 ? '' : _ref$y2,
      _ref$minor = _ref.minor,
      minor = _ref$minor === void 0 ? {
    scale: 'y',
    ref: 'y'
  } : _ref$minor,
      _ref$area = _ref.area,
      area = _ref$area === void 0 ? false : _ref$area;

  var comp = {
    type: 'line',
    key: key,
    displayOrder: displayOrder,
    data: {
      extract: {
        field: field,
        props: {
          y: y,
          y0: y0
        }
      }
    },
    settings: {
      coordinates: {
        major: {
          scale: 'x'
        },
        minor: minor,
        minor0: y0 ? {
          scale: 'y',
          ref: 'y0'
        } : null
      },
      orientation: 'horizontal',
      layers: {
        curve: 'linear',
        show: true,
        line: {
          opacity: 1,
          stroke: stroke,
          strokeWidth: strokeWidth
        },
        area: {
          show: area,
          fill: fill,
          opacity: 0.8
        }
      }
    }
  };
  return comp;
};

/* harmony default export */ var line = (line_component);
// CONCATENATED MODULE: ./src/picasso/settings/components/index.js











// EXTERNAL MODULE: ./src/picasso/settings/interactions/pan.js
var pan = __webpack_require__(20);

// CONCATENATED MODULE: ./src/picasso/settings/interactions/tooltip.js
var interaction = {
  type: 'native',
  events: {
    mousemove: function mousemove(e) {
      this.chart.component('tooltip').emit('show', e);
    },
    mouseleave: function mouseleave() {
      this.chart.component('tooltip').emit('hide');
    }
  }
};
/* harmony default export */ var interactions_tooltip = (interaction);
// CONCATENATED MODULE: ./src/picasso/settings/interactions/index.js



// CONCATENATED MODULE: ./src/styles/index.js
var palette = ['#3399CC', // Light Blue
'#CC6666', // Light Red
'#99CC66', // Light Green
'#275378', // Blue
'#B35A01', // Orange
'#B974FD', // Purple
'#993300', // Dark Red
'#99CCCC', // Very light blue
'#669933', // Green
'#898989', // Gray
'#EDA1A1', '#C6E2A9', '#D4B881', '#137D77', // Dark Green
'#D7C2EC', // Light purple
'#FF5500', // Bright Orange
'#15DFDF', // Terquase
'#93A77E', // Olive Green
'#CB5090', // Dark Pink
'#BFBFBF', // Light Gray
'#d6d6d6', // Lighter Gray
'#eaeaea'];
var theme = {
  palette: palette,
  primary: palette[3],
  primaryLight: palette[0],
  secondary: palette[4],
  secondaryLight: palette[1],
  tertiary: palette[8],
  tertiaryLight: palette[2],
  quaternary: {},
  quinary: {},
  senary: {}
};
/* harmony default export */ var styles = (theme);
// CONCATENATED MODULE: ./src/picasso/settings/horizontalBarchart.js



var setting = {
  scales: {
    x: {
      data: {
        field: 'qMeasureInfo/0'
      },
      include: [0]
    },
    y: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.2
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), box({
    orientation: 'horizontal',
    fill: styles.primary,
    stroke: styles.primaryLight
  }), range({
    scale: 'y'
  }), components_labels({
    direction: 'right'
  }), tooltip],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])({
    scale: 'y'
  })]
};
/* harmony default export */ var horizontalBarchart = (setting);
// CONCATENATED MODULE: ./src/picasso/settings/verticalBarchart.js



var verticalBarchart_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.3
    },
    y: {
      data: {
        field: 'qMeasureInfo/0'
      },
      include: [0],
      invert: true
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), box({
    fill: styles.primary,
    stroke: styles.primaryLight
  }), range(), components_labels(), tooltip],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var verticalBarchart = (verticalBarchart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/scatterplot.js



var scatterplot_component = {
  scales: {
    x: {
      data: {
        field: 'qMeasureInfo/1'
      },
      expand: 0.1
    },
    y: {
      data: {
        field: 'qMeasureInfo/0'
      },
      expand: 0.2,
      invert: true
    },
    c: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      range: styles.palette,
      type: 'color'
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), legend, domPointLabel, point({
    x: {
      field: 'qMeasureInfo/1'
    }
  }), tooltip, range(), range({
    scale: 'y'
  })],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])(), Object(pan["a" /* default */])({
    scale: 'y'
  })]
};
/* harmony default export */ var scatterplot = (scatterplot_component);
// CONCATENATED MODULE: ./src/picasso/settings/scatterplotImage.js
/* harmony default export */ var scatterplotImage = ({
  scales: {
    s: {
      data: {
        field: 'qMeasureInfo/0'
      },
      expand: 0.2,
      invert: true
    },
    m: {
      data: {
        field: 'qMeasureInfo/1'
      },
      expand: 0.1
    },
    col: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      type: 'color'
    }
  },
  components: [{
    key: 'y-axis',
    type: 'axis',
    scale: 's',
    dock: 'left'
  }, {
    type: 'legend-cat',
    dock: 'right',
    scale: 'col',
    brush: {
      trigger: [{
        on: 'tap',
        contexts: ['select']
      }],
      consume: [{
        context: 'select',
        style: {
          active: {
            opacity: 1
          },
          inactive: {
            opacity: 0.5
          }
        }
      }]
    }
  }, {
    key: 'x-axis',
    type: 'axis',
    scale: 'm',
    dock: 'bottom'
  }, {
    key: 'tooltip',
    type: 'tooltip',
    background: 'white'
  }, {
    key: 'p',
    type: 'domPointImage',
    displayOrder: 1,
    data: {
      extract: {
        field: 'qDimensionInfo/0',
        props: {
          y: {
            field: 'qMeasureInfo/0'
          },
          x: {
            field: 'qMeasureInfo/1'
          }
        }
      }
    },
    settings: {
      x: {
        scale: 'm'
      },
      y: {
        scale: 's'
      },
      color: '#000'
    }
  }, {
    key: 'p',
    type: 'point',
    // Need this for tooltip to work
    data: {
      extract: {
        field: 'qDimensionInfo/0',
        props: {
          y: {
            field: 'qMeasureInfo/0'
          },
          x: {
            field: 'qMeasureInfo/1'
          },
          num: {
            field: 'qMeasureInfo/0'
          },
          qMeasure: {
            field: 'qMeasureInfo/0'
          },
          qMeasure2: {
            field: 'qMeasureInfo/1'
          },
          qDimension: function qDimension(data) {
            return data;
          }
        }
      }
    },
    settings: {
      x: {
        scale: 'm'
      },
      y: {
        scale: 's'
      },
      shape: 'rect',
      size: 0.2,
      opacity: 0,
      fill: {
        scale: 'col'
      }
    },
    brush: {
      trigger: [{
        on: 'tap',
        contexts: ['select']
      }],
      consume: [{
        context: 'select',
        style: {
          active: {
            opacity: 1
          },
          inactive: {
            opacity: 0.5
          }
        }
      }]
    }
  }],
  interactions: [{
    type: 'native',
    events: {
      mousemove: function mousemove(e) {
        this.chart.component('tooltip').emit('hover', e);
      }
    }
  }]
});
// CONCATENATED MODULE: ./src/picasso/settings/lineChart.js



var lineChart_setting = {
  scales: {
    y: {
      data: {
        field: 'qMeasureInfo/0'
      },
      expand: 0.1,
      invert: true
    },
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.2
    }
  },
  components: [{
    type: 'grid-line',
    y: 'y'
  }, axis(), axis({
    scale: 'y'
  }), tooltip, line({
    stroke: styles.primary
  }), point({
    displayOrder: 2,
    fill: styles.primary,
    stroke: styles.primaryLight
  }), range()],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var lineChart = (lineChart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/multiLineChart.js



var multiLineChart_setting = {
  scales: {
    y: {
      data: {
        fields: ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      invert: true,
      expand: 0.2
    },
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.2
    }
  },
  components: [{
    type: 'grid-line',
    y: 'y'
  }, axis(), axis({
    scale: 'y'
  }), tooltip, line({
    stroke: styles.primary
  }), point({
    displayOrder: 2,
    fill: styles.primary,
    stroke: styles.primaryLight
  }), line({
    key: 'line2',
    displayOrder: 3,
    y: {
      field: 'qMeasureInfo/1'
    },
    stroke: styles.secondary
  }), point({
    key: 'point2',
    displayOrder: 4,
    y: {
      field: 'qMeasureInfo/1'
    },
    fill: styles.secondary,
    stroke: styles.secondaryLight
  }), range()],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var multiLineChart = (multiLineChart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/pie.js


var pie_setting = {
  scales: {
    color: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      type: 'color'
    }
  },
  components: [legend, tooltip, pie, components_labels({
    component: 'pie',
    selector: 'path',
    type: 'slice',
    direction: 'horizontal'
  })],
  interactions: [interactions_tooltip]
};
/* harmony default export */ var settings_pie = (pie_setting);
// CONCATENATED MODULE: ./src/picasso/settings/comboLineBarchart.js



var comboLineBarchart_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.3
    },
    y: {
      data: {
        fields: ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      invert: true,
      expand: 0.2
    },
    c: {
      data: {
        field: 'qMeasureInfo/0'
      },
      type: 'color'
    }
  },
  components: [{
    type: 'grid-line',
    y: 'y'
  }, axis(), axis({
    scale: 'y'
  }), tooltip, box({
    fill: styles.primary,
    stroke: styles.primaryLight
  }), line({
    key: 'line2',
    displayOrder: 3,
    y: {
      field: 'qMeasureInfo/1'
    },
    stroke: styles.secondary
  }), point({
    key: 'point2',
    displayOrder: 4,
    y: {
      field: 'qMeasureInfo/1'
    },
    fill: styles.secondary,
    stroke: styles.secondaryLight
  }), components_labels({
    displayOrder: 3,
    direction: 'up'
  }), range()],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var comboLineBarchart = (comboLineBarchart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/stackedBarchart.js



var stackedBarchart_setting = {
  collections: [{
    key: 'stacked',
    data: {
      extract: {
        field: 'qDimensionInfo/0',
        props: {
          series: {
            field: 'qDimensionInfo/1'
          },
          end: {
            field: 'qMeasureInfo/0'
          }
        }
      },
      stack: {
        stackKey: function stackKey(d) {
          return d.value;
        },
        value: function value(d) {
          return d.end.value;
        }
      }
    }
  }],
  scales: {
    y: {
      data: {
        collection: {
          key: 'stacked'
        }
      },
      invert: true,
      expand: 0.2,
      min: 0
    },
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.3
    },
    c: {
      data: {
        extract: {
          field: 'qDimensionInfo/1'
        }
      },
      range: styles.palette,
      type: 'color'
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), legend, tooltip, range(), box({
    collection: 'stacked',
    fill: {
      scale: 'c',
      ref: 'series'
    }
  }), components_labels({
    displayOrder: 3,
    direction: 'up'
  })],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var stackedBarchart = (stackedBarchart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/verticalRangeGauge.js



var verticalRangeGauge_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qMeasureInfo/0'
        }
      },
      include: [1]
    },
    y: {
      data: {
        fields: ['qMeasureInfo/3', 'qMeasureInfo/4']
      },
      invert: true
    }
  },
  components: [axis({
    scale: 'y'
  }), tooltip, box({
    field: 'qMeasureInfo/0',
    start: {
      field: 'qMeasureInfo/3'
    },
    end: {
      field: 'qMeasureInfo/4'
    },
    fill: styles.palette[20],
    stroke: styles.palette[9]
  }), box({
    key: 'range',
    displayOrder: 2,
    field: 'qMeasureInfo/0',
    start: {
      field: 'qMeasureInfo/1'
    },
    end: {
      field: 'qMeasureInfo/2'
    },
    fill: styles.palette[8],
    stroke: styles.palette[9]
  }), box({
    key: 'line',
    displayOrder: 4,
    field: 'qMeasureInfo/0',
    start: {
      field: 'qMeasureInfo/0'
    },
    end: {
      field: 'qMeasureInfo/0'
    },
    fill: '#FFFFFF',
    stroke: '#FFFFFF'
  }), components_labels({
    displayOrder: 4,
    component: 'line',
    direction: 'up',
    outsideFill: '#FFFFFF',
    fontSize: 18
  })],
  interactions: [interactions_tooltip]
};
/* harmony default export */ var verticalRangeGauge = (verticalRangeGauge_setting);
// CONCATENATED MODULE: ./src/picasso/settings/verticalGauge.js



var verticalGauge_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qMeasureInfo/0'
        }
      },
      include: [1]
    },
    y: {
      min: 0,
      max: 100,
      invert: true
    }
  },
  components: [axis({
    scale: 'y'
  }), tooltip, box({
    field: 'qMeasureInfo/0',
    end: 100,
    fill: styles.palette[19],
    stroke: styles.palette[9]
  }), box({
    key: 'range',
    displayOrder: 2,
    field: 'qMeasureInfo/0',
    fill: styles.primary,
    stroke: styles.primaryLight
  }), box({
    key: 'line',
    displayOrder: 3,
    field: 'qMeasureInfo/0',
    start: {
      field: 'qMeasureInfo/0'
    },
    fill: '#FFFFFF',
    stroke: '#FFFFFF'
  }), components_labels({
    displayOrder: 4,
    component: 'line',
    direction: 'up',
    outsideFill: '#FFFFFF',
    fontSize: 18
  })],
  interactions: [interactions_tooltip]
};
/* harmony default export */ var verticalGauge = (verticalGauge_setting);
// CONCATENATED MODULE: ./src/picasso/settings/verticalGroupBarchart.js
 // box



var verticalGroupBarchart_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.3
    },
    y: {
      data: {
        fields: ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      include: [0],
      invert: true
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), box({
    displayOrder: 0,
    measures: 2,
    end: {
      field: 1
    },
    fill: styles.primary,
    stroke: styles.primaryLight
  }), box({
    displayOrder: 1,
    measures: 2,
    end: {
      field: 2
    },
    fill: styles.secondary,
    stroke: styles.secondaryLight
  }), range(), components_labels({
    displayOrder: 3,
    direction: 'up'
  }), tooltip],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var verticalGroupBarchart = (verticalGroupBarchart_setting);
// CONCATENATED MODULE: ./src/picasso/settings/rangeArea.js



var rangeArea_setting = {
  scales: {
    x: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.2
    },
    y: {
      data: {
        fields: ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      invert: true,
      expand: 0.2
    }
  },
  components: [{
    type: 'grid-line',
    y: 'y'
  }, axis(), axis({
    scale: 'y'
  }), tooltip, range(), line({
    y0: {
      field: 'qMeasureInfo/0'
    },
    y: {
      field: 'qMeasureInfo/1'
    },
    fill: styles.palette[20],
    area: true,
    stroke: styles.primary
  }), point({
    displayOrder: 2,
    y: {
      field: 'qMeasureInfo/1'
    },
    fill: styles.primary,
    stroke: styles.primaryLight
  }), line({
    key: 'line2',
    displayOrder: 3,
    y: {
      field: 'qMeasureInfo/0'
    },
    stroke: styles.secondary
  }), point({
    key: 'point2',
    displayOrder: 4,
    y: {
      field: 'qMeasureInfo/0'
    },
    fill: styles.secondary,
    stroke: styles.secondaryLight
  })],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])()]
};
/* harmony default export */ var rangeArea = (rangeArea_setting);
// CONCATENATED MODULE: ./src/picasso/settings/gantt.js



var gantt_setting = {
  scales: {
    x: {
      data: {
        fields: ['qMeasureInfo/0', 'qMeasureInfo/1']
      },
      expand: 0.1
    },
    y: {
      data: {
        extract: {
          field: 'qDimensionInfo/0'
        }
      },
      padding: 0.2
    }
  },
  components: [axis(), axis({
    scale: 'y'
  }), box({
    orientation: 'horizontal',
    start: {
      field: 'qMeasureInfo/0'
    },
    end: {
      field: 'qMeasureInfo/1'
    },
    fill: styles.primary,
    stroke: styles.primaryLight
  }), range({
    scale: 'y'
  }), components_labels({
    direction: 'right'
  }), tooltip],
  interactions: [interactions_tooltip, Object(pan["a" /* default */])({
    scale: 'y'
  })]
};
/* harmony default export */ var gantt = (gantt_setting);
// CONCATENATED MODULE: ./src/picasso/settings/index.js














/* harmony default export */ var picasso_settings = ({
  horizontalBarchart: horizontalBarchart,
  verticalBarchart: verticalBarchart,
  scatterplot: scatterplot,
  scatterplotImage: scatterplotImage,
  lineChart: lineChart,
  multiLineChart: multiLineChart,
  pie: settings_pie,
  comboLineBarchart: comboLineBarchart,
  stackedBarchart: stackedBarchart,
  verticalRangeGauge: verticalRangeGauge,
  verticalGauge: verticalGauge,
  verticalGroupBarchart: verticalGroupBarchart,
  rangeArea: rangeArea,
  gantt: gantt
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(6);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(7);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(8);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(9);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/applyDecoratedDescriptor.js
var applyDecoratedDescriptor = __webpack_require__(4);
var applyDecoratedDescriptor_default = /*#__PURE__*/__webpack_require__.n(applyDecoratedDescriptor);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(0);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ./node_modules/autobind-decorator/lib/esm/index.js
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Return a descriptor removing the value and returning a getter
 * The getter will return a .bind version of the function
 * and memoize the result against a symbol on the instance
 */
function boundMethod(target, key, descriptor) {
  var fn = descriptor.value;

  if (typeof fn !== 'function') {
    throw new TypeError("@boundMethod decorator can only be applied to methods not: ".concat(_typeof(fn)));
  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the
  // getter for the property which is being replaced. This causes infinite
  // recursion and an "Out of stack space" error.


  var definingProperty = false;
  return {
    configurable: true,
    get: function get() {
      // eslint-disable-next-line no-prototype-builtins
      if (definingProperty || this === target.prototype || this.hasOwnProperty(key) || typeof fn !== 'function') {
        return fn;
      }

      var boundFn = fn.bind(this);
      definingProperty = true;
      Object.defineProperty(this, key, {
        configurable: true,
        get: function get() {
          return boundFn;
        },
        set: function set(value) {
          fn = value;
          delete this[key];
        }
      });
      definingProperty = false;
      return boundFn;
    },
    set: function set(value) {
      fn = value;
    }
  };
}
/**
 * Use boundMethod to bind all methods on the target.prototype
 */

function boundClass(target) {
  // (Using reflect to get all keys including symbols)
  var keys; // Use Reflect if exists

  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {
    keys = Reflect.ownKeys(target.prototype);
  } else {
    keys = Object.getOwnPropertyNames(target.prototype); // Use symbols if support is provided

    if (typeof Object.getOwnPropertySymbols === 'function') {
      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));
    }
  }

  keys.forEach(function (key) {
    // Ignore special case target method
    if (key === 'constructor') {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding

    if (typeof descriptor.value === 'function') {
      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));
    }
  });
  return target;
}
function autobind() {
  if (arguments.length === 1) {
    return boundClass.apply(void 0, arguments);
  }

  return boundMethod.apply(void 0, arguments);
}
// EXTERNAL MODULE: ./node_modules/qdt-lui/dist/qdt-lui.js
var qdt_lui = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(16);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(13);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/styles/index.scss
var src_styles = __webpack_require__(14);

// CONCATENATED MODULE: ./src/utilities/Preloader.jsx




var Preloader_Preloader = function Preloader(props) {
  var width = props.width,
      height = props.height,
      paddingTop = props.paddingTop,
      type = props.type;

  if (type === 'dots') {
    return '...';
  }

  if (type === 'bgColor') {
    return react_default.a.createElement("div", {
      className: "qtd-preloader-bg",
      style: {
        width: width,
        height: height,
        'padding-top': paddingTop
      }
    });
  }

  return react_default.a.createElement("div", {
    className: "qtd-preloader",
    style: {
      width: width,
      height: height,
      'padding-top': paddingTop
    }
  }, react_default.a.createElement("div", {
    className: "qtd-preloader-ball1"
  }), react_default.a.createElement("div", {
    className: "qtd-preloader-ball2"
  }));
};

Preloader_Preloader.propTypes = {
  width: prop_types_default.a.string,
  height: prop_types_default.a.string,
  paddingTop: prop_types_default.a.string,
  type: prop_types_default.a.string
};
Preloader_Preloader.defaultProps = {
  width: '100%',
  height: '100%',
  paddingTop: 0,
  type: 'balls'
};
/* harmony default export */ var utilities_Preloader = (Preloader_Preloader);
// CONCATENATED MODULE: ./src/components/withListObject.jsx













/**
 * @name withListObject
 * @param {array} cols - The dimension for the ListObject
 * @param {object} qListObjectDef - Pass the entire Definition to bypass our creation object
 * @param {bool} autoSortByState - IF we want the selected to be always on top like Qlik Sense. Default true
 * @param {number} qSortByAscii [1] - For sorting the list by text. 1 = ASC, 0 = none, -1 = DESC
 * @param {number} qSortByLoadOrder [1] - For sorting the list by Sense load. 1 = ASC, 0 = none, -1 = DESC
 * @description
 * Creates a Session List Object
 * https://help.qlik.com/en-US/sense-developer/June2018/Subsystems/EngineAPI/Content/GenericObject/PropertyLevel/ListObjectDef.htm
 *
*/




function withListObject(Component) {
  var _class, _class2, _temp;

  return _class = (_temp = _class2 =
  /*#__PURE__*/
  function (_React$Component) {
    inherits_default()(_class, _React$Component);

    function _class(props) {
      var _this;

      classCallCheck_default()(this, _class);

      _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(_class).call(this, props));
      _this.state = {
        qObject: null,
        qLayout: null,
        qData: null,
        updating: false,
        error: null
      };
      return _this;
    }

    createClass_default()(_class, [{
      key: "componentWillMount",
      value: function () {
        var _componentWillMount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee() {
          var _this2 = this;

          var _this$props, qDocPromise, qPage, qDoc, qProp, qObject;

          return regenerator_default.a.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _this$props = this.props, qDocPromise = _this$props.qDocPromise, qPage = _this$props.qPage;
                  _context.next = 4;
                  return qDocPromise;

                case 4:
                  qDoc = _context.sent;
                  qProp = this.generateQProp();
                  _context.next = 8;
                  return qDoc.createSessionObject(qProp);

                case 8:
                  qObject = _context.sent;
                  qObject.on('changed', function () {
                    _this2.update();
                  });
                  this.setState({
                    qObject: qObject
                  }, function () {
                    _this2.update(qPage.qTop);
                  });
                  _context.next = 16;
                  break;

                case 13:
                  _context.prev = 13;
                  _context.t0 = _context["catch"](0);
                  this.setState({
                    error: _context.t0
                  });

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[0, 13]]);
        }));

        function componentWillMount() {
          return _componentWillMount.apply(this, arguments);
        }

        return componentWillMount;
      }()
    }, {
      key: "componentWillUnmount",
      value: function () {
        var _componentWillUnmount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee2() {
          var qDocPromise, id, qDoc;
          return regenerator_default.a.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  qDocPromise = this.props.qDocPromise;
                  id = this.state.qObject.id;
                  _context2.next = 4;
                  return qDocPromise;

                case 4:
                  qDoc = _context2.sent;
                  qDoc.destroySessionObject(id);

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function componentWillUnmount() {
          return _componentWillUnmount.apply(this, arguments);
        }

        return componentWillUnmount;
      }()
    }, {
      key: "getLayout",
      value: function () {
        var _getLayout = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee3() {
          var qObject, qLayout;
          return regenerator_default.a.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.prev = 0;
                  qObject = this.state.qObject;
                  _context3.next = 4;
                  return qObject.getLayout();

                case 4:
                  qLayout = _context3.sent;
                  return _context3.abrupt("return", qLayout);

                case 8:
                  _context3.prev = 8;
                  _context3.t0 = _context3["catch"](0);
                  this.setState({
                    error: _context3.t0
                  });
                  return _context3.abrupt("return", null);

                case 12:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this, [[0, 8]]);
        }));

        function getLayout() {
          return _getLayout.apply(this, arguments);
        }

        return getLayout;
      }()
    }, {
      key: "getData",
      value: function () {
        var _getData = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee4(qTop) {
          var qPage, qObject, qDataPages;
          return regenerator_default.a.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.prev = 0;
                  qPage = this.props.qPage;
                  qObject = this.state.qObject;
                  _context4.next = 5;
                  return qObject.getListObjectData('/qListObjectDef', [objectSpread_default()({}, qPage, {
                    qTop: qTop
                  })]);

                case 5:
                  qDataPages = _context4.sent;
                  return _context4.abrupt("return", qDataPages[0]);

                case 9:
                  _context4.prev = 9;
                  _context4.t0 = _context4["catch"](0);
                  this.setState({
                    error: _context4.t0
                  });
                  return _context4.abrupt("return", null);

                case 13:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this, [[0, 9]]);
        }));

        function getData(_x) {
          return _getData.apply(this, arguments);
        }

        return getData;
      }()
      /** Generate the Definition file */

    }, {
      key: "generateQProp",
      value: function generateQProp() {
        var currentColumn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        try {
          var _this$props2 = this.props,
              cols = _this$props2.cols,
              qListObjectDef = _this$props2.qListObjectDef,
              autoSortByState = _this$props2.autoSortByState,
              qSortByAscii = _this$props2.qSortByAscii,
              qSortByLoadOrder = _this$props2.qSortByLoadOrder;
          var qProp = {
            qInfo: {
              qType: 'visualization'
            }
          };

          if (qListObjectDef) {
            qProp.qListObjectDef = qListObjectDef;
          } else {
            var qDimensions = cols.filter(function (col) {
              return typeof col === 'string' && !col.startsWith('=') || typeof_default()(col) === 'object' && col.qDef && col.qDef.qFieldDefs || typeof_default()(col) === 'object' && col.qLibraryId && col.qType && col.qType === 'dimension';
            }).map(function (col) {
              if (typeof col === 'string') {
                return {
                  qDef: {
                    qFieldDefs: [col],
                    qSortCriterias: [{
                      qSortByAscii: qSortByAscii,
                      qSortByLoadOrder: qSortByLoadOrder
                    }]
                  }
                };
              }

              return col;
            });
            var qLibraryId = {
              qLibraryId: typeof_default()(cols[0]) === 'object' && cols[0].qLibraryId ? cols[0].qLibraryId : ''
            };
            var qDef = qDimensions[currentColumn];
            qProp.qListObjectDef = objectSpread_default()({}, qLibraryId, qDef, {
              qShowAlternatives: true,
              qAutoSortByState: {
                qDisplayNumberOfRows: autoSortByState
              }
            });
          }

          return qProp;
        } catch (error) {
          this.setState({
            error: error
          });
          return null;
        }
      }
    }, {
      key: "offset",
      value: function offset(qTop) {
        try {
          this.update(qTop);
        } catch (error) {
          this.setState({
            error: error
          });
        }
      }
    }, {
      key: "update",
      value: function () {
        var _update = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee5() {
          var qTopPassed,
              _ref,
              qDataGenerated,
              _ref2,
              qArea,
              _ref3,
              qTopGenerated,
              qTop,
              _ref4,
              _ref5,
              qLayout,
              qData,
              _args5 = arguments;

          return regenerator_default.a.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  qTopPassed = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : 0;
                  // Short-circuit evaluation because one line destructuring on Null values breaks on the browser.
                  _ref = this.state || {}, qDataGenerated = _ref.qData;
                  _ref2 = qDataGenerated || {}, qArea = _ref2.qArea;
                  _ref3 = qArea || {}, qTopGenerated = _ref3.qTop;
                  qTop = qTopPassed || qTopGenerated;
                  _context5.prev = 5;
                  this.setState({
                    updating: true
                  });
                  _context5.next = 9;
                  return Promise.all([this.getLayout(), this.getData(qTop)]);

                case 9:
                  _ref4 = _context5.sent;
                  _ref5 = slicedToArray_default()(_ref4, 2);
                  qLayout = _ref5[0];
                  qData = _ref5[1];
                  this.setState({
                    updating: false,
                    qLayout: qLayout,
                    qData: qData
                  });
                  _context5.next = 19;
                  break;

                case 16:
                  _context5.prev = 16;
                  _context5.t0 = _context5["catch"](5);
                  this.setState({
                    error: _context5.t0
                  });

                case 19:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[5, 16]]);
        }));

        function update() {
          return _update.apply(this, arguments);
        }

        return update;
      }()
    }, {
      key: "beginSelections",
      value: function () {
        var _beginSelections = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee6() {
          var qObject, qDocPromise, qDoc;
          return regenerator_default.a.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.prev = 0;
                  qObject = this.state.qObject;
                  qDocPromise = this.props.qDocPromise; // Make sure we close all other open selections. We usually get that when we have morethan one dropDown in the same page and while one is open, we click on the second one

                  _context6.next = 5;
                  return qDocPromise;

                case 5:
                  qDoc = _context6.sent;
                  _context6.next = 8;
                  return qDoc.abortModal(false);

                case 8:
                  _context6.next = 10;
                  return qObject.beginSelections(['/qListObjectDef']);

                case 10:
                  _context6.next = 15;
                  break;

                case 12:
                  _context6.prev = 12;
                  _context6.t0 = _context6["catch"](0);
                  this.setState({
                    error: _context6.t0
                  });

                case 15:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[0, 12]]);
        }));

        function beginSelections() {
          return _beginSelections.apply(this, arguments);
        }

        return beginSelections;
      }()
    }, {
      key: "endSelections",
      value: function () {
        var _endSelections = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee7(qAccept) {
          var qObject;
          return regenerator_default.a.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.prev = 0;
                  qObject = this.state.qObject;
                  _context7.next = 4;
                  return qObject.endSelections(qAccept);

                case 4:
                  _context7.next = 9;
                  break;

                case 6:
                  _context7.prev = 6;
                  _context7.t0 = _context7["catch"](0);
                  this.setState({
                    error: _context7.t0
                  });

                case 9:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[0, 6]]);
        }));

        function endSelections(_x2) {
          return _endSelections.apply(this, arguments);
        }

        return endSelections;
      }()
    }, {
      key: "select",
      value: function () {
        var _select = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee8(qElemNumber) {
          var toggle,
              ignoreLock,
              qObject,
              _args8 = arguments;
          return regenerator_default.a.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  toggle = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : true;
                  ignoreLock = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : false;
                  _context8.prev = 2;
                  qObject = this.state.qObject;
                  _context8.next = 6;
                  return qObject.selectListObjectValues('/qListObjectDef', [qElemNumber], toggle, ignoreLock);

                case 6:
                  _context8.next = 11;
                  break;

                case 8:
                  _context8.prev = 8;
                  _context8.t0 = _context8["catch"](2);
                  this.setState({
                    error: _context8.t0
                  });

                case 11:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this, [[2, 8]]);
        }));

        function select(_x3) {
          return _select.apply(this, arguments);
        }

        return select;
      }()
    }, {
      key: "searchListObjectFor",
      value: function () {
        var _searchListObjectFor = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee9(string) {
          var qObject;
          return regenerator_default.a.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  _context9.prev = 0;
                  qObject = this.state.qObject;
                  _context9.next = 4;
                  return qObject.searchListObjectFor('/qListObjectDef', string);

                case 4:
                  _context9.next = 9;
                  break;

                case 6:
                  _context9.prev = 6;
                  _context9.t0 = _context9["catch"](0);
                  this.setState({
                    error: _context9.t0
                  });

                case 9:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this, [[0, 6]]);
        }));

        function searchListObjectFor(_x4) {
          return _searchListObjectFor.apply(this, arguments);
        }

        return searchListObjectFor;
      }()
    }, {
      key: "acceptListObjectSearch",
      value: function () {
        var _acceptListObjectSearch = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee10() {
          var ignoreLock,
              qObject,
              _args10 = arguments;
          return regenerator_default.a.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  ignoreLock = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : false;
                  _context10.prev = 1;
                  qObject = this.state.qObject;
                  _context10.next = 5;
                  return qObject.acceptListObjectSearch('/qListObjectDef', true, ignoreLock);

                case 5:
                  _context10.next = 10;
                  break;

                case 7:
                  _context10.prev = 7;
                  _context10.t0 = _context10["catch"](1);
                  this.setState({
                    error: _context10.t0
                  });

                case 10:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this, [[1, 7]]);
        }));

        function acceptListObjectSearch() {
          return _acceptListObjectSearch.apply(this, arguments);
        }

        return acceptListObjectSearch;
      }()
    }, {
      key: "applyPatches",
      value: function () {
        var _applyPatches = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee11(patches) {
          var qObject;
          return regenerator_default.a.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _context11.prev = 0;
                  qObject = this.state.qObject;
                  _context11.next = 4;
                  return qObject.applyPatches(patches);

                case 4:
                  _context11.next = 9;
                  break;

                case 6:
                  _context11.prev = 6;
                  _context11.t0 = _context11["catch"](0);
                  this.setState({
                    error: _context11.t0
                  });

                case 9:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this, [[0, 6]]);
        }));

        function applyPatches(_x5) {
          return _applyPatches.apply(this, arguments);
        }

        return applyPatches;
      }()
      /** Finally return the Component with the ListObject items */

    }, {
      key: "render",
      value: function render() {
        var _this$state = this.state,
            qObject = _this$state.qObject,
            qLayout = _this$state.qLayout,
            qData = _this$state.qData,
            error = _this$state.error;

        if (error) {
          return react_default.a.createElement("div", null, error.message);
        }

        if (!qObject || !qLayout || !qData) {
          return react_default.a.createElement(utilities_Preloader, {
            width: "100%",
            height: "100%",
            paddingTop: "0",
            type: "bgColor"
          });
        }

        return react_default.a.createElement(Component, extends_default()({}, this.props, this.state, {
          offset: this.offset,
          select: this.select,
          beginSelections: this.beginSelections,
          endSelections: this.endSelections,
          searchListObjectFor: this.searchListObjectFor,
          acceptListObjectSearch: this.acceptListObjectSearch,
          applyPatches: this.applyPatches
        }));
      }
    }]);

    return _class;
  }(react_default.a.Component), _class2.propTypes = {
    qDocPromise: prop_types_default.a.object.isRequired,
    cols: prop_types_default.a.array,
    qListObjectDef: prop_types_default.a.object,
    qPage: prop_types_default.a.object,
    autoSortByState: prop_types_default.a.bool,
    qSortByAscii: prop_types_default.a.oneOf([1, 0, -1]),
    qSortByLoadOrder: prop_types_default.a.oneOf([1, 0, -1])
  }, _class2.defaultProps = {
    autoSortByState: 1,
    qSortByAscii: 1,
    qSortByLoadOrder: 1
  }, _class2.defaultProps = {
    cols: null,
    qListObjectDef: null,
    qPage: {
      qTop: 0,
      qLeft: 0,
      qWidth: 1,
      qHeight: 100
    }
  }, _temp), (applyDecoratedDescriptor_default()(_class.prototype, "offset", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "offset"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "beginSelections", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "beginSelections"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "endSelections", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "endSelections"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "select", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "select"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "searchListObjectFor", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "searchListObjectFor"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "acceptListObjectSearch", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "acceptListObjectSearch"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "applyPatches", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "applyPatches"), _class.prototype)), _class;
}
// CONCATENATED MODULE: ./src/components/QdtVirtualScroll.jsx








var QdtVirtualScroll_class, QdtVirtualScroll_class2, QdtVirtualScroll_temp;




var QdtVirtualScroll_QdtVirtualScroll = (QdtVirtualScroll_class = (QdtVirtualScroll_temp = QdtVirtualScroll_class2 =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtVirtualScroll, _React$Component);

  function QdtVirtualScroll(props) {
    var _this;

    classCallCheck_default()(this, QdtVirtualScroll);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtVirtualScroll).call(this, props));
    var _this$props = _this.props,
        viewportHeight = _this$props.viewportHeight,
        rowHeight = _this$props.rowHeight;
    _this.state = {
      start: 0,
      end: viewportHeight / rowHeight,
      translateY: 0
    };
    return _this;
  }

  createClass_default()(QdtVirtualScroll, [{
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var qcy = this.props.qcy;

      if (qcy !== nextProps.qcy) {
        this.node.scrollTop = 0;
      }
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(event) {
      var scrollTop = event.target.scrollTop;
      var _this$props2 = this.props,
          qData = _this$props2.qData,
          viewportHeight = _this$props2.viewportHeight,
          rowHeight = _this$props2.rowHeight,
          offset = _this$props2.offset;
      var numOfViewportItems = viewportHeight / rowHeight;
      var start = scrollTop / rowHeight;
      var end = start + numOfViewportItems;
      var translateY = rowHeight * start;

      if (qData.qArea.qTop > start) {
        var qTop = Math.max(0, start - qData.qArea.qHeight + numOfViewportItems);
        offset(qTop);
      } else if (qData.qArea.qTop + qData.qArea.qHeight < end) {
        var _qTop = start;
        offset(_qTop);
      }

      this.setState({
        start: start,
        end: end,
        translateY: translateY
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          qData = _this$props3.qData,
          qcy = _this$props3.qcy,
          viewportHeight = _this$props3.viewportHeight,
          rowHeight = _this$props3.rowHeight,
          Component = _this$props3.Component,
          componentProps = _this$props3.componentProps;
      var _this$state = this.state,
          start = _this$state.start,
          end = _this$state.end,
          translateY = _this$state.translateY;
      var qMatrix = qData.qMatrix.slice(start - qData.qArea.qTop, end - qData.qArea.qTop);
      return react_default.a.createElement("div", {
        ref: function ref(node) {
          return _this2.node = node;
        },
        style: {
          position: 'relative',
          height: "".concat(viewportHeight, "px"),
          overflowY: 'auto'
        },
        onScroll: this.handleScroll
      }, react_default.a.createElement("div", {
        style: {
          transform: "translateY(".concat(translateY, "px)"),
          width: '100%',
          maxHeight: '100%',
          overflow: 'hidden',
          position: 'absolute'
        }
      }, react_default.a.createElement(Component, extends_default()({}, componentProps, {
        qMatrix: qMatrix,
        rowHeight: rowHeight
      }))), react_default.a.createElement("div", {
        style: {
          height: "".concat(rowHeight * qcy, "px")
        }
      }));
    }
  }]);

  return QdtVirtualScroll;
}(react_default.a.Component), QdtVirtualScroll_class2.propTypes = {
  qData: prop_types_default.a.object.isRequired,
  qcy: prop_types_default.a.number.isRequired,
  Component: prop_types_default.a.func.isRequired,
  componentProps: prop_types_default.a.object,
  offset: prop_types_default.a.func.isRequired,
  rowHeight: prop_types_default.a.number,
  viewportHeight: prop_types_default.a.number
}, QdtVirtualScroll_class2.defaultProps = {
  componentProps: {},
  rowHeight: 40,
  viewportHeight: 200
}, QdtVirtualScroll_temp), (applyDecoratedDescriptor_default()(QdtVirtualScroll_class.prototype, "handleScroll", [autobind], Object.getOwnPropertyDescriptor(QdtVirtualScroll_class.prototype, "handleScroll"), QdtVirtualScroll_class.prototype)), QdtVirtualScroll_class);

// CONCATENATED MODULE: ./src/components/QdtFilter.jsx









var QdtFilter_class, QdtFilter_class2, QdtFilter_temp;

/**
 * @name QdtFilter
 * @param {bool} single [false] - If we want single selections only. For regular menu like components
 * @param {bool} hideStateCountsBar [false] -
 * @param {string} placeholder [Dropdown] - Custom text on the DropDown
 * @param {bool} showStateInDropdown [false] - Selection state in the placeholder
 * @param {bool} expanded [false] - Display as a list object
 * @param {bool} expandedHorizontal [false] - Display as tabs
 * @param {bool} expandedHorizontalSense [false] -
 * @param {bool} qSortByAscii [1] - For sorting the list. 1 = ASC, 0 = none, -1 = DESC
 * @description
 * Filter component for custom filters.
 * DropDown, List or Tabs
*/







/** Create the DropDown list */

var QdtFilter_DropdownItemList = function DropdownItemList(_ref) {
  var qMatrix = _ref.qMatrix,
      rowHeight = _ref.rowHeight,
      select = _ref.select;
  return react_default.a.createElement("span", null, qMatrix.map(function (row) {
    return react_default.a.createElement(qdt_lui["LuiListItem"], {
      className: "".concat(row[0].qState),
      key: row[0].qElemNumber,
      "data-q-elem-number": row[0].qElemNumber,
      "data-q-state": row[0].qState,
      "data-q-text": row[0].qText,
      onClick: select,
      style: {
        height: "".concat(rowHeight - 1, "px")
      }
    }, row[0].qText);
  }));
};

QdtFilter_DropdownItemList.propTypes = {
  qMatrix: prop_types_default.a.array.isRequired,
  rowHeight: prop_types_default.a.number.isRequired,
  select: prop_types_default.a.func.isRequired
};
/** Create the Tabs */

var QdtFilter_ExpandedHorizontalTab = function ExpandedHorizontalTab(_ref2) {
  var qData = _ref2.qData,
      select = _ref2.select,
      expandedHorizontalSense = _ref2.expandedHorizontalSense;
  var element = qData.qMatrix.map(function (row) {
    var className = expandedHorizontalSense ? "".concat(row[0].qState) : '';
    if (!expandedHorizontalSense && row[0].qState === 'S') className += ' lui-active';
    return react_default.a.createElement(qdt_lui["LuiTab"], {
      className: className,
      key: row[0].qElemNumber,
      "data-q-elem-number": row[0].qElemNumber,
      "data-q-state": row[0].qState,
      onClick: select
    }, row[0].qText);
  });
  return react_default.a.createElement("div", {
    style: {
      width: '100%',
      display: 'flex'
    }
  }, element);
};

QdtFilter_ExpandedHorizontalTab.propTypes = {
  qData: prop_types_default.a.array.isRequired,
  select: prop_types_default.a.func.isRequired,
  expandedHorizontalSense: prop_types_default.a.bool.isRequired
};
/** Create StateCountsBar (the green line below the dropdown) */

var QdtFilter_StateCountsBar = function StateCountsBar(_ref3) {
  var qStateCounts = _ref3.qStateCounts;
  var totalStateCounts = Object.values(qStateCounts).reduce(function (a, b) {
    return a + b;
  });
  var fillWidth = "".concat((qStateCounts.qOption + qStateCounts.qSelected) * 100 / totalStateCounts, "%");
  var fillStyle = {
    position: 'absolute',
    width: fillWidth,
    height: '100%',
    backgroundColor: '#52CC52',
    transition: 'width .6s ease'
  };
  return react_default.a.createElement("div", {
    className: "qdt-filter-state-counts-bar"
  }, react_default.a.createElement("div", {
    style: fillStyle
  }));
};

QdtFilter_StateCountsBar.propTypes = {
  qStateCounts: prop_types_default.a.object.isRequired
};
/** The Actual Component */

var QdtFilter_QdtFilterComponent = (QdtFilter_class = (QdtFilter_temp = QdtFilter_class2 =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtFilterComponent, _React$Component);

  function QdtFilterComponent(props) {
    var _this;

    classCallCheck_default()(this, QdtFilterComponent);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtFilterComponent).call(this, props));
    _this.getSelections =
    /*#__PURE__*/
    asyncToGenerator_default()(
    /*#__PURE__*/
    regenerator_default.a.mark(function _callee() {
      var qObject, qDataPages, selections;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              qObject = _this.props.qObject;
              _context.next = 3;
              return qObject.getListObjectData('/qListObjectDef', [{
                qWidth: 1,
                qHeight: 10000
              }]);

            case 3:
              qDataPages = _context.sent;
              selections = qDataPages[0].qMatrix.filter(function (row) {
                return row[0].qState === 'S';
              });

              _this.setState({
                selections: selections
              });

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    _this.state = {
      dropdownOpen: false,
      searchListInputValue: '',
      selections: null,
      placeholder: props.placeholder
    };
    return _this;
  }

  createClass_default()(QdtFilterComponent, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      var _this$props = this.props,
          showStateInDropdown = _this$props.showStateInDropdown,
          qObject = _this$props.qObject;

      if (showStateInDropdown) {
        this.getSelections();
        qObject.on('changed', this.getSelections);
      }
    } // componentDidMount() {
    //   window.addEventListener('click', this.handleOutsideClick);
    // }
    // componentWillUnmount() {
    //   window.removeEventListener('click', this.handleOutsideClick);
    // }

    /** Get the selected items of the current object */

  }, {
    key: "toggle",
    // handleOutsideClick = (event) => {
    //   const outsideClick = !this.node.contains(event.target);
    //   const { dropdownOpen } = this.state;
    //   const { endSelections } = this.props;
    //   if (dropdownOpen && outsideClick) {
    //     endSelections(false);
    //     this.clear();
    //   }
    // }

    /** Toggle dropdown visibility */
    value: function toggle() {
      var _this2 = this;

      var dropdownOpen = this.state.dropdownOpen;
      var _this$props2 = this.props,
          beginSelections = _this$props2.beginSelections,
          endSelections = _this$props2.endSelections;
      this.setState({
        dropdownOpen: !dropdownOpen
      }, function () {
        if (!dropdownOpen) {
          beginSelections();
        }

        if (dropdownOpen) {
          endSelections(true);

          _this2.clear();
        }
      });
    }
    /** Make Selections */

  }, {
    key: "select",
    value: function select(event) {
      var _event$currentTarget$ = event.currentTarget.dataset,
          qElemNumber = _event$currentTarget$.qElemNumber,
          qState = _event$currentTarget$.qState; // qText

      var _this$props3 = this.props,
          single = _this$props3.single,
          select = _this$props3.select; // placeholder

      if (qState === 'S') {
        select(Number(qElemNumber));
      } else {
        select(Number(qElemNumber), !single);
      }

      if (single) this.toggle();
    }
    /** Clear all of the selections */

  }, {
    key: "clear",
    value: function clear() {
      var searchListObjectFor = this.props.searchListObjectFor;
      this.setState({
        searchListInputValue: ''
      });
      searchListObjectFor('');
    }
  }, {
    key: "searchListObjectFor",
    value: function searchListObjectFor(event) {
      var _this$props4 = this.props,
          offset = _this$props4.offset,
          searchListObjectFor = _this$props4.searchListObjectFor;
      this.setState({
        searchListInputValue: event.target.value
      });
      offset(0);
      searchListObjectFor(event.target.value);
    }
  }, {
    key: "acceptListObjectSearch",
    value: function acceptListObjectSearch(event) {
      if (event.charCode === 13) {
        var acceptListObjectSearch = this.props.acceptListObjectSearch;
        this.setState({
          searchListInputValue: ''
        });
        acceptListObjectSearch();
      }
    }
    /** Finally start rendering into the Dom */

  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props5 = this.props,
          qData = _this$props5.qData,
          qLayout = _this$props5.qLayout,
          offset = _this$props5.offset,
          hideStateCountsBar = _this$props5.hideStateCountsBar,
          showStateInDropdown = _this$props5.showStateInDropdown,
          expanded = _this$props5.expanded,
          expandedHorizontal = _this$props5.expandedHorizontal,
          expandedHorizontalSense = _this$props5.expandedHorizontalSense;
      var _this$state = this.state,
          dropdownOpen = _this$state.dropdownOpen,
          searchListInputValue = _this$state.searchListInputValue,
          selections = _this$state.selections,
          placeholder = _this$state.placeholder;
      var qStateCounts = qLayout.qListObject.qDimensionInfo.qStateCounts;
      var qSelected = qStateCounts.qSelected;
      var totalStateCounts = Object.values(qStateCounts).reduce(function (a, b) {
        return a + b;
      });
      return react_default.a.createElement("div", {
        ref: function ref(node) {
          _this3.node = node;
        }
      }, !expanded && !expandedHorizontal && react_default.a.createElement(qdt_lui["LuiDropdown"], {
        isOpen: dropdownOpen,
        toggle: this.toggle
      }, react_default.a.createElement("span", null, !showStateInDropdown && placeholder, showStateInDropdown && selections && selections.length === 0 && placeholder, showStateInDropdown && selections && selections.length === 1 && "".concat(placeholder, ": ").concat(selections[0][0].qText), showStateInDropdown && selections && selections.length > 1 && "".concat(placeholder, ": ").concat(qSelected, " of ").concat(totalStateCounts)), react_default.a.createElement(qdt_lui["LuiList"], {
        style: {
          width: '15rem'
        }
      }, react_default.a.createElement(qdt_lui["LuiSearch"], {
        value: searchListInputValue,
        clear: this.clear,
        onChange: this.searchListObjectFor,
        onKeyPress: this.acceptListObjectSearch
      }), react_default.a.createElement(QdtVirtualScroll_QdtVirtualScroll, {
        qData: qData,
        qcy: qLayout.qListObject.qSize.qcy,
        Component: QdtFilter_DropdownItemList,
        componentProps: {
          select: this.select
        },
        offset: offset,
        rowHeight: 38,
        viewportHeight: 190
      })), !hideStateCountsBar && react_default.a.createElement(QdtFilter_StateCountsBar, {
        qStateCounts: qStateCounts
      })), expanded && react_default.a.createElement(qdt_lui["LuiList"], {
        style: {
          width: '15rem'
        }
      }, react_default.a.createElement(qdt_lui["LuiSearch"], {
        value: searchListInputValue,
        clear: this.clear,
        onChange: this.searchListObjectFor,
        onKeyPress: this.acceptListObjectSearch
      }), react_default.a.createElement(QdtVirtualScroll_QdtVirtualScroll, {
        qData: qData,
        qcy: qLayout.qListObject.qSize.qcy,
        Component: QdtFilter_DropdownItemList,
        componentProps: {
          select: this.select
        },
        offset: offset,
        rowHeight: 38,
        viewportHeight: 190
      })), expandedHorizontal && react_default.a.createElement(qdt_lui["LuiTabset"], {
        fill: true,
        style: {
          height: '100%'
        }
      }, react_default.a.createElement(QdtFilter_ExpandedHorizontalTab, {
        qData: qData,
        select: this.select,
        expandedHorizontalSense: expandedHorizontalSense
      })));
    }
  }]);

  return QdtFilterComponent;
}(react_default.a.Component), QdtFilter_class2.propTypes = {
  qObject: prop_types_default.a.object.isRequired,
  qData: prop_types_default.a.object.isRequired,
  qLayout: prop_types_default.a.object.isRequired,
  offset: prop_types_default.a.func.isRequired,
  select: prop_types_default.a.func.isRequired,
  beginSelections: prop_types_default.a.func.isRequired,
  endSelections: prop_types_default.a.func.isRequired,
  searchListObjectFor: prop_types_default.a.func.isRequired,
  acceptListObjectSearch: prop_types_default.a.func.isRequired,
  single: prop_types_default.a.bool,
  hideStateCountsBar: prop_types_default.a.bool,
  placeholder: prop_types_default.a.string,
  showStateInDropdown: prop_types_default.a.bool,
  expanded: prop_types_default.a.bool,
  expandedHorizontal: prop_types_default.a.bool,
  expandedHorizontalSense: prop_types_default.a.bool // qSortByAscii: PropTypes.oneOf([1, 0, -1]),

}, QdtFilter_class2.defaultProps = {
  single: false,
  hideStateCountsBar: false,
  placeholder: 'Dropdown',
  showStateInDropdown: false,
  expanded: false,
  expandedHorizontal: false,
  expandedHorizontalSense: true // qSortByAscii: 1,

}, QdtFilter_temp), (applyDecoratedDescriptor_default()(QdtFilter_class.prototype, "toggle", [autobind], Object.getOwnPropertyDescriptor(QdtFilter_class.prototype, "toggle"), QdtFilter_class.prototype), applyDecoratedDescriptor_default()(QdtFilter_class.prototype, "select", [autobind], Object.getOwnPropertyDescriptor(QdtFilter_class.prototype, "select"), QdtFilter_class.prototype), applyDecoratedDescriptor_default()(QdtFilter_class.prototype, "clear", [autobind], Object.getOwnPropertyDescriptor(QdtFilter_class.prototype, "clear"), QdtFilter_class.prototype), applyDecoratedDescriptor_default()(QdtFilter_class.prototype, "searchListObjectFor", [autobind], Object.getOwnPropertyDescriptor(QdtFilter_class.prototype, "searchListObjectFor"), QdtFilter_class.prototype), applyDecoratedDescriptor_default()(QdtFilter_class.prototype, "acceptListObjectSearch", [autobind], Object.getOwnPropertyDescriptor(QdtFilter_class.prototype, "acceptListObjectSearch"), QdtFilter_class.prototype)), QdtFilter_class);
/** Create the Component but based on the ListObject */

var QdtFilter = withListObject(QdtFilter_QdtFilterComponent);
QdtFilter.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  qListObjectDef: prop_types_default.a.object,
  qPage: prop_types_default.a.object,
  single: prop_types_default.a.bool,
  hideStateCountsBar: prop_types_default.a.bool,
  placeholder: prop_types_default.a.string,
  expanded: prop_types_default.a.bool,
  expandedHorizontal: prop_types_default.a.bool,
  expandedHorizontalSense: prop_types_default.a.bool,
  showStateInDropdown: prop_types_default.a.bool,
  autoSortByState: prop_types_default.a.bool
};
QdtFilter.defaultProps = {
  cols: null,
  qListObjectDef: null,
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 1,
    qHeight: 100
  },
  single: false,
  hideStateCountsBar: false,
  placeholder: 'Dropdown',
  expanded: false,
  expandedHorizontal: false,
  expandedHorizontalSense: true,
  showStateInDropdown: false,
  autoSortByState: 1
};
/* harmony default export */ var components_QdtFilter = (QdtFilter);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(15);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/components/withHyperCube.jsx












/**
 * @name withHyperCube
 * @param {array} cols - The dimension for the ListObject
 * @param {object} qListObjectDef - Pass the entire Definition to bypass our creation object
 * @param {bool} autoSortByState - IF we want the selected to be always on top like Qlik Sense. Default true
 * @param {number} qSortByAscii [1] - For sorting the list by text. 1 = ASC, 0 = none, -1 = DESC
 * @param {number} qSortByLoadOrder [1] - For sorting the list by Sense load. 1 = ASC, 0 = none, -1 = DESC
 * @description
 * Creates a Session List Object
 * https://help.qlik.com/en-US/sense-developer/June2018/Subsystems/EngineAPI/Content/GenericObject/PropertyLevel/HyperCubeDef.htm
 *
*/



function withHyperCube(Component) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    inherits_default()(_class, _React$Component);

    function _class(props) {
      var _this;

      classCallCheck_default()(this, _class);

      _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(_class).call(this, props));
      _this.getLayout =
      /*#__PURE__*/
      asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee() {
        var qObject, qLayout;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                qObject = _this.state.qObject;
                _context.next = 3;
                return qObject.getLayout();

              case 3:
                qLayout = _context.sent;
                return _context.abrupt("return", qLayout);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      _this.getData =
      /*#__PURE__*/
      function () {
        var _ref2 = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee2(qTop) {
          var qPage, qObject, qDataPages;
          return regenerator_default.a.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  qPage = _this.props.qPage;
                  qObject = _this.state.qObject;
                  _context2.next = 4;
                  return qObject.getHyperCubeData('/qHyperCubeDef', [objectSpread_default()({}, qPage, {
                    qTop: qTop
                  })]);

                case 4:
                  qDataPages = _context2.sent;
                  return _context2.abrupt("return", qDataPages[0]);

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }();

      _this.generateQProp = function () {
        var _this$props = _this.props,
            cols = _this$props.cols,
            qHyperCubeDef = _this$props.qHyperCubeDef,
            qSortByAscii = _this$props.qSortByAscii,
            qSortByLoadOrder = _this$props.qSortByLoadOrder,
            qSuppressZero = _this$props.qSuppressZero,
            qInterColumnSortOrder = _this$props.qInterColumnSortOrder,
            qSortByExpression = _this$props.qSortByExpression,
            qExpression = _this$props.qExpression,
            qSuppressMissing = _this$props.qSuppressMissing;
        var qProp = {
          qInfo: {
            qType: 'visualization'
          }
        };

        if (qHyperCubeDef) {
          if (cols && cols[1]) qHyperCubeDef.qMeasures[0].qDef = {
            qDef: cols[1]
          };
          if (cols && cols[0]) qHyperCubeDef.qDimensions[0].qDef.qFieldDefs = [cols[0]];
          qProp.qInfo.qType = 'HyperCube';
          qProp.qHyperCubeDef = qHyperCubeDef;
          return qProp;
        }

        var myqInterColumnSortOrder = qInterColumnSortOrder || [];
        var qInterColumnSortOrderSet = !!qInterColumnSortOrder;
        var sortIndex = 0;
        var qDimensions = cols.filter(function (col, i) {
          var isDimension = typeof col === 'string' && !col.startsWith('=') || typeof_default()(col) === 'object' && col.qDef && col.qDef.qFieldDefs || typeof_default()(col) === 'object' && col.qLibraryId && col.qType && col.qType === 'dimension';

          if (isDimension && !qInterColumnSortOrderSet) {
            myqInterColumnSortOrder[i] = sortIndex;
            sortIndex += 1;
          }

          return isDimension;
        }).map(function (col) {
          if (typeof col === 'string') {
            return {
              qDef: {
                qFieldDefs: [col],
                qSortCriterias: [{
                  qSortByAscii: qSortByAscii,
                  qSortByLoadOrder: qSortByLoadOrder
                }]
              }
            }; //
          }

          return col;
        });
        var qMeasures = cols.filter(function (col, i) {
          var isMeasure = typeof col === 'string' && col.startsWith('=') || typeof_default()(col) === 'object' && col.qDef && col.qDef.qDef || typeof_default()(col) === 'object' && col.qLibraryId && col.qType && col.qType === 'measure';

          if (isMeasure && !qInterColumnSortOrderSet) {
            myqInterColumnSortOrder[i] = sortIndex;
            sortIndex += 1;
          }

          return isMeasure;
        }).map(function (col) {
          if (typeof col === 'string') {
            return {
              qDef: {
                qDef: col
              },
              qSortBy: {
                qSortByNumeric: -1,
                qSortByExpression: qSortByExpression,
                qExpression: qExpression,
                qSuppressMissing: qSuppressMissing
              }
            };
          }

          return col;
        });
        qProp.qHyperCubeDef = {
          qDimensions: qDimensions,
          qMeasures: qMeasures,
          qInterColumnSortOrder: qInterColumnSortOrder,
          qSuppressZero: qSuppressZero,
          qSuppressMissing: qSuppressMissing
        };
        return qProp;
      };

      _this.offset = function (qTop) {
        _this.update(qTop);
      };

      _this.update =
      /*#__PURE__*/
      asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee3() {
        var qTopPassed,
            _ref4,
            qDataGenerated,
            _ref5,
            qArea,
            _ref6,
            qTopGenerated,
            qTop,
            _ref7,
            _ref8,
            qLayout,
            qData,
            _args3 = arguments;

        return regenerator_default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                qTopPassed = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 0;
                // Short-circuit evaluation because one line destructuring on Null values breaks on the browser.
                _ref4 = _this.state || {}, qDataGenerated = _ref4.qData;
                _ref5 = qDataGenerated || {}, qArea = _ref5.qArea;
                _ref6 = qArea || {}, qTopGenerated = _ref6.qTop;
                qTop = qTopPassed || qTopGenerated;

                _this.setState({
                  updating: true
                });

                _context3.next = 8;
                return Promise.all([_this.getLayout(), _this.getData(qTop)]);

              case 8:
                _ref7 = _context3.sent;
                _ref8 = slicedToArray_default()(_ref7, 2);
                qLayout = _ref8[0];
                qData = _ref8[1];

                _this.setState({
                  updating: false,
                  qLayout: qLayout,
                  qData: qData
                });

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      _this.beginSelections =
      /*#__PURE__*/
      asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee4() {
        var qObject;
        return regenerator_default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                qObject = _this.state.qObject;
                qObject.beginSelections(['/qHyperCubeDef']);
                _context4.next = 4;
                return _this.setState({
                  selections: true
                });

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      _this.endSelections =
      /*#__PURE__*/
      function () {
        var _ref10 = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee5(qAccept) {
          var qObject;
          return regenerator_default.a.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  qObject = _this.state.qObject;
                  qObject.endSelections(qAccept);
                  _context5.next = 4;
                  return _this.setState({
                    selections: false
                  });

                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x2) {
          return _ref10.apply(this, arguments);
        };
      }();

      _this.select =
      /*#__PURE__*/
      function () {
        var _ref11 = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee6(dimIndex, selections) {
          var toggle,
              qObject,
              _args6 = arguments;
          return regenerator_default.a.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  toggle = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : true;
                  qObject = _this.state.qObject;
                  _context6.next = 4;
                  return qObject.selectHyperCubeValues('/qHyperCubeDef', dimIndex, selections, toggle);

                case 4:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x3, _x4) {
          return _ref11.apply(this, arguments);
        };
      }();

      _this.applyPatches =
      /*#__PURE__*/
      function () {
        var _ref12 = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee7(patches) {
          var qObject;
          return regenerator_default.a.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  qObject = _this.state.qObject;
                  _context7.next = 3;
                  return qObject.applyPatches(patches);

                case 3:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function (_x5) {
          return _ref12.apply(this, arguments);
        };
      }();

      _this.state = {
        qObject: null,
        qLayout: null,
        qData: null,
        selections: false,
        updating: false,
        error: null
      };
      return _this;
    }

    createClass_default()(_class, [{
      key: "componentWillMount",
      value: function () {
        var _componentWillMount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee8() {
          var _this2 = this;

          var qDocPromise, qProp, qDoc, qObject;
          return regenerator_default.a.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.prev = 0;
                  qDocPromise = this.props.qDocPromise;
                  _context8.next = 4;
                  return this.generateQProp();

                case 4:
                  qProp = _context8.sent;
                  _context8.next = 7;
                  return qDocPromise;

                case 7:
                  qDoc = _context8.sent;
                  _context8.next = 10;
                  return qDoc.createSessionObject(qProp);

                case 10:
                  qObject = _context8.sent;
                  qObject.on('changed', function () {
                    _this2.update();
                  });
                  this.setState({
                    qObject: qObject
                  }, function () {
                    var qPage = _this2.props.qPage;

                    _this2.update(qPage.qTop);
                  });
                  _context8.next = 18;
                  break;

                case 15:
                  _context8.prev = 15;
                  _context8.t0 = _context8["catch"](0);
                  this.setState({
                    error: _context8.t0
                  });

                case 18:
                  _context8.prev = 18;
                  this.setState({
                    loading: false
                  });
                  return _context8.finish(18);

                case 21:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this, [[0, 15, 18, 21]]);
        }));

        function componentWillMount() {
          return _componentWillMount.apply(this, arguments);
        }

        return componentWillMount;
      }()
    }, {
      key: "componentWillUnmount",
      value: function () {
        var _componentWillUnmount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee9() {
          var qDocPromise, id, qDoc;
          return regenerator_default.a.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  qDocPromise = this.props.qDocPromise;
                  id = this.state.qObject.id;
                  _context9.next = 4;
                  return qDocPromise;

                case 4:
                  qDoc = _context9.sent;
                  qDoc.destroySessionObject(id);

                case 6:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function componentWillUnmount() {
          return _componentWillUnmount.apply(this, arguments);
        }

        return componentWillUnmount;
      }()
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            width = _this$props2.width,
            height = _this$props2.height,
            cols = _this$props2.cols;
        var _this$state = this.state,
            qObject = _this$state.qObject,
            qLayout = _this$state.qLayout,
            qData = _this$state.qData,
            error = _this$state.error;

        if (error) {
          return react_default.a.createElement("div", null, error.message);
        }

        if (!qObject || !qLayout || !qData) {
          var preloaderType = cols && cols.length === 1 ? 'dots' : 'balls';
          var paddingTop = parseInt(height, 0) ? height / 2 - 10 : 0;
          return react_default.a.createElement(utilities_Preloader, {
            width: width,
            height: height,
            paddingTop: paddingTop,
            type: preloaderType
          });
        }

        return react_default.a.createElement(Component, extends_default()({}, this.props, this.state, {
          offset: this.offset,
          select: this.select,
          beginSelections: this.beginSelections,
          endSelections: this.endSelections,
          applyPatches: this.applyPatches
        }));
      }
    }]);

    return _class;
  }(react_default.a.Component), _class.propTypes = {
    qDocPromise: prop_types_default.a.object.isRequired,
    cols: prop_types_default.a.array,
    qHyperCubeDef: prop_types_default.a.object,
    qPage: prop_types_default.a.object,
    width: prop_types_default.a.string,
    height: prop_types_default.a.string,
    qSortByAscii: prop_types_default.a.oneOf([1, 0, -1]),
    qSortByLoadOrder: prop_types_default.a.oneOf([1, 0, -1]),
    qInterColumnSortOrder: prop_types_default.a.array,
    qSuppressZero: prop_types_default.a.bool,
    qSortByExpression: prop_types_default.a.oneOf([1, 0, -1]),
    qSuppressMissing: prop_types_default.a.bool,
    qExpression: prop_types_default.a.object
  }, _class.defaultProps = {
    cols: null,
    qHyperCubeDef: null,
    qSortByAscii: 1,
    qSortByLoadOrder: 1,
    qInterColumnSortOrder: [],
    qSuppressZero: false,
    qSortByExpression: 0,
    qSuppressMissing: false,
    qExpression: null,
    qPage: {
      qTop: 0,
      qLeft: 0,
      qWidth: 10,
      qHeight: 100
    },
    width: '100%',
    height: '100%'
  }, _temp;
}
// CONCATENATED MODULE: ./src/components/QdtTable.jsx










var QdtTable_class, QdtTable_class2, QdtTable_temp;








var QdtTable_TableHead = function TableHead(_ref) {
  var columnWidth = _ref.columnWidth,
      labels = _ref.labels,
      sortColumn = _ref.sortColumn,
      setSortColumn = _ref.setSortColumn;
  return react_default.a.createElement("table", {
    className: "qtd-table-header"
  }, react_default.a.createElement("thead", null, react_default.a.createElement("tr", null, labels.map(function (label, index) {
    return react_default.a.createElement("th", {
      className: index === sortColumn ? 'active' : null,
      style: {
        width: "".concat(columnWidth, "%")
      },
      key: label,
      "data-index": index,
      onClick: setSortColumn
    }, label);
  }))));
};

QdtTable_TableHead.propTypes = {
  columnWidth: prop_types_default.a.number.isRequired,
  labels: prop_types_default.a.array.isRequired,
  sortColumn: prop_types_default.a.number.isRequired,
  setSortColumn: prop_types_default.a.func.isRequired
};

var QdtTable_TableBody = function TableBody(_ref2) {
  var qMatrix = _ref2.qMatrix,
      rowHeight = _ref2.rowHeight,
      columnWidth = _ref2.columnWidth,
      select = _ref2.select;
  return react_default.a.createElement("table", {
    className: "qtd-table-body"
  }, react_default.a.createElement("tbody", null, qMatrix.map(function (row) {
    return react_default.a.createElement("tr", {
      key: row.slice(0, 2).reduce(function (a, b) {
        return a.qElemNumber.toString().concat(b.qElemNumber.toString());
      })
    }, row.map(function (col, i) {
      return react_default.a.createElement("td", {
        key: col.qText,
        style: {
          height: "".concat(rowHeight, "px"),
          width: "".concat(columnWidth, "%")
        },
        "data-q-elem-number": col.qElemNumber,
        "data-index": i,
        "data-qstate": col.qState,
        onClick: select
      }, col.qText);
    }));
  })));
};

QdtTable_TableBody.propTypes = {
  qMatrix: prop_types_default.a.array.isRequired,
  rowHeight: prop_types_default.a.number.isRequired,
  columnWidth: prop_types_default.a.number.isRequired,
  select: prop_types_default.a.func.isRequired
};
var QdtTable_QdtTableComponent = (QdtTable_class = (QdtTable_temp = QdtTable_class2 =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtTableComponent, _React$Component);

  function QdtTableComponent(props) {
    var _this;

    classCallCheck_default()(this, QdtTableComponent);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtTableComponent).call(this, props));
    _this.state = {
      sortColumn: 0
    };
    return _this;
  }

  createClass_default()(QdtTableComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.resize();
      window.addEventListener('resize', this.resize);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.resize();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('resize', this.resize);
    }
  }, {
    key: "setSortColumn",
    value: function () {
      var _setSortColumn = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee(event) {
        var index, applyPatches;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index = Number(event.target.dataset.index);
                applyPatches = this.props.applyPatches;
                _context.next = 4;
                return applyPatches([{
                  qOp: 'replace',
                  qPath: '/qHyperCubeDef/qInterColumnSortOrder',
                  qValue: JSON.stringify([index])
                }]);

              case 4:
                this.setState({
                  sortColumn: index
                });

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setSortColumn(_x) {
        return _setSortColumn.apply(this, arguments);
      }

      return setSortColumn;
    }()
  }, {
    key: "select",
    value: function select(e) {
      var _e$target$dataset = e.target.dataset,
          qstate = _e$target$dataset.qstate,
          qElemNumber = _e$target$dataset.qElemNumber,
          index = _e$target$dataset.index;
      var select = this.props.select;

      if (qstate !== 'L') {
        select(Number(index), [Number(qElemNumber)]);
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var thead = this.node.getElementsByTagName('thead')[0];
      var tbody = this.node.getElementsByTagName('tbody')[0];
      thead.style.width = "".concat(tbody.clientWidth, "px");
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var select = this.select,
          setSortColumn = this.setSortColumn;
      var _this$props = this.props,
          qData = _this$props.qData,
          qLayout = _this$props.qLayout,
          offset = _this$props.offset,
          height = _this$props.height,
          rowHeight = _this$props.rowHeight;
      var columnWidth = 100 / qLayout.qHyperCube.qSize.qcx;
      var sortColumn = this.state.sortColumn;
      var labels = [].concat(toConsumableArray_default()(qLayout.qHyperCube.qDimensionInfo.map(function (dim) {
        return dim.qFallbackTitle;
      })), toConsumableArray_default()(qLayout.qHyperCube.qMeasureInfo.map(function (measure) {
        return measure.qFallbackTitle;
      })));
      return react_default.a.createElement("div", {
        ref: function ref(node) {
          _this2.node = node;
        }
      }, react_default.a.createElement(QdtTable_TableHead, {
        columnWidth: columnWidth,
        labels: labels,
        sortColumn: sortColumn,
        setSortColumn: setSortColumn
      }), react_default.a.createElement(QdtVirtualScroll_QdtVirtualScroll, {
        qData: qData,
        qcy: qLayout.qHyperCube.qSize.qcy,
        Component: QdtTable_TableBody,
        componentProps: {
          columnWidth: columnWidth,
          select: select
        },
        offset: offset,
        rowHeight: rowHeight,
        viewportHeight: height
      }));
    }
  }]);

  return QdtTableComponent;
}(react_default.a.Component), QdtTable_class2.propTypes = {
  qData: prop_types_default.a.object.isRequired,
  qLayout: prop_types_default.a.object.isRequired,
  offset: prop_types_default.a.func.isRequired,
  select: prop_types_default.a.func.isRequired,
  applyPatches: prop_types_default.a.func.isRequired,
  height: prop_types_default.a.number.isRequired,
  rowHeight: prop_types_default.a.number.isRequired
}, QdtTable_temp), (applyDecoratedDescriptor_default()(QdtTable_class.prototype, "setSortColumn", [autobind], Object.getOwnPropertyDescriptor(QdtTable_class.prototype, "setSortColumn"), QdtTable_class.prototype), applyDecoratedDescriptor_default()(QdtTable_class.prototype, "select", [autobind], Object.getOwnPropertyDescriptor(QdtTable_class.prototype, "select"), QdtTable_class.prototype), applyDecoratedDescriptor_default()(QdtTable_class.prototype, "resize", [autobind], Object.getOwnPropertyDescriptor(QdtTable_class.prototype, "resize"), QdtTable_class.prototype)), QdtTable_class);
var QdtTable = withHyperCube(QdtTable_QdtTableComponent);
QdtTable.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  qHyperCubeDef: prop_types_default.a.object,
  qPage: prop_types_default.a.object,
  width: prop_types_default.a.string,
  height: prop_types_default.a.number,
  rowHeight: prop_types_default.a.number
};
QdtTable.defaultProps = {
  cols: null,
  qHyperCubeDef: null,
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 10,
    qHeight: 100
  },
  width: '100%',
  height: 400,
  rowHeight: 50
};
/* harmony default export */ var components_QdtTable = (QdtTable);
// CONCATENATED MODULE: ./src/components/QdtButton.jsx









var QdtButton_class, QdtButton_class2, QdtButton_temp;

/**
 * @name QdtButton
 * @param {string} type [clearSelections, exportData, exportImg, exportPdf] - The button action
 * @param {string} title - The text on the button
 * @description
 * exportData, exportImg, exportPdf documentation:
 * https://help.qlik.com/en-US/sense-developer/September2018/Subsystems/APIs/Content/Sense_ClientAPIs/CapabilityAPIs/VisualizationAPI/QVisualization.htm
*/





var QdtButton_QdtButton = (QdtButton_class = (QdtButton_temp = QdtButton_class2 =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtButton, _React$Component);

  function QdtButton() {
    classCallCheck_default()(this, QdtButton);

    return possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtButton).apply(this, arguments));
  }

  createClass_default()(QdtButton, [{
    key: "urlFix",
    // Sept 2018 BUG. Adds the current www folder in the path
    value: function urlFix(url) {
      var tempUrl = url.split('/');
      var sbstrIndex = url.indexOf('tempcontent');
      var myUrl = "".concat(tempUrl[0], "//").concat(tempUrl[2], "/").concat(tempUrl[3], "/").concat(url.substring(sbstrIndex, url.length));
      return myUrl;
    }
  }, {
    key: "action",
    value: function () {
      var _action = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee() {
        var _this$props, type, qDocPromise, qAppPromise, qVizPromise, options, qDoc, qApp, qViz, myOptions, url, myUrl, _myOptions, _url, _myUrl, _myOptions2, _url2, _myUrl2;

        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$props = this.props, type = _this$props.type, qDocPromise = _this$props.qDocPromise, qAppPromise = _this$props.qAppPromise, qVizPromise = _this$props.qVizPromise, options = _this$props.options;

                if (!qDocPromise) {
                  _context.next = 7;
                  break;
                }

                _context.next = 4;
                return qDocPromise;

              case 4:
                _context.t0 = _context.sent;
                _context.next = 8;
                break;

              case 7:
                _context.t0 = null;

              case 8:
                qDoc = _context.t0;

                if (!qAppPromise) {
                  _context.next = 15;
                  break;
                }

                _context.next = 12;
                return qAppPromise;

              case 12:
                _context.t1 = _context.sent;
                _context.next = 16;
                break;

              case 15:
                _context.t1 = null;

              case 16:
                qApp = _context.t1;

                if (!qVizPromise) {
                  _context.next = 23;
                  break;
                }

                _context.next = 20;
                return qVizPromise;

              case 20:
                _context.t2 = _context.sent;
                _context.next = 24;
                break;

              case 23:
                _context.t2 = null;

              case 24:
                qViz = _context.t2;
                _context.t3 = type;
                _context.next = _context.t3 === 'clearSelections' ? 28 : _context.t3 === 'exportData' ? 31 : _context.t3 === 'exportImg' ? 39 : _context.t3 === 'exportPdf' ? 47 : 28;
                break;

              case 28:
                if (qApp) qApp.clearAll();
                if (qDoc) qDoc.clearAll();
                return _context.abrupt("break", 55);

              case 31:
                if (!qViz) {
                  _context.next = 38;
                  break;
                }

                myOptions = options || {
                  format: 'CSV_T',
                  state: 'P'
                };
                _context.next = 35;
                return qViz.exportData(myOptions);

              case 35:
                url = _context.sent;
                myUrl = this.urlFix(url);
                window.open(myUrl, '_blank');

              case 38:
                return _context.abrupt("break", 55);

              case 39:
                if (!qViz) {
                  _context.next = 46;
                  break;
                }

                _myOptions = options || {
                  width: 300,
                  height: 400,
                  format: 'JPG'
                };
                _context.next = 43;
                return qViz.exportImg(_myOptions);

              case 43:
                _url = _context.sent;
                _myUrl = this.urlFix(_url);
                window.open(_myUrl, '_blank');

              case 46:
                return _context.abrupt("break", 55);

              case 47:
                if (!qViz) {
                  _context.next = 54;
                  break;
                }

                _myOptions2 = options || {
                  documentSize: 'A4',
                  orientation: 'landscape',
                  aspectRatio: 2
                };
                _context.next = 51;
                return qViz.exportPdf(_myOptions2);

              case 51:
                _url2 = _context.sent;
                _myUrl2 = this.urlFix(_url2);
                window.open(_myUrl2, '_blank');

              case 54:
                return _context.abrupt("break", 55);

              case 55:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function action() {
        return _action.apply(this, arguments);
      }

      return action;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          title = _this$props2.title,
          block = _this$props2.block;
      return react_default.a.createElement("div", null, react_default.a.createElement(qdt_lui["LuiButton"], {
        onClick: this.action,
        block: block
      }, title));
    }
  }]);

  return QdtButton;
}(react_default.a.Component), QdtButton_class2.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  qAppPromise: prop_types_default.a.object.isRequired,
  qVizPromise: prop_types_default.a.object,
  type: prop_types_default.a.oneOf(['clearSelections', 'exportData', 'exportImg', 'exportPdf']).isRequired,
  title: prop_types_default.a.string.isRequired,
  block: prop_types_default.a.string,
  options: prop_types_default.a.object
}, QdtButton_class2.defaultProps = {
  block: false,
  qVizPromise: null,
  options: {}
}, QdtButton_temp), (applyDecoratedDescriptor_default()(QdtButton_class.prototype, "urlFix", [autobind], Object.getOwnPropertyDescriptor(QdtButton_class.prototype, "urlFix"), QdtButton_class.prototype), applyDecoratedDescriptor_default()(QdtButton_class.prototype, "action", [autobind], Object.getOwnPropertyDescriptor(QdtButton_class.prototype, "action"), QdtButton_class.prototype)), QdtButton_class);

// CONCATENATED MODULE: ./src/components/QdtViz.jsx












var QdtViz_QdtViz =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtViz, _React$Component);

  function QdtViz(props) {
    var _this;

    classCallCheck_default()(this, QdtViz);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtViz).call(this, props));
    _this.state = {
      loading: true,
      error: null
    };
    return _this;
  }

  createClass_default()(QdtViz, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      this.qVizPromise = this.create();
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.show();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(newProps) {
      var options = this.props;

      if (JSON.stringify(newProps.options) !== JSON.stringify(options)) {
        this.setOptions(newProps.options);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.close();
    }
  }, {
    key: "setOptions",
    value: function () {
      var _setOptions = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee(options) {
        var qViz;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this.qVizPromise;

              case 3:
                qViz = _context.sent;
                qViz.setOptions(options);
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](0);
                this.setState({
                  error: _context.t0
                });

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 7]]);
      }));

      function setOptions(_x) {
        return _setOptions.apply(this, arguments);
      }

      return setOptions;
    }()
  }, {
    key: "create",
    value: function () {
      var _create = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee2() {
        var _this$props, qAppPromise, id, type, cols, options, qApp, qVizPromise;

        return regenerator_default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _this$props = this.props, qAppPromise = _this$props.qAppPromise, id = _this$props.id, type = _this$props.type, cols = _this$props.cols, options = _this$props.options;
                _context2.next = 4;
                return qAppPromise;

              case 4:
                qApp = _context2.sent;
                qVizPromise = id ? qApp.visualization.get(id) : qApp.visualization.create(type, cols, options); // eslint-disable-line max-len

                return _context2.abrupt("return", qVizPromise);

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](0);
                this.setState({
                  error: _context2.t0
                });
                return _context2.abrupt("return", undefined);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 9]]);
      }));

      function create() {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "show",
    value: function () {
      var _show = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee3() {
        var noSelections, qViz;
        return regenerator_default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                noSelections = this.props.noSelections;
                _context3.next = 4;
                return this.qVizPromise;

              case 4:
                qViz = _context3.sent;

                if (!qViz) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 8;
                return this.setState({
                  loading: false
                });

              case 8:
                qViz.show(this.node, {
                  noSelections: noSelections
                });
                _context3.next = 12;
                break;

              case 11:
                throw new Error('Please specify a qConfig global variable');

              case 12:
                _context3.next = 17;
                break;

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](0);
                this.setState({
                  error: _context3.t0
                });

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 14]]);
      }));

      function show() {
        return _show.apply(this, arguments);
      }

      return show;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee4() {
        var qViz;
        return regenerator_default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return this.qVizPromise;

              case 3:
                qViz = _context4.sent;
                qViz.close();
                _context4.next = 10;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](0);
                this.setState({
                  error: _context4.t0
                });

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[0, 7]]);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "resize",
    value: function () {
      var _resize = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee5() {
        var qViz;
        return regenerator_default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.qVizPromise;

              case 2:
                qViz = _context5.sent;
                qViz.resize();

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function resize() {
        return _resize.apply(this, arguments);
      }

      return resize;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          width = _this$props2.width,
          height = _this$props2.height,
          minWidth = _this$props2.minWidth,
          minHeight = _this$props2.minHeight,
          exportData = _this$props2.exportData,
          exportDataTitle = _this$props2.exportDataTitle,
          exportDataOptions = _this$props2.exportDataOptions,
          exportImg = _this$props2.exportImg,
          exportImgTitle = _this$props2.exportImgTitle,
          exportImgOptions = _this$props2.exportImgOptions,
          exportPdf = _this$props2.exportPdf,
          exportPdfTitle = _this$props2.exportPdfTitle,
          exportPdfOptions = _this$props2.exportPdfOptions;
      var _this$state = this.state,
          error = _this$state.error,
          loading = _this$state.loading;

      if (error) {
        return react_default.a.createElement("div", null, error.message);
      }

      if (loading) {
        //   return <div>Loading...</div>;
        var paddingTop = parseInt(height, 0) ? height / 2 - 10 : 0;
        return react_default.a.createElement(utilities_Preloader, {
          width: width,
          height: height,
          paddingTop: paddingTop
        });
      }

      var btnStyle = {
        display: 'inline-block',
        paddingRight: 20,
        paddingTop: 15
      };
      return react_default.a.createElement("div", null, react_default.a.createElement("div", {
        ref: function ref(node) {
          _this2.node = node;
        },
        style: {
          width: width,
          height: height,
          minWidth: minWidth,
          minHeight: minHeight
        }
      }), exportData && react_default.a.createElement("div", {
        style: btnStyle
      }, react_default.a.createElement(QdtButton_QdtButton, {
        type: "exportData",
        qVizPromise: this.qVizPromise,
        title: exportDataTitle,
        options: exportDataOptions
      })), exportImg && react_default.a.createElement("div", {
        style: btnStyle
      }, react_default.a.createElement(QdtButton_QdtButton, {
        type: "exportImg",
        qVizPromise: this.qVizPromise,
        title: exportImgTitle,
        options: exportImgOptions
      })), exportPdf && react_default.a.createElement("div", {
        style: btnStyle
      }, react_default.a.createElement(QdtButton_QdtButton, {
        type: "exportPdf",
        qVizPromise: this.qVizPromise,
        title: exportPdfTitle,
        options: exportPdfOptions
      })));
    }
  }]);

  return QdtViz;
}(react_default.a.Component);

QdtViz_QdtViz.propTypes = {
  qAppPromise: prop_types_default.a.object.isRequired,
  id: prop_types_default.a.string,
  type: prop_types_default.a.oneOf([null, 'barchart', 'boxplot', 'combochart', 'distributionplot', 'gauge', 'histogram', 'kpi', 'linechart', 'piechart', 'pivot-table', 'scatterplot', 'table', 'treemap', 'extension']),
  cols: prop_types_default.a.array,
  options: prop_types_default.a.object,
  noSelections: prop_types_default.a.bool,
  width: prop_types_default.a.string,
  height: prop_types_default.a.string,
  minWidth: prop_types_default.a.string,
  minHeight: prop_types_default.a.string,
  exportData: prop_types_default.a.bool,
  exportDataTitle: prop_types_default.a.string,
  exportDataOptions: prop_types_default.a.object,
  exportImg: prop_types_default.a.bool,
  exportImgTitle: prop_types_default.a.string,
  exportImgOptions: prop_types_default.a.object,
  exportPdf: prop_types_default.a.bool,
  exportPdfTitle: prop_types_default.a.string,
  exportPdfOptions: prop_types_default.a.object
};
QdtViz_QdtViz.defaultProps = {
  id: null,
  type: null,
  cols: [],
  options: {},
  noSelections: false,
  width: '100%',
  height: '100%',
  minWidth: 'auto',
  minHeight: 'auto',
  exportData: false,
  exportDataTitle: 'Export Data',
  exportDataOptions: {
    format: 'CSV_T',
    state: 'P'
  },
  exportImg: false,
  exportImgTitle: 'Export Image',
  exportImgOptions: {
    width: 300,
    height: 400,
    format: 'JPG'
  },
  exportPdf: false,
  exportPdfTitle: 'Export Pdf',
  exportPdfOptions: {
    documentSize: 'A4',
    orientation: 'landscape',
    aspectRatio: 2
  }
};

// CONCATENATED MODULE: ./src/components/withSelectionObject.jsx












function withSelectionObject_withListObject(Component) {
  var _class, _class2, _temp;

  return _class = (_temp = _class2 =
  /*#__PURE__*/
  function (_React$Component) {
    inherits_default()(_class, _React$Component);

    function _class(props) {
      var _this;

      classCallCheck_default()(this, _class);

      _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(_class).call(this, props));
      _this.state = {
        qDoc: null,
        qObject: null,
        qLayout: null,
        updating: false,
        error: null
      };
      return _this;
    }

    createClass_default()(_class, [{
      key: "componentWillMount",
      value: function () {
        var _componentWillMount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee() {
          var _this2 = this;

          var qDocPromise, qProp, qDoc, qObject;
          return regenerator_default.a.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  qDocPromise = this.props.qDocPromise;
                  qProp = {
                    qInfo: {
                      qType: 'SelectionObject'
                    },
                    qSelectionObjectDef: {}
                  };
                  _context.next = 5;
                  return qDocPromise;

                case 5:
                  qDoc = _context.sent;
                  this.setState({
                    qDoc: qDoc
                  });
                  _context.next = 9;
                  return qDoc.createSessionObject(qProp);

                case 9:
                  qObject = _context.sent;
                  qObject.on('changed', function () {
                    _this2.update();
                  });
                  this.setState({
                    qObject: qObject
                  }, function () {
                    _this2.update();
                  });
                  _context.next = 17;
                  break;

                case 14:
                  _context.prev = 14;
                  _context.t0 = _context["catch"](0);
                  this.setState({
                    error: _context.t0
                  });

                case 17:
                  _context.prev = 17;
                  this.setState({
                    loading: false
                  });
                  return _context.finish(17);

                case 20:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[0, 14, 17, 20]]);
        }));

        function componentWillMount() {
          return _componentWillMount.apply(this, arguments);
        }

        return componentWillMount;
      }()
    }, {
      key: "componentWillUnmount",
      value: function () {
        var _componentWillUnmount = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee2() {
          var qDocPromise, qDoc, id;
          return regenerator_default.a.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  qDocPromise = this.props.qDocPromise;
                  _context2.next = 3;
                  return qDocPromise;

                case 3:
                  qDoc = _context2.sent;
                  id = this.state.qObject.id;
                  qDoc.destroySessionObject(id);

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function componentWillUnmount() {
          return _componentWillUnmount.apply(this, arguments);
        }

        return componentWillUnmount;
      }()
    }, {
      key: "getLayout",
      value: function () {
        var _getLayout = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee3() {
          var qObject, qLayout;
          return regenerator_default.a.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  qObject = this.state.qObject;
                  _context3.next = 3;
                  return qObject.getLayout();

                case 3:
                  qLayout = _context3.sent;
                  return _context3.abrupt("return", qLayout);

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function getLayout() {
          return _getLayout.apply(this, arguments);
        }

        return getLayout;
      }()
    }, {
      key: "update",
      value: function () {
        var _update = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee4() {
          var qLayout;
          return regenerator_default.a.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  this.setState({
                    updating: true
                  });
                  _context4.next = 3;
                  return this.getLayout();

                case 3:
                  qLayout = _context4.sent;
                  this.setState({
                    updating: false,
                    qLayout: qLayout
                  });

                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function update() {
          return _update.apply(this, arguments);
        }

        return update;
      }()
    }, {
      key: "clearSelections",
      value: function () {
        var _clearSelections = asyncToGenerator_default()(
        /*#__PURE__*/
        regenerator_default.a.mark(function _callee5(field, value) {
          var qDoc, qField;
          return regenerator_default.a.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  this.setState({
                    updating: true
                  });
                  qDoc = this.state.qDoc;

                  if (!field) {
                    _context5.next = 15;
                    break;
                  }

                  _context5.next = 5;
                  return qDoc.getField(field);

                case 5:
                  qField = _context5.sent;

                  if (!value) {
                    _context5.next = 11;
                    break;
                  }

                  _context5.next = 9;
                  return qField.toggleSelect(value);

                case 9:
                  _context5.next = 13;
                  break;

                case 11:
                  _context5.next = 13;
                  return qField.clear();

                case 13:
                  _context5.next = 16;
                  break;

                case 15:
                  qDoc.clearAll();

                case 16:
                  this.setState({
                    updating: false
                  });

                case 17:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function clearSelections(_x, _x2) {
          return _clearSelections.apply(this, arguments);
        }

        return clearSelections;
      }()
    }, {
      key: "render",
      value: function render() {
        var _this$state = this.state,
            qObject = _this$state.qObject,
            qLayout = _this$state.qLayout,
            error = _this$state.error;

        if (error) {
          return react_default.a.createElement("div", null, error.message);
        }

        if (!qObject || !qLayout) {
          return react_default.a.createElement("div", null, "Loading...");
        }

        return react_default.a.createElement(Component, extends_default()({}, this.props, this.state, {
          clearSelections: this.clearSelections
        }));
      }
    }]);

    return _class;
  }(react_default.a.Component), _class2.propTypes = {
    qDocPromise: prop_types_default.a.object.isRequired
  }, _temp), (applyDecoratedDescriptor_default()(_class.prototype, "update", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "update"), _class.prototype), applyDecoratedDescriptor_default()(_class.prototype, "clearSelections", [autobind], Object.getOwnPropertyDescriptor(_class.prototype, "clearSelections"), _class.prototype)), _class;
}
// CONCATENATED MODULE: ./src/components/QdtSelectionToolbar.jsx







var QdtSelectionToolbar_class, QdtSelectionToolbar_class2, QdtSelectionToolbar_temp;







var QdtSelectionToolbar_QdtSelectionToolbarDropdown = (QdtSelectionToolbar_class = (QdtSelectionToolbar_temp = QdtSelectionToolbar_class2 =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtSelectionToolbarDropdown, _React$Component);

  function QdtSelectionToolbarDropdown() {
    var _getPrototypeOf2;

    var _this;

    classCallCheck_default()(this, QdtSelectionToolbarDropdown);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = possibleConstructorReturn_default()(this, (_getPrototypeOf2 = getPrototypeOf_default()(QdtSelectionToolbarDropdown)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this.state = {
      dropdownOpen: false
    };
    return _this;
  }

  createClass_default()(QdtSelectionToolbarDropdown, [{
    key: "toggle",
    value: function toggle() {
      var dropdownOpen = this.state.dropdownOpen;
      this.setState({
        dropdownOpen: !dropdownOpen
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          clearSelections = _this$props.clearSelections,
          value = _this$props.value;
      var dropdownOpen = this.state.dropdownOpen;
      return react_default.a.createElement(qdt_lui["LuiDropdown"], {
        isOpen: dropdownOpen,
        toggle: this.toggle,
        select: false
      }, react_default.a.createElement("div", null, value.field, ":", value.selected.length, ' ', "of", value.total, react_default.a.createElement("span", {
        className: "lui-icon lui-icon--triangle-bottom"
      })), react_default.a.createElement("ul", null, value.selected.map(function (value2) {
        return react_default.a.createElement("li", {
          key: value2
        }, value2, react_default.a.createElement("span", {
          className: "lui-icon lui-icon--remove pull-right",
          onClick: function onClick() {
            return clearSelections(value.field, value2);
          },
          role: "button",
          tabIndex: 0
        }));
      })));
    }
  }]);

  return QdtSelectionToolbarDropdown;
}(react_default.a.Component), QdtSelectionToolbar_class2.propTypes = {
  clearSelections: prop_types_default.a.func.isRequired,
  value: prop_types_default.a.object.isRequired
}, QdtSelectionToolbar_temp), (applyDecoratedDescriptor_default()(QdtSelectionToolbar_class.prototype, "toggle", [autobind], Object.getOwnPropertyDescriptor(QdtSelectionToolbar_class.prototype, "toggle"), QdtSelectionToolbar_class.prototype)), QdtSelectionToolbar_class);

var QdtSelectionToolbar_QdtSelectionToolbar = function QdtSelectionToolbar(_ref) {
  var qLayout = _ref.qLayout,
      clearSelections = _ref.clearSelections,
      title = _ref.title,
      btnText = _ref.btnText;
  var selectedFields = qLayout.qSelectionObject.qSelections;
  var selections = [];

  if (selectedFields.length) {
    selections = selectedFields.map(function (value) {
      if (value.qSelectedCount >= 1 && value.qSelectedCount <= 6) {
        return {
          field: value.qField,
          selected: value.qSelectedFieldSelectionInfo.map(function (valueInner) {
            return valueInner.qName;
          }),
          total: value.qTotal
        };
      }

      if (value.qSelectedCount > 6) {
        return {
          field: value.qField,
          selected: ["".concat(value.qSelectedCount, " of ").concat(value.qTotal)]
        };
      }

      return null;
    });
  }

  return react_default.a.createElement("div", {
    className: "qdt-selection-toolbar"
  }, react_default.a.createElement("ul", null, react_default.a.createElement("li", null, react_default.a.createElement("strong", null, title, ":")), selections.length === 0 && react_default.a.createElement("li", {
    className: "no-selections"
  }, "None"), selections.length >= 1 && selections.length <= 6 && selections.map(function (value) {
    if (value.selected.length === 1) {
      return react_default.a.createElement("li", {
        key: value.field
      }, value.field, ":", ' ', value.selected[0], react_default.a.createElement("span", {
        className: "lui-icon lui-icon--remove",
        onClick: function onClick() {
          return clearSelections(value.field);
        },
        role: "button",
        tabIndex: 0
      }));
    }

    return react_default.a.createElement("li", {
      key: value.field
    }, react_default.a.createElement(QdtSelectionToolbar_QdtSelectionToolbarDropdown, {
      value: value,
      clearSelections: clearSelections
    }));
  }), selections.length >= 1 && selections.length <= 6 && react_default.a.createElement("li", null, react_default.a.createElement("button", {
    type: "button",
    className: "lui-button lui-button--warning clear-all",
    onClick: function onClick() {
      return clearSelections();
    },
    tabIndex: 0
  }, btnText))));
};

QdtSelectionToolbar_QdtSelectionToolbar.propTypes = {
  qLayout: prop_types_default.a.object.isRequired,
  clearSelections: prop_types_default.a.func.isRequired,
  title: prop_types_default.a.string,
  btnText: prop_types_default.a.string
};
QdtSelectionToolbar_QdtSelectionToolbar.defaultProps = {
  title: 'SELECTIONS',
  btnText: 'Clear All'
};
var QdtSelectionToolbarObject = withSelectionObject_withListObject(QdtSelectionToolbar_QdtSelectionToolbar);
QdtSelectionToolbarObject.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  options: prop_types_default.a.object,
  qPage: prop_types_default.a.object
};
QdtSelectionToolbarObject.defaultProps = {
  cols: [],
  options: {
    qType: 'SelectionObject'
  },
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 1,
    qHeight: 1
  }
};
/* harmony default export */ var components_QdtSelectionToolbar = (QdtSelectionToolbarObject);
// CONCATENATED MODULE: ./src/components/QdtKpi.jsx






var QdtKpi_QdtKpiComponent = function QdtKpiComponent(_ref) {
  var qData = _ref.qData,
      roundNum = _ref.roundNum;
  return react_default.a.createElement("div", {
    className: "qdt-kpi"
  }, roundNum && utilities.RoundNum(qData.qMatrix[0][0].qNum, true), !roundNum && qData.qMatrix[0][0].qText);
};

QdtKpi_QdtKpiComponent.propTypes = {
  qData: prop_types_default.a.object.isRequired,
  roundNum: prop_types_default.a.bool
};
QdtKpi_QdtKpiComponent.defaultProps = {
  roundNum: false
};
var QdtKpi = withHyperCube(QdtKpi_QdtKpiComponent);
QdtKpi.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  qHyperCubeDef: prop_types_default.a.object,
  qPage: prop_types_default.a.object,
  roundNum: prop_types_default.a.bool
};
QdtKpi.defaultProps = {
  cols: null,
  qHyperCubeDef: null,
  roundNum: false,
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 1,
    qHeight: 1
  }
};
/* harmony default export */ var components_QdtKpi = (QdtKpi);
// CONCATENATED MODULE: ./node_modules/picasso.js/dist/picasso.esm.js
/*
* picasso.js v0.25.3
* Copyright (c) 2019 QlikTech International AB
* Released under the MIT license.
*/


var ARG_LENGTH = {
  a: 7,
  c: 6,
  h: 1,
  l: 2,
  m: 2,
  q: 4,
  s: 4,
  t: 2,
  v: 1,
  z: 0
};
var SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
var NUMBER = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

function parseValues(args) {
  var numbers = args.match(NUMBER);
  return numbers ? numbers.map(Number) : [];
}
/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation
 * @ignore
 *
 * @param {string} path
 * @returns {array}
 */


function parse(path) {
  var data = [];
  var p = String(path).trim(); // A path data segment (if there is one) must begin with a "moveto" command

  if (p[0] !== 'M' && p[0] !== 'm') {
    return data;
  }

  p.replace(SEGMENT_PATTERN, function (_, command, args) {
    var type = command.toLowerCase();
    var theArgs = parseValues(args);
    var theCommand = command; // overloaded moveTo

    if (type === 'm' && theArgs.length > 2) {
      data.push([theCommand].concat(theArgs.splice(0, 2)));
      type = 'l';
      theCommand = theCommand === 'm' ? 'l' : 'L';
    } // Ignore invalid commands


    if (theArgs.length < ARG_LENGTH[type]) {
      return '';
    }

    data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type]))); // The command letter can be eliminated on subsequent commands if the
    // same command is used multiple times in a row (e.g., you can drop the
    // second "L" in "M 100 200 L 200 100 L -100 -200" and use
    // "M 100 200 L 200 100 -100 -200" instead).

    while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {
      data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));
    }

    return '';
  });
  return data;
}

var parsePath = parse;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
/**
 * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/
 * @ignore
 */


function supportsSvgPathArgument(window) {
  var canvas = window.document.createElement('canvas');
  var g = canvas.getContext('2d');
  var p = new window.Path2D('M0 0 L1 1');
  g.strokeStyle = 'red';
  g.lineWidth = 1;
  g.stroke(p);
  var imgData = g.getImageData(0, 0, 1, 1);
  return imgData.data[0] === 255; // Check if pixel is red
}

function rotatePoint(point, angle) {
  var nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);
  var ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);
  point.x = nx;
  point.y = ny;
}

function translatePoint(point, dx, dy) {
  point.x += dx;
  point.y += dy;
}

function scalePoint(point, s) {
  point.x *= s;
  point.y *= s;
}

function polyFillPath2D(window) {
  if (typeof window === 'undefined' || !window.CanvasRenderingContext2D) {
    return;
  }

  if (window.Path2D && supportsSvgPathArgument(window)) {
    return;
  }
  /**
     * Crates a Path2D polyfill object
     * @constructor
     * @ignore
     * @param {String} path
     */


  var Path2D =
  /*#__PURE__*/
  function () {
    function Path2D(path) {
      _classCallCheck(this, Path2D);

      this.segments = [];

      if (path && path instanceof Path2D) {
        var _this$segments;

        (_this$segments = this.segments).push.apply(_this$segments, _toConsumableArray(path.segments));
      } else if (path) {
        this.segments = parsePath(path);
      }
    }

    _createClass(Path2D, [{
      key: "addPath",
      value: function addPath(path) {
        if (path && path instanceof Path2D) {
          var _this$segments2;

          (_this$segments2 = this.segments).push.apply(_this$segments2, _toConsumableArray(path.segments));
        }
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        this.segments.push(['M', x, y]);
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        this.segments.push(['L', x, y]);
      }
    }, {
      key: "arc",
      value: function arc(x, y, r, start, end, ccw) {
        this.segments.push(['AC', x, y, r, start, end, !!ccw]);
      }
    }, {
      key: "arcTo",
      value: function arcTo(x1, y1, x2, y2, r) {
        this.segments.push(['AT', x1, y1, x2, y2, r]);
      }
    }, {
      key: "ellipse",
      value: function ellipse(x, y, rx, ry, angle, start, end, ccw) {
        this.segments.push(['E', x, y, rx, ry, angle, start, end, !!ccw]);
      }
    }, {
      key: "closePath",
      value: function closePath() {
        this.segments.push(['Z']);
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.segments.push(['C', cp1x, cp1y, cp2x, cp2y, x, y]);
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y) {
        this.segments.push(['Q', cpx, cpy, x, y]);
      }
    }, {
      key: "rect",
      value: function rect(x, y, width, height) {
        this.segments.push(['R', x, y, width, height]);
      }
    }]);

    return Path2D;
  }();

  var cFill = window.CanvasRenderingContext2D.prototype.fill;
  var cStroke = window.CanvasRenderingContext2D.prototype.stroke;

  function buildPath(canvas, segments) {
    var endAngle;
    var startAngle;
    var largeArcFlag;
    var sweepFlag;
    var endPoint;
    var midPoint;
    var angle;
    var lambda;
    var t1;
    var t2;
    var x;
    var x1;
    var y;
    var y1;
    var r;
    var rx;
    var ry;
    var w;
    var h;
    var pathType;
    var centerPoint;
    var cpx;
    var cpy;
    var qcpx;
    var qcpy;
    var ccw;
    var startPoint = {
      x: 0,
      y: 0
    };
    var currentPoint = {
      x: 0,
      y: 0
    };
    canvas.beginPath();

    for (var i = 0; i < segments.length; ++i) {
      var s = segments[i];
      pathType = s[0]; // Reset control point if command is not cubic

      if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {
        cpx = null;
        cpy = null;
      }

      if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {
        qcpx = null;
        qcpy = null;
      }

      switch (pathType) {
        case 'm':
        case 'M':
          if (pathType === 'm') {
            x += s[1];
            y += s[2];
          } else {
            x = s[1];
            y = s[2];
          }

          if (pathType === 'M' || !startPoint) {
            startPoint = {
              x: x,
              y: y
            };
          }

          canvas.moveTo(x, y);
          break;

        case 'l':
          x += s[1];
          y += s[2];
          canvas.lineTo(x, y);
          break;

        case 'L':
          x = s[1];
          y = s[2];
          canvas.lineTo(x, y);
          break;

        case 'H':
          x = s[1];
          canvas.lineTo(x, y);
          break;

        case 'h':
          x += s[1];
          canvas.lineTo(x, y);
          break;

        case 'V':
          y = s[1];
          canvas.lineTo(x, y);
          break;

        case 'v':
          y += s[1];
          canvas.lineTo(x, y);
          break;

        case 'a':
        case 'A':
          if (pathType === 'a') {
            x += s[6];
            y += s[7];
          } else {
            x = s[6];
            y = s[7];
          }

          rx = s[1]; // rx

          ry = s[2]; // ry

          angle = s[3] * Math.PI / 180;
          largeArcFlag = !!s[4];
          sweepFlag = !!s[5];
          endPoint = {
            x: x,
            y: y
          }; // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes

          midPoint = {
            x: (currentPoint.x - endPoint.x) / 2,
            y: (currentPoint.y - endPoint.y) / 2
          };
          rotatePoint(midPoint, -angle); // radius correction

          lambda = midPoint.x * midPoint.x / (rx * rx) + midPoint.y * midPoint.y / (ry * ry);

          if (lambda > 1) {
            lambda = Math.sqrt(lambda);
            rx *= lambda;
            ry *= lambda;
          }

          centerPoint = {
            x: rx * midPoint.y / ry,
            y: -(ry * midPoint.x) / rx
          };
          t1 = rx * rx * ry * ry;
          t2 = rx * rx * midPoint.y * midPoint.y + ry * ry * midPoint.x * midPoint.x;

          if (sweepFlag !== largeArcFlag) {
            scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);
          } else {
            scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);
          }

          startAngle = Math.atan2((midPoint.y - centerPoint.y) / ry, (midPoint.x - centerPoint.x) / rx);
          endAngle = Math.atan2(-(midPoint.y + centerPoint.y) / ry, -(midPoint.x + centerPoint.x) / rx);
          rotatePoint(centerPoint, angle);
          translatePoint(centerPoint, (endPoint.x + currentPoint.x) / 2, (endPoint.y + currentPoint.y) / 2);
          canvas.save();
          canvas.translate(centerPoint.x, centerPoint.y);
          canvas.rotate(angle);
          canvas.scale(rx, ry);
          canvas.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);
          canvas.restore();
          break;

        case 'C':
          cpx = s[3]; // Last control point

          cpy = s[4];
          x = s[5];
          y = s[6];
          canvas.bezierCurveTo(s[1], s[2], cpx, cpy, x, y);
          break;

        case 'c':
          canvas.bezierCurveTo(s[1] + x, s[2] + y, s[3] + x, s[4] + y, s[5] + x, s[6] + y);
          cpx = s[3] + x; // Last control point

          cpy = s[4] + y;
          x += s[5];
          y += s[6];
          break;

        case 'S':
          if (cpx === null || cpx === null) {
            cpx = x;
            cpy = y;
          }

          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1], s[2], s[3], s[4]);
          cpx = s[1]; // last control point

          cpy = s[2];
          x = s[3];
          y = s[4];
          break;

        case 's':
          if (cpx === null || cpx === null) {
            cpx = x;
            cpy = y;
          }

          canvas.bezierCurveTo(2 * x - cpx, 2 * y - cpy, s[1] + x, s[2] + y, s[3] + x, s[4] + y);
          cpx = s[1] + x; // last control point

          cpy = s[2] + y;
          x += s[3];
          y += s[4];
          break;

        case 'Q':
          qcpx = s[1]; // last control point

          qcpy = s[2];
          x = s[3];
          y = s[4];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'q':
          qcpx = s[1] + x; // last control point

          qcpy = s[2] + y;
          x += s[3];
          y += s[4];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'T':
          if (qcpx === null || qcpx === null) {
            qcpx = x;
            qcpy = y;
          }

          qcpx = 2 * x - qcpx; // last control point

          qcpy = 2 * y - qcpy;
          x = s[1];
          y = s[2];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 't':
          if (qcpx === null || qcpx === null) {
            qcpx = x;
            qcpy = y;
          }

          qcpx = 2 * x - qcpx; // last control point

          qcpy = 2 * y - qcpy;
          x += s[1];
          y += s[2];
          canvas.quadraticCurveTo(qcpx, qcpy, x, y);
          break;

        case 'z':
        case 'Z':
          x = startPoint.x;
          y = startPoint.y;
          startPoint = undefined;
          canvas.closePath();
          break;

        case 'AC':
          // arc
          x = s[1];
          y = s[2];
          r = s[3];
          startAngle = s[4];
          endAngle = s[5];
          ccw = s[6];
          canvas.arc(x, y, r, startAngle, endAngle, ccw);
          break;

        case 'AT':
          // arcTo
          x1 = s[1];
          y1 = s[2];
          x = s[3];
          y = s[4];
          r = s[5];
          canvas.arcTo(x1, y1, x, y, r);
          break;

        case 'E':
          // ellipse
          x = s[1];
          y = s[2];
          rx = s[3];
          ry = s[4];
          angle = s[5];
          startAngle = s[6];
          endAngle = s[7];
          ccw = s[8];
          canvas.save();
          canvas.translate(x, y);
          canvas.rotate(angle);
          canvas.scale(rx, ry);
          canvas.arc(0, 0, 1, startAngle, endAngle, ccw);
          canvas.restore();
          break;

        case 'R':
          // rect
          x = s[1];
          y = s[2];
          w = s[3];
          h = s[4];
          startPoint = {
            x: x,
            y: y
          };
          canvas.rect(x, y, w, h);
          break;

        default: // throw new Error(`${pathType} is not implemented`); ?

      }

      currentPoint.x = x;
      currentPoint.y = y;
    }
  }

  window.CanvasRenderingContext2D.prototype.fill = function fill() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var fillRule = 'nonzero';

    if (args.length === 0 || args.length === 1 && typeof args[0] === 'string') {
      cFill.apply(this, args);
      return;
    }

    if (arguments.length === 2) {
      fillRule = args[1];
    }

    var path = args[0];
    buildPath(this, path.segments);
    cFill.call(this, fillRule);
  };

  window.CanvasRenderingContext2D.prototype.stroke = function stroke(path) {
    if (!path) {
      cStroke.call(this);
      return;
    }

    buildPath(this, path.segments);
    cStroke.call(this);
  };

  window.Path2D = Path2D;
}

var path2dPolyfill = polyFillPath2D;

if (typeof window !== 'undefined') {
  path2dPolyfill(window);
}
var parsePath_1 = parsePath;

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var about = {
  version: '0.25.3'
};

function picasso_esm_typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    picasso_esm_typeof = function (obj) {
      return typeof obj;
    };
  } else {
    picasso_esm_typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return picasso_esm_typeof(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
}

function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray$1(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * Initilize a new dock configuration
 * @private
 * @param {object} [settings] - Settings object
 * @returns {object} A dock configuration instance
 * @example
 * let instance = dockConfig({
 *  dock: 'left',
 *  displayOrder: 2,
 *  prioOrder: 1,
 *  preferredSize: 33,
 *  minimumLayoutMode: 'L',
 *  show: true
 * });
 */
function dockConfig() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callbackContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _settings$dock = settings.dock,
      _dock = _settings$dock === void 0 ? 'center' : _settings$dock,
      _settings$displayOrde = settings.displayOrder,
      _displayOrder = _settings$displayOrde === void 0 ? 0 : _settings$displayOrde,
      _settings$prioOrder = settings.prioOrder,
      _prioOrder = _settings$prioOrder === void 0 ? 0 : _settings$prioOrder,
      _settings$preferredSi = settings.preferredSize,
      preferredSize = _settings$preferredSi === void 0 ? 0 : _settings$preferredSi,
      _minimumLayoutMode = settings.minimumLayoutMode,
      _settings$show = settings.show,
      _show = _settings$show === void 0 ? true : _settings$show; // avoid empty string dock


  _dock = _dock || 'center';
  /**
   * @private
   */

  return {
    /**
     * Returns the preferred size of a component.
     * The return value of the function can either be a number representing the required size in the dock direction
     * or an object with a `size` and `edgeBleed` property.
     * @param {object} [inner]
     * @param {object} [outer]
     * @returns {number|object} Returns the computed preferred size
     * @example
     * dockConfig.computePreferredSize(() => 150); // Require a size of 150 in the dock direction
     *
     * dockConfig.computePreferredSize(() => ({
     *  size: 150,
     *  edgeBleed: {
     *    left: 50,
     *    right: 50
     *  }
     * })); // Require a size of 150 in the dock direction and a bleed size of 50 to the left and right dock direction
     */
    computePreferredSize: function computePreferredSize(_ref) {
      var inner = _ref.inner,
          outer = _ref.outer;

      if (typeof preferredSize === 'function') {
        return preferredSize({
          inner: inner,
          outer: outer,
          dock: this.dock()
        }, callbackContext);
      }

      return preferredSize;
    },

    /**
     * Set the dock direction, supported values are left | right | top | bottom. Any other value will be interpreted as center dock.
     * @param {string} [val=''] - Dock direction
     * @returns {this} The current context
     * @example
     * dockConfig.dock('left');
     */
    dock: function dock(val) {
      if (typeof val !== 'undefined') {
        _dock = val;
        return this;
      }

      return typeof _dock === 'function' ? _dock(callbackContext) : _dock;
    },

    /**
     * The `displayOrder` property is used by the layout engine to lay out components.
     * Components are interpreted in the ascending order of the `displayOrder` value. The layout engine apply the value in two ways,
     * the first is the order in which components are rendererd. The second is the area components are laid out in
     * when they have a direction, i.e. docked to either top, bottom, left or right.
     *
     * If docked at the same area, the component with a higher `displayOrder` will be rendered
     * on top of the component with a lower `displayOrder`. It can be seen as defining a z-index.
     * A lower `displayOrder` also means that a component will be laid out first in a given direction,
     * i.e. laid out closer to the central area (non-directional area) then a component with a higher `displayOrder`.
     * It can in this case be seen as the x-index or y-index.
     * @param {number} [val=0] - The display order
     * @returns {this|number} The current context or display order
     * @example
     * dockConfig.displayOrder(99);
     */
    displayOrder: function displayOrder(val) {
      if (typeof val !== 'undefined') {
        _displayOrder = val;
        return this;
      }

      return typeof _displayOrder === 'function' ? _displayOrder(callbackContext) : _displayOrder;
    },

    /**
     * The `prioOrder` property is used to define the order in which components are added to the layout engine,
     * this is done before any components are laid out. When there is not enough space to add any more components
     * to a given area, all components not all ready added, are then discarded. The `prioOrder` is interpreted
     * in the ascending order. Such that a lower value is added to the layout engine first.
     * @param {number} [val=0] - The prio order
     * @returns {this|number} The current context or prio order
     * @example
     * dockConfig.prioOrder(-1);
     */
    prioOrder: function prioOrder(val) {
      if (typeof val !== 'undefined') {
        _prioOrder = val;
        return this;
      }

      return typeof _prioOrder === 'function' ? _prioOrder(callbackContext) : _prioOrder;
    },

    /**
     * Ger or set the minimumLayoutMode
     * @param {string|object} [val] - The minimum layout mode
     * @returns {string|object|this} If no parameter is passed the current context is returned, else the current layout mode.
     * @example
     * dockConfig.minimumLayoutMode('L');
     * dockConfig.minimumLayoutMode({ width: 'S', height: 'L' });
     */
    minimumLayoutMode: function minimumLayoutMode(val) {
      if (typeof val !== 'undefined') {
        _minimumLayoutMode = val;
        return this;
      }

      return typeof _minimumLayoutMode === 'function' ? _minimumLayoutMode(callbackContext) : _minimumLayoutMode;
    },

    /**
     * Set the component visibility. If false the component is not added to the layout engine.
     * @param {boolean} [val=true] - Toggle visibility
     * @returns {this|boolean} The current context or show
     */
    show: function show(val) {
      if (typeof val !== 'undefined') {
        _show = val;
        return this;
      }

      return typeof _show === 'function' ? _show(callbackContext) : _show;
    }
  };
}

function roundRect(rect) {
  rect.x = Math.floor(rect.x);
  rect.y = Math.floor(rect.y);
  rect.width = Math.floor(rect.width);
  rect.height = Math.floor(rect.height);
}

function resolveContainerRects(rect, settings) {
  var containerRect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  var logicalContainerRect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }; // Check input object for size

  containerRect.width = rect.width || 0;
  containerRect.height = rect.height || 0;

  if (typeof settings.size !== 'undefined') {
    containerRect.width = isNaN(settings.size.width) ? containerRect.width : settings.size.width;
    containerRect.height = isNaN(settings.size.height) ? containerRect.height : settings.size.height;
  }

  if (typeof settings.logicalSize !== 'undefined') {
    logicalContainerRect.width = isNaN(settings.logicalSize.width) ? containerRect.width : settings.logicalSize.width;
    logicalContainerRect.height = isNaN(settings.logicalSize.height) ? containerRect.height : settings.logicalSize.height;
    logicalContainerRect.align = isNaN(settings.logicalSize.align) ? 0.5 : Math.min(Math.max(settings.logicalSize.align, 0), 1);
    logicalContainerRect.preserveAspectRatio = settings.logicalSize.preserveAspectRatio;
  } else {
    logicalContainerRect.width = containerRect.width;
    logicalContainerRect.height = containerRect.height;
    logicalContainerRect.preserveAspectRatio = false;
  }

  roundRect(logicalContainerRect);
  roundRect(containerRect);
  return {
    logicalContainerRect: logicalContainerRect,
    containerRect: containerRect
  };
}
function resolveSettings(s) {
  var settings = {
    center: {
      minWidthRatio: 0.5,
      minHeightRatio: 0.5,
      minWidth: 0,
      minHeight: 0
    }
  };
  extend(true, settings, s);
  settings.center.minWidthRatio = Math.min(Math.max(settings.center.minWidthRatio, 0), 1); // Only accept value between 0-1

  settings.center.minHeightRatio = Math.min(Math.max(settings.center.minHeightRatio, 0), 1); // Only accept value between 0-1

  settings.center.minWidth = Math.max(settings.center.minWidth, 0); // Consider <= 0 to be falsy and fallback to ratio

  settings.center.minHeight = Math.max(settings.center.minHeight, 0); // Consider <= 0 to be falsy and fallback to ratio

  return settings;
}

function isNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
function notNumber(value) {
  return typeof value !== 'number' || isNaN(value);
}

function getMinMax(points) {
  var num = points.length;
  var xMin = NaN;
  var xMax = NaN;
  var yMin = NaN;
  var yMax = NaN;

  for (var i = 0; i < num; i++) {
    xMin = isNaN(xMin) ? points[i].x : Math.min(xMin, points[i].x);
    xMax = isNaN(xMax) ? points[i].x : Math.max(xMax, points[i].x);
    yMin = isNaN(yMin) ? points[i].y : Math.min(yMin, points[i].y);
    yMax = isNaN(yMax) ? points[i].y : Math.max(yMax, points[i].y);
  }

  return [xMin, yMin, xMax, yMax];
}
/**
 * @ignore
 * @param {oject} line
 * @returns {point[]} Array of points
 */

function lineToPoints(line) {
  var x1 = line.x1 || 0;
  var y1 = line.y1 || 0;
  var x2 = line.x2 || 0;
  var y2 = line.y2 || 0;
  return [{
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  }];
}
/**
 * @ignore
 * @param {oject} rect
 * @returns {point[]} Array of points
 */

function rectToPoints(rect) {
  return [{
    x: rect.x,
    y: rect.y
  }, {
    x: rect.x + rect.width,
    y: rect.y
  }, {
    x: rect.x + rect.width,
    y: rect.y + rect.height
  }, {
    x: rect.x,
    y: rect.y + rect.height
  }];
}
function pointsToRect(points) {
  var _getMinMax = getMinMax(points),
      _getMinMax2 = _slicedToArray(_getMinMax, 4),
      xMin = _getMinMax2[0],
      yMin = _getMinMax2[1],
      xMax = _getMinMax2[2],
      yMax = _getMinMax2[3];

  return {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
}
function pointsToCircle(points, r) {
  return {
    cx: points[0].x,
    cy: points[0].y,
    r: r
  };
}
function pointsToLine(points) {
  return {
    x1: points[0].x,
    y1: points[0].y,
    x2: points[1].x,
    y2: points[1].y
  };
}
/**
 * @ignore
 * @param {oject}
 * @returns {string} Type of geometry
 */

function getShapeType(shape) {
  var _ref = shape || {},
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      x1 = _ref.x1,
      x2 = _ref.x2,
      y1 = _ref.y1,
      y2 = _ref.y2,
      cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r,
      vertices = _ref.vertices;

  if (isNumber(cx) && isNumber(cy) && isNumber(r)) {
    return 'circle';
  }

  if (isNumber(x1) && isNumber(x2) && isNumber(y1) && isNumber(y2)) {
    return 'line';
  }

  if (isNumber(x) && isNumber(y) && isNumber(width) && isNumber(height)) {
    return 'rect';
  }

  if (isNumber(x) && isNumber(y)) {
    return 'point';
  }

  if (Array.isArray(vertices)) {
    return 'polygon';
  }

  return null;
}
function expandRect(size, rect) {
  return {
    x: rect.x - size,
    y: rect.y - size,
    width: rect.width + size,
    height: rect.height + size
  };
}

function createRect(x, y, width, height, margin) {
  return {
    x: isNaN(x) ? 0 : x,
    y: isNaN(x) ? 0 : y,
    width: isNaN(x) ? 0 : width,
    height: isNaN(x) ? 0 : height,
    margin: isNaN(margin) ? 0 : margin
  };
}

function cacheSize(c, reducedRect, layoutRect) {
  if (typeof c.cachedSize === 'undefined') {
    var dock = c.config.dock();
    var size = c.comp.preferredSize({
      inner: reducedRect,
      outer: layoutRect,
      dock: dock
    }); // backwards compatibility

    if (!isNaN(size)) {
      size = {
        width: size,
        height: size
      };
    } else if (size && !isNaN(size.size)) {
      size.width = size.size;
      size.height = size.size;
    }

    var relevantSize;

    if (dock === 'top' || dock === 'bottom') {
      relevantSize = size.height;
    } else if (dock === 'right' || dock === 'left') {
      relevantSize = size.width;
    } else {
      relevantSize = Math.max(size.width, size.height);
    }

    c.cachedSize = Math.ceil(relevantSize);
    c.edgeBleed = size.edgeBleed || 0;
  }

  return c.cachedSize;
}

function validateReduceRect(rect, reducedRect, settings) {
  // Absolute value for width/height should have predence over relative value
  var minReduceWidth = Math.min(settings.center.minWidth, rect.width) || Math.max(rect.width * settings.center.minWidthRatio, 1);
  var minReduceHeight = Math.min(settings.center.minHeight, rect.height) || Math.max(rect.height * settings.center.minHeightRatio, 1);
  return reducedRect.width >= minReduceWidth && reducedRect.height >= minReduceHeight;
}

function reduceDocRect(reducedRect, c) {
  switch (c.config.dock()) {
    case 'top':
      reducedRect.y += c.cachedSize;
      reducedRect.height -= c.cachedSize;
      break;

    case 'bottom':
      reducedRect.height -= c.cachedSize;
      break;

    case 'left':
      reducedRect.x += c.cachedSize;
      reducedRect.width -= c.cachedSize;
      break;

    case 'right':
      reducedRect.width -= c.cachedSize;
      break;

    default:
  }
}

function addEdgeBleed(currentEdgeBleed, c) {
  var edgeBleed = c.edgeBleed;

  if (!edgeBleed) {
    return;
  }

  currentEdgeBleed.left = Math.max(currentEdgeBleed.left, edgeBleed.left || 0);
  currentEdgeBleed.right = Math.max(currentEdgeBleed.right, edgeBleed.right || 0);
  currentEdgeBleed.top = Math.max(currentEdgeBleed.top, edgeBleed.top || 0);
  currentEdgeBleed.bottom = Math.max(currentEdgeBleed.bottom, edgeBleed.bottom || 0);
}

function reduceEdgeBleed(layoutRect, reducedRect, edgeBleed) {
  if (reducedRect.x < edgeBleed.left) {
    reducedRect.width -= edgeBleed.left - reducedRect.x;
    reducedRect.x = edgeBleed.left;
  }

  var reducedRectRightBoundary = layoutRect.width - (reducedRect.x + reducedRect.width);

  if (reducedRectRightBoundary < edgeBleed.right) {
    reducedRect.width -= edgeBleed.right - reducedRectRightBoundary;
  }

  if (reducedRect.y < edgeBleed.top) {
    reducedRect.height -= edgeBleed.top - reducedRect.y;
    reducedRect.y = edgeBleed.top;
  }

  var reducedRectBottomBoundary = layoutRect.height - (reducedRect.y + reducedRect.height);

  if (reducedRectBottomBoundary < edgeBleed.bottom) {
    reducedRect.height -= edgeBleed.bottom - reducedRectBottomBoundary;
  }
}

function reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings) {
  var newReduceRect = extend({}, reducedRect);
  var newEdgeBleed = extend({}, edgeBleed);
  reduceDocRect(newReduceRect, c);
  addEdgeBleed(newEdgeBleed, c);
  reduceEdgeBleed(layoutRect, newReduceRect, newEdgeBleed);
  var isValid = validateReduceRect(layoutRect, newReduceRect, settings);

  if (!isValid) {
    return false;
  }

  reduceDocRect(reducedRect, c);
  addEdgeBleed(edgeBleed, c);
  return true;
}
/**
 * Updates the visible and hidden components based on components that are docked to other components.
 * For example, assume a component called myRect:
 * {
 *  key: 'myRect',
 *  type: 'rect',
 *  dock: 'bottom'
 * }
 * and a component called myLine:
 * {
 *  key: 'myLine',
 *  type: 'line',
 *  dock: '@myRect'
 * }
 * if the layout engine decides to hide myRect, then myLine should be hidden as well.
 * @param {Array} visible - Components to be decided if they should be hidden or not.
 * @param {Array} hidden - Components that are already hidden.
 * @returns {Object} containing the new visible components and additional components to be hidden.
 * @ignore
 */


function filterReferencedDocks(visible, hidden) {
  if (hidden.length === 0) {
    return;
  }

  for (var i = 0; i < visible.length; ++i) {
    var v = visible[i];

    if (v.referencedDocks.length) {
      var isAllHidden = v.referencedDocks.every(function (refDock) {
        return hidden.some(function (h) {
          return h.key === refDock;
        });
      });

      if (isAllHidden) {
        hidden.push(visible.splice(i, 1)[0]);
      }
    }
  }
}

function reduceLayoutRect(_ref) {
  var layoutRect = _ref.layoutRect,
      visible = _ref.visible,
      hidden = _ref.hidden,
      settings = _ref.settings;
  var reducedRect = createRect(layoutRect.x, layoutRect.y, layoutRect.width, layoutRect.height);
  var edgeBleed = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var sortedComponents = visible.slice();
  sortedComponents.sort(function (a, b) {
    return a.config.prioOrder() - b.config.prioOrder();
  }); // lower prioOrder will have higher prio

  for (var i = 0; i < sortedComponents.length; ++i) {
    var c = sortedComponents[i];
    cacheSize(c, reducedRect, layoutRect);

    if (!reduceSingleLayoutRect(layoutRect, reducedRect, edgeBleed, c, settings)) {
      hidden.push(sortedComponents.splice(i, 1)[0]);
      --i;
    }
  }

  filterReferencedDocks(visible, hidden);
  var filteredUnsortedComps = visible.filter(function (c) {
    return sortedComponents.indexOf(c) !== -1;
  });
  visible.length = 0;
  visible.push.apply(visible, _toConsumableArray$1(filteredUnsortedComps));
  reduceEdgeBleed(layoutRect, reducedRect, edgeBleed);
  return reducedRect;
}

function computeRect(rect) {
  return {
    x: rect.margin.left + rect.x * rect.scaleRatio.x,
    y: rect.margin.top + rect.y * rect.scaleRatio.y,
    width: rect.width * rect.scaleRatio.x,
    height: rect.height * rect.scaleRatio.y
  };
}

function appendScaleRatio(rect, outerRect, layoutRect, containerRect) {
  var scaleRatio = {
    x: containerRect.width / layoutRect.width,
    y: containerRect.height / layoutRect.height
  };
  var margin = {
    left: 0,
    top: 0
  };

  if (layoutRect.preserveAspectRatio) {
    var xLessThenY = scaleRatio.x < scaleRatio.y; // To preserve the aspect ratio, take the smallest ratio and apply in both directions to "meet" the size of the container

    var minRatio = Math.min(scaleRatio.x, scaleRatio.y);
    scaleRatio.x = minRatio;
    scaleRatio.y = minRatio;
    var area = xLessThenY ? 'height' : 'width';
    var spread = (containerRect[area] - layoutRect[area] * scaleRatio.x) * layoutRect.align;
    margin.left = xLessThenY ? 0 : spread;
    margin.top = xLessThenY ? spread : 0;
  }

  rect.scaleRatio = scaleRatio;
  rect.margin = margin;
  outerRect.scaleRatio = scaleRatio;
  outerRect.margin = margin;
  layoutRect.scaleRatio = scaleRatio;
  layoutRect.margin = margin;
}

function boundingBox(rects) {
  var _ref2;

  var points = (_ref2 = []).concat.apply(_ref2, _toConsumableArray$1(rects.map(rectToPoints)));

  return pointsToRect(points);
}

function positionComponents(_ref3) {
  var visible = _ref3.visible,
      layoutRect = _ref3.layoutRect,
      reducedRect = _ref3.reducedRect,
      containerRect = _ref3.containerRect,
      translation = _ref3.translation;
  var vRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);
  var hRect = createRect(reducedRect.x, reducedRect.y, reducedRect.width, reducedRect.height);
  var referencedComponents = {};
  var referenceArray = visible.slice();
  var elementOrder = referenceArray.slice().sort(function (a, b) {
    return a.config.displayOrder() - b.config.displayOrder();
  });
  visible.sort(function (a, b) {
    if (b.referencedDocks.length > 0) {
      return -1;
    }

    if (a.referencedDocks.length > 0) {
      return 1;
    }

    var diff = a.config.displayOrder() - b.config.displayOrder();

    if (diff === 0) {
      return referenceArray.indexOf(a) - referenceArray.indexOf(b);
    }

    return diff;
  }).forEach(function (c) {
    var outerRect = {};
    var rect = {};
    var d = c.config.dock();

    switch (d) {
      case 'top':
        outerRect.height = rect.height = c.cachedSize;
        outerRect.width = layoutRect.width;
        rect.width = vRect.width;
        outerRect.x = layoutRect.x;
        rect.x = vRect.x;
        outerRect.y = rect.y = vRect.y - c.cachedSize;
        vRect.y -= c.cachedSize;
        vRect.height += c.cachedSize;
        break;

      case 'bottom':
        outerRect.x = layoutRect.x;
        rect.x = vRect.x;
        outerRect.y = rect.y = vRect.y + vRect.height;
        outerRect.width = layoutRect.width;
        rect.width = vRect.width;
        outerRect.height = rect.height = c.cachedSize;
        vRect.height += c.cachedSize;
        break;

      case 'left':
        outerRect.x = rect.x = hRect.x - c.cachedSize;
        outerRect.y = layoutRect.y;
        rect.y = hRect.y;
        outerRect.width = rect.width = c.cachedSize;
        outerRect.height = layoutRect.height;
        rect.height = hRect.height;
        hRect.x -= c.cachedSize;
        hRect.width += c.cachedSize;
        break;

      case 'right':
        outerRect.x = rect.x = hRect.x + hRect.width;
        outerRect.y = layoutRect.y;
        rect.y = hRect.y;
        outerRect.width = rect.width = c.cachedSize;
        outerRect.height = layoutRect.height;
        rect.height = hRect.height;
        hRect.width += c.cachedSize;
        break;

      case 'center':
        outerRect.x = rect.x = reducedRect.x;
        outerRect.y = rect.y = reducedRect.y;
        outerRect.width = rect.width = reducedRect.width;
        outerRect.height = rect.height = reducedRect.height;
        break;

      default:
        if (c.referencedDocks.length > 0) {
          var refs = c.referencedDocks.map(function (ref) {
            return referencedComponents[ref];
          }).filter(function (ref) {
            return !!ref;
          });

          if (refs.length > 0) {
            outerRect = boundingBox(refs.map(function (ref) {
              return ref.outerRect;
            }));
            rect = boundingBox(refs.map(function (ref) {
              return ref.r;
            }));
          }
        }

        break;
    }

    if (c.key) {
      referencedComponents[c.key] = {
        // store the size of this component
        r: rect,
        outerRect: outerRect
      };
    }

    appendScaleRatio(rect, outerRect, layoutRect, containerRect);
    rect.edgeBleed = c.edgeBleed;
    rect.computed = computeRect(rect);
    outerRect.edgeBleed = c.edgeBleed;
    outerRect.computed = computeRect(outerRect);
    rect.x += translation.x;
    rect.y += translation.y;
    outerRect.x += translation.x;
    outerRect.y += translation.y;
    c.comp.resize(rect, outerRect);
    c.cachedSize = undefined;
    c.edgeBleed = undefined;
  });
  return visible.map(function (c) {
    return elementOrder.indexOf(c);
  });
}

function checkShowSettings(strategySettings, dockSettings, logicalContainerRect) {
  var layoutModes = strategySettings.layoutModes || {};
  var minimumLayoutMode = dockSettings.minimumLayoutMode();
  var show = dockSettings.show();

  if (show && picasso_esm_typeof(minimumLayoutMode) === 'object') {
    show = layoutModes[minimumLayoutMode.width] && layoutModes[minimumLayoutMode.height] && logicalContainerRect.width >= layoutModes[minimumLayoutMode.width].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode.height].height;
  } else if (show && minimumLayoutMode !== undefined) {
    show = layoutModes[minimumLayoutMode] && logicalContainerRect.width >= layoutModes[minimumLayoutMode].width && logicalContainerRect.height >= layoutModes[minimumLayoutMode].height;
  }

  return show;
}

function validateComponent(component) {
  if (!component.settings && !component.settings) {
    throw new Error('Invalid component settings');
  }

  if (!component.resize || typeof component.resize !== 'function') {
    throw new Error('Component is missing resize function');
  }

  if (!component.dockConfig && !component.preferredSize) {
    throw new Error('Component is missing preferredSize function');
  }
}

function filterComponents(components, settings, rect) {
  var visible = [];
  var hidden = []; // check show settings

  for (var i = 0; i < components.length; ++i) {
    var comp = components[i];
    validateComponent(comp); // backwards compatibility

    var config = void 0;

    if (comp.instance) {
      config = comp.instance.dockConfig();
    } else {
      config = dockConfig(comp.settings.layout);
    }

    var key = comp.settings.key;
    var d = config.dock();
    var referencedDocks = /@/.test(d) ? d.split(',').map(function (s) {
      return s.replace(/^\s*@/, '');
    }) : [];

    if (checkShowSettings(settings, config, rect)) {
      visible.push({
        comp: comp,
        key: key,
        config: config,
        referencedDocks: referencedDocks
      });
    } else {
      hidden.push({
        comp: comp,
        key: key,
        config: config,
        referencedDocks: referencedDocks
      });
    }
  }

  return [visible, hidden];
}
/**
 * @typedef {object} dock-layout-settings
 * @property {object} [logicalSize] - Logical size
 * @property {number} [logicalSize.width] - Width in pixels
 * @property {number} [logicalSize.height] - Height in pixels
 * @property {boolean} [logicalSize.preserveAspectRatio=false] - If true, takes the smallest ratio of width/height between logical and physical size ( physical / logical )
 * @property {number} [logicalSize.align=0.5] - Normalized value between 0-1. Defines how the space around the scaled axis is spread in the container, with 0.5 meaning the spread is equal on both sides. Only applicable if preserveAspectRatio is set to true
 * @property {object} [center] - Define how much space the center dock area requires
 * @property {number} [center.minWidthRatio=0.5] - Value between 0 and 1
 * @property {number} [center.minHeightRatio=0.5] - Value between 0 and 1
 * @property {number} [center.minWidth] - Width in pixels
 * @property {number} [center.minHeight] - Height in pixels
 * @property {object<string, {width: number, height: number}>} [layoutModes] Dictionary with named sizes
 */


function dockLayout(initialSettings) {
  var settings = resolveSettings(initialSettings);
  var docker = {};

  docker.layout = function layout(rect) {
    var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!rect || isNaN(rect.x) || isNaN(rect.y) || isNaN(rect.width) || isNaN(rect.height)) {
      throw new Error('Invalid rect');
    }

    if (!components.length) {
      return {
        visible: [],
        hidden: []
      };
    }

    var _resolveContainerRect = resolveContainerRects(rect, settings),
        logicalContainerRect = _resolveContainerRect.logicalContainerRect,
        containerRect = _resolveContainerRect.containerRect;

    var _filterComponents = filterComponents(components, settings, logicalContainerRect),
        _filterComponents2 = _slicedToArray(_filterComponents, 2),
        visible = _filterComponents2[0],
        hidden = _filterComponents2[1];

    var reducedRect = reduceLayoutRect({
      layoutRect: logicalContainerRect,
      visible: visible,
      hidden: hidden,
      settings: settings
    });
    var translation = {
      x: rect.x,
      y: rect.y
    };
    var order = positionComponents({
      visible: visible,
      layoutRect: logicalContainerRect,
      reducedRect: reducedRect,
      containerRect: containerRect,
      translation: translation
    });
    hidden.forEach(function (c) {
      c.comp.visible = false; // set empty rects on hidden components

      var r = createRect();
      c.comp.resize(r, r);
    });
    return {
      visible: visible.map(function (v) {
        return v.comp;
      }),
      hidden: hidden.map(function (h) {
        return h.comp;
      }),
      order: order
    };
  };

  docker.settings = function settingsFn(s) {
    settings = resolveSettings(s);
  };

  return docker;
}

/* global navigator */
function detectTouchSupport(e) {
  if ('ontouchstart' in e && 'ontouchend' in e || navigator.maxTouchPoints > 1) {
    return true;
  }

  return false;
}
function isTouchEvent(e) {
  return !!e.changedTouches;
}
function isValidTapEvent(e, eventInfo) {
  var isTouch = isTouchEvent(e);
  var ee = isTouch ? e.changedTouches[0] : e;
  var dt = Date.now() - eventInfo.time;
  var dx = isNaN(eventInfo.x) ? 0 : Math.abs(ee.clientX - eventInfo.x);
  var dy = isNaN(eventInfo.y) ? 0 : Math.abs(ee.clientY - eventInfo.y);
  return (e.button === 0 || isTouch) && !eventInfo.multiTouch && dx <= 12 && dy <= 12 && dt <= 300;
}

// import types from './types';

/**
 * @ignore
 * @param {Array<data-source>} dataSources
 * @param {any} { logger }
 * @returns {function}
 */
function datasets(dataSources, _ref) {
  var types = _ref.types,
      logger = _ref.logger;
  var data = {};
  var sets = [];

  if (!Array.isArray(dataSources)) {
    logger.warn('Deprecated: "data-source" configuration"');
    sets.push(dataSources);
  } else {
    sets.push.apply(sets, _toConsumableArray$1(dataSources));
  }

  sets.forEach(function (d, i) {
    var datasetFactory = types(d.type);

    if (datasetFactory) {
      var key = d.key;

      if (typeof d.key === 'undefined') {
        logger.warn("Missing key for dataset. Using index '".concat(i, "' as key."));
        key = i;
      }

      var dataset = datasetFactory({
        key: key,
        data: d.data,
        config: d.config
      });
      data[key] = dataset;
    }
  });
  /**
   * Returns the `dataset` which has `key` as identifier
   * @ignore
   * @param {string} key - The dataset identifier
   * @returns {dataset}
   */

  var fn = function fn(key) {
    if (key) {
      return data[key];
    }

    return data[Object.keys(data)[0]];
  };

  return fn;
}
/**
 * @typedef {object} data-source
 * @property {string} key - Unique identifier for this data source
 * @property {string} type - The dataset type
 * @property {any} data
 */

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi = pi$1 / 2;
var tau$1 = 2 * pi$1;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$1) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$1)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$1 - epsilon$1) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$1) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$1) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon$1) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$1) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$1) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon$1) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon$1) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$1) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function picasso_esm_line() {
  var x$1 = x,
      y$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function picasso_esm_area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return picasso_esm_line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function picasso_esm_pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau$1),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var slice = Array.prototype.slice;

function picasso_esm_point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: picasso_esm_point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: picasso_esm_point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasis(context) {
  return new Basis(context);
}

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$1) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function curveNatural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function curveStep(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function stackOffsetNone(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function stackOrderNone(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = stackOrderNone,
      offset = stackOffsetNone,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
  };

  return stack;
}

function stackOffsetExpand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  stackOffsetNone(series, order);
}

function stackOffsetDiverging(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}

function stackOffsetSilhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  stackOffsetNone(series, order);
}

function stackOffsetWiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  stackOffsetNone(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return stackOrderNone(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function stackOrderAscending(series) {
  var sums = series.map(sum);
  return stackOrderNone(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function stackOrderInsideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function stackOrderReverse(series) {
  return stackOrderNone(series).reverse();
}

function registryFactory(parentRegistry) {
  var registerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unspecified';
  var logger = arguments.length > 2 ? arguments[2] : undefined;
  var defaultValue;
  var reg = {};
  var parent = parentRegistry || {
    get: function get() {
      return undefined;
    },
    has: function has() {
      return false;
    },
    default: function _default() {
      return undefined;
    }
  };
  defaultValue = parent.default();
  /**
   * @private
   * @param {string} key
   * @param {any} value
   * @throws {TypeError} Key must be a non-empty string
   * @returns {boolean} False if the given key already exists, true otherwise
   * @example
   * var r = registry();
   * r.add( "marker", function(args) {
   *   return new markers[args.type](args);
   * });
   *
   */

  function add(key, value) {
    if (!key || typeof key !== 'string') {
      throw new TypeError('Invalid argument: key must be a non-empty string');
    }

    if (key in reg) {
      return false;
    }

    reg[key] = value;
    return true;
  }

  function get(key) {
    return reg[key] || parent.get(key);
  }

  function has(key) {
    return !!reg[key] || parent.has(key);
  }

  function remove(key) {
    var d = reg[key];
    delete reg[key];
    return d;
  }

  function getKeys() {
    return Object.keys(reg);
  }

  function getValues() {
    return Object.keys(reg).map(function (key) {
      return reg[key];
    });
  }

  function deflt(d) {
    if (typeof d !== 'undefined') {
      defaultValue = d;
    }

    return defaultValue;
  }
  /**
   * @alias registry
   * @interface
   * @param {string} key
   * @param {any} value
   */


  function registry(key, value) {
    if (typeof value !== 'undefined') {
      return add(key, value);
    }

    var ret = get(key);

    if (logger && typeof ret === 'undefined') {
      logger.warn("".concat(key, " does not exist in ").concat(registerName, " registry"));
    }

    return ret || get(defaultValue);
  }

  registry.add = add;
  registry.get = get;
  registry.has = has;
  registry.remove = remove;
  registry.getKeys = getKeys;
  registry.getValues = getValues;
  registry.default = deflt;
  registry.register = add; // deprecated

  return registry;
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity$1(x) {
  return x;
}

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$1,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$1,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function formatter(pattern, thousand, decimal) {
  var locale, d3format;
  /**
   * Format a value according to the specified pattern created at construct
   * @private
   *
   * @param  {Number} value   The number to be formatted
   * @return {String}         [description]
   */

  function format(value) {
    return d3format(value);
  }
  /**
    * Set the locale for the formatter
    *
    * @param  {Object} args   Locale object for formatting
    * @return {Undefined}      Returns nothing
    */


  format.locale = function localeFn(settings) {
    locale = formatLocale(settings);
    d3format = locale.format(pattern);
    return this;
  };
  /**
   * Resets the formatter using format.locale
   * @ignore
   */


  function reset() {
    format.locale({
      decimal: decimal || '.',
      thousands: thousand || ',',
      grouping: [3],
      currency: ['$', '']
    });
  }

  reset();
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Number} v   Value
    * @param  {String} t   Thousand
    * @param  {String} d   Decimal
    * @return {String}     Formatted value
    */

  format.format = function formatFn(p, v, t, d) {
    if (t || d) {
      thousand = t;
      decimal = d;
      reset();
    }

    return locale.format(p)(v);
  };
  /**
   * Change the pattern on existing formatter
   *
   * @param  {String} p     Pattern (optional)
   * @return {String}       Returns the pattern
   */


  format.pattern = function patternFn(p) {
    if (p) {
      pattern = p;
      d3format = locale.format(p);
    }

    return pattern;
  };

  return format;
}

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day$1;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : utcParse(isoSpecifier);

function formatter$1(pattern) {
  // eslint-disable-line import/prefer-default-export
  var locale = formatLocale$1({
    dateTime: '%x, %X',
    date: '%-m/%-d/%Y',
    time: '%-I:%M:%S %p',
    periods: ['AM', 'PM'],
    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  });
  var d3format = locale.format(pattern);
  /**
   * Format a value according to the specified pattern created at construct
   *
   * @param  {Date} value   The number to be formatted
   * @return {String}         [description]
   * @private
   */

  function format(value) {
    return d3format(value);
  }
  /**
    * Format a value according to a specific pattern
    * that is not the one specified in the constructor
    *
    * @param  {String} p   Pattern
    * @param  {Date} v   Value
    * @return {String}     Formatted value
    */


  format.format = function formatFn(p, v) {
    return locale.format(p)(v);
  };
  /**
   * Set the locale for the formatter
   *
   * @param  {Object} args   Locale object for formatting
   * @return {Undefined}      Returns nothing
   */


  format.locale = function localeFn() {
    locale = formatLocale$1.apply(void 0, arguments);
    d3format = locale.format(pattern);
    return this;
  };
  /**
   * Parse a string to a date according to a pattern
   *
   * @param  {String} p   Pattern
   * @param  {String} v   Value
   * @return {Date}     Date
   */


  format.parse = function parse(p, v) {
    return locale.parse(p)(v);
  };
  /**
   * Returns a parser that parses strings to date according to the pattern
   *
   * @param  {String} p   Pattern
   * @return {Function}   Parser
   */


  format.parsePattern = function parsePattern(p) {
    return locale.parse(p);
  };

  return format;
}

var formatterRegistry = registryFactory();
formatterRegistry('d3-number', formatter);
formatterRegistry('d3-time', formatter$1);

/* eslint no-return-assign: 0 */

var getFormatter = function getFormatter(data) {
  if (typeof data.formatter === 'function') {
    return data.formatter();
  }

  var f = data.formatter || {};
  return formatterRegistry(f.type || 'd3-number')(f.format || '');
};

var accessors = {
  id: function id(data) {
    return "".concat(data.source, "/").concat(data.key || data.title);
  },
  key: function key(data) {
    return String(data.key || data.title);
  },
  tags: function tags(data) {
    return data.tags;
  },
  min: function min(data) {
    return data.min;
  },
  max: function max(data) {
    return data.max;
  },
  type: function type(data) {
    return data.type;
  },
  title: function title(data) {
    return String(data.title);
  },
  values: function values(data) {
    return data.values;
  },
  value: function value(v) {
    return v;
  },
  label: function label(v) {
    return v;
  },
  formatter: function formatter(data) {
    return getFormatter(data);
  }
};
/**
 * Create a new field with default settings
 * @ignore
 * @return {field} Data field
 */

function picasso_esm_field(data) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$id = _ref.id,
      _id = _ref$id === void 0 ? accessors.id : _ref$id,
      _ref$key = _ref.key,
      _key = _ref$key === void 0 ? accessors.key : _ref$key,
      _ref$min = _ref.min,
      _min = _ref$min === void 0 ? accessors.min : _ref$min,
      _ref$max = _ref.max,
      _max = _ref$max === void 0 ? accessors.max : _ref$max,
      _ref$type = _ref.type,
      _type = _ref$type === void 0 ? accessors.type : _ref$type,
      _ref$tags = _ref.tags,
      _tags = _ref$tags === void 0 ? accessors.tags : _ref$tags,
      _ref$title = _ref.title,
      _title = _ref$title === void 0 ? accessors.title : _ref$title,
      _ref$values = _ref.values,
      values = _ref$values === void 0 ? accessors.values : _ref$values,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? accessors.value : _ref$value,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? accessors.label : _ref$label,
      _ref$formatter = _ref.formatter,
      _formatter = _ref$formatter === void 0 ? accessors.formatter : _ref$formatter;

  /**
   * @alias field
   */
  var f = {
    /**
     * Returns this field's id
     * @returns {string}
     */
    id: function id() {
      return _id(data);
    },

    /**
     * Returns this field's key
     * @returns {string}
     */
    key: function key() {
      return _key(data);
    },

    /**
     * Returns the input data
     * @returns {any}
     */
    raw: function raw() {
      return data;
    },

    /**
     * Returns the tags.
     * @return {Array<string>}
     */
    tags: function tags() {
      return _tags(data);
    },

    /**
     * Returns this field's type: 'dimension' or 'measure'.
     * @return {string}
     */
    type: function type() {
      return _type(data);
    },

    /**
     * Returns the min value of this field.
     * @return {number}
     */
    min: function min() {
      return _min(data);
    },

    /**
     * Returns the max value of this field.
     * @return {number}
     */
    max: function max() {
      return _max(data);
    },

    /**
     * Returns this field's title.
     * @return {string}
     */
    title: function title() {
      return _title(data);
    },

    /**
     * Returns the values of this field.
     * @return {Array<datum-extract>}
     */
    items: function items() {
      return values(data);
    },

    /**
     * Returns a formatter adapted to the content of this field.
     */
    formatter: function formatter() {
      return _formatter(data);
    },
    value: value,
    label: label
  };
  return f;
}

var OFFSETS = {
  diverging: stackOffsetDiverging,
  none: stackOffsetNone,
  silhouette: stackOffsetSilhouette,
  expand: stackOffsetExpand,
  wiggle: stackOffsetWiggle
};
var ORDERS = {
  ascending: stackOrderAscending,
  insideout: stackOrderInsideOut,
  none: stackOrderNone,
  reverse: stackOrderReverse
};

function stacked(data, config, ds) {
  var stackIds = {};
  var stackFn = config.stackKey;
  var valueFn = config.value;
  var startProp = config.startProp || 'start';
  var endProp = config.endProp || 'end';
  var offset = config.offset || 'none';
  var order = config.order || 'none';
  var valueRef = config.valueRef || '';
  var maxStackCount = 0;
  var valueFields = {};

  for (var i = 0; i < data.items.length; i++) {
    var p = data.items[i];
    var sourceField = valueRef ? p[valueRef] : null;

    if (sourceField && sourceField.source) {
      var ff = "".concat(sourceField.source.key || '', "/").concat(sourceField.source.field);

      if (!valueFields[ff]) {
        valueFields[ff] = sourceField.source;
      }
    }

    var sid = stackFn(p);
    stackIds[sid] = stackIds[sid] || {
      items: []
    };
    stackIds[sid].items.push(p);
    maxStackCount = Math.max(maxStackCount, stackIds[sid].items.length);
  }

  var keys = Array.apply(null, {
    length: maxStackCount
  }).map(Number.call, Number); // eslint-disable-line

  var matrix = Object.keys(stackIds).map(function (sid) {
    return stackIds[sid].items;
  });
  var d3Stack = stack().keys(keys).value(function (s, key) {
    return s[key] ? valueFn(s[key]) : 0;
  }).order(ORDERS[order]).offset(OFFSETS[offset]);
  var series = d3Stack(matrix);
  var values = [];

  for (var _i = 0; _i < series.length; _i++) {
    var serie = series[_i];

    for (var s = 0; s < serie.length; s++) {
      var range = serie[s];
      var item = serie[s].data[serie.key];

      if (!item) {
        continue;
      }

      item[startProp] = {
        value: range[0]
      };
      item[endProp] = {
        value: range[1]
      };
      values.push(range[0], range[1]);
    }
  }

  var stackedFields = Object.keys(valueFields).map(function (f) {
    var dSource = ds(valueFields[f].key);
    return dSource ? dSource.field(valueFields[f].field) : null;
  }).filter(function (f) {
    return !!f;
  });
  var field$1 = picasso_esm_field({
    title: stackedFields.map(function (f) {
      return f.title();
    }).join(', '),
    min: Math.min.apply(Math, values),
    max: Math.max.apply(Math, values),
    type: 'measure',
    formatter: stackedFields[0] ? stackedFields[0].formatter : undefined
  });
  data.fields.push(field$1);
}

function extract(dataConfig) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var extracted = {// items: [],
    // fields: [],
    // source: null,
    // value: null,
    // label: null,
    // children: null,
    // root: null,
    // graph: null
  };
  var logger = opts.logger;

  if (Array.isArray(dataConfig)) {
    // if data is an array, assume it's manual data input -> normalize
    extracted.items = dataConfig.map(function (v) {
      return {
        value: v,
        label: String(v)
      };
    });
  } else if (dataConfig) {
    if ('collection' in dataConfig) {
      extracted = _objectSpread({}, data.collection(dataConfig.collection));
    } else {
      var source = data.dataset ? data.dataset(dataConfig.source) : null;

      var valueFn = dataConfig.value || function (d) {
        return d;
      };

      var labelFn = dataConfig.label || function (d) {
        return d;
      };

      if (dataConfig.groupBy || dataConfig.mapTo) {
        // DEPRECATION
        logger.warn('Deprecated "data" configuration', dataConfig);
        extracted.items = [];
      } else if (dataConfig.hierarchy) {
        extracted.root = source.hierarchy ? source.hierarchy(dataConfig.hierarchy) : null;
        extracted.fields = source.fields();
      } else if (dataConfig.items) {
        extracted.items = dataConfig.items.map(function (v) {
          return {
            value: valueFn(v),
            label: String(labelFn(v))
          };
        });
      } else if (dataConfig.extract) {
        var extractionsConfigs = Array.isArray(dataConfig.extract) ? dataConfig.extract : [dataConfig.extract];
        extracted.items = [];
        var sourceFields = [];
        extractionsConfigs.forEach(function (cfg) {
          var _extracted$items;

          var s = cfg.source ? data.dataset(cfg.source) : source;

          if (!s) {
            return;
          }

          (_extracted$items = extracted.items).push.apply(_extracted$items, _toConsumableArray$1(s.extract(cfg)));

          if (typeof cfg.field !== 'undefined') {
            sourceFields.push(s.field(cfg.field));
          }
        });

        if (sourceFields.length) {
          extracted.fields = sourceFields;
        }

        if (dataConfig.amend && Array.isArray(dataConfig.amend)) {
          var _extracted$items2;

          (_extracted$items2 = extracted.items).push.apply(_extracted$items2, _toConsumableArray$1(dataConfig.amend));
        }
      } else if (typeof dataConfig.field !== 'undefined' && source) {
        var f = source.field(dataConfig.field);

        if (f) {
          if (!extracted.fields) {
            extracted.fields = [];
          }

          extracted.fields.push(f);

          if (!('value' in dataConfig)) {
            valueFn = f.value || function (v) {
              return v;
            };

            labelFn = f.label || function (v) {
              return v;
            };

            extracted.value = valueFn;
          }

          extracted.items = f.items().map(function (v) {
            return {
              value: valueFn(v),
              label: String(labelFn(v)),
              source: {
                field: dataConfig.field
              }
            };
          }); // TODO - add source: { key: dataConfig.source, field: dataConfig.field, data: v }
        }
      } else if (dataConfig.fields) {
        dataConfig.fields.forEach(function (obj) {
          var s = picasso_esm_typeof(obj) === 'object' && obj.source ? data.dataset(obj.source) : source;

          if (!s) {
            return;
          }

          var f;

          if (picasso_esm_typeof(obj) === 'object' && typeof obj.field !== 'undefined') {
            f = s.field(obj.field);
          } else {
            f = s.field(obj);
          }

          if (f) {
            if (!extracted.fields) {
              extracted.fields = [];
            }

            extracted.fields.push(f);
          }
        });
      }

      if (extracted.items && dataConfig.map) {
        extracted.items = extracted.items.map(dataConfig.map);
      }
    }

    if (dataConfig && dataConfig.stack) {
      stacked(extracted, dataConfig.stack, data.dataset);
    }
  }

  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.filter === 'function' && extracted.items) {
    extracted.items = extracted.items.filter(dataConfig.filter);
  }

  if (dataConfig && !Array.isArray(dataConfig) && typeof dataConfig.sort === 'function' && extracted.items) {
    extracted.items = extracted.items.sort(dataConfig.sort);
  }

  return extracted;
}

function picasso_esm_create(config, d, opts) {
  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;
  var collections = {};
  (config || []).forEach(function (cfg) {
    if (!cfg.key) {
      throw new Error('Data collection is missing "key" property');
    }

    if (picasso_esm_typeof(cfg.data) === 'object' && 'collection' in cfg.data) {
      throw new Error('Data config for collections may not reference other collections');
    }

    collections[cfg.key] = function () {
      return extractor(cfg.data, d, opts);
    };
  });

  var fn = function fn(key) {
    var k;
    var cfg;

    if (typeof key === 'string') {
      k = key;
    } else if (picasso_esm_typeof(key) === 'object') {
      k = key.key;
      cfg = key;
    }

    if (!(k in collections)) {
      throw new Error("Unknown data collection: ".concat(k));
    }

    if (typeof collections[k] === 'function') {
      collections[k] = collections[k]();
    }

    var coll = collections[k];

    if (cfg) {
      if (cfg.fields && cfg.fields.filter) {
        var filtered = coll.fields.filter(cfg.fields.filter);

        if (coll.fields.length !== filtered.length) {
          coll = extend(coll, {
            fields: filtered
          });
        }
      }
    }

    return coll;
  };

  return fn;
}

function create$1(options, data, deps) {
  var extractor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : extract;

  if (options.data) {
    var d = extractor(options.data, data, deps);

    if (d && d.fields && d.fields[0]) {
      // TODO Have some magic to handle and merge formatters from multiple sources
      return d.fields[0].formatter();
    }
  }

  var formatterType;

  if (options.formatter) {
    formatterType = "".concat(options.formatter, "-").concat(options.type || 'number');
  } else {
    formatterType = options.type || 'd3-number';
  }

  if (deps.formatter.has(formatterType)) {
    var f = deps.formatter.get(formatterType)(options.format || '');
    return f;
  }

  throw new Error("Formatter of type '".concat(formatterType, "' was not found"));
}
function collection(formattersConfig, data, deps) {
  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$1;
  var formatters = {};
  return {
    get: function get(def) {
      var key;

      if (typeof def === 'string' && formattersConfig[def]) {
        key = def;
      } else if (picasso_esm_typeof(def) === 'object' && 'formatter' in def && formattersConfig[def.formatter]) {
        key = def.formatter;
      } else if (picasso_esm_typeof(def) === 'object' && 'type' in def && formattersConfig[def.type]) {
        key = def.type;
      }

      if (key) {
        formatters[key] = formatters[key] || fn(formattersConfig[key], data, deps);
        return formatters[key];
      }

      return fn(def || {}, data, deps);
    },
    all: function all() {
      Object.keys(formattersConfig).forEach(this.get);
      return formatters;
    }
  };
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

var picasso_esm_prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (picasso_esm_prefix + key) in this;
  },
  get: function(key) {
    return this[picasso_esm_prefix + key];
  },
  set: function(key, value) {
    this[picasso_esm_prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = picasso_esm_prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === picasso_esm_prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === picasso_esm_prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === picasso_esm_prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === picasso_esm_prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === picasso_esm_prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === picasso_esm_prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === picasso_esm_prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[picasso_esm_prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var array = Array.prototype;

var map$1 = array.map;
var slice$1 = array.slice;

var implicit = {name: "implicit"};

function ordinal() {
  var index = map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0$1 = 4 / 29,
    t1$1 = 6 / 29,
    t2 = 3 * t1$1 * t1$1,
    t3 = t1$1 * t1$1 * t1$1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend$1(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
}

function lab2xyz(t) {
  return t > t1$1 ? t * t * t : t2 * (t - t0$1);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend$1(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

function constant$1(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function array$1(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
}

function interpolateObject(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function picasso_esm_string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function interpolateValue(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$1(b)
      : (t === "number" ? interpolateNumber
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : picasso_esm_string)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array$1
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? interpolateObject
      : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
}

var degrees = 180 / Math.PI;

var rho = Math.SQRT2;

function constant$2(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity$2(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$2(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = interpolateValue,
      transform,
      untransform,
      unknown,
      clamp = identity$2,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), clamp === identity$2 || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice$1.call(_), interpolate = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity$2, scale) : clamp !== identity$2;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$1() {
  var scale = continuous(identity$2, identity$2);

  scale.copy = function() {
    return copy(scale, linear$1());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$1.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function applyFormat(formatter) {
  return typeof formatter === 'undefined' ? function (t) {
    return t;
  } : function (t) {
    return formatter(t);
  };
}

function clamp(val) {
  return Math.max(0, Math.min(1, val));
}

function isObject(obj) {
  return picasso_esm_typeof(obj) === 'object';
}

function minorTicksGenerator(count, start, end) {
  var r = Math.abs(start - end);
  var interval = r / (count + 1);
  var ticks = [];

  for (var i = 1; i <= count; i++) {
    var v = i * interval;
    ticks.push(start < end ? start + v : start - v);
  }

  return ticks;
}

function appendMinorTicks(majorTicks, minorCount, scale) {
  if (majorTicks.length === 1) {
    return majorTicks;
  }

  var ticks = majorTicks.concat([]);

  for (var i = 0; i < majorTicks.length; i++) {
    var start = majorTicks[i];
    var end = majorTicks[i + 1];

    if (i === 0 && start !== scale.start()) {
      // Before and after first major tick
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
      start -= end - start;
      end = majorTicks[i];
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    } else if (i === majorTicks.length - 1 && end !== scale.end()) {
      // After last major tick
      end = start + (start - majorTicks[i - 1]);
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    } else {
      ticks.push.apply(ticks, _toConsumableArray$1(minorTicksGenerator(minorCount, start, end)));
    }
  }

  return ticks.filter(function (t) {
    return t >= scale.min() && t <= scale.max();
  });
}
/**
* Generate ticks based on a distance, for each 100th unit, one additional tick may be added
* @private
* @param  {Number} distance       Distance between each tick
* @param  {Number} scale         The scale instance
* @param  {Number} [minorCount=0]     Number of tick added between each distance
* @param  {Number} [unitDivider=100]   Number to divide distance with
* @return {Array}               Array of ticks
*/


function looseDistanceBasedGenerator(_ref) {
  var distance = _ref.distance,
      scale = _ref.scale,
      _ref$minorCount = _ref.minorCount,
      minorCount = _ref$minorCount === void 0 ? 0 : _ref$minorCount,
      _ref$unitDivider = _ref.unitDivider,
      unitDivider = _ref$unitDivider === void 0 ? 100 : _ref$unitDivider,
      _ref$formatter = _ref.formatter,
      formatter = _ref$formatter === void 0 ? undefined : _ref$formatter;
  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;
  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers

  var majorTicks = scale.ticks(count);

  if (majorTicks.length <= 1) {
    majorTicks = scale.ticks(count + 1);
  }

  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;
  ticks.sort(function (a, b) {
    return a - b;
  });
  var ticksFormatted = ticks.map(applyFormat(formatter));
  return ticks.map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: ticksFormatted[i],
      value: tick,
      isMinor: majorTicks.indexOf(tick) === -1
    };
  });
}
/**
* Generate ticks based on a distance, for each 100th unit, one additional tick may be added.
* Will attempt to round the bounds of domain to even values and generate ticks hitting the domain bounds.
* @private
* @param  {Number} distance       Distance between each tick
* @param  {Number} scale         The scale instance
* @param  {Number} [minorCount=0]     Number of tick added between each distance
* @param  {Number} [unitDivider=100]   Number to divide distance with
* @return {Array}               Array of ticks
*/

function tightDistanceBasedGenerator(_ref2) {
  var distance = _ref2.distance,
      scale = _ref2.scale,
      _ref2$minorCount = _ref2.minorCount,
      minorCount = _ref2$minorCount === void 0 ? 0 : _ref2$minorCount,
      _ref2$unitDivider = _ref2.unitDivider,
      unitDivider = _ref2$unitDivider === void 0 ? 100 : _ref2$unitDivider,
      _ref2$formatter = _ref2.formatter,
      formatter = _ref2$formatter === void 0 ? undefined : _ref2$formatter;
  var step = !notNumber(unitDivider) && !notNumber(distance) ? Math.max(distance / unitDivider, 2) : 2;
  var count = Math.min(1000, Math.round(step)); // safe guard against huge numbers

  var n = count > 10 ? 10 : count;
  scale.nice(n);
  var majorTicks = scale.ticks(count);
  var ticks = minorCount > 0 ? appendMinorTicks(majorTicks, minorCount, scale) : majorTicks;
  ticks.sort(function (a, b) {
    return a - b;
  });
  var ticksFormatted = ticks.map(applyFormat(formatter));
  return ticks.map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: ticksFormatted[i],
      value: tick,
      isMinor: majorTicks.indexOf(tick) === -1
    };
  });
}

function ticksByCount(_ref3) {
  var count = _ref3.count,
      minorCount = _ref3.minorCount,
      scale = _ref3.scale,
      formatter = _ref3.formatter;
  return scale.ticks((count - 1) * minorCount + count).map(function (tick, i) {
    var position = scale(tick);
    return {
      position: position,
      start: position,
      end: position,
      label: formatter(tick),
      isMinor: i % (minorCount + 1) !== 0,
      value: tick
    };
  });
}

function ticksByValue(_ref4) {
  var values = _ref4.values,
      scale = _ref4.scale,
      _ref4$formatter = _ref4.formatter,
      formatter = _ref4$formatter === void 0 ? function (v) {
    return v;
  } : _ref4$formatter;
  return values.sort(function (a, b) {
    return (isObject(a) ? a.value : a) - (isObject(b) ? b.value : b);
  }).filter(function (v, i, ary) {
    var val = isObject(v) ? v.value : v;
    return val <= scale.max() && val >= scale.min() && ary.indexOf(v) === i;
  }).map(function (v) {
    var isObj = isObject(v);
    var value = isObj ? v.value : v;
    var position = scale(value);
    return {
      position: position,
      value: value,
      label: isObj && typeof v.label !== 'undefined' ? v.label : formatter(value),
      isMinor: isObj ? !!v.isMinor : false,
      start: isObj && !isNaN(v.start) ? clamp(scale(v.start)) : position,
      // TODOHandle end < start?
      end: isObj && !isNaN(v.end) ? clamp(scale(v.end)) : position // TODO Handle start > end?

    };
  });
}

function forceTicksAtBounds(ticks, scale, formatter) {
  var ticksP = ticks.map(function (t) {
    return t.position;
  });
  var range = scale.range();

  if (ticksP.indexOf(range[0]) === -1) {
    ticks.splice(0, 0, {
      position: range[0],
      start: range[0],
      end: range[0],
      label: formatter(scale.start()),
      isMinor: false,
      value: scale.start()
    });
  } else if (ticks[0] && ticks[0].isMinor) {
    ticks[0].isMinor = false; // Convert to major tick
  }

  var lastTick = ticks[ticks.length - 1];

  if (ticksP.indexOf(range[1]) === -1) {
    ticks.push({
      position: range[1],
      start: range[1],
      end: range[1],
      label: formatter(scale.end()),
      isMinor: false,
      value: scale.end()
    });
  } else if (lastTick && lastTick.isMinor) {
    lastTick.isMinor = false; // Convert to major tick
  }
}

function generateContinuousTicks(_ref5) {
  var settings = _ref5.settings,
      scale = _ref5.scale,
      distance = _ref5.distance,
      _ref5$formatter = _ref5.formatter,
      formatter = _ref5$formatter === void 0 ? function (val) {
    return val;
  } : _ref5$formatter;
  var ticks;
  var minorCount = settings.minorTicks && !notNumber(settings.minorTicks.count) ? Math.min(100, settings.minorTicks.count) : 0;

  if (Array.isArray(settings.ticks.values)) {
    var values = settings.ticks.values.filter(function (v) {
      return picasso_esm_typeof(v) === 'object' ? !notNumber(v.value) : !notNumber(v);
    });
    ticks = ticksByValue({
      values: values,
      scale: scale.copy(),
      formatter: formatter
    });
  } else if (!notNumber(settings.ticks.count)) {
    var count = Math.min(1000, settings.ticks.count);
    ticks = ticksByCount({
      count: count,
      minorCount: minorCount,
      scale: scale.copy(),
      formatter: formatter
    });
  } else {
    var tickGen = settings.ticks.tight ? tightDistanceBasedGenerator : looseDistanceBasedGenerator;
    ticks = tickGen({
      distance: distance,
      minorCount: minorCount,
      unitDivider: settings.ticks.distance,
      scale: scale,
      formatter: formatter
    });

    if (settings.ticks.forceBounds) {
      forceTicksAtBounds(ticks, scale, formatter);
    }
  }

  return ticks;
}
function generateDiscreteTicks(_ref6) {
  var scale = _ref6.scale;
  var domain = scale.domain();
  var values = domain;
  var dataItems = scale.data().items;
  var labels = scale.labels ? scale.labels() : values;
  var bandwidth = scale.bandwidth();
  return values.map(function (d, i) {
    var start = scale(d);
    return {
      position: start + bandwidth / 2,
      label: "".concat(labels[i]),
      data: dataItems ? dataItems[i] : undefined,
      start: start,
      end: start + bandwidth
    };
  });
}

function resolveSettings$1() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var stngs = {};
  Object.keys(defaultSettings).forEach(function (key) {
    var type = picasso_esm_typeof(settings[key]);

    if (type === 'function') {
      stngs[key] = settings[key](context);
    } else if (type === 'undefined') {
      stngs[key] = defaultSettings[key];
    } else {
      stngs[key] = settings[key];
    }
  });
  return stngs;
}

var DEFAULT_SETTINGS = {
  min: NaN,
  max: NaN,
  expand: NaN,
  include: [],
  invert: false
};
var DEFAULT_TICKS_SETTINGS = {
  tight: false,
  forceBounds: false,
  values: undefined,
  count: NaN,
  distance: 100
};
var DEFAULT_MINORTICKS_SETTINGS = {
  count: NaN
};
/**
 * @typedef {object} scale--linear
 * @property {string} [type='linear']
 * @property {number} [expand] - Expand the output range
 * @property {boolean} [invert=false] - Invert the output range
 * @property {number[]} [include] - Include specified numbers in the output range
 * @property {object} [ticks]
 * @property {boolean} [ticks.tight = false]
 * @property {boolean} [ticks.forceBounds = false]
 * @property {number} [ticks.distance = 100]  - Approximate distance between each tick
 * @property {number[]|object[]} [ticks.values] - If set, ticks are no longer generated but instead equal to this set
 * @property {number} [ticks.count]
 * @property {object} [minorTicks]
 * @property {number} [minorTicks.count = 3]
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 */

function getMinMax$1(settings, fields) {
  var min = +settings.min;
  var max = +settings.max;
  var fieldMin = 0;
  var fieldMax = 1;

  if (fields && fields[0]) {
    var minValues = fields.map(function (m) {
      return m.min();
    }).filter(function (v) {
      return !isNaN(v);
    });
    var maxValues = fields.map(function (m) {
      return m.max();
    }).filter(function (v) {
      return !isNaN(v);
    });
    fieldMin = minValues.length ? Math.min.apply(Math, _toConsumableArray$1(minValues)) : Number.NaN;
    fieldMax = maxValues.length ? Math.max.apply(Math, _toConsumableArray$1(maxValues)) : Number.NaN;

    if (isNaN(fieldMin) || isNaN(fieldMax)) {
      fieldMin = -1;
      fieldMax = 1;
    } else if (fieldMin === fieldMax && fieldMin === 0) {
      fieldMin = -1;
      fieldMax = 1;
    } else if (fieldMin === fieldMax && fieldMin) {
      fieldMin -= Math.abs(fieldMin * 0.1);
      fieldMax += Math.abs(fieldMax * 0.1);
    } else if (!isNaN(settings.expand)) {
      var range = fieldMax - fieldMin;
      fieldMin -= range * settings.expand;
      fieldMax += range * settings.expand;
    }

    if (Array.isArray(settings.include)) {
      var i = settings.include.filter(function (n) {
        return !isNaN(n);
      });
      fieldMin = Math.min.apply(Math, _toConsumableArray$1(i).concat([fieldMin]));
      fieldMax = Math.max.apply(Math, _toConsumableArray$1(i).concat([fieldMax]));
    }
  }

  return {
    mini: !isNaN(min) ? min : fieldMin,
    maxi: !isNaN(max) ? max : fieldMax
  };
}

function initNormScale(normScale, scale) {
  if (normScale.instance) {
    return;
  }

  normScale.instance = scale.copy();
  normScale.instance.domain([scale.start(), scale.end()]);
  normScale.instance.clamp(true);
  normScale.instance.range(normScale.invert ? [1, 0] : [0, 1]);
}
/**
 * @alias scaleLinear
 * @private
 * @param { object } settings
 * @param { field[] } [fields]
 * @return { linear }
 */


function scaleLinear() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var d3Scale = linear$1();
  var normScale = {
    instance: null,
    invert: false
  };
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS, ctx);
  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS, ctx);
  stgns.minorTicks = resolveSettings$1(settings.minorTicks, DEFAULT_MINORTICKS_SETTINGS, ctx);
  var tickCache;
  /**
   * @alias linear
   * @private
   * @param { Object } value
   * @return { number }
   */

  function fn(v) {
    if (notNumber(v)) {
      return NaN;
    }

    return d3Scale(v);
  }

  fn.data = function () {
    return data;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_invert }
   * @param { number } value The inverted value
   * @return { number } The inverted scaled value
   */


  fn.invert = function invert(value) {
    return d3Scale.invert(value);
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_rangeRound }
   * @param { number[] } values Range values
   * @return { linear } The instance this method was called on
   */


  fn.rangeRound = function rangeRound(values) {
    d3Scale.rangeRound(values);
    return fn;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_clamp }
   * @param { boolean } [ value=true ] TRUE if clamping should be enabled
   * @return { linear } The instance this method was called on
   */


  fn.clamp = function clamp() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    d3Scale.clamp(value);
    return fn;
  };
  /**
   * Get cached ticks (if any)
   * @return { number | undefined }
   */


  fn.cachedTicks = function fnCachedTicks() {
    return tickCache;
  };
  /**
   * Clear the tick cache
   * @return {number | undefined}
   */


  fn.clearTicksCache = function fnClearTicks() {
    tickCache = undefined;
    return this;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_ticks }
   * @param { Object } input Number of ticks to generate or an object passed to tick generator
   * @return { number[] | Object } Array of ticks or any type the custom tick generator returns
   */


  fn.ticks = function ticks(input) {
    if (input !== null && picasso_esm_typeof(input) === 'object') {
      input.settings = input.settings || {}; // TODO Discontinue support for custom ticks settings as argument

      input.settings = extend(true, {}, stgns, input.settings);
      input.scale = fn;
      tickCache = generateContinuousTicks(input);
      return tickCache;
    }

    tickCache = d3Scale.ticks(input);
    return tickCache;
  };
  /**
   * {@link https://github.com/d3/d3-scale#continuous_nice }
   * @param { number } count
   * @return { linear } The instance this method was called on
   */


  fn.nice = function nice(count) {
    d3Scale.nice(count);
    return fn;
  }; // TODO Support this?


  fn.tickFormat = function tickFormat(count, format) {
    return d3Scale.tickFormat(count, format);
  }; // TODO Support this?


  fn.interpolate = function interpolate(func) {
    d3Scale.interpolate(func);
    return fn;
  };
  /**
   * @param { number[] } [values] Set or Get domain values
   * @return { linear | Number[] } The instance this method was called on if a parameter is provided, otherwise the current domain is returned
   */


  fn.domain = function domain(values) {
    if (arguments.length) {
      d3Scale.domain(values);

      if (normScale.instance) {
        normScale.instance.domain([fn.start(), fn.end()]);
      }

      return fn;
    }

    return d3Scale.domain();
  };
  /**
   * @param { number[] } [values] Set or Get range values
   * @return { linear | number[] } The instance this method was called on if a parameter is provided, otherwise the current range is returned
   */


  fn.range = function range(values) {
    if (arguments.length) {
      d3Scale.range(values);
      return fn;
    }

    return d3Scale.range();
  };
  /**
   * Get the first value of the domain
   * @return { number }
   */


  fn.start = function start() {
    return fn.domain()[0];
  };
  /**
   * Get the last value of the domain
   * @return { number }
   */


  fn.end = function end() {
    return fn.domain()[this.domain().length - 1];
  };
  /**
   * Get the minimum value of the domain
   * @return { number }
   */


  fn.min = function min() {
    return Math.min(this.start(), this.end());
  };
  /**
   * Get the maximum value of the domain
   * @return { number }
   */


  fn.max = function max() {
    return Math.max(this.start(), this.end());
  };
  /**
   * Divides the domain and range into uniform segments, based on start and end value
   * @param  { number } segments The number of segments
   * @return { function } The instance this method was called on
   * @example
   * let s = linear();
   * s.domain([0, 10]);
   * s.range([0, 1]);
   * s.classify( 2 );
   * s.domain(); // [10, 5, 5, 0]
   * s.range(); // [0.75, 0.75, 0.25, 0.25]
   */


  fn.classify = function classify(segments) {
    var valueRange = (fn.start() - fn.end()) / segments,
        domain = [fn.end()],
        range = [],
        samplePos = valueRange / 2;

    for (var i = 0; i < segments; i++) {
      var lastVal = domain[domain.length - 1] || 0,
          calIntervalPos = lastVal + valueRange,
          calSamplePos = lastVal + samplePos,
          sampleColValue = fn(calSamplePos);
      domain.push.apply(domain, [calIntervalPos, calIntervalPos]);
      range.push.apply(range, [sampleColValue, sampleColValue]);
    }

    domain.pop();
    fn.domain(domain);
    fn.range(range);
    return fn;
  };

  fn.copy = function copy() {
    var cop = scaleLinear(settings, data, resources);
    cop.domain(fn.domain());
    cop.range(fn.range());
    cop.clamp(d3Scale.clamp());
    return cop;
  };
  /**
   * @param {number} d - A domain value
   * @return {number} A normalized range output given in range 0-1
   * @example
   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
   * scale.norm(5); // Returns 0.5
   * scale(5); // Returns 5000
   *
   * scale.domain([0, 2, 10]);
   * scale.norm(5); // Returns 0.5
   */


  fn.norm = function norm(d) {
    initNormScale(normScale, fn);
    return normScale.instance(d);
  };
  /**
   * @param {number} d - A normalized value in range 0-1
   * @return {number} A corresponding domain value
   * @example
   * const scale = scaleLinear().domain([0, 10]).range([0, 10000]);
   * scale.normInvert(0.5); // Returns 5
   * scale.invert(5000); // Returns 5
   */


  fn.normInvert = function norm(t) {
    initNormScale(normScale, fn);
    return normScale.instance.invert(t);
  };

  var _getMinMax = getMinMax$1(stgns, data ? data.fields : []),
      mini = _getMinMax.mini,
      maxi = _getMinMax.maxi;

  fn.domain([mini, maxi]);
  fn.range(stgns.invert ? [1, 0] : [0, 1]);
  normScale.invert = stgns.invert;
  return fn;
}

var DEFAULT_SETTINGS$1 = {
  padding: 0,
  paddingInner: NaN,
  paddingOuter: NaN,
  align: 0.5,
  invert: false,
  maxPxStep: NaN,
  range: [0, 1]
};
/**
 * @typedef {object} scale--band
 * @property {string} [type='band']
 * @property {number} [padding] - {@link https://github.com/d3/d3-scale#band_padding}
 * @property {number} [paddingInner] - {@link https://github.com/d3/d3-scale#band_paddingInner}
 * @property {number} [paddingOuter] - {@link https://github.com/d3/d3-scale#band_paddingOuter}
 * @property {number} [align] - {@link https://github.com/d3/d3-scale#band_align}
 * @property {boolean} [invert=false] - Invert the output range
 * @property {number} [maxPxStep] - Explicitly limit the bandwidth to a pixel value
 * @property {function} [label] - Callback label function, applied on each datum
 * @property {function} [value] - Callback value function, applied on each datum
 * @property {array<number>|function} [range=[0, 1]] - Set range explicitly (ignored when maxPxStep takes effect)
 */

/**
 * @alias scaleBand
 * @memberof picasso
 * @private
 * @param { Object } settings
 * @param { fields[] } [fields]
 * @param { dataset } [dataset]
 * @return { band }
 */

function scaleBand() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  /**
   * An augmented {@link https://github.com/d3/d3-scale#_band|d3 band scale}
   * @alias band
   * @private
   * @kind function
   * @param { Object } value
   * @return { number }
   */
  var band$1 = band();
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);
  var items = data.items || [];
  var domainToDataMapping = {};
  var values = [];
  var labels = []; // I would like to define this outside of scaleBand but it cause the documentation to be in the wrong order

  function augmentScaleBand(band, settings) {
    // eslint-disable-line no-shadow
    band.data = function () {
      return data;
    };

    band.datum = function (domainValue) {
      return items[domainToDataMapping[domainValue]];
    };
    /**
     * Get the first value of the domain
     * @return { number }
     */


    band.start = function start() {
      return band.domain()[0];
    };
    /**
     * Get the last value of the domain
     * @return { number }
     */


    band.end = function end() {
      return band.domain()[band.domain().length - 1];
    };

    band.labels = function () {
      return labels;
    };
    /**
     * Generate discrete ticks
     * @return {Object[]} Array of ticks
     */


    band.ticks = function ticks() {
      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      input.scale = band;
      return generateDiscreteTicks(input, settings.trackBy || 'label');
    };
  }

  augmentScaleBand(band$1, settings);
  /**
   * if required creates a new scale with a restricted range
   * so that step size is at most maxPxStep
   * otherwise it returns itself
   * @param { number } size
   * @return { band }
   */

  band$1.pxScale = function pxScale(size) {
    var max = stgns.maxPxStep;

    if (isNaN(max)) {
      return band$1;
    }

    var n = band$1.domain().length;
    var sizeRelativeToStep = Math.max(1, n - band$1.paddingInner() + 2 * band$1.paddingOuter());

    if (sizeRelativeToStep * max >= size) {
      return band$1;
    }

    var newBand = band$1.copy();
    newBand.type = band$1.type;
    augmentScaleBand(newBand, settings);
    var t = sizeRelativeToStep * max / size;
    var offset = (1 - t) * band$1.align();
    newBand.range(stgns.invert ? [t + offset, offset] : [offset, t + offset]);
    return newBand;
  };

  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.label;
  };

  for (var i = 0; i < items.length; i++) {
    var arg = extend({
      datum: items[i]
    }, ctx);
    var v = valueFn(arg, i);

    if (values.indexOf(v) === -1) {
      values.push(v);
      labels.push(labelFn(arg, i));
      domainToDataMapping[v] = i;
    }
  }

  band$1.domain(values);
  band$1.range(stgns.invert ? stgns.range.slice().reverse() : stgns.range);
  band$1.padding(isNaN(stgns.padding) ? 0 : stgns.padding);

  if (!isNaN(stgns.paddingInner)) {
    band$1.paddingInner(stgns.paddingInner);
  }

  if (!isNaN(stgns.paddingOuter)) {
    band$1.paddingOuter(stgns.paddingOuter);
  }

  band$1.align(isNaN(stgns.align) ? 0.5 : stgns.align);
  return band$1;
}

var DEFAULT_TICKS_SETTINGS$1 = {
  depth: 0
};

function keyGen(node, valueFn, ctx) {
  return node.ancestors().map(function (a) {
    return valueFn(extend({
      datum: a.data
    }, ctx));
  }).reverse().slice(1) // Delete root node
  .toString();
}

function flattenTree(rootNode, settings, ctx) {
  var ticksDepth = settings.ticks.depth;
  var valueFn = settings.value;
  var labelFn = settings.label;
  var values = [];
  var labels = [];
  var items = {};
  var ticks = [];
  var expando = 0;

  if (!rootNode) {
    return {
      values: values,
      labels: labels,
      items: items,
      ticks: ticks
    };
  }

  rootNode.eachAfter(function (node) {
    if (node.depth > 0) {
      var key = keyGen(node, valueFn, ctx);
      var leaves = node.leaves() || [node]; // If leaf node returns itself

      var value = valueFn(extend({
        datum: node.data
      }, ctx));
      var label = labelFn(extend({
        datum: node.data
      }, ctx));
      var isBranch = Array.isArray(node.children);
      var item = {
        key: key,
        count: leaves.length,
        value: value,
        label: label,
        leftEdge: keyGen(leaves[0], valueFn, ctx),
        rightEdge: keyGen(leaves[Math.max(leaves.length - 1, 0)], valueFn, ctx),
        node: node // isTick: ticksDepth === null ? !isBranch : node.depth === ticksDepth

      };

      if (isBranch) {
        values.push("SPACER_".concat(expando, "_SPACER"));
        expando++;
      } else {
        values.push(key);
        labels.push(label);
      }

      if (ticksDepth <= 0 && !isBranch || node.depth === ticksDepth) {
        ticks.push(item);
      }

      items[key] = item;
    }
  });
  var spill = rootNode.height - 1;

  if (spill > 0) {
    values.splice(-spill);
  }

  return {
    values: values,
    labels: labels,
    items: items,
    ticks: ticks
  };
}
/**
 * @typedef {object} scale-hBand.settings
 * @private
 * @property {number} [padding=0] - Exposes {@link https://github.com/d3/d3-scale#band_padding}
 * @property {boolean} [paddingOuter=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingOuter}
 * @property {number[]} [paddingInner=0] - Exposes {@link https://github.com/d3/d3-scale#band_paddingInner}
 * @property {object} [align=0.5] - Exposes {@link https://github.com/d3/d3-scale#band_align}
 * @property {boolean} [invert=false] - Invert the output range
 */

/**
  * Hierarchical band scale, that is an augmented band scale, that takes hierarchical data as input
 * @alias scaleHierarchicalBand
 * @private
 * @param { Object } settings
 * @param { fields[] } [fields]
 * @param { dataset } [dataset] - With a root property that is an instance of D3.js Hierarchy
 * @return { h-band }
 */


function scaleHierarchicalBand() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$1, ctx);
  stgns.ticks = resolveSettings$1(settings.ticks, DEFAULT_TICKS_SETTINGS$1, ctx);
  stgns.value = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  stgns.label = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.value;
  };
  var bandInstance = scaleBand(stgns);

  var _flattenTree = flattenTree(data.root, stgns, ctx),
      values = _flattenTree.values,
      labels = _flattenTree.labels,
      items = _flattenTree.items,
      ticks = _flattenTree.ticks;
  /**
   * @alias h-band
   * @private
   * @kind function
   * @param { Object[] } value - Array where each value is a reference to a node, going from depth 1 to n.
   * @return { number }
   */


  var hBand = function fn(val) {
    var strVal = String(val);
    var item = items[strVal];

    if (item) {
      return bandInstance(stgns.invert ? item.rightEdge : item.leftEdge);
    }

    return bandInstance(strVal);
  };

  extend(true, hBand, bandInstance);
  /**
   * Wrapped {@link https://github.com/d3/d3-scale#band_bandwidth}
   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, bandwidth for the leaf nodes is return.
   * @return { number }
   */

  hBand.bandwidth = function bandwidth(val) {
    var item = items[String(val)];
    var bw = bandInstance.bandwidth();

    if (item && !item.isLeaf) {
      var left = hBand(item.leftEdge);
      var right = hBand(item.rightEdge);
      return Math.abs(left - right) + bw;
    }

    return bw;
  };
  /**
   * Wrapped {@link https://github.com/d3/d3-scale#band_step}
   * @param { Object[] } [val] - Array where each value is a reference to a node, going from depth 1 to n. If omitted, step size for the leaf nodes is return.
   * @return { number }
   */


  hBand.step = function step(val) {
    var item = items[String(val)];
    var leafCount = item ? item.count : 1;
    var stepSize = bandInstance.step();
    stepSize *= leafCount;
    return stepSize;
  };
  /**
   * @return { dataset }
   */


  hBand.data = function () {
    return data;
  };
  /**
   * Return datum for a given node
   * @param { Object[] } val - Array where each value is a reference to a node, going from depth 1 to n.
   * @return { Object } The datum
   */


  hBand.datum = function (val) {
    var item = items[String(val)];

    if (item) {
      return item.node.data;
    }

    return null;
  };

  hBand.copy = function () {
    return scaleHierarchicalBand(settings, data, resources);
  };
  /**
   * @return { Object[] } Labels for each leaf node
   */


  hBand.labels = function () {
    return labels;
  };
  /**
   * Generate discrete ticks
   * @return { Object[] } Ticks for each leaf node
   */


  hBand.ticks = function () {
    // eslint-disable-line arrow-body-style
    return ticks.map(function (item) {
      var start = hBand(item.key);
      var bandwidth = hBand.bandwidth(item.key);
      return {
        position: start + bandwidth / 2,
        label: item.label,
        data: item.node.data,
        start: start,
        end: start + bandwidth
      };
    });
  };

  var orgPxScale = bandInstance.pxScale;

  hBand.pxScale = function pxScale(size) {
    bandInstance = orgPxScale(size);
    return hBand;
  };

  hBand.domain(values);
  return hBand;
}

var minAccessor = function minAccessor(v) {
  return v.min();
};

var maxAccessor = function maxAccessor(v) {
  return v.max();
};
/**
 * Calculate the min/max value based on various inputs.
 *
 * Provided min/max setting takes presedence over all other inputs. If not provided, the respective values are calculated
 * from the given arr input, where each item in the array is expected to have a min/max accessor.
 *
 * @private
 * @param {object} [settings]
 * @param {number} [settings.min] The minimum value. Defaults to 0 if not provided.
 * @param {number} [settings.max] The maximum value. Defaults to 1 if not provided.
 * @param {object} [arr]
 * @returns { object[] } An array containing the min and max values.
 *
 * @example
 * minmax(); // [0, 1]
 *
 * minmax({}, [
 * { min: () => 13, max: () => 15 },
 * { min: () => NaN, max: () => 17 },
 * ]); // [13, 17]
 *
 * minmax({ min: -5, max: 4 }, [
 * { min: () => -20, max: () => 15 },
 * ]); // [-5, 4]
 */


function minmax(settings, arr) {
  // const definedMin = settings && typeof settings.min !== 'undefined';
  // const definedMax = settings && typeof settings.max !== 'undefined';
  var definedMin = settings && !isNaN(settings.min);
  var definedMax = settings && !isNaN(settings.max);
  var min = definedMin ? +settings.min : 0;
  var max = definedMax ? +settings.max : 1;

  if (arr && arr.length) {
    if (!definedMin) {
      var arrMin = arr.map(minAccessor).filter(isNumber);
      min = arrMin.length ? Math.min.apply(Math, _toConsumableArray$1(arrMin)) : min;
    }

    if (!definedMax) {
      var arrMax = arr.map(maxAccessor).filter(isNumber);
      max = arrMax.length ? Math.max.apply(Math, _toConsumableArray$1(arrMax)) : max;
    }
  }

  return [min, max];
}

var DEFAULT_SETTINGS$2 = {
  domain: [],
  range: [],
  invert: false,
  min: NaN,
  max: NaN
};

function generateDomain(range, min, max) {
  var len = range.length;

  if (len === 2) {
    return [min, max];
  }

  var domain = [];
  var part = (max - min) / (len - 1);
  domain.push(min);

  for (var i = 1; i < len - 1; i++) {
    domain.push(min + part * i);
  }

  domain.push(max);
  return domain;
}
/**
 * @typedef {object} scale--sequential-color
 * @property {string} [type='sequential-color']
 * @property {string[]} [range] - CSS color values of the output range
 * @property {boolean} [invert=false] - Invert range
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 */

/**
 * @alias scaleSequentialColor
 * @private
 * @param { Object } [settings] Settings for this scale. If both range and domain are specified, they have to fulfill range.length === domain.length, otherwise they will be overriden.
 * @param { number[] } [settings.domain] Numeric values indicating stop limits between start and end values.
 * @param { color[] } [settings.range] CSS color values indicating stop colors between start and end values.
 * @param { field[] } [fields] Fields to dynamically calculate the domain extent.
 * @return { sequentialColor }
 *
 * @example
 * picasso.scaleSequentialColor({
 *  range: ['red', '#fc6', 'green'],
 *  domain: [-40, 0, 100]
 * });
 */


function scaleSequentialColor() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = scaleLinear(settings, data, resources).clamp(true).interpolate(interpolateRgb);
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$2, {
    data: data,
    resources: resources
  });
  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;
  var isRange = Array.isArray(stgns.range) && stgns.range.length;
  /**
   * @alias sequentialColor
   * @private
   * @kind function
   * @param { Object } v Object containing a 'value' property
   * @return { string } The blended color
   */

  var fn = s;
  extend(true, fn, s);

  var _minmax = minmax(stgns, data ? data.fields : []),
      _minmax2 = _slicedToArray(_minmax, 2),
      min = _minmax2[0],
      max = _minmax2[1];

  var num = isDomain ? stgns.domain.length : -1;
  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];
  var range = isRange ? stgns.range : DEFAULT_COLORS;
  fn.range(stgns.invert ? range.slice().reverse() : range.slice());
  fn.domain(isDomain ? stgns.domain : generateDomain(fn.range(), min, max));
  return fn;
}

var DEFAULT_SETTINGS$3 = {
  domain: [],
  range: [],
  invert: false,
  min: NaN,
  max: NaN,
  nice: false
};

function generateDomain$1(range, min, max) {
  var len = range.length;

  if (len === 2) {
    return [min + (max - min) / 2];
  }

  var domain = [];
  var part = (max - min) / len;

  for (var i = 1; i < len; i++) {
    domain.push(min + part * i);
  }

  return domain;
}

function getBreaks(domain) {
  var ret = [];

  for (var i = 0; i < domain.length - 1; i++) {
    ret.push((domain[i] + domain[i + 1]) / 2);
  }

  return ret;
}

function generateRange(domain, colors, min, max) {
  min = domain[0];
  max = domain && domain.length >= 2 ? domain[domain.length - 1] : max;
  var seq = scaleSequentialColor().domain([min, max]).range(colors);
  var values = [min].concat(_toConsumableArray$1(getBreaks(domain)), [max]);
  return values.map(function (v) {
    return seq(v);
  });
}

function generateNiceDomain(range, min, max) {
  var numPoints = range.length === 2 ? 10 : Math.max(1, range.length);
  var lin = linear$1().domain([min, max]).nice(numPoints);
  var domain = lin.ticks(numPoints);

  if (!range || !range.length) {
    return domain;
  } // remove values from endpoints


  var num = Math.max(0, range.length - 1);

  while (domain.length > num) {
    if (domain[0] - min <= max - domain[domain.length - 1]) {
      domain.shift();
    } else {
      domain.pop();
    }
  }

  return domain;
}
/**
 * @typedef {object} scale--threshold-color
 * @property {string} [type='threshold-color']
 * @property {number[]} [domain] Values defining the thresholds
 * @property {string[]} [range] - CSS color values of the output range
 * @property {boolean} [invert=false] - Invert range
 * @property {number} [min] - Set an explicit minimum value
 * @property {number} [max] - Set an explicit maximum value
 * @property {boolean} [nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
 */

/**
 * @alias scaleThresholdColor
 * @private
 * @param { object } [settings] Settings for this scale. If both domain and range are specified, they have to fulfill domain.length === range.length + 1,  otherwise they will be overriden.
 * @param { number[] } [settings.domain] Values defining the thresholds.
 * @param { color[] } [settings.range] CSS color values of the output range.
 * @param { boolean } [settings.nice=false] If set to true, will generate 'nice' domain values. Ignored if domain is set.
 * @param { number } [settings.min] Minimum value to generate domain extent from. Ignored if domain is set.
 * @param { number } [settings.max] Maximum value to generate domain extend from. Ignored if domain is set.
 * @param { field[] } [fields] Fields to dynamically calculate the domain extent from. Ignored if min/max are set.
 * @return { thresholdColor }
 *
 * @example
 * let t = threshold({
 *   range: ['black', 'white'],
 *   domain: [25,50,75],
 *   max: 100,
 *   min: 0
 * });
 * t.domain(); // [25,50,75]
 * t.range(); // Generates from colors and domain: ['rgb(0,0,0)','rgb(85,85,85)','rgb(170,170,170)','rgb(255,255,255)']
 */


function scaleThresholdColor() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var d3Scale = threshold();
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$3, {
    data: data,
    resources: resources
  });
  var isDomain = Array.isArray(stgns.domain) && stgns.domain.length;
  var isRange = Array.isArray(stgns.range) && stgns.range.length;
  /**
   * @alias thresholdColor
   * @private
   * @param { object } v Object literal containing a 'value' property.
   * @return { string } A CSS color from the scale's range.
   */

  function fn(v) {
    if (notNumber(v)) {
      return NaN;
    }

    return d3Scale(v);
  }

  Object.keys(d3Scale).forEach(function (key) {
    return fn[key] = d3Scale[key];
  });
  var fields = data.fields;

  var _minmax = minmax(stgns, fields),
      _minmax2 = _slicedToArray(_minmax, 2),
      min = _minmax2[0],
      max = _minmax2[1];

  var num = isDomain ? stgns.domain.length : -1;
  var DEFAULT_COLORS = resources.theme ? resources.theme.palette('sequential', num > 0 ? num : 2) : [];
  var range = isRange ? stgns.range : DEFAULT_COLORS;
  var domain = [];

  if (isDomain) {
    domain = stgns.domain;
  } else if (stgns.nice) {
    domain = generateNiceDomain(range, min, max);
  } else {
    domain = [min + (max - min) / 2];
  }

  if (range.length > domain.length + 1) {
    // Generate limits from range
    domain = generateDomain$1(range, min, max);
  } else if (range.length < domain.length + 1) {
    // Generate additional colors
    range = generateRange(domain, range, min, max);
  }

  fn.data = function () {
    return data;
  };

  fn.range(stgns.invert ? range.slice().reverse() : range);
  fn.domain(domain);
  return fn;
}

var DEFAULT_SETTINGS$4 = {
  domain: [],
  range: []
};
/**
 * @alias scaleOrdinal
 * @private
 * @param { Object } settings
 * @param { field[] } [fields]
 * @param { dataset } data
 * @return { ordinal }
 */

function ordinal$1() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  /**
   * An augmented {@link https://github.com/d3/d3-scale#_ordinal|d3 ordinal scale}
   * @private
   * @alias ordinal
   * @param { Object }
   * @return { number }
   */
  var fn = ordinal();
  var ctx = {
    data: data,
    resources: resources
  };
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$4, ctx);
  var valueFn = typeof settings.value === 'function' ? settings.value : function (d) {
    return d.datum.value;
  };
  var labelFn = typeof settings.label === 'function' ? settings.label : function (d) {
    return d.datum.label;
  };
  var items = data.items || [];
  var domainToDataMapping = {};
  var values = [];
  var labels = [];

  for (var i = 0; i < items.length; i++) {
    var arg = extend({
      datum: items[i]
    }, ctx);
    var v = valueFn(arg, i);

    if (values.indexOf(v) === -1) {
      values.push(v);
      labels.push(labelFn(arg, i));
      domainToDataMapping[v] = i;
    }
  }

  fn.data = function () {
    return data;
  };

  fn.labels = function () {
    return labels;
  };

  fn.label = function (domainValue) {
    return labels[values.indexOf(domainValue)];
  };

  fn.datum = function (domainValue) {
    return items[domainToDataMapping[domainValue]];
  };

  fn.range(stgns.range);

  if (Array.isArray(stgns.domain) && stgns.domain.length) {
    fn.domain(stgns.domain);
  } else {
    fn.domain(values);
  }

  return fn;
}

var DEFAULT_SETTINGS$5 = {
  domain: [],
  range: [],
  unknown: undefined
};
var DEFAULT_EXPLICIT_SETTINGS = {
  domain: [],
  range: [],
  override: false
};
/**
 * @typedef {object} scale--categorical-color
 * @property {string} [type='categorical-color']
 * @property {string[]} [range=false] - CSS color values of the output range
 * @property {string} [unknown] - {@link https://github.com/d3/d3-scale#ordinal_unknown}
 * @property {object} [explicit] - Explicitly bind values to an output
 * @property {object[]} [explicit.domain[]] - Values to bind
 * @property {string[]} [explicit.range[]] - Output range
 */

/**
 * An ordinal scale with the output range set to default colors, as defined by *scaleCategorical.range*
 * @alias scaleCategorical
 * @private
 * @param { Object } settings
 * @param { field[] } [fields]
 * @param { dataset } [dataset]
 * @return { ordinal }
 */

function scaleCategorical() {
  var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var resources = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var s = ordinal$1(settings, data, resources);
  var theme = resources.theme;
  var stgns = resolveSettings$1(settings, DEFAULT_SETTINGS$5, {
    data: data,
    resources: resources
  });
  stgns.explicit = resolveSettings$1(settings.explicit, DEFAULT_EXPLICIT_SETTINGS, {
    data: data,
    resources: resources
  });
  var range;

  if (!Array.isArray(stgns.range) || stgns.range.length === 0) {
    range = theme ? theme.palette('categorical', s.domain().length).slice() : [];
  } else {
    range = stgns.range.slice();
  }

  if (stgns.unknown) {
    s.unknown(stgns.unknown);
  } else if (theme && theme.palette('unknown')) {
    var un = theme.palette('unknown');
    s.unknown(un[0]);
  }

  if (Array.isArray(stgns.explicit.domain) && stgns.explicit.domain.length) {
    var domain = s.domain().slice();
    var explicitDomain = stgns.explicit.domain;
    var explicitRange = Array.isArray(stgns.explicit.range) ? stgns.explicit.range : []; // duplicate range values to cover entire domain

    var numCopies = Math.floor(domain.length / range.length);

    for (var i = 1; i < numCopies + 1; i *= 2) {
      range = range.concat(range);
    }

    if (stgns.explicit.override) {
      for (var _i = 0; _i < explicitDomain.length; _i++) {
        var index = domain.indexOf(explicitDomain[_i]);

        if (index > -1) {
          range[index] = explicitRange[_i];
        }
      }
    } else {
      // inject explicit colors
      var order = explicitDomain.map(function (d, i) {
        return [domain.indexOf(d), d, explicitRange[i]];
      }).sort(function (a, b) {
        return a[0] - b[0];
      });
      order.forEach(function (v) {
        var idx = domain.indexOf(v[1]);

        if (idx !== -1) {
          range.splice(idx, 0, v[2]);
        }
      });
    } // cutoff excess range values


    range.length = domain.length;
  }

  s.range(range);
  return s;
}

var scaleRegistry = registryFactory();
scaleRegistry('linear', scaleLinear);
scaleRegistry('band', scaleBand);
scaleRegistry('h-band', scaleHierarchicalBand);
scaleRegistry('sequential-color', scaleSequentialColor);
scaleRegistry('threshold-color', scaleThresholdColor);
scaleRegistry('categorical-color', scaleCategorical);

function getTypeFromMeta(fields) {
  var types = fields.map(function (field) {
    return field.type() === 'dimension' ? 'band' : 'linear';
  });
  return types.indexOf('linear') !== -1 ? 'linear' : 'band';
}

function deduceScaleTypeFromData(data) {
  if (data.root) {
    return 'h-band';
  }

  if (data.fields && data.fields[0]) {
    return getTypeFromMeta(data.fields);
  }

  return 'linear';
}

function create$2(options, d, deps) {
  var dataSourceConfig = options.data;

  if (options.source) {
    // DEPRECATION
    deps.logger.warn('Deprecated: Scale data source configuration');
    dataSourceConfig = {
      extract: []
    };
    (Array.isArray(options.source) ? options.source : [options.source]).forEach(function (source) {
      dataSourceConfig.extract.push({
        field: source
      });
    });
  }

  var data = extract(dataSourceConfig, d, deps);
  var type = options.type || deduceScaleTypeFromData(data);
  var s;

  if (type === 'color') {
    if (data.fields && data.fields[0] && data.fields[0].type() === 'dimension') {
      type = 'categorical-color';
    } else {
      type = 'sequential-color';
    }
  }

  if (deps.scale.has(type)) {
    s = deps.scale.get(type);
    s = s(options, data, {
      theme: deps.theme,
      logger: deps.logger
    });
    s.type = type;
  }

  return s;
}
function collection$1(scalesConfig, data, deps) {
  var fn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : create$2;
  var scales = {};
  return {
    get: function get(def) {
      var key;

      if (typeof def === 'string' && scalesConfig[def]) {
        key = def;
      } else if (picasso_esm_typeof(def) === 'object' && 'scale' in def && scalesConfig[def.scale]) {
        key = def.scale;
      }

      if (key) {
        scales[key] = scales[key] || fn(scalesConfig[key], data, deps);
        return scales[key];
      }

      return fn(def, data, deps);
    },
    all: function all() {
      Object.keys(scalesConfig).forEach(this.get);
      return scales;
    }
  };
}

/**
 * Utility functions
 */

var util = {};

util.isObject = function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
};

util.isNumber = function isNumber(arg) {
  return typeof arg === 'number';
};

util.isUndefined = function isUndefined(arg) {
  return arg === void 0;
};

util.isFunction = function isFunction(arg){
  return typeof arg === 'function';
};


/**
 * EventEmitter class
 */

function EventEmitter() {
  EventEmitter.init.call(this);
}
var nodeEventEmitter = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!util.isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error' && !this._events.error) {
    er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      throw Error('Uncaught, unspecified "error" event.');
    }
    return false;
  }

  handler = this._events[type];

  if (util.isUndefined(handler))
    return false;

  if (util.isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (util.isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              util.isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (util.isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (util.isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!util.isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;

      if (util.isFunction(console.error)) {
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
      }
      if (util.isFunction(console.trace))
        console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!util.isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (util.isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (util.isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (util.isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (Array.isArray(listeners)) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (util.isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (util.isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

var EventEmitter$1 = {
  /**
   * Function used to add event handling to objects passed in.
   * @private
   * @param {Object} obj Object instance that will get event handling.
   */
  mixin: function mixin(obj) {
    Object.keys(nodeEventEmitter.prototype).forEach(function (key) {
      obj[key] = nodeEventEmitter.prototype[key];
    });
    nodeEventEmitter.init(obj);
    return obj;
  }
};

function scrollApi() {
  var min = 0;
  var max = 0;
  var start = 0;
  var viewSize = 0;
  start = start || min;
  /**
   * The scroll api
   * @private
   * @alias scroll
   */

  var s = {
    /**
     * Move the current scroll
     * @param {number} value
     * @emits update
     */
    move: function move(value) {
      this.moveTo(start + value);
    },

    /**
     * Change the current scroll to a specific value
     * @param {number} value
     * @emits update
     */
    moveTo: function moveTo(value) {
      var newStart = Math.max(min, Math.min(max - viewSize, value));

      if (start !== newStart) {
        start = newStart;
        s.emit('update');
      }
    },

    /**
     * Update scroll settings
     * @param {number} [settings.min]
     * @param {number} [settings.max]
     * @param {number} [settings.viewSize]
     * @emits update
     */
    update: function update(settings) {
      var triggerUpdate = false;
      var _settings$min = settings.min;
      min = _settings$min === void 0 ? min : _settings$min;
      var _settings$max = settings.max;
      max = _settings$max === void 0 ? max : _settings$max;

      if (settings.viewSize !== undefined && settings.viewSize !== viewSize) {
        viewSize = settings.viewSize;
        triggerUpdate = true;
      } // update scroll to be within the new bounds


      var newStart = Math.max(min, Math.min(max - viewSize, start));

      if (start !== newStart) {
        start = newStart;
        triggerUpdate = true;
      }

      if (triggerUpdate) {
        s.emit('update');
      }
    },

    /**
     * Get the current scroll state
     * @return {object} with min, max, start & viewSize
     */
    getState: function getState() {
      return {
        min: min,
        max: max,
        start: start,
        viewSize: viewSize
      };
    }
  };
  EventEmitter$1.mixin(s);
  return s;
}

function createOrUpdate(options, oldApi) {
  var min = options.min || 0;
  var max = options.max || 0;
  var viewSize = options.viewSize || 0;
  var s = oldApi || scrollApi();
  s.update({
    min: min,
    max: max,
    viewSize: viewSize
  });
  return s;
}
function builder(obj, oldScrollApis) {
  var scrollApis = {};

  for (var n in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, n)) {
      scrollApis[n] = createOrUpdate(obj[n], oldScrollApis ? oldScrollApis[n] : null);
    }
  }

  return scrollApis;
}
function getOrCreateScrollApi(v, scrollApis) {
  if (!scrollApis[v]) {
    scrollApis[v] = scrollApi();
  }

  return scrollApis[v];
}

function lessThanOrEqual(value, limit) {
  return value <= limit;
}

function lessThan(value, limit) {
  return value < limit;
}

function picasso_esm_index(boundaries, point, after) {
  var i = 0;

  while (i < boundaries.length && point > boundaries[i]) {
    ++i;
  }

  if (boundaries[i] === point && after) {
    ++i;
  }

  return i;
}

function contains(boundaries, point, minCondition, maxCondition) {
  var len = boundaries.length;

  for (var i = 1; i < len; i += 2) {
    if (minCondition(boundaries[i - 1], point) && maxCondition(point, boundaries[i])) {
      return true;
    }
  }

  return false;
}

function rangeCollection() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var maxCondition;
  var minCondition;
  var boundaries = [];

  function fn() {}

  fn.configure = function () {
    var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _c$includeMax = c.includeMax,
        includeMax = _c$includeMax === void 0 ? true : _c$includeMax,
        _c$includeMin = c.includeMin,
        includeMin = _c$includeMin === void 0 ? true : _c$includeMin;
    maxCondition = includeMax ? lessThanOrEqual : lessThan;
    minCondition = includeMin ? lessThanOrEqual : lessThan;
  };

  fn.add = function (_ref) {
    var _boundaries;

    var min = _ref.min,
        max = _ref.max;
    var i0 = picasso_esm_index(boundaries, min);
    var i1 = picasso_esm_index(boundaries, max, true);
    var args = [i0, i1 - i0];

    if (i0 % 2 === 0) {
      args.push(min);
    }

    if (i1 % 2 === 0) {
      args.push(max);
    }

    var before = boundaries.join(',');

    (_boundaries = boundaries).splice.apply(_boundaries, args);

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.remove = function (_ref2) {
    var _boundaries2;

    var min = _ref2.min,
        max = _ref2.max;
    var i0 = picasso_esm_index(boundaries, min);
    var i1 = picasso_esm_index(boundaries, max, true);
    var args = [i0, i1 - i0];

    if (i0 % 2 === 1) {
      args.push(min);
    }

    if (i1 % 2 === 1) {
      args.push(max);
    }

    var before = boundaries.join(',');

    (_boundaries2 = boundaries).splice.apply(_boundaries2, args);

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.set = function (range) {
    var before = boundaries.join(',');
    boundaries = [];

    if (Array.isArray(range)) {
      range.forEach(fn.add);
    } else {
      fn.add(range);
    }

    var after = boundaries.join(',');
    return before !== after;
  };

  fn.clear = function () {
    var before = boundaries.length > 0;
    boundaries = [];
    return before;
  };

  fn.containsValue = function (value) {
    return contains(boundaries, value, minCondition, maxCondition);
  };

  fn.containsRange = function (_ref3) {
    var min = _ref3.min,
        max = _ref3.max;
    var i0 = picasso_esm_index(boundaries, min, true);
    var i1 = picasso_esm_index(boundaries, max);
    return i0 === i1 && i1 % 2 === 1;
  };

  fn.toggle = function (range) {
    if (fn.containsRange(range)) {
      return fn.remove(range);
    }

    return fn.add(range);
  };

  fn.ranges = function () {
    var collection = [];

    for (var i = 1; i < boundaries.length; i += 2) {
      collection.push({
        min: boundaries[i - 1],
        max: boundaries[i]
      });
    }

    return collection;
  };

  fn.configure(config);
  return fn;
}

function valueCollection() {
  var values = [];

  function vc() {}

  vc.add = function (value) {
    if (values.indexOf(value) === -1) {
      values.push(value);
      return true;
    }

    return false;
  };

  vc.remove = function (value) {
    var idx = values.indexOf(value);

    if (idx !== -1) {
      values.splice(idx, 1);
      return true;
    }

    return false;
  };

  vc.contains = function (value) {
    return values.indexOf(value) !== -1;
  };

  vc.values = function () {
    return values.slice();
  };

  vc.clear = function () {
    return values = [];
  };

  vc.toString = function () {
    return values.join(';');
  };

  return vc;
}

/**
 * @typedef {object} brush-config
 * @property {Array<brush-config--ranges>} [ranges] - Range configurations
 */

/**
 * @typedef {object}
 * @alias brush-config--ranges
 */

var DEFAULT_RANGE_CONFIG = {
  /**
   * An identifier that represents the data source of the value
   * @type {string=}
   */
  key: undefined,

  /**
   * Whether or not the minimum value of a range should be included when determening if a value is brushed.
   * @type {boolean=} */
  includeMin: true,

  /**
   * Whether or not the maximum value of a range should be included when determening if a value is brushed.
   * @type {boolean=} */
  includeMax: true
};

function add(_ref) {
  var items = _ref.items,
      collection = _ref.collection,
      vc = _ref.vc;
  var changedMap = {};
  var changed = [];
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;

    if (!collection[key]) {
      collection[key] = vc();
    }

    values = items[i].values || [items[i].value];

    for (var vi = 0; vi < values.length; vi++) {
      if (collection[key].add(values[vi])) {
        changedMap[key] = changedMap[key] || [];
        changedMap[key].push(values[vi]);
      }
    }
  }

  var keys = Object.keys(changedMap);

  for (var _i = 0, _num = keys.length; _i < _num; _i++) {
    key = keys[_i];
    changed.push({
      id: key,
      values: changedMap[key]
    });
  }

  return changed;
}

function remove(_ref2) {
  var items = _ref2.items,
      collection = _ref2.collection;
  var changedMap = {};
  var changed = [];
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;

    if (!collection[key]) {
      continue;
    }

    values = items[i].values || [items[i].value];

    for (var vi = 0; vi < values.length; vi++) {
      if (collection[key].remove(values[vi])) {
        changedMap[key] = changedMap[key] || [];
        changedMap[key].push(values[vi]);
      }
    }
  }

  var keys = Object.keys(changedMap);

  for (var _i2 = 0, _num2 = keys.length; _i2 < _num2; _i2++) {
    key = keys[_i2];
    changed.push({
      id: key,
      values: changedMap[key]
    });
  }

  return changed;
}

function collectUnique(items) {
  var filteredSet = {};
  var key;
  var values;

  for (var i = 0, num = items.length; i < num; i++) {
    key = items[i].key;
    values = items[i].values || [items[i].value];

    if (!filteredSet[key]) {
      filteredSet[key] = [];
    }

    for (var vi = 0; vi < values.length; vi++) {
      var idx = filteredSet[key].indexOf(values[vi]);

      if (idx === -1) {
        filteredSet[key].push(values[vi]);
      }
    }
  }

  return filteredSet;
}

function createValueCollection(_ref3) {
  var key = _ref3.key,
      collection = _ref3.collection,
      obj = _ref3.obj,
      fn = _ref3.fn,
      value = _ref3.value;

  if (!collection[key]) {
    collection[key] = fn();
  }

  obj[key] = obj[key] || [];
  obj[key].push(value);
  collection[key].add(value);
}

function picasso_esm_toggle(_ref4) {
  var items = _ref4.items,
      values = _ref4.values,
      vc = _ref4.vc;
  var addedMap = {};
  var removedMap = {};
  var added = [];
  var removed = [];
  var filteredSet = collectUnique(items);
  var key;
  var value;
  var fs;
  var setKeys = Object.keys(filteredSet);

  for (var i = 0, num = setKeys.length; i < num; i++) {
    key = setKeys[i];
    fs = filteredSet[key];

    for (var k = 0, len = fs.length; k < len; k++) {
      value = fs[k];

      if (!values[key] || !values[key].contains(value)) {
        createValueCollection({
          key: key,
          value: value,
          collection: values,
          obj: addedMap,
          fn: vc
        });
      } else if (values[key] && values[key].contains(value)) {
        removedMap[key] = removedMap[key] || [];
        removedMap[key].push(value);
        values[key].remove(value);
      }
    }
  }

  var addedKeys = Object.keys(addedMap);

  for (var _i3 = 0, _num3 = addedKeys.length; _i3 < _num3; _i3++) {
    key = addedKeys[_i3];
    added.push({
      id: key,
      values: addedMap[key]
    });
  }

  var removedKeys = Object.keys(removedMap);

  for (var _i4 = 0, _num4 = removedKeys.length; _i4 < _num4; _i4++) {
    key = removedKeys[_i4];
    removed.push({
      id: key,
      values: removedMap[key]
    });
  }

  return [added, removed];
}

function diff(old, current) {
  var changed = [];
  var keys = Object.keys(old);
  var key;
  var changedValues;

  var filterFn = function filterFn(v) {
    return current[key].indexOf(v) === -1;
  };

  for (var i = 0, num = keys.length; i < num; i++) {
    key = keys[i];

    if (!current[key]) {
      changed.push({
        id: key,
        values: old[key]
      });
    } else {
      changedValues = old[key].filter(filterFn);

      if (changedValues.length) {
        changed.push({
          id: key,
          values: changedValues
        });
      }
    }
  }

  return changed;
}

function set$1(_ref5) {
  var items = _ref5.items,
      vCollection = _ref5.vCollection,
      vc = _ref5.vc;
  var addedMap = {};
  var filteredSet = collectUnique(items);
  var added = [];
  var removed = [];
  var key;
  var oldMap = {};
  var vcKeys = Object.keys(vCollection);

  for (var i = 0, num = vcKeys.length; i < num; i++) {
    key = vcKeys[i];
    oldMap[key] = vCollection[key].values().slice();
    delete vCollection[key];
  }

  var createValueCollectionFn = function createValueCollectionFn(value) {
    if (!vCollection[key] || !vCollection[key].contains(value)) {
      createValueCollection({
        key: key,
        value: value,
        collection: vCollection,
        obj: addedMap,
        fn: vc
      });
    }
  };

  var fsKeys = Object.keys(filteredSet);

  for (var _i5 = 0, _num5 = fsKeys.length; _i5 < _num5; _i5++) {
    key = fsKeys[_i5];
    filteredSet[key].forEach(createValueCollectionFn);
  }

  removed = diff(oldMap, addedMap);
  added = diff(addedMap, oldMap);
  return [added, removed];
}

function applyAliases(items, aliases) {
  if (!Object.keys(aliases).length) {
    return items;
  }

  var len = items.length;
  var its = Array(len);

  for (var i = 0; i < len; i++) {
    its[i] = items[i].key in aliases ? extend({}, items[i], {
      key: aliases[items[i].key]
    }) : items[i];
  }

  return its;
}

function intercept(handlers, items, aliases) {
  var its = applyAliases(items, aliases);
  return handlers && handlers.length ? handlers.reduce(function (value, interceptor) {
    return interceptor(value);
  }, its) : its;
}

function toCamelCase(s) {
  return s.replace(/(-[a-z])/g, function ($1) {
    return $1.toUpperCase().replace('-', '');
  });
}

function toSnakeCase(s) {
  return s.replace(/([A-Z])/g, function ($1) {
    return "-".concat($1.toLowerCase());
  });
}

function updateRange(items, action, _ref6) {
  var ranges = _ref6.ranges,
      interceptors = _ref6.interceptors,
      rc = _ref6.rc,
      aliases = _ref6.aliases,
      rangeConfig = _ref6.rangeConfig;
  var inter = "".concat(action, "Ranges");
  var its = intercept(interceptors[inter], items, aliases);
  var changed = false;
  its.forEach(function (item) {
    var key = item.key;

    if (!ranges[key]) {
      ranges[key] = rc(rangeConfig.sources[key] || rangeConfig.default);
    }

    if (action === 'set') {
      changed = ranges[key][action](item.ranges || item.range) || changed;
    } else {
      var rangeValues = item.ranges || [item.range];

      for (var i = 0; i < rangeValues.length; i++) {
        changed = ranges[key][action](rangeValues[i]) || changed;
      }
    }
  });
  return changed;
}

function brush() {
  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref7$vc = _ref7.vc,
      vc = _ref7$vc === void 0 ? valueCollection : _ref7$vc,
      _ref7$rc = _ref7.rc,
      rc = _ref7$rc === void 0 ? rangeCollection : _ref7$rc;

  var activated = false;
  var ranges = {};
  var values = {};
  var aliases = {};
  var rangeConfig = {
    sources: {},
    default: extend({}, DEFAULT_RANGE_CONFIG)
  };
  var interceptors = {
    addValues: [],
    removeValues: [],
    toggleValues: [],
    setValues: [],
    addRanges: [],
    setRanges: [],
    removeRanges: [],
    toggleRanges: []
  };

  var getState = function getState() {
    var state = {
      values: {},
      ranges: {}
    };
    Object.keys(values).forEach(function (key) {
      state.values[key] = values[key].values();
    });
    Object.keys(ranges).forEach(function (key) {
      state.ranges[key] = ranges[key].ranges();
    });
    return state;
  };

  var links = {
    ls: [],
    clear: function clear() {
      this.ls.forEach(function (b) {
        return b.clear();
      });
    },
    start: function start() {
      this.ls.forEach(function (b) {
        return b.start();
      });
    },
    end: function end() {
      this.ls.forEach(function (b) {
        return b.end();
      });
    },
    update: function update() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state(s);
      });
    },
    updateValues: function updateValues() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state({
          values: s.values
        });
      });
    },
    updateRanges: function updateRanges() {
      var s = getState();
      this.ls.forEach(function (b) {
        return b._state({
          ranges: s.ranges
        });
      });
    }
  };
  /**
   * A brush context
   * @alias brush
   * @interface
   */

  var fn = {};
  /**
   * Triggered when this brush is activated
   * @event brush#start
   * @type {string}
   */

  /**
   * Triggered when this brush is updated
   * @event brush#update
   * @type {string}
   * @param {Array<object>} added - The added items
   * @param {Array<object>} removed - The removed items
   */

  /**
   * Triggered when this brush is deactivated
   * @event brush#end
   * @type {string}
   */

  /**
    * Configure the brush instance.
    *
    * @param {brush-config} config
    * @example
    * brushInstance.configure({
    *   ranges: [
    *     { key: 'some key', includeMax: false },
    *     { includeMax: true, includeMin: true },
    *   ]
    * })
    */

  fn.configure = function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (Array.isArray(config.ranges) && config.ranges.length) {
      rangeConfig = {
        sources: {},
        default: extend({}, DEFAULT_RANGE_CONFIG)
      };
      config.ranges.forEach(function (cfg) {
        var c = {};
        Object.keys(DEFAULT_RANGE_CONFIG).filter(function (attr) {
          return attr !== 'key';
        }).forEach(function (attr) {
          c[attr] = typeof cfg[attr] !== 'undefined' ? cfg[attr] : DEFAULT_RANGE_CONFIG[attr];
        });

        if (typeof cfg.key !== 'undefined') {
          rangeConfig.sources[cfg.key] = c;
        } else {
          rangeConfig.default = c;
        }
      });
      Object.keys(ranges).forEach(function (key) {
        return ranges[key].configure(rangeConfig.sources[key] || rangeConfig.default);
      }); // TODO only emit update if config has changed

      fn.emit('update', [], []);
    }
  };
  /**
   * Link this brush to another brush instance.
   *
   * When linked, the `target` will receive updates whenever this brush changes.
   * @param {brush} target - The brush instance to link to
   */


  fn.link = function (target) {
    if (fn === target) {
      throw new Error('Can\'t link to self');
    }

    links.ls.push(target);

    target._state(getState());
  };

  fn._state = function (s) {
    if (!s) {
      return getState();
    }

    if (s.values) {
      var arr = [];
      Object.keys(s.values).forEach(function (key) {
        if (!values[key] || s.values[key].join(';') !== values[key].toString()) {
          arr.push({
            key: key,
            values: s.values[key]
          });
        }
      });
      Object.keys(values).forEach(function (key) {
        if (!s.values[key]) {
          arr.push({
            key: key,
            values: []
          });
        }
      });

      if (arr.length) {
        fn.setValues(arr);
      }
    }

    if (s.ranges) {
      var _arr = [];
      Object.keys(s.ranges).forEach(function (key) {
        if (!ranges[key] || s.ranges[key].join(';') !== ranges[key].toString()) {
          _arr.push({
            key: key,
            ranges: s.ranges[key]
          });
        }
      });
      Object.keys(ranges).forEach(function (key) {
        if (!s.ranges[key]) {
          _arr.push({
            key: key,
            ranges: []
          });
        }
      });

      if (_arr.length) {
        fn.setRanges(_arr);
      }
    }

    return undefined;
  };
  /**
   * Starts this brush context
   *
   * Starts this brush context and emits a 'start' event if it is not already started.
   * @emits brush#start
   */


  fn.start = function () {
    if (!activated) {
      activated = true;
      fn.emit('start');
      links.start();
    }
  };
  /**
   * Ends this brush context
   *
   * Ends this brush context and emits an 'end' event if it is not already ended.
   * @emits brush#end
   */


  fn.end = function () {
    if (!activated) {
      return;
    }

    activated = false;
    ranges = {};
    values = {};
    fn.emit('end');
    links.end();
  };
  /**
   * Checks if this brush is activated
   *
   * Returns true if started, false otherwise
   * @return {boolean}
   */


  fn.isActive = function () {
    return activated;
  };
  /**
   * Clears this brush context
   */


  fn.clear = function () {
    var removed = fn.brushes().filter(function (b) {
      return b.type === 'value' && b.brush.values().length;
    }).map(function (b) {
      return {
        id: b.id,
        values: b.brush.values()
      };
    });
    var hasChanged = Object.keys(ranges).length > 0 || removed.length;
    ranges = {};
    values = {};

    if (hasChanged) {
      fn.emit('update', [], removed); // TODO - do not emit update if state hasn't changed

      links.clear();
    }
  };
  /**
   * Returns all brushes within this context
   * @return {object}
   */


  fn.brushes = function () {
    var result = [];
    result = result.concat(Object.keys(ranges).map(function (key) {
      return {
        type: 'range',
        id: key,
        brush: ranges[key]
      };
    }));
    result = result.concat(Object.keys(values).map(function (key) {
      return {
        type: 'value',
        id: key,
        brush: values[key]
      };
    }));
    return result;
  };
  /**
   * Adds a primitive value to this brush context
   *
   * If this brush context is not started, a 'start' event is emitted.
   * If the state of the brush changes, ie. if the added value does not already exist, an 'update' event is emitted.
   *
   * @param {string} key  An identifier that represents the data source of the value
   * @param {string|number} value The value to add
   * @emits brush#start
   * @emits brush#update
   * @example
   * brush.addValue('countries', 'Sweden');
   * brush.addValue('/qHyperCube/qDimensionInfo/0', 3);
   */


  fn.addValue = function (key, value) {
    fn.addValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to add
   */


  fn.addValues = function (items) {
    var its = intercept(interceptors.addValues, items, aliases);
    var added = add({
      vc: vc,
      collection: values,
      items: its
    });
    fn.emit('add-values', its);

    if (added.length) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', added, []);
      links.updateValues();
    }
  };
  /**
   * @param {object[]} items Items to set
   */


  fn.setValues = function (items) {
    var its = intercept(interceptors.setValues, items, aliases);
    var changed = set$1({
      items: its,
      vCollection: values,
      vc: vc
    });
    fn.emit('set-values', its);

    if (changed[0].length > 0 || changed[1].length > 0) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', changed[0], changed[1]);
      links.updateValues();
    }
  };
  /**
   * Removes a primitive values from this brush context
   *
   * If the state of the brush changes, ie. if the removed value does exist, an 'update' event is emitted.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to remove
   * @example
   * brush.removeValue('countries', 'Sweden');
   */


  fn.removeValue = function (key, value) {
    fn.removeValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to remove
   */


  fn.removeValues = function (items) {
    var its = intercept(interceptors.removeValues, items, aliases);
    var removed = remove({
      collection: values,
      items: its
    });
    fn.emit('remove-values', its);

    if (removed.length) {
      fn.emit('update', [], removed);
      links.updateValues(); // TODO - emit 'end' event if there are no remaining active brushes
    }
  };
  /**
   * Add and remove values in a single operation
   * almost the same as calling addValues and removeValues but only triggers one 'update' event
   *
   * If the state of the brush changes, an 'update' event is emitted.
   *
   * @param {object[]} addItems Items to add
   * @param {object[]} removeItems Items to remove
   */


  fn.addAndRemoveValues = function (addItems, removeItems) {
    var addIts = intercept(interceptors.addValues, addItems, aliases);
    var removeIts = intercept(interceptors.removeValues, removeItems, aliases);
    var added = add({
      vc: vc,
      collection: values,
      items: addIts
    });
    var removed = remove({
      collection: values,
      items: removeIts
    });
    fn.emit('add-values', addIts);
    fn.emit('remove-values', removeIts);

    if (added.length || removed.length) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', added, removed);
      links.updateValues();
    }
  };
  /**
   * Toggles a primitive value in this brush context
   *
   * If the given value exist in this brush context, it will be removed. If it does not exist it will be added.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to toggle
   * @example
   * brush.toggleValue('countries', 'Sweden');
   */


  fn.toggleValue = function (key, value) {
    fn.toggleValues([{
      key: key,
      value: value
    }]);
  };
  /**
   * @param {object[]} items Items to toggle
   */


  fn.toggleValues = function (items) {
    var its = intercept(interceptors.toggleValues, items, aliases);
    var toggled = picasso_esm_toggle({
      items: its,
      values: values,
      vc: vc
    });
    fn.emit('toggle-values', its);

    if (toggled[0].length > 0 || toggled[1].length > 0) {
      if (!activated) {
        activated = true;
        fn.emit('start');
      }

      fn.emit('update', toggled[0], toggled[1]);
      links.updateValues();
    }
  };
  /**
   * Checks if a certain value exists in this brush context
   *
   * Returns true if the values exists for the provided key, returns false otherwise.
   *
   * @param  {string} key  An identifier that represents the data source of the value
   * @param  {string|number} value The value to check for
   * @return {boolean}
   * @example
   * brush.addValue('countries', 'Sweden');
   * brush.containsValue('countries', 'Sweden'); // true
   * brush.toggleValue('countries', 'Sweden'); // remove 'Sweden'
   * brush.containsValue('countries', 'Sweden'); // false
   */


  fn.containsValue = function (key, value) {
    var k = aliases[key] || key;

    if (!values[k]) {
      return false;
    }

    return values[k].contains(value);
  };
  /**
   * Adds a numeric range to this brush context
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to add to this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   * @example
   * brush.addRange('Sales', { min: 20, max: 50 });
   */


  fn.addRange = function (key, range) {
    fn.addRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.addRange}
   * @param {object[]} items - Items containing the ranges to remove
   * @param {string} items[].key
   * @param {object} items[].range
   */


  fn.addRanges = function (items) {
    var changed = updateRange(items, 'add', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Removes a numeric range from this brush context
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to remove from this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.removeRange = function (key, range) {
    fn.removeRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.removeRange}
   * @param {object[]} items - Items containing the ranges to remove
   */


  fn.removeRanges = function (items) {
    var changed = updateRange(items, 'remove', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Sets a numeric range to this brush context
   *
   * Overwrites any active ranges identified by `key`
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to set on this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.setRange = function (key, range) {
    fn.setRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.setRange}
   * @param {object[]} items - Items containing the ranges to set
   */


  fn.setRanges = function (items) {
    var changed = updateRange(items, 'set', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Toggles a numeric range in this brush context
   *
   * Removes the range if it's already contained within the given identifier,
   * otherwise the given range is added to the brush.
   *
   * @param {string} key - An identifier that represents the data source of the range
   * @param {object} range - The range to toggle in this brush
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   */


  fn.toggleRange = function (key, range) {
    fn.toggleRanges([{
      key: key,
      range: range
    }]);
  };
  /**
   * @see {brush.toggleRange}
   * @param {object[]} items - Items containing the ranges to toggle
   */


  fn.toggleRanges = function (items) {
    var changed = updateRange(items, 'toggle', {
      ranges: ranges,
      rc: rc,
      interceptors: interceptors,
      aliases: aliases,
      rangeConfig: rangeConfig
    });

    if (!changed) {
      return;
    }

    if (!activated) {
      activated = true;
      fn.emit('start');
    }

    fn.emit('update', [], []);
    links.updateRanges();
  };
  /**
   * Checks if a value is contained within a range in this brush context
   *
   * Returns true if the values exists for the provided key, returns false otherwise.
   *
   * @param  {string} key - An identifier that represents the data source of the value
   * @param  {number} value - The value to check for
   * @return {boolean}
   * @example
   * brush.addRange('Sales', { min: 10, max: 50 });
   * brush.containsRangeValue('Sales', 30); // true
   * brush.containsRangeValue('Sales', 5); // false
   */


  fn.containsRangeValue = function (key, value) {
    var k = aliases[key] || key;

    if (!ranges[k]) {
      return false;
    }

    return ranges[k].containsValue(value);
  };
  /**
   * Checks if a range segment is contained within this brush context
   *
   * Returns true if the range segment exists for the provided key, returns false otherwise.
   *
   * @param {string} key - An identifier that represents the data source of the value
   * @param {object} range - The range to check for
   * @param {number} range.min - Min value of the range
   * @param {number} range.max - Max value of the range
   * @return {boolean}
   * @example
   * brush.addRange('Sales', { min: 10, max: 50 });
   * brush.containsRange('Sales', { min: 15, max: 20 }); // true - the range segment is fully contained within [10, 50]
   * brush.containsRange('Sales', { min: 5, max: 20 }); // false - part of the range segment is outside [10, 50]
   * brush.containsRange('Sales', { min: 30, max: 80 }); // false - part of the range segment is outside [10, 50]
   */


  fn.containsRange = function (key, range) {
    var k = aliases[key] || key;

    if (!ranges[k]) {
      return false;
    }

    return ranges[k].containsRange(range);
  };

  fn.containsMappedData = function (d, props, mode) {
    var status = [];
    var keys = Object.keys(d);
    var key;
    var item;
    var source;
    var value;

    for (var i = 0, num = keys.length; i < num; i++) {
      key = keys[i];

      if (key === 'value') {
        item = d;
        status[i] = {
          key: '',
          i: i,
          bool: false
        };
      } else if (key === 'source') {
        continue;
      } else {
        item = d[key];
        status[i] = {
          key: key,
          i: i,
          bool: false
        };
      }

      source = item.source && item.source.field;

      if (typeof source === 'undefined') {
        continue;
      }

      if (typeof item.source.key !== 'undefined') {
        source = "".concat(item.source.key, "/").concat(source);
      }

      if (source in aliases) {
        source = aliases[source];
      }

      value = item.value;

      if (ranges[source]) {
        status[i].bool = Array.isArray(value) ? ranges[source].containsRange({
          min: value[0],
          max: value[1]
        }) : ranges[source].containsValue(value);
      } else if (values[source] && values[source].contains(value)) {
        status[i].bool = true;
      }
    }

    if (props) {
      status = status.filter(function (b) {
        return props.indexOf(b.key) !== -1;
      });

      if (mode === 'and') {
        return !!status.length && !status.some(function (s) {
          return s.bool === false;
        });
      }

      if (mode === 'xor') {
        return !!status.length && status.some(function (s) {
          return s.bool;
        }) && status.some(function (s) {
          return s.bool === false;
        });
      } // !mode || mode === 'or'


      return status.some(function (s) {
        return s.bool;
      });
    }

    return status.some(function (s) {
      return s.bool;
    });
  };
  /**
   * Adds an event interceptor
   *
   * @param {string} name Name of the event to intercept
   * @param {function} ic Handler to call before event is triggered
   * @example
   * brush.intercept('add-values', items => {
   *  console.log('about to add the following items', items);
   *  return items;
   * });
   */


  fn.intercept = function (name, ic) {
    var s = toCamelCase(name);

    if (!interceptors[s]) {
      return;
    }

    interceptors[s].push(ic);
  };
  /**
   * Removes an interceptor
   *
   * @param {string} name Name of the event to intercept
   * @param {function} ic Handler to remove
   */


  fn.removeInterceptor = function (name, ic) {
    var s = toCamelCase(name);

    if (!interceptors[s]) {
      return;
    }

    var idx = interceptors[s].indexOf(ic);

    if (idx !== -1) {
      interceptors[s].splice(idx, 1);
    }
  };
  /**
   * Removes all interceptors
   *
   * @param {string} [name] Name of the event to remove interceptors for. If not provided, removes all interceptors.
   */


  fn.removeAllInterceptors = function (name) {
    var toRemove = [];

    if (name) {
      var s = toCamelCase(name);

      if (interceptors[s] && interceptors[s].length) {
        toRemove.push({
          name: name,
          handlers: interceptors[s]
        });
      }
    } else {
      Object.keys(interceptors).forEach(function (n) {
        if (interceptors[n].length) {
          toRemove.push({
            name: toSnakeCase(n),
            handlers: interceptors[n]
          });
        }
      });
    }

    toRemove.forEach(function (ic) {
      var interceptorHandlers = ic.handlers.slice();
      interceptorHandlers.forEach(function (handler) {
        return fn.removeInterceptor(ic.name, handler);
      });
    });
  };
  /**
   * Adds an alias to the given key
   *
   * @param {string} key - Value to be replaced
   * @param {string} alias - Value to replace key with
   * @example
   * brush.addKeyAlias('BadFieldName', 'Region');
   * brush.addValue('BadFieldName', 'Sweden'); // 'BadFieldName' will be stored as 'Region'
   * brush.containsValue('Region', 'Sweden'); // true
   * brush.containsValue('BadFieldName', 'Sweden'); // true
   */


  fn.addKeyAlias = function (key, alias) {
    aliases[key] = alias;
  };
  /**
   * Removes an alias
   *
   * This will only remove the key to alias mapping for new manipulations of the brush,
   * no changes will be made to the current state of this brush.
   *
   * @param {string} key - Value to remove as alias
   * @example
   * brush.removeKeyAlias('BadFieldName');
   */


  fn.removeKeyAlias = function (key) {
    delete aliases[key];
  };

  EventEmitter$1.mixin(fn);
  return fn;
}

var reg = registryFactory();

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var pi$2 = Math.PI;

var tau$2 = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$2);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau$2); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

/* globals window */

function nodeId(node, i) {
  if (node.data) {
    return node.data.value;
  }

  if (node.type === 'text') {
    return node.text;
  }

  return i;
}

function tween(_ref, _ref2, config) {
  var old = _ref.old,
      current = _ref.current;
  var renderer = _ref2.renderer;
  var ticker; // let staticNodes = [];

  var toBeUpdated = [];
  var entered = {
    nodes: [],
    ips: []
  };
  var exited = {
    nodes: [],
    ips: []
  };
  var updated = {
    nodes: [],
    ips: []
  };
  var stages = [];
  var trackBy = config.trackBy || nodeId;
  var tweener = {
    start: function start() {
      var ids = {};
      old.forEach(function (node, i) {
        var id = trackBy(node, i);
        ids[id] = node;
      });
      current.forEach(function (node, i) {
        var id = trackBy(node, i);

        if (ids[id]) {
          updated.ips.push(interpolateObject(ids[id], node));
          updated.nodes.push(node);
          toBeUpdated.push(ids[id]);
          ids[id] = false;
        } else {
          entered.nodes.push(node);
          entered.ips.push(interpolateObject({
            r: 0.001,
            opacity: 0
          }, node));
        }
      });
      Object.keys(ids).forEach(function (key) {
        if (ids[key]) {
          exited.nodes.push(ids[key]);
          exited.ips.push(interpolateObject(ids[key], extend({}, ids[key], {
            r: 0.0001,
            opacity: 0
          })));
        }
      });

      if (exited.ips.length) {
        stages.push({
          easing: cubicInOut,
          duration: 200,
          tweens: exited.ips,
          nodes: [].concat(toBeUpdated)
        });
      }

      if (updated.ips.length) {
        stages.push({
          easing: cubicInOut,
          duration: 400,
          tweens: updated.ips,
          nodes: []
        });
      }

      if (entered.ips.length) {
        stages.push({
          easing: elasticOut,
          duration: 1200,
          tweens: entered.ips,
          nodes: _toConsumableArray$1(updated.nodes)
        });
      } // console.log(stages);


      if (stages.length) {
        stages[0].started = Date.now();

        if (typeof window !== 'undefined') {
          ticker = window.requestAnimationFrame(tweener.tick);
        }
      }
    },
    tick: function tick() {
      var currentStage = stages[0];

      if (!currentStage) {
        tweener.stop();
      }

      if (!currentStage.started) {
        currentStage.started = Date.now();
      }

      var t = (Date.now() - currentStage.started) / currentStage.duration;
      var currentNodes = [];
      var tweenedNodes = currentStage.tweens.map(function (ip) {
        return ip(currentStage.easing(Math.min(1, t)));
      });
      currentNodes.push.apply(currentNodes, _toConsumableArray$1(tweenedNodes));
      currentNodes.push.apply(currentNodes, _toConsumableArray$1(currentStage.nodes)); // currentNodes.push(...staticNodes);
      // stages.slice(1).forEach(stage => currentNodes.push(...stage.nodes));

      renderer.render(currentNodes);

      if (t >= 1) {
        // staticNodes.push(...currentStage.nodes);
        stages.shift();

        if (!stages.length) {
          tweener.stop();
        }
      }

      if (ticker) {
        ticker = window.requestAnimationFrame(tweener.tick);
      }
    },
    stop: function stop() {
      if (ticker) {
        window.cancelAnimationFrame(ticker);
        ticker = false;
      }
    }
  };
  return tweener;
}

var GLOBAL_DEFAULTS = {
  fontFamily: 'Arial',
  fontSize: '13px',
  color: '#595959',
  backgroundColor: '#ffffff',
  stroke: '#000000',
  strokeWidth: 0,
  $fill: '#333333'
};
var REF_RX = /^\$/;

function isPrimitive(x) {
  var type = picasso_esm_typeof(x);

  return type !== 'object' && type !== 'function' && type !== 'undefined';
}
/**
 * @callback datum-accessor
 * @param {datum-extract} d
 */

/**
 * @typedef {object} datum-config
 * @property {string} [scale]
 * @property {datum-accessor} fn
 * @property {string} ref - A reference to a datum-extract property
 */

/**
 * @typedef {string|datum-config|datum-accessor} datum-string
 */

/**
 * @typedef {number|datum-config|datum-accessor} datum-number
 */

/**
 * Normalizes property settings
 *
 * @ignore
 * @export
 * @param {any} settings
 * @param {any} defaults
 * @param {any} chart
 * @returns {any}
 */


function normalizeSettings(settings, defaults, chart) {
  var composition = extend({}, settings);
  var defs = extend({}, defaults);
  Object.keys(composition).forEach(function (key) {
    defs[key] = {};
    var v = composition[key];

    var vType = picasso_esm_typeof(v);

    if (typeof v === 'function') {
      defs[key].fn = v;
    } else if (isPrimitive(v)) {
      var defaultValue = defaults[key];

      if (typeof defaultValue === 'string' && REF_RX.test(defaultValue)) {
        defaultValue = GLOBAL_DEFAULTS[defaultValue];
      }

      var defaultType = picasso_esm_typeof(defaultValue);

      if (defaultType === 'undefined') {
        // if property has no default, assign provided value
        defs[key] = v;
      } else {
        // assign provided value if it's of same type as default, otherwise use default
        defs[key] = defaultType === vType ? v : defaultValue;
      }
    } else if (v && picasso_esm_typeof(v) === 'object') {
      if (typeof v.fn === 'function') {
        defs[key].fn = v.fn;
      }

      if (typeof v.scale !== 'undefined') {
        defs[key].scale = chart.scale(v.scale);
      }

      if (typeof v.ref === 'string') {
        defs[key].ref = v.ref;
      }
    }
  });
  Object.keys(defaults).forEach(function (key) {
    if (key in composition) {
      // don't process same props again
      return;
    }

    var v = defaults[key];

    var defaultType = picasso_esm_typeof(v);

    if (defaultType === 'string' && REF_RX.test(v)) {
      defs[key] = GLOBAL_DEFAULTS[v];
    } else {
      defs[key] = v;
    }
  });
  return defs;
}
function resolveForItem(context, normalized, idx) {
  var ret = {};
  var keys = Object.keys(normalized);
  var len = keys.length;
  var fallbackData = context.datum;
  var datum = context.datum;

  for (var i = 0; i < len; i++) {
    var key = keys[i];
    var normalizedProp = normalized[key];
    var exists = picasso_esm_typeof(datum) === 'object' && typeof normalizedProp !== 'undefined';
    var hasExplicitDataProp = exists && typeof normalizedProp.ref === 'string';
    var hasImplicitDataProp = exists && key in datum;
    var propData = hasExplicitDataProp ? datum[normalizedProp.ref] : hasImplicitDataProp ? datum[key] : fallbackData; // eslint-disable-line

    if (isPrimitive(normalizedProp)) {
      ret[key] = normalizedProp;
    } else if (exists && normalizedProp.fn) {
      // callback function
      if (normalizedProp.scale) {
        context.scale = normalizedProp.scale;
      }

      ret[key] = normalizedProp.fn.call(null, context, idx);
    } else if (exists && normalizedProp.scale && propData) {
      ret[key] = normalizedProp.scale(propData.value);

      if (normalizedProp.scale.bandwidth) {
        ret[key] += normalizedProp.scale.bandwidth() / 2;
      }
    } else if (hasExplicitDataProp && propData) {
      ret[key] = propData.value;
    } else if (normalizedProp.fn) {
      ret[key] = normalizedProp.fn.call(null, context, idx);
    } else {
      ret[key] = normalizedProp;
    }
  }

  return ret;
}

function updateScaleSize(object, path, size) {
  var o = object[path];

  if (o && o.scale && o.scale.pxScale) {
    o.scale = o.scale.pxScale(size);
  } else if (o && o.pxScale) {
    object[path] = o.pxScale(size);
  }
}
function scaleWithSize(scale, size) {
  return scale.pxScale ? scale.pxScale(size) : scale;
}

var externals = {
  normalizeSettings: normalizeSettings,
  resolveForItem: resolveForItem,
  updateScaleSize: updateScaleSize
};
function settingsResolver (resources) {
  var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : externals;
  var cache = {};

  function resolve(_ref) {
    var data = _ref.data,
        settings = _ref.settings,
        _ref$defaults = _ref.defaults,
        defaults = _ref$defaults === void 0 ? {} : _ref$defaults,
        scaled = _ref.scaled;
    var norm = cache.norm = deps.normalizeSettings(settings, defaults, resources.chart);
    var res = {
      scale: resources.chart.scale,
      formatter: resources.chart.formatter
    };

    if (scaled) {
      Object.keys(scaled).forEach(function (key) {
        if (norm[key]) {
          deps.updateScaleSize(norm, key, scaled[key]);
        }
      });
    }

    var resolved = [];

    if (data && Array.isArray(data.items)) {
      var context;

      for (var i = 0, len = data.items.length; i < len; i++) {
        context = {
          datum: data.items[i],
          data: data,
          resources: res
        };
        var obj = deps.resolveForItem(context, cache.norm, i);
        obj.data = data.items[i];
        resolved.push(obj);
      }
    } else {
      var _context = {
        data: data,
        resources: res
      };

      var _obj = deps.resolveForItem(_context, cache.norm, -1);

      return {
        settings: cache.norm,
        item: _obj
      };
    }

    return {
      settings: cache.norm,
      items: resolved
    };
  }

  return {
    resolve: resolve
  };
}

/**
 * Flatten the array of nodes by removing any containers as they do not support styling, thus unable to brush them.
 * @param {array} nodes
 * @ignore
 */

function reduceToLeafNodes() {
  var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return nodes.reduce(function (ary, node) {
    if (Array.isArray(node.children)) {
      ary.push.apply(ary, _toConsumableArray$1(reduceToLeafNodes(node.children)));
      return ary;
    }

    ary.push(node);
    return ary;
  }, []);
}
function styler(obj, _ref) {
  var context = _ref.context,
      data = _ref.data,
      style = _ref.style,
      filter = _ref.filter,
      mode = _ref.mode;
  var brusher = obj.chart.brush(context);
  var dataProps = data;
  var active = style.active || {};
  var inactive = style.inactive || {};
  var styleProps = [];
  Object.keys(active).forEach(function (key) {
    styleProps.push(key);
  });
  Object.keys(inactive).forEach(function (key) {
    if (styleProps.indexOf(key) === -1) {
      styleProps.push(key);
    }
  });
  var activeNodes = [];
  var globalActivation = false; // track when we need to loop through all nodes, not just the active ones

  var getNodes = function getNodes() {
    var nodes = reduceToLeafNodes(obj.nodes);

    if (typeof filter === 'function') {
      nodes = nodes.filter(filter);
    }

    return nodes;
  };

  var update = function update() {
    // TODO - render nodes only once, i.e. don't render for each brush, update nodes for all brushes and then render
    var nodes = getNodes();
    var len = nodes.length;
    var nodeData;
    var globalChanged = false;

    var _loop = function _loop(i) {
      // TODO - update only added and removed nodes
      nodeData = nodes[i].data;

      if (!nodeData) {
        return "continue";
      }

      if (!nodes[i].__style) {
        nodes[i].__style = {};
        styleProps.forEach(function (s) {
          nodes[i].__style[s] = nodes[i][s]; // store original value
        });
      }

      var isActive = brusher.containsMappedData(nodeData, dataProps, mode);
      var activeIdx = activeNodes.indexOf(nodes[i]);
      var changed = false;

      if (isActive && activeIdx === -1) {
        // activated
        activeNodes.push(nodes[i]);
        changed = true;
      } else if (!isActive && activeIdx !== -1) {
        // was active
        activeNodes.splice(activeIdx, 1);
        changed = true;
      }

      if (changed || globalActivation) {
        var original = extend({}, nodes[i], nodes[i].__style);
        styleProps.forEach(function (s) {
          if (isActive && s in active) {
            nodes[i][s] = typeof active[s] === 'function' ? active[s].call(null, original) : active[s];
          } else if (!isActive && s in inactive) {
            nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, original) : inactive[s];
          } else {
            nodes[i][s] = nodes[i].__style[s];
          }
        });
        globalChanged = true;
      }
    };

    for (var i = 0; i < len; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    globalActivation = false;
    return globalChanged;
  };

  var onStart = function onStart() {
    var nodes = getNodes();
    var len = nodes.length;

    var _loop2 = function _loop2(i) {
      if (!nodes[i].data) {
        return "continue";
      }

      nodes[i].__style = nodes[i].__style || {};
      styleProps.forEach(function (s) {
        nodes[i].__style[s] = nodes[i][s]; // store original value

        if (s in inactive) {
          nodes[i][s] = typeof inactive[s] === 'function' ? inactive[s].call(null, nodes[i]) : inactive[s];
        }
      });
    };

    for (var i = 0; i < len; i++) {
      var _ret2 = _loop2(i);

      if (_ret2 === "continue") continue;
    }

    globalActivation = true;
    activeNodes.length = 0;
    obj.renderer.render(obj.nodes);
  };

  var onEnd = function onEnd() {
    var nodes = getNodes();
    var len = nodes.length;

    var _loop3 = function _loop3(i) {
      if (nodes[i].__style) {
        Object.keys(nodes[i].__style).forEach(function (s) {
          nodes[i][s] = nodes[i].__style[s];
        });
        nodes[i].__style = undefined;
      }
    };

    for (var i = 0; i < len; i++) {
      _loop3(i);
    }

    activeNodes.length = 0;
    obj.renderer.render(obj.nodes);
  };

  var onUpdate = function onUpdate()
  /* added, removed */
  {
    var changed = update();

    if (changed) {
      obj.renderer.render(obj.nodes);
    }
  };

  var externalUpdate = function externalUpdate() {
    activeNodes.length = 0;
    globalActivation = true;
    update();
  };

  brusher.on('start', onStart);
  brusher.on('end', onEnd);
  brusher.on('update', onUpdate);

  function cleanUp() {
    brusher.removeListener('start', onStart);
    brusher.removeListener('end', onEnd);
    brusher.removeListener('update', onUpdate);
  }

  return {
    isActive: function isActive() {
      return brusher.isActive();
    },
    update: externalUpdate,
    cleanUp: cleanUp
  };
}
function brushDataPoints(_ref2) {
  var dataPoints = _ref2.dataPoints,
      action = _ref2.action,
      chart = _ref2.chart,
      trigger = _ref2.trigger;

  if (!trigger) {
    return;
  }

  var dataProps = trigger.data || [''];
  var rangeBrush = {
    items: [],
    actionFn: 'toggleRanges'
  };
  var valueBrush = {
    items: [],
    actionFn: 'toggleValues'
  };

  if (['add', 'remove', 'set', 'toggle'].indexOf(action) !== -1) {
    rangeBrush.actionFn = "".concat(action, "Ranges");
    valueBrush.actionFn = "".concat(action, "Values");
  }

  var _loop4 = function _loop4(i) {
    var dataPoint = dataPoints[i];

    if (!dataPoint) {
      return "continue";
    }

    dataProps.forEach(function (p) {
      var d = dataPoint && !p ? dataPoint : dataPoint[p];

      if (d) {
        var it = {
          key: d.source.field
        };

        if (typeof d.source.key !== 'undefined') {
          it.key = "".concat(d.source.key, "/").concat(d.source.field);
        }

        if (Array.isArray(d.value)) {
          it.range = {
            min: d.value[0],
            max: d.value[1]
          };
          rangeBrush.items.push(it);
        } else {
          it.value = d.value;
          valueBrush.items.push(it);
        }
      }
    });
  };

  for (var i = 0; i < dataPoints.length; i++) {
    var _ret3 = _loop4(i);

    if (_ret3 === "continue") continue;
  }

  trigger.contexts.forEach(function (c) {
    if (rangeBrush.items.length) {
      chart.brush(c)[rangeBrush.actionFn](rangeBrush.items);
    } else {
      chart.brush(c)[valueBrush.actionFn](valueBrush.items); // call action even if there are items to potentially clear what is currently in the brush
    }
  });
}
function brushFromSceneNodes(_ref3) {
  var nodes = _ref3.nodes,
      action = _ref3.action,
      chart = _ref3.chart,
      trigger = _ref3.trigger;
  var dataPoints = [];

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var nodeData = node.data;

    if (nodeData !== null) {
      dataPoints.push(nodeData);
    }
  }

  brushDataPoints({
    dataPoints: dataPoints,
    action: action,
    chart: chart,
    trigger: trigger
  });
}
function resolveEvent(_ref4) {
  var collisions = _ref4.collisions,
      t = _ref4.t,
      config = _ref4.config,
      action = _ref4.action;
  var brushCollisions = [];
  var resolved = false;

  if (collisions.length > 0) {
    brushCollisions = collisions;
    resolved = true;

    if (t.propagation === 'stop') {
      brushCollisions = [collisions[collisions.length - 1]];
    }
  }

  var nodes = brushCollisions.map(function (c) {
    return c.node;
  });
  brushFromSceneNodes({
    nodes: nodes,
    action: action,
    chart: config.chart,
    data: config.data,
    trigger: t
  });
  return resolved;
}

function touchSingleContactPoint(e, rect) {
  if (e.changedTouches.length !== 1) {
    return null;
  }

  return {
    x: e.changedTouches[0].clientX - rect.left,
    y: e.changedTouches[0].clientY - rect.top
  };
}

function singleContactPoint(e, rect) {
  return {
    x: e.clientX - rect.left,
    y: e.clientY - rect.top
  };
}

function resolveCollisions(e, t, renderer) {
  var rect = renderer.element().getBoundingClientRect();
  var p = isTouchEvent(e) ? touchSingleContactPoint(e, rect) : singleContactPoint(e, rect);

  if (p === null || p.x < 0 || p.y < 0 || p.x > rect.width || p.y > rect.height) {
    // TODO include radius in this check?
    return [];
  }

  if (t.touchRadius > 0 && isTouchEvent(e)) {
    p = {
      cx: p.x,
      cy: p.y,
      r: t.touchRadius // TODO Use touch event radius/width value (Need to handle dpi scaling as well)

    };
  }

  return renderer.itemsAt(p);
}

function resolveAction(action, e, def) {
  if (action) {
    if (typeof action === 'function') {
      return action(e);
    }

    return action;
  }

  return def;
}

function resolveTapEvent(_ref5) {
  var e = _ref5.e,
      t = _ref5.t,
      config = _ref5.config;
  var collisions = resolveCollisions(e, t, config.renderer);
  return resolveEvent({
    collisions: collisions,
    t: t,
    config: config,
    action: resolveAction(t.action, e, 'toggle')
  });
}
function resolveOverEvent(_ref6) {
  var e = _ref6.e,
      t = _ref6.t,
      config = _ref6.config;
  var collisions = resolveCollisions(e, t, config.renderer);
  return resolveEvent({
    collisions: collisions,
    t: t,
    config: config,
    action: resolveAction(t.action, e, 'set')
  });
}

/**
 * A list of supported attributes in lower camelCase notation mapped to corresponding kebab-case notation.
 * The kebab-case notations are a sub-set of SVG attributes (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute).
 * @ignore
 */
var mappedAttributes = {
  fill: 'fill',
  stroke: 'stroke',
  opacity: 'opacity',
  strokeWidth: 'stroke-width',
  strokeLinejoin: 'stroke-linejoin',
  fontFamily: 'font-family',
  fontSize: 'font-size',
  baseline: 'dominant-baseline',
  // Special case where we have defined our own attribute name
  dominantBaseline: 'dominant-baseline',
  anchor: 'text-anchor',
  // Special case where we have defined our own attribute name
  textAnchor: 'text-anchor',
  maxWidth: 'maxWidth',
  transform: 'transform',
  strokeDasharray: 'stroke-dasharray',
  id: 'id'
};
/**
 * Takes a target object and assign each supported attribute from a source object to that target.
 * Each supported attributes is converted to a mapped kebab-case notation.
 * @ignore
 *
 * @param {object} target - Target object on which to assign mapped attribute values
 * @param {object} source - Source object
 */

function assignMappedAttribute(target, source) {
  Object.keys(mappedAttributes).forEach(function (key) {
    var sourceValue = source[key];

    if (typeof sourceValue !== 'undefined') {
      var mappedKey = mappedAttributes[key];
      target[mappedKey] = sourceValue;
    }
  });
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--circle
 */
function circle(options) {
  return {
    type: 'circle',
    fill: 'black',
    cx: options.x,
    cy: options.y,
    r: options.size / 2
  };
}

function pointsToPath(points) {
  var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var d = '';

  for (var i = 0; i < points.length; i++) {
    var p = points[i];

    if (i === 0) {
      d += "M".concat(p.x, " ").concat(p.y);
    } else {
      d += "L".concat(p.x, " ").concat(p.y);
    }

    d += ' ';
  }

  if (close) {
    d += 'Z';
  }

  return d;
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--diamond
 */

function diamond(options) {
  var size = options.size;
  var left = options.x - size / 2;
  var top = options.y - size / 2;
  var points = [{
    x: left,
    y: top + size / 2
  }, {
    x: left + size / 2,
    y: top
  }, {
    x: left + size,
    y: top + size / 2
  }, {
    x: left + size / 2,
    y: top + size
  }, {
    x: left,
    y: top + size / 2
  }];
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

function generateCrossPoints(x, y, size, barWidth) {
  var r = size / 2;
  var innerLeft = x - barWidth / 2;
  var innerTop = y - barWidth / 2;
  var left = x - r;
  var top = y - r;
  return [{
    x: innerLeft,
    y: innerTop
  }, // Top
  {
    x: innerLeft,
    y: top
  }, {
    x: innerLeft + barWidth,
    y: top
  }, {
    x: innerLeft + barWidth,
    y: innerTop
  }, // Right
  {
    x: left + size,
    y: innerTop
  }, {
    x: left + size,
    y: innerTop + barWidth
  }, {
    x: innerLeft + barWidth,
    y: innerTop + barWidth
  }, // Bottom
  {
    x: innerLeft + barWidth,
    y: top + size
  }, {
    x: innerLeft,
    y: top + size
  }, {
    x: innerLeft,
    y: innerTop + barWidth
  }, // Left
  {
    x: left,
    y: innerTop + barWidth
  }, {
    x: left,
    y: innerTop
  }];
}
/**
 * @extends symbol-config
 * @typedef {object} symbol--cross
 * @property {number} [width] - Width of the diagonals
 */

function cross(options) {
  var x = options.x;
  var y = options.y;
  var r = options.size / 2;
  var width = isNaN(options.width) ? r / 2 : options.width;
  var barWidth = Math.min(width, r);
  var points = generateCrossPoints(x, y, options.size, barWidth);
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * Get x1, y1, x2, y2 point from angle
 * Source: {@link https://codepen.io/NV/pen/jcnmK}
 * @private
 *
 * @param  {number} angle Radians
 * @return {object}       Point with x1, y2, x2, y2.
 */
function angleToPoints(angle) {
  var segment = Math.floor(angle / Math.PI * 2) + 2;
  var diagonal = (0.5 * segment + 0.25) * Math.PI;
  var op = Math.cos(Math.abs(diagonal - angle)) * Math.sqrt(2);
  var x = op * Math.cos(angle);
  var y = op * Math.sin(angle);
  return {
    x1: x < 0 ? 1 : 0,
    y1: y < 0 ? 1 : 0,
    x2: x >= 0 ? x : x + 1,
    y2: y >= 0 ? y : y + 1
  };
}
/**
 * Turns degrees into radians
 * @private
 *
 * @param  {number} degrees Degrees
 * @return {number}         Radians
 */

function toRadians(d) {
  return -d / 180 * Math.PI;
}
/**
 * Get x1, y1, x2, y2 point from degree
 * @private
 *
 * @param  {number} d Degree
 * @return {object}   Point with x1, y2, x2, y2.
 */

function degreesToPoints(d) {
  return angleToPoints(toRadians(d));
}

function add$1(v1, v2) {
  return {
    x: v1.x + v2.x,
    y: v1.y + v2.y
  };
}
function sub(v1, v2) {
  return {
    x: v1.x - v2.x,
    y: v1.y - v2.y
  };
}
function scalarMultiply(v, s) {
  return {
    x: v.x * s,
    y: v.y * s
  };
}
function distanceX(v1, v2) {
  return v1.x - v2.x;
}
function distanceY(v1, v2) {
  return v1.y - v2.y;
}
function sqrDistance(v1, v2) {
  return Math.pow(distanceX(v1, v2), 2) + Math.pow(distanceY(v1, v2), 2);
}
function distance(v1, v2) {
  return Math.sqrt(sqrDistance(v1, v2));
}
function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}
function projectOnto(v1, v2) {
  var m = dot(v1, v2) / dot(v2, v2) || 1;
  return {
    x: v2.x * m,
    y: v2.y * m
  };
}
function rotate(v, radians) {
  var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    x: 0,
    y: 0
  };
  var cos = Math.cos(radians);
  var sin = Math.sin(radians);
  var t1 = sub(v, origin);
  var t2 = {
    x: cos * t1.x - sin * t1.y,
    y: sin * t1.x + cos * t1.y
  };
  return add$1(t2, origin);
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--saltire
 * @property {number} [width] - Width of the diagonals
 */

function saltire(options) {
  var radians = toRadians(45);
  var r = options.size / 2;
  var width = isNaN(options.width) ? r / 2 : options.width;
  var barWidth = Math.min(width, r);
  var adjustedSize = options.size; // Adjust for the barwidth and rotation angle, so that the visual part is always inside the symbol area

  var h = Math.sin(Math.asin(-radians)) * (barWidth / 2);
  var c = r / Math.sin(-radians);
  adjustedSize += (c - r) * 2;
  adjustedSize -= h * 2;
  var centroid = {
    x: options.x,
    y: options.y
  };
  var points = generateCrossPoints(options.x, options.y, adjustedSize, barWidth).map(function (p) {
    return rotate(p, radians, centroid);
  });
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--square
 */
function square(options) {
  var size = options.size;
  return {
    type: 'rect',
    fill: 'black',
    x: options.x - size / 2,
    y: options.y - size / 2,
    width: size,
    height: size
  };
}

var DIRECTION_TO_ANGLE = {
  up: 0,
  down: 180,
  left: 90,
  right: -90
};
/**
 * @extends symbol-config
 * @typedef {object} symbol--triangle
 * @property {string} [direction='up'] - Direction of the triangle ('up'|'down'|'left'|'right')
 */

function triangle(options) {
  var size = options.size;
  var p = {
    x: options.x,
    y: options.y
  };
  var directionAngle = DIRECTION_TO_ANGLE[options.direction] || 0;
  var halfSize = size / 2;
  var left = options.x - halfSize;
  var top = options.y - halfSize;
  var points = [{
    x: left,
    y: top + size
  }, {
    x: left + halfSize,
    y: top
  }, {
    x: left + size,
    y: top + size
  }, {
    x: left,
    y: top + size
  }];
  var radians = toRadians(directionAngle);
  points = points.map(function (pp) {
    return rotate(pp, radians, p);
  });
  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

function createRectCollider(_ref) {
  var x = _ref.x,
      y = _ref.y,
      size = _ref.size;
  var r = size / 2;
  return {
    type: 'rect',
    x: x - r,
    y: y - r,
    width: size,
    height: size
  };
}
/**
 * @extends symbol-config
 * @typedef {object} symbol--line
 * @property {string} [direction='horizontal'] - Direction of line ('horizontal'|'vertical').
 */


function line$1(options) {
  var isVertical = options.direction === 'vertical';
  var r = options.size / 2;
  var x = options.x;
  var y = options.y;
  return {
    type: 'line',
    stroke: 'black',
    strokeWidth: 1,
    x1: x - (isVertical ? 0 : r),
    y1: y - (isVertical ? r : 0),
    x2: x + (isVertical ? 0 : r),
    y2: y + (isVertical ? r : 0),
    collider: createRectCollider(options) // TODO Use visual collider?

  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--star
 * @property {number} [points=5] - Number of points on the star
 * @property {number} [startAngle=90] - Start drawing angle
 * @property {number} [innerRadius=size/2] - Size of the star core. My not exceed size of symbol.
 */

function star(options) {
  var size = options.size;
  var points = [];
  var outerRadius = size / 2;
  var drawPoints = options.points || 5;
  var innerRadius = Math.min(options.innerRadius || size / 2, size) / 2;
  var startAngle = isNaN(options.startAngle) ? 90 : options.startAngle;
  var angle = 360 / drawPoints;

  for (var i = 1; i <= drawPoints; i++) {
    var pAngle = angle * i + startAngle;
    var radians = toRadians(pAngle);
    var innerRadians = toRadians(pAngle + angle / 2);
    var y = Math.sin(radians);
    var x = Math.cos(radians);
    var iy = Math.sin(innerRadians);
    var ix = Math.cos(innerRadians);
    points.push({
      x: options.x + x * outerRadius,
      y: options.y + y * outerRadius
    });
    points.push({
      x: options.x + ix * innerRadius,
      y: options.y + iy * innerRadius
    });
  }

  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--n-polygon
 * @property {object} [sides=6] - Number of sides on the regular polygon
 * @property {object} [startAngle=0] - Start drawing angle
 */

function nPolygon(options) {
  var points = [];
  var radius = options.size / 2;
  var drawPoints = Math.max(isNaN(options.sides) ? 6 : options.sides, 3);
  var angle = 360 / drawPoints;
  var startAngle = isNaN(options.startAngle) ? 0 : options.startAngle;

  for (var i = 1; i <= drawPoints; i++) {
    var radians = toRadians(angle * i + startAngle);
    var y = Math.sin(radians);
    var x = Math.cos(radians);
    points.push({
      x: options.x + x * radius,
      y: options.y + y * radius
    });
  }

  return {
    type: 'path',
    fill: 'black',
    d: pointsToPath(points)
  };
}

/**
 * @extends symbol-config
 * @typedef {object} symbol--bar
 * @property {string} [direction='horizontal'] - Direction of bar ('horizontal'|'vertical').
 */

function bar(options) {
  var p = {
    x: options.x,
    y: options.y
  };
  var isVertical = options.direction === 'vertical';
  var r = options.size / 2;
  var width = r / 2;
  var halfWidth = width / 2;
  var points = [{
    x: p.x - r,
    y: p.y + halfWidth
  }, {
    x: p.x - r,
    y: p.y - halfWidth
  }, {
    x: p.x + r,
    y: p.y - halfWidth
  }, {
    x: p.x + r,
    y: p.y + halfWidth
  }];

  if (isVertical) {
    var radians = toRadians(90);
    points = points.map(function (pp) {
      return rotate(pp, radians, p);
    });
  }

  var rect = pointsToRect(points);
  rect.type = 'rect';
  rect.fill = 'black';
  return rect;
}

var reg$1 = registryFactory();
reg$1.add('circle', circle);
reg$1.add('diamond', diamond);
reg$1.add('saltire', saltire);
reg$1.add('square', square);
reg$1.add('triangle', triangle);
reg$1.add('line', line$1);
reg$1.add('star', star);
reg$1.add('n-polygon', nPolygon);
reg$1.add('cross', cross);
reg$1.add('bar', bar);

function applyOpts(obj) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  Object.keys(opts).forEach(function (key) {
    if (typeof mappedAttributes[key] !== 'undefined' && key !== 'transform') {
      obj[key] = opts[key];
    }
  });
}
/**
 * Factory function for symbols.
 * Options object is passed to symbols function.
 * @private
 * @param {symbol--bar|symbol--circle|symbol--cross|symbol--diamond|symbol--line|symbol--n-polygon|symbol--saltire|symbol--square|symbol--star|symbol--triangle} options - Options definition may contain any of the supported display-object attributes
 * @returns {object} A node definition
 */


function create$3() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // TODO handle reserverd properties x, y, size, data, etc..
  var fn = reg$1.get(options.type);

  if (fn) {
    var s = fn(options);
    applyOpts(s, options);

    if (typeof options.data !== 'undefined') {
      s.data = options.data;
    }

    return s;
  }

  return fn;
}
/**
 * Mandatory symbol config
 * @typedef {object} symbol-config
 * @property {object} options - Options definition may contain any of the supported display-object attributes
 * @property {string} options.type - Type of symbol
 * @property {number} options.x - x-coordinate
 * @property {number} options.y - y-coordinate
 * @property {number} options.size
 * @property {object} [options.data]
 */

var isReservedProperty = function isReservedProperty(prop) {
  return ['on', 'preferredSize', 'created', 'beforeMount', 'mounted', 'resize', 'beforeUpdate', 'updated', 'beforeRender', 'render', 'beforeUnmount', 'beforeDestroy', 'destroyed', 'defaultSettings', 'data', 'settings', 'formatter', 'scale', 'chart', 'dockConfig', 'mediator', 'style', 'resolver', 'registries', '_DO_NOT_USE_getInfo', 'symbol', 'isVisible'].some(function (name) {
    return name === prop;
  });
};

function prepareContext(ctx, definition, opts) {
  var _definition$require = definition.require,
      require = _definition$require === void 0 ? [] : _definition$require;

  var mediatorSettings = definition.mediator || {};
  var settings = opts.settings,
      formatter = opts.formatter,
      scale = opts.scale,
      data = opts.data,
      renderer = opts.renderer,
      chart = opts.chart,
      dockConfig = opts.dockConfig,
      mediator = opts.mediator,
      instance = opts.instance,
      rect = opts.rect,
      style = opts.style,
      registries = opts.registries,
      resolver = opts.resolver,
      update = opts.update,
      _DO_NOT_USE_getInfo = opts._DO_NOT_USE_getInfo,
      symbol = opts.symbol,
      isVisible = opts.isVisible;

  ctx.emit = function () {};

  if (isVisible) {
    ctx.isVisible = isVisible;
  } // TODO add setters and log warnings / errors to console


  Object.defineProperty(ctx, 'settings', {
    get: settings
  });
  Object.defineProperty(ctx, 'data', {
    get: data
  });
  Object.defineProperty(ctx, 'formatter', {
    get: formatter
  });
  Object.defineProperty(ctx, 'scale', {
    get: scale
  });
  Object.defineProperty(ctx, 'mediator', {
    get: mediator
  });
  Object.defineProperty(ctx, 'style', {
    get: style
  });
  Object.defineProperty(ctx, 'registries', {
    get: registries
  });

  if (rect) {
    Object.defineProperty(ctx, 'rect', {
      get: rect
    });
  } // TODO _DO_NOT_USE_getInfo is a temporary solution to expose info from a component
  // It should replace ASAP with a proper solution.
  // The only component activaly in need of it is the legend-cat


  if (_DO_NOT_USE_getInfo) {
    ctx._DO_NOT_USE_getInfo = _DO_NOT_USE_getInfo;
  }

  Object.keys(definition).forEach(function (key) {
    if (!isReservedProperty(key)) {
      // Add non-lifecycle methods to the context
      if (typeof definition[key] === 'function') {
        ctx[key] = definition[key].bind(ctx);
      } else {
        ctx[key] = definition[key];
      }
    }
  }); // Add properties to context

  require.forEach(function (req) {
    if (req === 'renderer') {
      Object.defineProperty(ctx, 'renderer', {
        get: renderer
      });
    } else if (req === 'chart') {
      Object.defineProperty(ctx, 'chart', {
        get: chart
      });
    } else if (req === 'dockConfig') {
      Object.defineProperty(ctx, 'dockConfig', {
        get: dockConfig
      });
    } else if (req === 'instance') {
      Object.defineProperty(ctx, 'instance', {
        get: instance
      });
    } else if (req === 'update' && update) {
      Object.defineProperty(ctx, 'update', {
        get: update
      });
    } else if (req === 'resolver') {
      Object.defineProperty(ctx, 'resolver', {
        get: resolver
      });
    } else if (req === 'symbol') {
      Object.defineProperty(ctx, 'symbol', {
        get: symbol
      });
    }
  });

  Object.keys(mediatorSettings).forEach(function (eventName) {
    ctx.mediator.on(eventName, mediatorSettings[eventName].bind(ctx));
  });
}

function createDockDefinition(settings, preferredSize, logger) {
  var getLayoutProperty = function getLayoutProperty(propName) {
    if (settings[propName]) {
      logger.warn("Deprecation Warning the ".concat(propName, " property should be moved into layout: {} property")); // eslint-disable-line no-console

      return settings[propName];
    }

    return settings.layout ? settings.layout[propName] : undefined;
  };

  var def = {};
  def.displayOrder = getLayoutProperty('displayOrder');
  def.dock = getLayoutProperty('dock');
  def.prioOrder = getLayoutProperty('prioOrder');
  def.minimumLayoutMode = getLayoutProperty('minimumLayoutMode'); // move layout properties to layout object

  settings.layout = settings.layout || {};
  settings.layout.displayOrder = typeof def.displayOrder !== 'undefined' ? def.displayOrder : settings.layout.displayOrder;
  settings.layout.prioOrder = typeof def.prioOrder !== 'undefined' ? def.prioOrder : settings.layout.prioOrder;
  settings.layout.dock = def.dock || settings.layout.dock;
  settings.layout.minimumLayoutMode = def.minimumLayoutMode || settings.layout.minimumLayoutMode; // not directly a dock layout property

  def.show = settings.show;
  def.preferredSize = preferredSize;
  return def;
}

function setUpEmitter(ctx, emitter, settings) {
  // Object.defineProperty(ctx, 'emitter', )
  Object.keys(settings.on || {}).forEach(function (event) {
    ctx.eventListeners = ctx.eventListeners || [];
    var listener = settings.on[event].bind(ctx);
    ctx.eventListeners.push({
      event: event,
      listener: listener
    });
    emitter.on(event, listener);
  });

  ctx.emit = function (name) {
    for (var _len = arguments.length, event = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      event[_key - 1] = arguments[_key];
    }

    return emitter.emit.apply(emitter, [name].concat(event));
  };
}

function tearDownEmitter(ctx, emitter) {
  if (ctx.eventListeners) {
    ctx.eventListeners.forEach(function (_ref) {
      var event = _ref.event,
          listener = _ref.listener;
      emitter.removeListener(event, listener);
    });
    ctx.eventListeners.length = 0;
  }

  ctx.emit = function () {};
} // First render
// preferredSize -> resize -> beforeRender -> render -> mounted
// Normal update
// beforeUpdate -> preferredSize -> resize -> beforeRender -> render -> updated
// Update without relayout
// beforeUpdate -> beforeRender -> render -> updated
// TODO support es6 classes


function componentFactory(definition) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _definition$defaultSe = definition.defaultSettings,
      defaultSettings = _definition$defaultSe === void 0 ? {} : _definition$defaultSe,
      _definition$_DO_NOT_U = definition._DO_NOT_USE_getInfo,
      _DO_NOT_USE_getInfo = _definition$_DO_NOT_U === void 0 ? function () {
    return {};
  } : _definition$_DO_NOT_U;

  var _chart = context.chart,
      container = context.container,
      _mediator = context.mediator,
      _registries = context.registries,
      theme = context.theme,
      renderer = context.renderer;
  var emitter = EventEmitter$1.mixin({});
  var config = context.settings || {};

  var _settings = extend(true, {}, defaultSettings, config);

  var _data = [];

  var _scale;

  var _formatter;

  var element;
  var size;

  var _style;

  var _resolver = settingsResolver({
    chart: _chart
  });

  var _isVisible = false;
  var brushArgs = {
    nodes: [],
    chart: _chart,
    config: _settings.brush || {},
    renderer: null
  };
  var brushTriggers = {
    tap: [],
    over: []
  };
  var brushStylers = [];
  var definitionContext = {};
  var instanceContext = extend({}, config); // Create a callback that calls lifecycle functions in the definition and config (if they exist).

  function createCallback(method) {
    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    var canBeValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return function cb() {
      var inDefinition = typeof definition[method] !== 'undefined';
      var inConfig = typeof config[method] !== 'undefined';
      var returnValue;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (inDefinition) {
        if (typeof definition[method] === 'function') {
          var _definition$method;

          returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [definitionContext].concat(args));
        } else if (canBeValue) {
          returnValue = definition[method];
        }
      }

      if (inConfig) {
        if (typeof config[method] === 'function') {
          var _config$method;

          returnValue = (_config$method = config[method]).call.apply(_config$method, [instanceContext].concat(args));
        } else if (canBeValue) {
          returnValue = config[method];
        }
      }

      if (!inDefinition && !inConfig) {
        returnValue = defaultMethod.call.apply(defaultMethod, [definitionContext].concat(args));
      }

      return returnValue;
    };
  }

  var preferredSize = createCallback('preferredSize', function () {
    return 0;
  }, true);
  var resize = createCallback('resize', function (_ref2) {
    var inner = _ref2.inner;
    return inner;
  });
  var created = createCallback('created');
  var beforeMount = createCallback('beforeMount');
  var mounted = createCallback('mounted');
  var beforeUnmount = createCallback('beforeUnmount');
  var beforeUpdate = createCallback('beforeUpdate');
  var updated = createCallback('updated');
  var beforeRender = createCallback('beforeRender');
  var beforeDestroy = createCallback('beforeDestroy');
  var destroyed = createCallback('destroyed');
  var render = definition.render; // Do not allow overriding of this function

  var addBrushStylers = function addBrushStylers() {
    if (_settings.brush) {
      (_settings.brush.consume || []).forEach(function (b) {
        if (b.context && b.style) {
          brushStylers.push(styler(brushArgs, b));
        }
      });
    }
  };

  var addBrushTriggers = function addBrushTriggers() {
    if (_settings.brush) {
      (_settings.brush.trigger || []).forEach(function (t) {
        if (t.on === 'over') {
          brushTriggers.over.push(t);
        } else {
          brushTriggers.tap.push(t);
        }
      });
    }
  };

  Object.defineProperty(brushArgs, 'data', {
    get: function get() {
      return _data;
    }
  });
  var rendString = _settings.renderer || definition.renderer;
  var rend = rendString ? renderer || _registries.renderer(rendString)() : renderer || _registries.renderer()();
  brushArgs.renderer = rend;
  var dockConfigCallbackContext = {
    resources: _chart.logger ? {
      logger: _chart.logger()
    } : {}
  };

  var _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);

  var appendComponentMeta = function appendComponentMeta(node) {
    node.key = _settings.key;
    node.element = rend.element();
  };

  var fn = function fn() {};

  fn.dockConfig = function () {
    return _dockConfig;
  }; // Set new settings - will trigger mapping of data and creation of scale / formatter.


  fn.set = function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (opts.settings) {
      config = opts.settings;
      _settings = extend(true, {}, defaultSettings, opts.settings);
      _dockConfig = dockConfig(createDockDefinition(_settings, preferredSize, _chart.logger()), dockConfigCallbackContext);
    }

    if (_settings.scale) {
      _scale = _chart.scale(_settings.scale);
    }

    if (_settings.data) {
      _data = extract(_settings.data, {
        dataset: _chart.dataset,
        collection: _chart.dataCollection
      }, {
        logger: _chart.logger()
      }, _chart.dataCollection);
    } else if (_scale) {
      _data = _scale.data();
    } else {
      _data = [];
    }

    if (typeof _settings.formatter === 'string') {
      _formatter = _chart.formatter(_settings.formatter);
    } else if (picasso_esm_typeof(_settings.formatter) === 'object') {
      _formatter = _chart.formatter(_settings.formatter);
    } else if (_scale && _scale.data().fields) {
      _formatter = _scale.data().fields[0].formatter();
    }

    _style = theme.style(_settings.style || {});
  };

  fn.resize = function () {
    var inner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var outer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var newSize = resize({
      inner: inner,
      outer: outer
    });

    if (newSize) {
      size = rend.size(newSize);
    } else {
      size = rend.size(inner);
    }

    instanceContext.rect = extend(true, {
      computedPhysical: size.computedPhysical,
      computedOuter: outer.computed || outer,
      computedInner: inner.computed || inner
    }, inner);
    size = extend(true, {
      computedOuter: outer.computed || outer,
      computedInner: inner.computed || inner
    }, size);
  };

  fn.getRect = function () {
    return instanceContext.rect;
  };

  var getRenderArgs = function getRenderArgs() {
    var renderArgs = rend.renderArgs ? rend.renderArgs.slice(0) : [];
    renderArgs.push({
      data: _data
    });
    return renderArgs;
  };

  fn.beforeMount = beforeMount;

  fn.beforeRender = function () {
    beforeRender({
      size: size
    });
  };

  var currentNodes;

  fn.render = function () {
    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs())));
    rend.render(nodes);
    currentNodes = nodes;
  };

  fn.hide = function () {
    fn.unmount();
    rend.size({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    rend.clear();
  };

  fn.beforeUpdate = function () {
    beforeUpdate({
      settings: _settings,
      data: _data
    });
  };

  var currentTween;

  fn.update = function () {
    if (currentTween) {
      currentTween.stop();
    }

    var nodes = brushArgs.nodes = render.call.apply(render, [definitionContext].concat(_toConsumableArray$1(getRenderArgs()))); // Reset brush stylers and triggers

    brushStylers.forEach(function (b) {
      return b.cleanUp();
    });
    brushStylers.length = 0;
    brushTriggers.tap = [];
    brushTriggers.over = [];

    if (_settings.brush) {
      addBrushStylers();
      addBrushTriggers();
    }

    brushStylers.forEach(function (bs) {
      if (bs.isActive()) {
        bs.update();
      }
    });

    if (currentNodes && _settings.animations && _settings.animations.enabled) {
      currentTween = tween({
        old: currentNodes,
        current: nodes
      }, {
        renderer: rend
      }, _settings.animations);
      currentTween.start();
    } else {
      rend.render(nodes);
    }

    currentNodes = nodes;

    if (rend.setKey && typeof config.key === 'string') {
      rend.setKey(config.key);
    }
  };

  fn.updated = updated;

  fn.destroy = function () {
    fn.unmount();
    beforeDestroy(element);
    rend.destroy();
    destroyed();
    element = null;
  };
  /**
   * Update active nodes. For now this can be used as a way update and apply brushing on nodes.
   * Ex: if a component have changed the nodes since its initial render.
   * @param {Nodes[]} nodes
   * @deprecated
   * @ignore
   */


  var updateNodes = function updateNodes(nodes) {
    brushArgs.nodes = nodes;
    brushStylers.forEach(function (bs) {
      if (bs.isActive()) {
        bs.update();
      }
    });
    rend.render(nodes);
  }; // Set contexts, note that the definition and instance need different contexts (for example if they have different 'require' props)


  prepareContext(definitionContext, definition, {
    settings: function settings() {
      return _settings;
    },
    data: function data() {
      return _data;
    },
    scale: function scale() {
      return _scale;
    },
    formatter: function formatter() {
      return _formatter;
    },
    renderer: function renderer() {
      return rend;
    },
    chart: function chart() {
      return _chart;
    },
    dockConfig: function dockConfig() {
      return _dockConfig;
    },
    mediator: function mediator() {
      return _mediator;
    },
    instance: function instance() {
      return instanceContext;
    },
    rect: function rect() {
      return instanceContext.rect;
    },
    style: function style() {
      return _style;
    },
    update: function update() {
      return updateNodes;
    },
    registries: function registries() {
      return _registries;
    },
    resolver: function resolver() {
      return _resolver;
    },
    symbol: function symbol() {
      return create$3;
    }
  });
  prepareContext(instanceContext, config, {
    settings: function settings() {
      return _settings;
    },
    data: function data() {
      return _data;
    },
    scale: function scale() {
      return _scale;
    },
    formatter: function formatter() {
      return _formatter;
    },
    renderer: function renderer() {
      return rend;
    },
    chart: function chart() {
      return _chart;
    },
    dockConfig: function dockConfig() {
      return _dockConfig;
    },
    mediator: function mediator() {
      return _mediator;
    },
    style: function style() {
      return _style;
    },
    _DO_NOT_USE_getInfo: _DO_NOT_USE_getInfo.bind(definitionContext),
    isVisible: function isVisible() {
      return _isVisible;
    }
  });

  fn.getBrushedShapes = function getBrushedShapes(brushCtx, mode, props) {
    var shapes = [];

    if (_settings.brush && _settings.brush.consume) {
      var brusher = _chart.brush(brushCtx);

      var sceneNodes = rend.findShapes('*');

      _settings.brush.consume.filter(function (t) {
        return t.context === brushCtx;
      }).forEach(function (consume) {
        for (var i = 0; i < sceneNodes.length; i++) {
          var node = sceneNodes[i];

          if (node.data && brusher.containsMappedData(node.data, props || consume.data, mode)) {
            appendComponentMeta(node);
            shapes.push(node);
            sceneNodes.splice(i, 1);
            i--;
          }
        }
      });
    }

    return shapes;
  };

  fn.findShapes = function (selector) {
    var shapes = rend.findShapes(selector);

    for (var i = 0, num = shapes.length; i < num; i++) {
      appendComponentMeta(shapes[i]);
    }

    return shapes;
  };

  fn.shapesAt = function (shape) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var items = rend.itemsAt(shape);
    var shapes;

    if (opts && opts.propagation === 'stop' && items.length > 0) {
      shapes = [items.pop().node];
    } else {
      shapes = items.map(function (i) {
        return i.node;
      });
    }

    for (var i = 0, num = shapes.length; i < num; i++) {
      appendComponentMeta(shapes[i]);
    }

    return shapes;
  };

  fn.brushFromShapes = function (shapes) {
    var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    trigger.contexts = Array.isArray(trigger.contexts) ? trigger.contexts : [];
    var action = trigger.action || 'toggle';
    brushFromSceneNodes({
      nodes: shapes,
      action: action,
      trigger: trigger,
      chart: _chart,
      data: brushArgs.data
    });
  };

  fn.mount = function () {
    element = rend.element && rend.element() ? element : rend.appendTo(container);

    if (rend.setKey && typeof config.key === 'string') {
      rend.setKey(config.key);
    }

    if (_settings.brush) {
      addBrushStylers();
      addBrushTriggers();
    }

    setUpEmitter(instanceContext, emitter, config);
    setUpEmitter(definitionContext, emitter, definition);
    _isVisible = true;
  };

  fn.mounted = function () {
    return mounted(element);
  };

  fn.unmount = function () {
    [instanceContext, definitionContext].forEach(function (ctx) {
      tearDownEmitter(ctx, emitter);
    });
    brushTriggers.tap = [];
    brushTriggers.over = [];
    brushStylers.forEach(function (bs) {
      bs.cleanUp();
    });
    brushStylers.length = 0;
    beforeUnmount();
    _isVisible = false;
  };

  fn.onBrushTap = function (e) {
    brushTriggers.tap.forEach(function (t) {
      if (resolveTapEvent({
        e: e,
        t: t,
        config: brushArgs
      }) && t.globalPropagation === 'stop') {
        _chart.toggleBrushing(true);
      }
    });
  };

  fn.onBrushOver = function (e) {
    brushTriggers.over.forEach(function (t) {
      if (resolveOverEvent({
        e: e,
        t: t,
        config: brushArgs
      }) && t.globalPropagation === 'stop') {
        _chart.toggleBrushing(true);
      }
    });
  };
  /**
   * Expose definition on instance
   * @private
   * @experimental
   */


  fn.def = definitionContext;
  /**
   * Expose instanceCtx on "instance"
   * @private
   * @experimental
   */

  fn.ctx = instanceContext;

  fn.renderer = function () {
    return rend;
  };

  fn.set({
    settings: config
  });
  created();
  return fn;
}

function mediator() {
  var instance = {};
  EventEmitter$1.mixin(instance);
  return instance;
}

var EPSILON = 1e-12;
function closestPointToLine(start, end, p) {
  var startToPoint = sub(p, start);
  var startToEnd = sub(end, start);
  var pointOnLine = add$1(projectOnto(startToPoint, startToEnd), start);
  return pointOnLine;
}
function isPointOnLine(start, end, p) {
  return distance(start, p) + distance(end, p) - distance(start, end) < EPSILON;
}
/**
 * Check if rectangle a is located inside rectangle b or if they are the same rectangle.
 * @param {rect} a - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
 * @param {rect} b - An rect containing (x,y) coordinates, width and height. The origin is assumed to be top left.
 * @ignore
 */

function rectContainsRect(a, b) {
  return a.x >= b.x && a.x + a.width <= b.x + b.width && a.y >= b.y && a.y + a.height <= b.y + b.height;
}

function lineHasNoLength(line) {
  return line.x1 === line.x2 && line.y1 === line.y2;
}

function rectHasNoSize(rect) {
  return rect.width <= 0 || rect.height <= 0;
}

function circleHasNoSize(circle) {
  return circle.r <= 0;
}

function toFewEdges(polygon) {
  return polygon.edges.length <= 2;
}
/**
   * Test if a Circle contains a point. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if circle contains point
   */


function testCirclePoint(circle, point) {
  if (circleHasNoSize(circle)) {
    return false;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };
  var sqrDist = sqrDistance(center, point);

  if (sqrDist <= Math.pow(circle.r, 2)) {
    return true;
  }

  return false;
}
/**
   * Test if a Circle collide with a rectangle. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if circle collide with rectangle
  */

function testCircleRect(circle, rect) {
  if (rectHasNoSize(rect) || circleHasNoSize(circle)) {
    return false;
  }

  var rX = rect.width / 2;
  var rY = rect.height / 2;
  var rcX = rect.x + rX;
  var rcY = rect.y + rY;
  var r = circle.r;
  var cx = circle.cx;
  var cy = circle.cy;
  var dX = Math.abs(cx - rcX);
  var dY = Math.abs(cy - rcY);

  if (dX > rX + r || dY > rY + r) {
    return false;
  }

  if (dX <= rX || dY <= rY) {
    return true;
  }

  var sqrDist = Math.pow(dX - rX, 2) + Math.pow(dY - rY, 2);
  return sqrDist <= Math.pow(r, 2);
}
/**
   * Test if a Circle collide with a line segment. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Line must have a length greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if circle collide with line
  */

function testCircleLine(circle, line) {
  if (circleHasNoSize(circle) || lineHasNoLength(line)) {
    return false;
  }

  var _lineToPoints = lineToPoints(line),
      _lineToPoints2 = _slicedToArray(_lineToPoints, 2),
      p1 = _lineToPoints2[0],
      p2 = _lineToPoints2[1];

  if (testCirclePoint(circle, p1) || testCirclePoint(circle, p2)) {
    return true;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };
  var pointOnLine = closestPointToLine(p1, p2, center);
  var dist = sqrDistance(pointOnLine, center);
  return dist <= Math.pow(circle.r, 2) && isPointOnLine(p1, p2, pointOnLine);
}
/**
   * Test if a Circle collide with another Circle. If so, returns true and false otherwise.
   * Both circles muse have a radius greater then 0.
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @return {boolean} true if circle collide with circle
  */

function testCircleCircle(circle1, circle2) {
  if (circleHasNoSize(circle1) || circleHasNoSize(circle2)) {
    return false;
  }

  var dx = circle1.cx - circle2.cx;
  var dy = circle1.cy - circle2.cy;
  var sqrDist = Math.pow(dx, 2) + Math.pow(dy, 2);

  if (sqrDist <= Math.pow(circle1.r + circle2.r, 2)) {
    return true;
  }

  return false;
}
/**
   * Test if a Circle collide with Polygon. If so, returns true and false otherwise.
   * Circle muse have a radius greater then 0.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} circle
   * @param {number} circle.cx - center x-coordinate
   * @param {number} circle.cy - center y-coordinate
   * @param {number} circle.r - circle radius
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @return {boolean} true if circle collide with polygon
  */

function testCirclePolygon(circle, polygon) {
  // TODO handle polygon that is a straight line, current impl will interrept it is a true, if radius is extended onto any of the edges
  if (toFewEdges(polygon) || circleHasNoSize(circle)) {
    return false;
  }

  var center = {
    x: circle.cx,
    y: circle.cy
  };

  if (testPolygonPoint(polygon, center)) {
    return true;
  }

  var num = polygon.edges.length;

  for (var i = 0; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testCircleLine(circle, edge)) {
      return true;
    }
  }

  return false;
}
/**
   * Test if a Polygon contains a Point. If so, returns true and false otherwise.
   * Polygon must contain at least 2 vertices
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if polygon conatins point
  */

function testPolygonPoint(polygon, point) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon) || !testRectPoint(polygon.boundingRect(), point)) {
    return false;
  }

  var even = true;
  var num = polygon.vertices.length;
  var rayStart = {
    x: polygon.xMin - 1,
    y: point.y
  };

  for (var i = 0; i < num - 1; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (!(edge.y1 < point.y && edge.y2 < point.y) && !(edge.y1 > point.y && edge.y2 > point.y)) {
      // filterout any edges that does not cross the ray
      even = testLineLine(edge, pointsToLine([rayStart, point])) ? !even : even;
    }
  }

  return !even;
}
/**
   * Test if a Polygon collider with a line. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Line must have length greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if polygon collider with line
  */

function testPolygonLine(polygon, line) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon)) {
    return false;
  }

  for (var i = 0, num = polygon.edges.length; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testLineLine(line, edge)) {
      return true;
    }
  }

  var _lineToPoints3 = lineToPoints(line),
      _lineToPoints4 = _slicedToArray(_lineToPoints3, 2),
      p1 = _lineToPoints4[0],
      p2 = _lineToPoints4[1];

  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2);
}
/**
   * Test if a Polygon collider with a rectangle. If so, returns true and false otherwise.
   * Polygon must contain at least 3 edges.
   * Rectangle must width and height greater then 0.
   * @private
   * @param {object} polygon
   * @param {Array} polygon.vertices - Array of vertices
   * @param {object} polygon.vertices.vertex
   * @param {number} polygon.vertices.vertex.x - x-coordinate
   * @param {number} polygon.vertices.vertex.y - y-coordinate
   * @param {Array} polygon.edges - Array of edges
   * @param {Array} polygon.edges.edge - Array of points
   * @param {object} polygon.edges.edge.point
   * @param {number} polygon.edges.edge.point.x - x-coordinate
   * @param {number} polygon.edges.edge.point.y - y-coordinate
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if polygon collider with rect
  */

function testPolygonRect(polygon, rect) {
  // TODO handle polygon that is a straight line, current impl gives a non-deterministic output, that is depending on number of vertices
  if (toFewEdges(polygon)) {
    return false;
  }

  for (var i = 0, num = polygon.edges.length; i < num; i++) {
    var edge = pointsToLine(polygon.edges[i]);

    if (testRectLine(rect, edge)) {
      return true;
    }
  }

  var _rectToPoints = rectToPoints(rect),
      _rectToPoints2 = _slicedToArray(_rectToPoints, 4),
      p1 = _rectToPoints2[0],
      p2 = _rectToPoints2[1],
      p3 = _rectToPoints2[2],
      p4 = _rectToPoints2[3];

  return testPolygonPoint(polygon, p1) || testPolygonPoint(polygon, p2) || testPolygonPoint(polygon, p3) || testPolygonPoint(polygon, p4);
}
/**
   * Test if a Rectangle collide with another rectangle. If so, returns true and false otherwise.
   * Both rectangles must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @return {boolean} true if rectangle collide with rectangle
  */

function testRectRect(rect1, rect2) {
  if (rectHasNoSize(rect1) || rectHasNoSize(rect2)) {
    return false;
  }

  return rect1.x <= rect2.x + rect2.width && rect2.x <= rect1.x + rect1.width && rect1.y <= rect2.y + rect2.height && rect2.y <= rect1.y + rect1.height;
}
/**
   * Test if a Rectangle contains a Point. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if rectangle contains point
  */

function testRectPoint(rect, point) {
  if (rectHasNoSize(rect)) {
    return false;
  }

  return point.x >= rect.x && point.x <= rect.x + rect.width && point.y >= rect.y && point.y <= rect.y + rect.height;
}
/**
   * Test if a Rectangle collider with a line. If so, returns true and false otherwise.
   * Rectangle must have a width and height greather then 0.
   * Line must have length greater then 0.
   * @private
   * @param {object} rect
   * @param {number} rect.x - x-coordinate
   * @param {number} rect.y - y-coordinate
   * @param {number} rect.width - width
   * @param {number} rect.height - height
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if rectangle collide with line
  */

function testRectLine(rect, line) {
  if (lineHasNoLength(line) || rectHasNoSize(rect)) {
    return false;
  }

  var _lineToPoints5 = lineToPoints(line),
      _lineToPoints6 = _slicedToArray(_lineToPoints5, 2),
      p1 = _lineToPoints6[0],
      p2 = _lineToPoints6[1];

  if (testRectPoint(rect, p1) || testRectPoint(rect, p2)) {
    return true;
  }

  var rectEdges = rectToPoints(rect);
  var num = rectEdges.length;

  for (var i = 0; i < num; i++) {
    var edge = pointsToLine([rectEdges[i], rectEdges[i !== 3 ? i + 1 : 0]]);

    if (testLineLine(edge, line)) {
      return true;
    }
  }

  return false;
}
/**
   * Test if a Line collider with another line. If so, returns true and false otherwise.
   * Both lines must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @return {boolean} true if line collide with line
  */

function testLineLine(line1, line2) {
  var _lineToPoints7 = lineToPoints(line1),
      _lineToPoints8 = _slicedToArray(_lineToPoints7, 2),
      p1 = _lineToPoints8[0],
      p2 = _lineToPoints8[1];

  var _lineToPoints9 = lineToPoints(line2),
      _lineToPoints10 = _slicedToArray(_lineToPoints9, 2),
      p3 = _lineToPoints10[0],
      p4 = _lineToPoints10[1];

  var dx1 = distanceX(p2, p1);
  var dy1 = distanceY(p2, p1);
  var dx2 = distanceX(p4, p3);
  var dy2 = distanceY(p4, p3);
  var dx3 = distanceX(p1, p3);
  var dy3 = distanceY(p1, p3);
  var ub = dy2 * dx1 - dx2 * dy1;
  var uat = dx2 * dy3 - dy2 * dx3;
  var ubt = dx1 * dy3 - dy1 * dx3;
  var t1;
  var t2;

  if (dx1 === 0 && dy1 === 0) {
    // Line segment has no length
    return false;
  }

  if (dx2 === 0 && dy2 === 0) {
    // Line segment has no length
    return false;
  }

  if (ub === 0) {
    if (uat === 0 && ubt === 0) {
      // COINCIDENT;
      if (dx1 === 0) {
        if (dy1 === 0) {
          // p1 = p2
          return p1.x === p2.x && p1.y === p2.y;
        }

        t1 = distanceY(p3, p1) / dy1;
        t2 = distanceY(p4, p1) / dy1;
      } else {
        t1 = (p3.x - p1.x) / dx1;
        t2 = (p4.x - p1.x) / dx1;
      }

      if (t1 < 0 && t2 < 0 || t1 > 1 && t2 > 1) {
        return false;
      }

      return true;
    }

    return false; // PARALLEL;
  }

  var ua = uat / ub;
  ub = ubt / ub;

  if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {
    return true;
  }

  return false;
}
/**
   * Test if a Line contains a Point. If so, returns true and false otherwise.
   * Line must have length greater then 0.
   * @private
   * @param {object} line
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {number} line.x1 - x-coordinate
   * @param {number} line.y1 - y-coordinate
   * @param {object} point
   * @param {number} point.x - x-coordinate
   * @param {number} point.y - y-coordinate
   * @return {boolean} true if line contains point
  */

function testLinePoint(line, point) {
  if (lineHasNoLength(line)) {
    return false;
  }

  var _lineToPoints11 = lineToPoints(line),
      _lineToPoints12 = _slicedToArray(_lineToPoints11, 2),
      p1 = _lineToPoints12[0],
      p2 = _lineToPoints12[1];

  return isPointOnLine(p1, p2, point);
}

var VARIABLE_RX = /^\$/;
var EXTEND = '@extend';

function throwCyclical(s) {
  throw new Error("Cyclical reference for \"".concat(s, "\""));
}

function picasso_esm_res(style, references, path) {
  if (typeof style === 'string') {
    var value = references[style];

    if (path.indexOf(style) !== -1) {
      throwCyclical(style);
    }

    if (VARIABLE_RX.test(value)) {
      path.push(style);
      return picasso_esm_res(value, references, path);
    }

    return value;
  }

  var computed = style;
  var refs = extend(true, {}, references, style);
  var s = {};

  if (style[EXTEND]) {
    var extendFrom = style[EXTEND];

    if (path.indexOf(extendFrom) !== -1) {
      throwCyclical(extendFrom);
    }

    var pext = path.slice();
    pext.push(extendFrom);
    computed = extend(true, {}, picasso_esm_res(refs[extendFrom], references, pext), style);
  }

  Object.keys(computed).forEach(function (key) {
    var p = path.slice();

    if (key === EXTEND || VARIABLE_RX.test(key)) {
      return;
    }

    s[key] = computed[key];
    var value = s[key];

    if (VARIABLE_RX.test(value) && value in refs) {
      if (path.indexOf(value) !== -1) {
        throwCyclical(value);
      }

      p.push(value);
      value = refs[value];

      if (picasso_esm_typeof(value) === 'object') {
        s[key] = picasso_esm_res(value, refs, p);
      } else if (VARIABLE_RX.test(value) && value in refs) {
        s[key] = picasso_esm_res(value, refs, p);
      } else {
        s[key] = value;
      }
    } else if (picasso_esm_typeof(value) === 'object') {
      s[key] = picasso_esm_res(value, refs, p);
    }
  });
  return s;
}
/**
 * Resolve style references
 * @private
 * @param {style-object} style
 * @param {style-object} references
 * @returns {object} The resolved style
 * @example
 * resolve({
 *   label: '$label--big'
 * }, {
 *   '$size--m': '12px',
 *   '$label--big': {
 *     fontFamily: 'Arial',
 *     fontSize: '$size--m'
 *   }
 * }); // { label: { fontFamily: 'Arial', fontSize: '12px' } }
 */


function picasso_esm_resolve(style, references) {
  return picasso_esm_res(style, references, []);
}

function themeFn() {
  var _style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var palettes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var pals = {};

  var setPalettes = function setPalettes(p) {
    p.forEach(function (palette) {
      var pal = Array.isArray(palette.colors[0]) ? palette.colors : [palette.colors];
      pals[palette.key] = {
        colors: pal,
        sizes: pal.map(function (colors) {
          return colors ? colors.length : 0;
        })
      };
    });
  };

  var getPalette = function getPalette(key, num) {
    var palette = pals[key];

    if (!palette) {
      return [];
    }

    var sizes = palette.sizes; // find the first color set containing at least 'num' colors

    for (var i = 0; i < sizes.length; i++) {
      if (num <= sizes[i]) {
        return palette.colors[i];
      }
    }

    return palette.colors[sizes.length - 1];
  };
  /**
   * Theme API
   * @private
   * @experimental
   */


  var theme = {
    /**
     * Get an array of colors
     * @param {string} name - Name of the color palette
     * @param {number} [num] - The minimum number of colors to get from the palette
     */
    palette: function palette(name, num) {
      return getPalette(name, num);
    },
    setPalettes: setPalettes,

    /**
     * Resolve style references
     * @param {style-object} s - Object containing
     */
    style: function style(s) {
      return picasso_esm_resolve(s, _style);
    }
  };
  setPalettes(palettes);
  return theme;
}

/**
 * @typedef {object} component-settings
 * @property {string} type - Component type (ex: axis, point, ...)
 * @property {function} [preferredSize] - Function returning the preferred size
 * @property {function} [created]
 * @property {function} [beforeMount]
 * @property {function} [mounted]
 * @property {function} [beforeUpdate]
 * @property {function} [updated]
 * @property {function} [beforeRender]
 * @property {function} [beforeDestroy]
 * @property {function} [destroyed]
 * @property {brush-setting} [brush] see [brushing](./brushing.md)
 * @property {object} [layout] Layout settings
 * @property {number} [layout.displayOrder = 0]
 * @property {number} [layout.prioOrder = 0]
 * @property {string | {width: string, height: string}} [layout.minimumLayoutMode] Refer to layout sizes defined by layoutModes in `strategy`
 * @property {string} [layout.dock] left, right, top or bottom
 * @property {boolean} [show = true] If the component should be rendered
 * @property {string} [scale] Named scale. Will be provided to the component if it ask for it.
 * @property {string} [formatter] Named formatter. Fallback to create formatter from scale. Will be provided to the component if it ask for it.
 */

function addComponentDelta(shape, containerBounds, componentBounds) {
  var dx = containerBounds.left - componentBounds.left;
  var dy = containerBounds.top - componentBounds.top;
  var type = getShapeType(shape);
  var deltaShape = extend(true, {}, shape);

  switch (type) {
    case 'circle':
      deltaShape.cx += dx;
      deltaShape.cy += dy;
      break;

    case 'polygon':
      for (var i = 0, num = deltaShape.vertices.length; i < num; i++) {
        var v = deltaShape.vertices[i];
        v.x += dx;
        v.y += dy;
      }

      break;

    case 'line':
      deltaShape.x1 += dx;
      deltaShape.y1 += dy;
      deltaShape.x2 += dx;
      deltaShape.y2 += dy;
      break;

    case 'point':
    case 'rect':
      deltaShape.x += dx;
      deltaShape.y += dy;
      break;

    default:
      break;
  }

  return deltaShape;
}

var moveToPosition = function moveToPosition(element, comp, index) {
  var el = comp.instance.renderer().element();

  if (isNaN(index) || !el || !element || !element.children) {
    return;
  }

  var nodes = element.children;
  var i = Math.max(0, index);
  var node = nodes[i];

  if (el === node) {
    return;
  }

  var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements().filter(Boolean);

  if (element.insertBefore && typeof node !== 'undefined') {
    element.insertBefore(el, node);

    if (additionalEl) {
      additionalEl.forEach(function (ae) {
        element.insertBefore(ae, el);
      });
    }
  } else {
    if (additionalEl) {
      additionalEl.forEach(function (ae) {
        element.appendChild(ae, el);
      });
    }

    element.appendChild(el);
  }
};

function orderComponents(element, visibleComponents, order) {
  var elToIdx = [];
  var numElements = 0;
  var ordered = order ? visibleComponents.slice().sort(function (a, b) {
    return order[visibleComponents.indexOf(a)] - order[visibleComponents.indexOf(b)];
  }) : visibleComponents;
  ordered.forEach(function (comp) {
    elToIdx.push(numElements); // assume each component has at least one element

    numElements++; // check additional elements

    var additionalEl = comp.instance.def.additionalElements && comp.instance.def.additionalElements();

    if (additionalEl) {
      numElements += additionalEl.length;
    }
  });
  ordered.forEach(function (comp, i) {
    return moveToPosition(element, comp, elToIdx[i]);
  });
}

function chartFn(definition, context) {
  /**
   * @typedef {object} chart-definition
   */
  var element = definition.element,
      _definition$data = definition.data,
      data = _definition$data === void 0 ? [] : _definition$data,
      _definition$settings = definition.settings,
      settings = _definition$settings === void 0 ? {} : _definition$settings,
      _definition$on = definition.on,
      on = _definition$on === void 0 ? {} : _definition$on;
  var registries = context.registries;
  var logger = context.logger;
  var theme = themeFn(context.style, context.palettes);
  var listeners = [];
  /**
   * @alias chart
   * @interface
   */

  var instance = extend({}, definition);
  var mediator$1 = mediator();
  var currentComponents = []; // Augmented components

  var visibleComponents = [];
  var currentScales = null; // Built scales

  var currentFormatters = null; // Built formatters

  var currentScrollApis = null; // Build scroll apis

  var currentInteractions = [];

  var dataset = function dataset() {};

  var dataCollection = function dataCollection() {};

  var brushes = {};
  var stopBrushing = false;

  var createComponent = function createComponent(compSettings, container) {
    if (!registries.component.has(compSettings.type)) {
      logger.warn("Unknown component: ".concat(compSettings.type));
      return false;
    }

    var componentDefinition = registries.component(compSettings.type);
    var compInstance = componentFactory(componentDefinition, {
      settings: compSettings,
      chart: instance,
      mediator: mediator$1,
      registries: registries,
      theme: theme,
      container: container
    });
    return {
      instance: compInstance,
      settings: extend(true, {}, compSettings),
      key: compSettings.key,
      hasKey: typeof compSettings.key !== 'undefined'
    };
  }; // Create a callback that calls lifecycle functions in the definition and config (if they exist).


  function createCallback(method) {
    var defaultMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    return function cb() {
      var inDefinition = typeof definition[method] === 'function';
      var returnValue;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (inDefinition) {
        var _definition$method;

        returnValue = (_definition$method = definition[method]).call.apply(_definition$method, [instance].concat(args));
      } else {
        returnValue = defaultMethod.call.apply(defaultMethod, [instance].concat(args));
      }

      return returnValue;
    };
  }

  var findComponent = function findComponent(componentInstance) {
    for (var i = 0; i < currentComponents.length; i++) {
      if (currentComponents[i].instance === componentInstance) {
        return currentComponents[i];
      }
    }

    return null;
  };

  var findComponentIndexByKey = function findComponentIndexByKey(key) {
    for (var i = 0; i < currentComponents.length; i++) {
      var currComp = currentComponents[i];

      if (currComp.hasKey && currComp.key === key) {
        return i;
      }
    }

    return -1;
  };

  function getElementRect(el) {
    if (typeof el.getBoundingClientRect === 'function') {
      var _el$getBoundingClient = el.getBoundingClientRect(),
          width = _el$getBoundingClient.width,
          height = _el$getBoundingClient.height;

      return {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
    }

    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var layout = function layout(components) {
    var vcomponents = components.map(function (c) {
      var dockConfig = c.instance.dockConfig();
      return {
        instance: c.instance,
        resize: c.instance.resize,
        preferredSize: dockConfig.computePreferredSize.bind(dockConfig),
        settings: c.settings,
        layoutComponents: function layoutComponents() {}
      };
    });
    var layoutSettings;

    if (settings.dockLayout) {
      logger.warn('Deprecation Warning: "dockLayout" property should be renamed to "strategy"');
      layoutSettings = settings.dockLayout;
    } else {
      layoutSettings = settings.strategy;
    }

    var dockLayout$1 = dockLayout(layoutSettings);
    var rect = getElementRect(element);

    var _dockLayout$layout = dockLayout$1.layout(rect, vcomponents),
        visible = _dockLayout$layout.visible,
        hidden = _dockLayout$layout.hidden,
        order = _dockLayout$layout.order;

    return {
      visible: visible.map(function (v) {
        return findComponent(v.instance);
      }),
      hidden: hidden.map(function (h) {
        return findComponent(h.instance);
      }),
      order: order
    };
  };

  var created = createCallback('created');
  var beforeMount = createCallback('beforeMount');
  var mounted = createCallback('mounted');
  var beforeUpdate = createCallback('beforeUpdate');
  var updated = createCallback('updated');
  var beforeRender = createCallback('beforeRender');
  var beforeDestroy = createCallback('beforeDestroy');
  var destroyed = createCallback('destroyed');

  var set = function set(_data, _settings) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        partialData = _ref.partialData;

    var _settings$formatters = _settings.formatters,
        formatters = _settings$formatters === void 0 ? {} : _settings$formatters,
        _settings$scales = _settings.scales,
        scales = _settings$scales === void 0 ? {} : _settings$scales,
        _settings$scroll = _settings.scroll,
        scroll = _settings$scroll === void 0 ? {} : _settings$scroll;
    dataset = datasets(_data, {
      logger: logger,
      types: registries.data
    });

    if (!partialData) {
      Object.keys(brushes).forEach(function (b) {
        return brushes[b].clear();
      });
    }

    if (_settings.palettes) {
      theme.setPalettes(_settings.palettes);
    }

    dataCollection = picasso_esm_create(_settings.collections, {
      dataset: dataset
    }, {
      logger: logger
    });
    var deps = {
      theme: theme,
      logger: logger
    };
    currentScales = collection$1(scales, {
      dataset: dataset,
      collection: dataCollection
    }, _objectSpread({}, deps, {
      scale: registries.scale
    }));
    currentFormatters = collection(formatters, {
      dataset: dataset,
      collection: dataCollection
    }, _objectSpread({}, deps, {
      formatter: registries.formatter
    }));
    currentScrollApis = builder(scroll, currentScrollApis);
  };

  var render = function render() {
    var _settings2 = settings,
        _settings2$components = _settings2.components,
        components = _settings2$components === void 0 ? [] : _settings2$components;
    beforeRender();
    set(data, settings);
    currentComponents = components.map(function (compSettings) {
      return createComponent(compSettings, element);
    }).filter(function (c) {
      return !!c;
    });

    var _layout = layout(currentComponents),
        visible = _layout.visible,
        hidden = _layout.hidden,
        order = _layout.order;

    visibleComponents = visible;
    hidden.forEach(function (comp) {
      comp.instance.hide();
      comp.visible = false;
    });
    visible.forEach(function (comp) {
      return comp.instance.beforeMount();
    });
    visible.forEach(function (comp) {
      return comp.instance.mount();
    });
    visible.forEach(function (comp) {
      return comp.instance.beforeRender();
    });
    visible.forEach(function (comp) {
      return comp.instance.render();
    });
    visible.forEach(function (comp) {
      return comp.instance.mounted();
    });
    visible.forEach(function (comp) {
      comp.visible = true;
    });
    orderComponents(element, visibleComponents, order);
  };

  function setInteractions() {
    var interactions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var current = {};
    var newKeys = interactions.filter(function (it) {
      return !!it.key;
    }).map(function (it) {
      return it.key;
    });
    currentInteractions.forEach(function (cit) {
      if (cit.key && newKeys.indexOf(cit.key) !== -1) {
        // keep old instance
        current[cit.key] = cit;
      } else {
        cit.destroy();
      }
    });
    currentInteractions = interactions.map(function (intSettings) {
      var intDefinition = intSettings.key && current[intSettings.key] ? current[intSettings.key] : registries.interaction(intSettings.type)(instance, mediator$1, element);
      intDefinition.set(intSettings);
      return intDefinition;
    });
  }

  var componentsFromPoint = function componentsFromPoint(p) {
    var br = element.getBoundingClientRect();
    var x = 'clientX' in p ? p.clientX : p.x;
    var y = 'clientY' in p ? p.clientY : p.y;
    var tp = {
      x: x - br.left,
      y: y - br.top
    };
    var ret = [];
    visibleComponents.forEach(function (c) {
      var r = c.instance.getRect(); // Do test on physical rect and use computed rect if available, otherwise fallback to computing a new rect for legacy support

      if (testRectPoint(r.computedPhysical ? r.computedPhysical : {
        x: r.margin.left + r.x * r.scaleRatio.x,
        y: r.margin.top + r.y * r.scaleRatio.y,
        width: r.width * r.scaleRatio.x,
        height: r.height * r.scaleRatio.y
      }, tp)) {
        ret.push(c);
      }
    });
    return ret;
  };

  var addDefaultEventListeners = function addDefaultEventListeners() {
    if (listeners.length || !element) {
      return;
    }

    Object.keys(on).forEach(function (key) {
      var listener = on[key].bind(instance);
      element.addEventListener(key, listener);
      listeners.push({
        key: key,
        listener: listener
      });
    });
    var eventInfo = {};

    var onTapDown = function onTapDown(e) {
      if (e.touches) {
        eventInfo.x = e.touches[0].clientX;
        eventInfo.y = e.touches[0].clientY;
        eventInfo.multiTouch = e.touches.length > 1;
      } else {
        eventInfo.x = e.clientX;
        eventInfo.y = e.clientY;
        eventInfo.multiTouch = false;
      }

      eventInfo.time = Date.now();
      eventInfo.comps = componentsFromPoint(eventInfo);
    };

    var onBrushTap = function onBrushTap(e) {
      var comps = eventInfo.comps || componentsFromPoint(e);

      if (comps.every(function (c) {
        return c.instance.def.disableTriggers;
      })) {
        return;
      }

      if (e.type === 'touchend') {
        e.preventDefault();
      }

      if (!isValidTapEvent(e, eventInfo)) {
        return;
      }

      for (var i = comps.length - 1; i >= 0; i--) {
        var comp = comps[i];
        comp.instance.onBrushTap(e);

        if (stopBrushing) {
          stopBrushing = false;
          break;
        }
      }
    };

    var onBrushOver = function onBrushOver(e) {
      var comps = componentsFromPoint(e);

      for (var i = comps.length - 1; i >= 0; i--) {
        var comp = comps[i];
        comp.instance.onBrushOver(e);

        if (stopBrushing) {
          stopBrushing = false;
          break;
        }
      }
    };

    var brushEventList = [];
    brushEventList.push({
      key: 'mousedown',
      listener: onTapDown
    });
    brushEventList.push({
      key: 'mouseup',
      listener: onBrushTap
    });

    if (detectTouchSupport(element)) {
      brushEventList.push({
        key: 'touchstart',
        listener: onTapDown
      });
      brushEventList.push({
        key: 'touchend',
        listener: onBrushTap
      });
    }

    brushEventList.push({
      key: 'mousemove',
      listener: onBrushOver
    });
    brushEventList.forEach(function (event) {
      element.addEventListener(event.key, event.listener);
      listeners.push(event);
    });
  };

  var removeDefaultEventListeners = function removeDefaultEventListeners() {
    listeners.forEach(function (_ref2) {
      var key = _ref2.key,
          listener = _ref2.listener;
      return element.removeEventListener(key, listener);
    });
    listeners.length = 0;
  }; // Browser only


  var mount = function mount() {
    element.innerHTML = '';
    render();
    addDefaultEventListeners();
    setInteractions(settings.interactions);
  };

  var unmount = function unmount() {
    removeDefaultEventListeners();
    setInteractions();
  };
  /**
   * Update the chart with new settings and / or data
   * @param {chart-definition} [chart] - Chart definition
   */


  instance.update = function () {
    var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var partialData = newProps.partialData,
        _newProps$excludeFrom = newProps.excludeFromUpdate,
        excludeFromUpdate = _newProps$excludeFrom === void 0 ? [] : _newProps$excludeFrom;
    var visibleOrder;

    if (newProps.data) {
      data = newProps.data;
    }

    if (newProps.settings) {
      settings = newProps.settings;
      setInteractions(newProps.settings.interactions);
    }

    beforeUpdate();
    set(data, settings, {
      partialData: partialData
    });
    var _settings3 = settings,
        formatters = _settings3.formatters,
        scales = _settings3.scales,
        _settings3$components = _settings3.components,
        components = _settings3$components === void 0 ? [] : _settings3$components;

    var _loop = function _loop(i) {
      var currComp = currentComponents[i]; // TODO warn when there is no key

      if (!components.some(function (c) {
        return currComp.hasKey && currComp.key === c.key;
      })) {
        // Component is removed
        currentComponents.splice(i, 1);
        currComp.instance.destroy();
      }
    };

    for (var i = currentComponents.length - 1; i >= 0; i--) {
      _loop(i);
    } // Let the "components" array determine order of components


    currentComponents = components.map(function (comp) {
      var idx = findComponentIndexByKey(comp.key); // Component should not be updated

      if (excludeFromUpdate.indexOf(comp.key) > -1) {
        return currentComponents[idx];
      }

      if (idx === -1) {
        // Component is added
        return createComponent(comp, element);
      } // Component is (potentially) updated


      currentComponents[idx].updateWith = {
        formatters: formatters,
        scales: scales,
        data: data,
        settings: comp
      };
      return currentComponents[idx];
    }).filter(function (c) {
      return !!c;
    });
    currentComponents.forEach(function (comp) {
      if (comp.updateWith) {
        comp.instance.set(comp.updateWith);
      }
    });
    currentComponents.forEach(function (comp) {
      if (comp.updateWith) {
        comp.instance.beforeUpdate();
      }
    });
    var toUpdate = [];
    var toRender = [];
    var toRenderOrUpdate;

    if (partialData) {
      currentComponents.forEach(function (comp) {
        if (comp.updateWith && comp.visible) {
          toUpdate.push(comp);
        }
      });
      toRenderOrUpdate = toUpdate;
    } else {
      var _layout2 = layout(currentComponents),
          visible = _layout2.visible,
          hidden = _layout2.hidden,
          order = _layout2.order; // Relayout


      visibleComponents = visible;
      toRenderOrUpdate = visible;
      visibleOrder = order;
      visible.forEach(function (comp) {
        if (comp.updateWith && comp.visible) {
          toUpdate.push(comp);
        } else {
          toRender.push(comp);
        }
      });
      hidden.forEach(function (comp) {
        comp.instance.hide();
        comp.visible = false;
        delete comp.updateWith;
      });
    }

    toRender.forEach(function (comp) {
      return comp.instance.beforeMount();
    });
    toRender.forEach(function (comp) {
      return comp.instance.mount();
    });
    toRenderOrUpdate.forEach(function (comp) {
      return comp.instance.beforeRender();
    });
    toRenderOrUpdate.forEach(function (comp) {
      if (comp.updateWith && comp.visible) {
        comp.instance.update();
      } else {
        comp.instance.render();
      }
    }); // Ensure that displayOrder is keept, only do so on re-layout update.
    // Which is only the case if partialData is false.

    if (!partialData) {
      orderComponents(element, visibleComponents, visibleOrder);
    }

    toRender.forEach(function (comp) {
      return comp.instance.mounted();
    });
    toUpdate.forEach(function (comp) {
      return comp.instance.updated();
    });
    visibleComponents.forEach(function (comp) {
      delete comp.updateWith;
      comp.visible = true;
    });
    updated();
  };
  /**
   * Destroy the chart instance.
   */


  instance.destroy = function () {
    beforeDestroy();
    currentComponents.forEach(function (comp) {
      return comp.instance.destroy();
    });
    currentComponents = [];
    unmount();
    delete instance.update;
    delete instance.destroy;
    destroyed();
  };
  /**
   * Get all shapes associated with the provided context
   * @param {string} context The brush context
   * @param {string} mode Property comparasion mode.
   * @param {Array<string>} props Which specific data properties to compare
   * @param {string} key Which component to get shapes from. Default gives shapes from all components.
   * @return {Array<object>} Array of objects containing shape and parent element
   */


  instance.getAffectedShapes = function (ctx) {
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'and';
    var props = arguments.length > 2 ? arguments[2] : undefined;
    var key = arguments.length > 3 ? arguments[3] : undefined;
    var shapes = [];
    currentComponents.filter(function (comp) {
      return key === undefined || key === null || comp.key === key;
    }).forEach(function (comp) {
      shapes.push.apply(shapes, _toConsumableArray$1(comp.instance.getBrushedShapes(ctx, mode, props)));
    });
    return shapes;
  };
  /**
   * Get all nodes matching the provided selector
   * @param {string} selector CSS selector [type, attribute, universal, class]
   * @returns {Array<SceneNode>} Array of objects containing matching nodes
   *
   * @example
   * chart.findShapes('Circle') // [<CircleNode>, <CircleNode>]
   * chart.findShapes('Circle[fill="red"][stroke!="black"]') // [CircleNode, CircleNode]
   * chart.findShapes('Container Rect') // [Rect, Rect]
   */


  instance.findShapes = function (selector) {
    var shapes = [];
    visibleComponents.forEach(function (c) {
      shapes.push.apply(shapes, _toConsumableArray$1(c.instance.findShapes(selector)));
    });
    return shapes;
  };
  /**
   * Get components overlapping a point.
   * @param {point} p - Point with x- and y-cooridnate. The coordinate is relative to the browser viewport.
   * @returns {Array<component-context>} Array of component contexts
   */


  instance.componentsFromPoint = function (p) {
    return componentsFromPoint(p).map(function (comp) {
      return comp.instance.ctx;
    });
  };
  /**
   * Get all nodes colliding with a geometrical shape (circle, line, rectangle, point, polygon).
   *
   * The input shape is identified based on the geometrical attributes in the following order: circle => line => rectangle => point => polygon.
   * Note that not all nodes on a scene have collision detection enabled.
   * @param {line|rect|point|circle} shape - A geometrical shape. Coordinates are relative to the top-left corner of the chart instance container.
   * @param {object} opts - Options
   * @param {object[]} [opts.components] - Array of components to include in the lookup. If no components are specified, all components will be included.
   * @param {string} [opts.components[].component.key] - Component key
   * @param {string} [opts.components[].component.propagation] - if set to `stop`, will start lookup on top visible shape and propagate downwards until a shape is found.
   * @param {string} [opts.propagation] - if set to `stop`, will start lookup on top visible component and propagate downwards until a component has at least a match.
   * @returns {Array<SceneNode>} Array of objects containing colliding nodes
   *
   * @example
   * chart.shapesAt(
   *  {
   *    x: 0,
   *    y: 0,
   *    width: 100,
   *    height: 100
   *  },
   *  {
   *    components: [
   *      { key: 'key1', propagation: 'stop' },
   *      { key: 'key2' }
   *    ],
   *    propagation: 'stop'
   *  }
   * );
   */


  instance.shapesAt = function (shape) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var result = [];
    var containerBounds = element.getBoundingClientRect();
    var comps = visibleComponents; // Assume that visibleComponents is ordererd according to displayOrder

    if (Array.isArray(opts.components) && opts.components.length > 0) {
      var compKeys = opts.components.map(function (c) {
        return c.key;
      });
      comps = visibleComponents.filter(function (c) {
        return compKeys.indexOf(c.key) !== -1;
      }).map(function (c) {
        return {
          instance: c.instance,
          opts: opts.components[compKeys.indexOf(c.key)]
        };
      });
    }

    for (var i = comps.length - 1; i >= 0; i--) {
      var c = comps[i];
      var componentBounds = c.instance.renderer().element().getBoundingClientRect();
      var deltaShape = addComponentDelta(shape, containerBounds, componentBounds);
      var shapes = c.instance.shapesAt(deltaShape, c.opts);
      var stopPropagation = shapes.length > 0 && opts.propagation === 'stop';
      result.push.apply(result, _toConsumableArray$1(shapes));

      if (result.length > 0 && stopPropagation) {
        return result;
      }
    }

    return result;
  };
  /**
   * Brush data by providing a collection of data bound shapes.
   * @param {SceneNode[]} shapes - An array of data bound shapes.
   * @param {object} config - Options
   * @param {Array<object>} opts.components - Array of components to include in the lookup.
   * @param {string} [opts.components.component.key] - Component key
   * @param {Array<string>} [opts.components.component.contexts] - Name of the brushing contexts to affect
   * @param {Array<string>} [opts.components.component.data] - The mapped data properties to add to the brush
   * @param {string} [opts.components.component.action] - Type of action to respond with
   *
   * @example
   * const shapes = chartInstance.shapesAt(...);
   * const config = {
   *  components:[
   *    {
   *      key: 'key1',
   *      contexts: ['myContext'],
   *      data: [''],
   *      action: 'add'
   *    }
   *  ]
   * };
   * chartInstance.brushFromShapes(shapes, config);
   */


  instance.brushFromShapes = function (shapes) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      components: []
    };

    var _loop2 = function _loop2(i) {
      var iKey = config.components[i].key;
      visibleComponents.filter(function (c) {
        return iKey === c.key;
      }).forEach(function (c) {
        var compShapes = shapes.filter(function (shape) {
          return shape.key === c.key;
        });
        c.instance.brushFromShapes(compShapes, config.components[i]);
      });
    };

    for (var i = 0; i < config.components.length; i++) {
      _loop2(i);
    }
  };
  /**
   * @param {string} name - Name of scroll api
   * @returns {scroll}
   */


  instance.scroll = function scroll() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
    return getOrCreateScrollApi(name, currentScrollApis);
  };
  /**
   * Get
   * @param {string} key - Get the dataset identified by `key`
   * @returns {dataset}
   */


  instance.dataset = function (key) {
    return dataset(key);
  };

  instance.dataCollection = function (key) {
    return dataCollection(key);
  };
  /**
   * Get all registered scales
   * @returns {Object<string,scale>}
   */


  instance.scales = function scales() {
    return currentScales.all();
  };
  /**
   * Get all registered formatters
   * @returns {Object<string,formatter>}
   */


  instance.formatters = function formatters() {
    return currentFormatters.all();
  };
  /**
   * Get or create brush context for this chart
   * @param {string} name - Name of the brush context. If no match is found, a new brush context is created and returned.
   * @returns {brush}
   */


  instance.brush = function brushFn() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

    if (!brushes[name]) {
      brushes[name] = brush();
    }

    return brushes[name];
  };
  /**
   * Get or create a scale for this chart
   * @param {string|object} v - Scale reference or scale options
   * @returns {scale}
   * @example
   * instance.scale('nameOfMyScale'); // Fetch an existing scale by name
   * instance.scale({ scale: 'nameOfMyScale' }); // Fetch an existing scale by name
   * instance.scale({ source: '0/1', type: 'linear' }); // Create a new scale
   */


  instance.scale = function scale(v) {
    return currentScales.get(v);
  };
  /**
   * Get or create a formatter for this chart
   * @param {string|object} v - Formatter reference or formatter options
   * @returns {formatter}
   * @example
   * instance.formatter('nameOfMyFormatter'); // Fetch an existing formatter by name
   * instance.formatter({ formatter: 'nameOfMyFormatter' }); // Fetch an existing formatter by name
   * instance.formatter({ type: 'q' }); // Fetch an existing formatter by type
   * instance.formatter({
   *  formatter: 'd3',
   *  type: 'number',
   *  format: '1.0.%'
   * }); // Create a new formatter
   */


  instance.formatter = function formatter(v) {
    return currentFormatters.get(v);
  };
  /**
   * @param {boolean} [val] - Toggle brushing on or off. If value is omitted, a toggle action is applied to the current state.
   */


  instance.toggleBrushing = function toggleBrushing(val) {
    if (typeof val !== 'undefined') {
      stopBrushing = val;
    } else {
      stopBrushing = !stopBrushing;
    }
  };
  /**
   * Get a component context
   * @param {string} key - Component key
   * @returns {component-context} Component context
   */


  instance.component = function (key) {
    var idx = findComponentIndexByKey(key);

    if (idx !== -1) {
      return currentComponents[idx].instance.ctx;
    }

    return undefined;
  };

  instance.logger = function () {
    return logger;
  };

  instance.theme = function () {
    return theme;
  };
  /**
   * Get the all interactions instances
   * @name chart.interactions
   * @type {object}
   * @example
   * chart.interactions.instances; // Array of all interaction instances
   * chart.interactions.on(); // Toggle on all interactions instances
   * chart.interactions.off(); // Toggle off all interactions instances
   */


  Object.defineProperty(instance, 'interactions', {
    get: function get() {
      return (
        /** @lends chart.interactions */
        {
          /** @type Array<interaction> */
          instances: currentInteractions,

          /** Enable all interaction instances */
          on: function on() {
            addDefaultEventListeners();
            currentInteractions.forEach(function (i) {
              return i.on();
            });
          },

          /** Disable all interaction instances */
          off: function off() {
            removeDefaultEventListeners();
            currentInteractions.forEach(function (i) {
              return i.off();
            });
          }
        }
      );
    }
  });
  created();

  if (element) {
    beforeMount();
    mount(element);
    mounted(element);
    instance.element = element;
  }

  return instance;
}

var rendererRegistry = function rendererRegistry(reg) {
  var f = registryFactory(reg);

  f.prio = function (p) {
    return p ? f.default(p[0]) : [f.default()];
  };

  f.types = function () {
    return f.getKeys();
  };

  return f;
};

var componentRegistry = registryFactory();

function findField(query, _ref) {
  var cache = _ref.cache;

  if (typeof query === 'number') {
    return cache.fields[query];
  } // Find by key first


  for (var i = 0; i < cache.fields.length; i++) {
    if (cache.fields[i].key() === query) {
      return cache.fields[i];
    }
  } // find by title


  for (var _i = 0; _i < cache.fields.length; _i++) {
    if (cache.fields[_i].title() === query) {
      return cache.fields[_i];
    }
  }

  return null;
}
var filters = {
  numeric: function numeric(values) {
    return values.filter(function (v) {
      return typeof v === 'number' && !isNaN(v);
    });
  }
};
var unfilteredReducers = {
  sum: function sum(values) {
    return values.reduce(function (a, b) {
      return a + b;
    }, 0);
  }
}; // function isPrimitive(x) {
//   const type = typeof x;
//   return (type !== 'object' && type !== 'function');
// }

/**
 * [reducers description]
 * @type {Object}
 * @private
 */

var reducers = {
  first: function first(values) {
    return values[0];
  },
  last: function last(values) {
    return values[values.length - 1];
  },
  min: function min(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : Math.min.apply(null, filtered);
  },
  max: function max(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : Math.max.apply(null, filtered);
  },
  sum: function sum(values) {
    var filtered = filters.numeric(values);
    return !filtered.length ? NaN : filtered.reduce(function (a, b) {
      return a + b;
    }, 0);
  },
  avg: function avg(values) {
    var filtered = filters.numeric(values);
    var len = filtered.length;
    return !len ? NaN : unfilteredReducers.sum(filtered) / len;
  }
};

function normalizeProperties(cfg, dataset, dataProperties, main) {
  // console.log('======', cfg, main, dataset);
  var props = {};
  var mainField = main.field || (typeof cfg.field !== 'undefined' ? dataset.field(cfg.field) : null);
  Object.keys(dataProperties).forEach(function (key) {
    var pConfig = dataProperties[key];
    var prop = props[key] = {};

    if (['number', 'string', 'boolean'].indexOf(picasso_esm_typeof(pConfig)) !== -1) {
      prop.type = 'primitive';
      prop.value = pConfig;
    } else if (typeof pConfig === 'function') {
      prop.type = 'function';
      prop.value = pConfig;
      prop.label = pConfig;
      prop.field = mainField;
    } else if (picasso_esm_typeof(pConfig) === 'object') {
      if (pConfig.fields) {
        prop.fields = pConfig.fields.map(function (ff) {
          return normalizeProperties(cfg, dataset, {
            main: ff
          }, main).main;
        });
      } else if (typeof pConfig.field !== 'undefined') {
        prop.type = 'field';
        prop.field = dataset.field(pConfig.field);
        prop.value = prop.field.value;
        prop.label = prop.field.label;
      } else if (mainField) {
        prop.value = mainField.value;
        prop.label = mainField.label;
        prop.field = mainField;
      }

      if (typeof pConfig.filter === 'function') {
        prop.filter = pConfig.filter;
      }

      if (typeof pConfig.value !== 'undefined') {
        prop.value = pConfig.value;
      }

      if (typeof pConfig.label !== 'undefined') {
        prop.label = pConfig.label;
      }

      if (typeof pConfig.reduce === 'function') {
        prop.reduce = pConfig.reduce;
      } else if (pConfig.reduce) {
        prop.reduce = reducers[pConfig.reduce];
      } else if (prop.field && prop.field.reduce) {
        prop.reduce = typeof prop.field.reduce === 'string' ? reducers[prop.field.reduce] : prop.field.reduce;
      }

      if (typeof pConfig.reduceLabel === 'function') {
        prop.reduceLabel = pConfig.reduceLabel;
      } else if (pConfig.reduceLabel) {
        prop.reduceLabel = reducers[pConfig.reduceLabel];
      } else if (prop.field && prop.field.reduceLabel) {
        prop.reduceLabel = typeof prop.field.reduceLabel === 'string' ? reducers[prop.field.reduceLabel] : prop.field.reduceLabel;
      }
    }
  });
  return props;
}
/*
example of configuration input
cfg = {
  field: 'State', // the 'top level' values are extracted from field state
  value: d => d.qText, // the value of the output
  props: { // additional data properties ammended to each item
    a: 3, // constant value
    b: d => d.qElemNumber, // function will receive the original field value
    c: {
      field: 'Country', // reference to another field
      value: d => d.qText // extract the qText value from the referenced field
    },
    d: {
      value: d => d.qRow //  extract qRow from field 'State'
    }
  }
}

// output
[{
  value: 'CA', source: { field: 'State' },
  a: { value: 3 },
  b: { value: 26, source: 'State' },
  c: { value: 'USA', source: 'Country' },
  d: { value: 131, source: 'State' }
},
...]
*/


function getPropsInfo(cfg, dataset) {
  // console.log('222', cfg);
  var _normalizeProperties = normalizeProperties(cfg, dataset, {
    main: {
      value: cfg.value,
      label: cfg.label,
      reduce: cfg.reduce,
      filter: cfg.filter
    }
  }, {}),
      main = _normalizeProperties.main;

  var props = normalizeProperties(cfg, dataset, cfg.props || {}, main);
  return {
    props: props,
    main: main
  };
}

function collectItems(items, cfg, formatter, prop) {
  var values = Array(items.length);
  var labels = Array(items.length);
  var it;

  for (var i = 0; i < items.length; i++) {
    it = prop ? items[i][prop] : items[i];
    values[i] = it.value;
    labels[i] = it.label;
  }

  var reduce = cfg.reduce;
  var reduceLabel = cfg.reduceLabel;
  var v = reduce ? reduce(values) : values;
  var b = reduceLabel ? reduceLabel(labels, v) : formatter ? formatter(v) : String(v); // eslint-disable-line no-nested-ternary
  // // ret[prop].label = String(propsFormatters[prop](ret[prop].value));

  var ret = {
    value: v,
    label: b
  };

  if (prop && items[0][prop].source) {
    ret.source = items[0][prop].source;
    return ret;
  }

  if (!prop && items[0].source) {
    ret.source = items[0].source;
    return ret;
  }

  return ret;
} // collect items that have been grouped and reduce per group and property


function collect(trackedItems, _ref2) {
  var main = _ref2.main,
      propsArr = _ref2.propsArr,
      props = _ref2.props;
  var dataItems = [];
  var mainFormatter = main.field.formatter(); // || (v => v);

  var propsFormatters = {};
  propsArr.forEach(function (prop) {
    propsFormatters[prop] = props[prop].field ? props[prop].field.formatter() : function (v) {
      return v;
    };
  });
  dataItems.push.apply(dataItems, _toConsumableArray$1(trackedItems.map(function (t) {
    var ret = collectItems(t.items, main, mainFormatter);
    propsArr.forEach(function (prop) {
      ret[prop] = collectItems(t.items, props[prop], propsFormatters[prop], prop);
    });
    return ret;
  })));
  return dataItems;
}
function track(_ref3) {
  var cfg = _ref3.cfg,
      itemData = _ref3.itemData,
      obj = _ref3.obj,
      target = _ref3.target,
      tracker = _ref3.tracker,
      trackType = _ref3.trackType;
  var trackId = trackType === 'function' ? cfg.trackBy(itemData) : itemData[cfg.trackBy];
  var trackedItem = tracker[trackId];

  if (!trackedItem) {
    trackedItem = tracker[trackId] = {
      items: [],
      id: trackId
    };
    target.push(trackedItem);
  }

  trackedItem.items.push(obj);
}

function datumExtract(propCfg, cell, _ref) {
  var key = _ref.key;
  var datum = {
    value: typeof propCfg.value === 'function' ? propCfg.value(cell) : typeof propCfg.value !== 'undefined' ? propCfg.value : cell // eslint-disable-line no-nested-ternary

  };
  datum.label = typeof propCfg.label === 'function' ? propCfg.label(cell) : typeof propCfg.label !== 'undefined' ? String(propCfg.label) : String(datum.value); // eslint-disable-line no-nested-ternary

  if (propCfg.field) {
    datum.source = {
      key: key,
      field: propCfg.field.key()
    };
  }

  return datum;
}

function extract$1(config, dataset) {
  var cfgs = Array.isArray(config) ? config : [config];
  var dataItems = [];
  cfgs.forEach(function (cfg) {
    if (typeof cfg.field !== 'undefined') {
      (function () {
        var f = dataset.field(cfg.field);
        var sourceKey = dataset.key();

        if (!f) {
          throw Error("Field '".concat(cfg.field, "' not found"));
        }

        var _getPropsInfo = getPropsInfo(cfg, dataset),
            props = _getPropsInfo.props,
            main = _getPropsInfo.main;

        var propsArr = Object.keys(props);
        var track$1 = !!cfg.trackBy;

        var trackType = picasso_esm_typeof(cfg.trackBy);

        var tracker = {};
        var trackedItems = [];
        var items = f.items();
        var mapped = [];

        var _loop = function _loop(idx) {
          var mainCell = items[idx];
          var exclude = main.filter && !main.filter(mainCell);

          if (exclude) {
            return "continue";
          }

          var ret = datumExtract(main, mainCell, {
            key: sourceKey
          }); // loop through all props that need to be mapped and
          // assign 'value' and 'source' to each property

          propsArr.forEach(function (prop) {
            var p = props[prop];
            var propCell = p.field ? p.field.items()[idx] : mainCell;
            ret[prop] = datumExtract(p, propCell, {
              key: sourceKey
            });
          }); // collect items based on the trackBy value
          // items with the same trackBy value are placed in an array and reduced later

          if (track$1) {
            track({
              cfg: cfg,
              itemData: mainCell,
              obj: ret,
              target: trackedItems,
              tracker: tracker,
              trackType: trackType
            });
          }

          mapped.push(ret);
        };

        for (var idx = 0; idx < items.length; idx++) {
          var _ret = _loop(idx);

          if (_ret === "continue") continue;
        } // reduce if items have been grouped


        if (track$1) {
          dataItems.push.apply(dataItems, _toConsumableArray$1(collect(trackedItems, {
            main: main,
            propsArr: propsArr,
            props: props
          })));
        } else {
          dataItems.push.apply(dataItems, mapped);
        }
      })();
    }
  });
  return dataItems;
}

var filters$1 = {
  numeric: function numeric(values) {
    return values.filter(function (v) {
      return typeof v === 'number' && !isNaN(v);
    });
  }
};

function createFields(_ref) {
  var source = _ref.source,
      data = _ref.data,
      cache = _ref.cache,
      config = _ref.config;
  var headers;
  var content = data;
  var parse = config && config.parse;

  if (Array.isArray(data[0])) {
    // assume 2d matrix of data
    if (parse && parse.headers === false) {
      headers = data[0].map(function (v, i) {
        return i;
      });
    } else {
      headers = data[0];
      content = data.slice(1);
    }
  } else {
    headers = Object.keys(data[0]);
  }

  var rowFn = !!parse && typeof parse.row === 'function' && parse.row;
  var flds = headers;

  if (parse && typeof parse.fields === 'function') {
    flds = parse.fields(flds.slice());
  } else {
    flds = headers.map(function (h) {
      return {
        key: h,
        title: h
      };
    });
  }

  var fieldValues;

  if (Array.isArray(data[0])) {
    fieldValues = flds.map(function () {
      return [];
    });
  } else {
    fieldValues = {};
    flds.forEach(function (f) {
      fieldValues[f.key] = [];
    });
  }

  for (var r = 0; r < content.length; r++) {
    var row = rowFn ? rowFn(content[r], r, flds) : content[r];

    if (!row) {
      continue;
    }

    if (Array.isArray(row)) {
      for (var c = 0; c < flds.length; c++) {
        fieldValues[c].push(row[c]);
      }
    } else {
      for (var _c = 0; _c < flds.length; _c++) {
        fieldValues[flds[_c].key].push(row[flds[_c].key]);
      }
    }
  }

  var fv = Array.isArray(fieldValues) ? function (i) {
    return fieldValues[i];
  } : function (i) {
    return fieldValues[flds[i].key];
  };

  for (var _c2 = 0; _c2 < flds.length; _c2++) {
    var values = fv(_c2);
    var numericValues = filters$1.numeric(values);
    var isMeasure = numericValues.length > 0;
    var type = isMeasure ? 'measure' : 'dimension';
    var min = isMeasure ? Math.min.apply(Math, _toConsumableArray$1(numericValues)) : NaN;
    var max = isMeasure ? Math.max.apply(Math, _toConsumableArray$1(numericValues)) : NaN;
    cache.fields.push(picasso_esm_field(extend({
      source: source,
      key: _c2,
      title: flds[_c2].title,
      values: values,
      min: min,
      max: max,
      type: type
    }, flds[_c2]), {
      value: flds[_c2].value,
      label: flds[_c2].label
    }));
  }
}

var dsv = function dsv(_ref2) {
  var data = _ref2.data,
      config = _ref2.config;
  var rows = data.split('\n');
  var row0 = rows[0];
  var row1 = rows[1];
  var delimiter = ',';

  if (config && config.parse && config.parse.delimiter) {
    delimiter = config.parse.delimiter;
  } else if (row0) {
    // guess delimiter
    var guesses = [/,/, /\t/, /;/];

    for (var i = 0; i < guesses.length; i++) {
      var d = guesses[i];

      if (row0 && row1) {
        if (d.test(row0) && d.test(row1) && row0.split(d).length === row1.split(d).length) {
          delimiter = d;
          break;
        }
      } else if (d.test(row0)) {
        delimiter = d;
      }
    }
  }

  return rows.map(function (row) {
    return row.split(delimiter);
  });
};

var parseData = function parseData(_ref3) {
  var key = _ref3.key,
      data = _ref3.data,
      cache = _ref3.cache,
      config = _ref3.config;

  if (!data) {
    return;
  }

  var dd = data;

  if (typeof dd === 'string') {
    // assume dsv
    dd = dsv({
      data: data,
      config: config
    });
  }

  if (!Array.isArray(dd)) {
    return; // warn?
  }

  createFields({
    data: dd,
    cache: cache,
    source: key,
    config: config
  });
};
/**
 * Create a new dataset with default settings
 * @private
 * @return {dataset}
 */


function ds() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _key = _ref4.key,
      data = _ref4.data,
      config = _ref4.config;

  var cache = {
    fields: []
  };
  /**
   * @alias dataset
   * @interface
   */

  var dataset = {
    /**
     * Get the key identifying this dataset
     * @returns {string}
     */
    key: function key() {
      return _key;
    },

    /**
     * Get the raw data
     * @returns {any}
     */
    raw: function raw() {
      return data;
    },

    /**
     * Find a field within this dataset
     * @param {string} query - The field to find
     * @returns {field}
     */
    field: function field(query) {
      return findField(query, {
        cache: cache,
        matrix: data
      });
    },

    /**
     * Get all fields within this dataset
     * @returns {Array<field>}
     */
    fields: function fields() {
      return cache.fields.slice();
    },

    /**
     * Extract data items from this dataset
     * @param {data-extract-config} config
     * @returns {Array<datum-extract>}
     */
    extract: function extract(cfg) {
      return extract$1(cfg, dataset, cache);
    },

    /**
     * @returns {null}
     */
    hierarchy: function hierarchy() {
      return null;
    }
  };
  parseData({
    key: _key,
    data: data,
    config: config,
    cache: cache
  });
  return dataset;
}

ds.util = {
  normalizeConfig: getPropsInfo,
  collect: collect,
  track: track
};
/**
 * @typedef {object} data-extract-config
 * @property {string} field - The field to extract data from
 * @property {data-extract-config~valueFn} [value] - The field value accessor
 * @property {data-extract-config~labelFn} [label] - The field label accessor
 * @property {data-extract-config~trackByFn} [trackBy] - Track by value accessor
 * @property {data-extract-config~reduceFn} [reduce] - Reducer function
 * @property {data-extract-config~reduceLabelFn} [reduceLabel] - Label reducer function
 * @property {data-extract-config~filterFn} [filter] - Filter function
 * @property {object} [props] - Additional properties to add to the extracted item
 */

/**
 * @callback data-extract-config~valueFn
 * @param {any} cell The field cell
 * @returns {any}
 */

/**
 * @callback data-extract-config~labelFn
 * @param {any} cell The field cell
 * @returns {string}
 */

/**
 * @callback data-extract-config~filterFn
 * @param {any} cell The field cell
 * @returns {boolean}
 */

/**
 * @callback data-extract-config~trackByFn
 * @param {any} cell The field cell
 * @returns {any}
 */

/**
 * @callback data-extract-config~reduceFn
 * @param {any[]} values The collected values to reduce
 * @returns {any}
 */

/**
 * @callback data-extract-config~reduceLabelFn
 * @param {any[]} labels The collected labels to reduce
 * @param {any} value Reduced value
 * @returns {string}
 */

/**
 * @typedef {object} datum-extract
 * @property {any} value - The extracted value
 * @property {string} label - The extracted value as a string
 * @property {object} source - The data source of the extracted data
 * @property {string} source.key - The data-source key
 * @property {string} source.field - The source field
 */

var dataRegistry = registryFactory();
dataRegistry.default('matrix');
dataRegistry('matrix', ds);
dataRegistry('default', ds); // deprecated

/**
 * Manages event handlers for native events
 * @private
 */
function picasso_esm_native(chart, mediator, element) {
  var instance = {
    chart: chart,
    mediator: mediator,
    element: element
  };
  var nativeEvents = [];
  var settings;
  var itKey;
  var isOn = true;
  /**
   * Set default settings
   * @private
   */

  function setDefaultSettings(newSettings) {
    itKey = newSettings.key;
    settings = newSettings;
    settings.events = settings.events || [];

    if (settings.enable === undefined) {
      settings.enable = true;
    }
  }
  /**
   * Add native events based on settings
   * @private
   */


  function addEvents() {
    if (typeof settings.enable === 'function') {
      settings.enable = settings.enable.bind(instance)();
    }

    if (!settings.enable) {
      return; // interaction is disabled
    }

    Object.keys(settings.events).forEach(function (key) {
      var listener = settings.events[key].bind(instance);
      element.addEventListener(key, listener);
      nativeEvents.push({
        key: key,
        listener: listener
      });
    });
  }
  /**
   * Removes all added native events
   * @private
   */


  function removeAddedEvents() {
    // remove added native events
    nativeEvents.forEach(function (_ref) {
      var key = _ref.key,
          listener = _ref.listener;
      element.removeEventListener(key, listener);
    });
    nativeEvents = [];
  }

  return {
    /**
     * Getter for the key.
     * @private
     */
    get key() {
      return itKey;
    },

    /**
     * Updates this with new settings
     * @private
     * @param {object} newSettings
     * @param {string} [newSettings.type] - The interaction type. Is 'native' for this component
     * @param {boolean|function} [newSettings.enable=true] - Should the interactions defined here be enabled or not.
     * This is only run when adding event handlers. In effect at startup, update or during on/off.
     * It does not run during every event loop.
     * @param {array} [newSettings.gestures] - The keys in this object is the names of native events
     * that should be added to the chart element and they should all point to function which
     * will be the corresponding event handler.
     */
    set: function set(newSettings) {
      setDefaultSettings(newSettings);
      removeAddedEvents();

      if (isOn) {
        addEvents();
      }
    },

    /**
     * Turns off interactions
     * @private
     */
    off: function off() {
      isOn = false;
      removeAddedEvents();
    },

    /**
     * Turns off interactions
     * @private
     */
    on: function on() {
      isOn = true;

      if (nativeEvents.length === 0) {
        addEvents();
      }
    },

    /**
     * Destroys and unbinds all event handlers
     * @private
     */
    destroy: function destroy() {
      removeAddedEvents();
      instance = null;
      settings = null;
    }
  };
}

var reg$2 = registryFactory();
reg$2('native', picasso_esm_native);

/**
 * Short-hand for max(min())
 *
 * @param {number} min Minimum allowed value
 * @param {number} max Maximum allowed value
 * @param {number} value The actual value to cap
 * @ignore
 */
function cap(min, max, value) {
  return Math.max(min, Math.min(max, value));
}
/**
 * Resolve a diff, i.e. resolveDiff(0.2, 0.6, 1, 100) = 20
 *
 * @param {object} params parameters
 * @param {number} params.start Normalized start value
 * @param {number} params.end Normalized end value
 * @param {number} params.minPx The minimum number of pixels
 * @param {number} params.maxPx Maximum number of pixels, i.e. the width or height
 * @ignore
 */

function resolveDiff(_ref) {
  var start = _ref.start,
      end = _ref.end,
      _ref$minPx = _ref.minPx,
      minPx = _ref$minPx === void 0 ? 0.1 : _ref$minPx,
      _ref$maxPx = _ref.maxPx,
      maxPx = _ref$maxPx === void 0 ? 1 : _ref$maxPx;
  var high = Math.max(start, end);
  var low = Math.min(start, end);
  var highModified = cap(-0.1, 1.2, high);
  var lowModified = cap(-0.1, 1.2, low);
  var wantedDiff = highModified * maxPx - lowModified * maxPx;
  var actualDiff = Math.max(minPx, wantedDiff);
  var startModifier = (actualDiff - wantedDiff) / 2;
  var actualLow = lowModified * maxPx - startModifier;
  return {
    actualDiff: actualDiff,
    startModifier: startModifier,
    actualLow: actualLow
  };
}

/**
 * Out of bounds shape
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.value 0 or 1 depending on where to render the oob shape
 * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
 * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY Wether or not to flip X and Y coordinates together with Width and Height
 * @param {function} params.symbol Symbol library function from component
 * @ignore
 */

function oob(_ref) {
  var _extend;

  var item = _ref.item,
      value = _ref.value,
      boxCenter = _ref.boxCenter,
      rendWidth = _ref.rendWidth,
      rendHeight = _ref.rendHeight,
      flipXY = _ref.flipXY,
      symbol = _ref.symbol;
  var x = 'x';
  var y = 'y';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;
  var startAngle = value < 0.5 ? 90 : -90;

  if (flipXY) {
    x = 'y';
    y = 'x';
    calcwidth = rendHeight;
    calcheight = rendWidth;
    startAngle = value < 0.5 ? 180 : 0;
  }

  return symbol(extend({}, item.oob, (_extend = {}, _defineProperty(_extend, x, boxCenter * calcwidth), _defineProperty(_extend, y, Math.max(item.oob.size / 2, Math.min(value * calcheight, calcheight - item.oob.size / 2))), _defineProperty(_extend, "startAngle", startAngle), _extend)));
}
/**
 * Box shape calculation function
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.boxWidth Un-calculated box width in relative/normalized format
 * @param {number} params.boxPadding Un-calculated box padding in relative/normalized format
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function picasso_esm_box(_ref2) {
  var _extend2;

  var item = _ref2.item,
      boxWidth = _ref2.boxWidth,
      boxPadding = _ref2.boxPadding,
      rendWidth = _ref2.rendWidth,
      rendHeight = _ref2.rendHeight,
      flipXY = _ref2.flipXY;
  var x = 'x';
  var y = 'y';
  var width = 'width';
  var height = 'height';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x = 'y';
    y = 'x';
    width = 'height';
    height = 'width';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  var _resolveDiff = resolveDiff({
    start: item.start,
    end: item.end,
    minPx: item.box.minHeightPx,
    maxPx: calcheight
  }),
      actualDiff = _resolveDiff.actualDiff,
      actualLow = _resolveDiff.actualLow;

  return extend({}, item.box, (_extend2 = {
    type: 'rect'
  }, _defineProperty(_extend2, x, (boxPadding + item.major) * calcwidth), _defineProperty(_extend2, y, actualLow), _defineProperty(_extend2, height, actualDiff), _defineProperty(_extend2, width, boxWidth * calcwidth), _defineProperty(_extend2, "data", item.data || {}), _defineProperty(_extend2, "collider", {
    type: null
  }), _extend2));
}
/**
 * A vertical line shape (for start - min, end - max values)
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {number} params.from Normalized from value
 * @param {number} params.to Normalized to value
 * @param {number} params.boxCenter Center coordinate for the box
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function verticalLine(_ref3) {
  var _extend3;

  var item = _ref3.item,
      from = _ref3.from,
      to = _ref3.to,
      boxCenter = _ref3.boxCenter,
      rendWidth = _ref3.rendWidth,
      rendHeight = _ref3.rendHeight,
      flipXY = _ref3.flipXY;
  var x1 = 'x1';
  var y1 = 'y1';
  var x2 = 'x2';
  var y2 = 'y2';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x1 = 'y1';
    y1 = 'x1';
    x2 = 'y2';
    y2 = 'x2';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  return extend({}, item.line, (_extend3 = {
    type: 'line'
  }, _defineProperty(_extend3, y2, Math.floor(from * calcheight)), _defineProperty(_extend3, x1, boxCenter * calcwidth), _defineProperty(_extend3, y1, Math.floor(to * calcheight)), _defineProperty(_extend3, x2, boxCenter * calcwidth), _defineProperty(_extend3, "data", item.data || {}), _defineProperty(_extend3, "collider", {
    type: null
  }), _extend3));
}
/**
 * A horizontal line shape (for median and whiskers)
 * @param {object} params parameters
 * @param {object} params.item Resolved styling item from box component with item.major
 * @param {string} params.key Which key to use as style base in the item object
 * @param {number} params.position At which "height" (X) to position the horizontal line
 * @param {number} params.width Width of the horizontal line (i.e. box width or a multiple of it)
 * @param {number} params.boxCenter Center coordinate for the box
 * @param {number} params.rendWidth The pixel width of the area to render upon
 * @param {number} params.rendHeight The pixel height of the area to render upon
 * @param {boolean} params.flipXY wether or not to flip X and Y coordinates together with Width and Height
 * @ignore
 */

function horizontalLine(_ref4) {
  var _extend4;

  var item = _ref4.item,
      key = _ref4.key,
      position = _ref4.position,
      width = _ref4.width,
      boxCenter = _ref4.boxCenter,
      rendWidth = _ref4.rendWidth,
      rendHeight = _ref4.rendHeight,
      flipXY = _ref4.flipXY;
  var x1 = 'x1';
  var y1 = 'y1';
  var x2 = 'x2';
  var y2 = 'y2';
  var calcwidth = rendWidth;
  var calcheight = rendHeight;

  if (flipXY) {
    x1 = 'y1';
    y1 = 'x1';
    x2 = 'y2';
    y2 = 'x2';
    calcwidth = rendHeight;
    calcheight = rendWidth;
  }

  var halfWidth = width / 2;
  return extend({
    type: 'line'
  }, item[key], (_extend4 = {}, _defineProperty(_extend4, y1, Math.floor(position * calcheight)), _defineProperty(_extend4, x1, (boxCenter - halfWidth) * calcwidth), _defineProperty(_extend4, y2, Math.floor(position * calcheight)), _defineProperty(_extend4, x2, (boxCenter + halfWidth) * calcwidth), _defineProperty(_extend4, "r", halfWidth * calcwidth), _defineProperty(_extend4, "cx", boxCenter * calcwidth), _defineProperty(_extend4, "cy", position * calcheight), _defineProperty(_extend4, "width", width * calcwidth), _defineProperty(_extend4, "data", item.data || {}), _defineProperty(_extend4, "collider", {
    type: null
  }), _extend4));
}
/**
 * A horizontal line shape (for median and whiskers)
 * @param {number} bandwidth The current bandwidth for this item
 * @param {object} item A resolved style item to render with major and box width variables, minWidthPx and maxWidthPx
 * @param {number} maxMajorWidth The actual maximum major width
 * @ignore
 */

function getBoxWidth(bandwidth, item, maxMajorWidth) {
  var _item$box = item.box,
      width = _item$box.width,
      maxWidthPx = _item$box.maxWidthPx,
      minWidthPx = _item$box.minWidthPx;
  var sign = bandwidth >= 0 ? 1 : -1;
  var boxWidth = Math.min(sign * bandwidth * width, isNaN(maxWidthPx) ? maxMajorWidth : maxWidthPx / maxMajorWidth);
  boxWidth = isNaN(minWidthPx) ? boxWidth : Math.max(minWidthPx / maxMajorWidth, boxWidth);
  return boxWidth * sign;
}

function buildShapes(_ref) {
  var width = _ref.width,
      height = _ref.height,
      flipXY = _ref.flipXY,
      resolved = _ref.resolved,
      keys = _ref.keys,
      symbol = _ref.symbol;
  // if (!settings || !settings.major || !settings.major.scale || !settings.minor || !settings.minor.scale) {
  //   return [];
  // }
  var output = [];
  var majorItems = resolved.major.items;

  if (!majorItems.length) {
    return output;
  }

  var rendWidth = width;
  var rendHeight = height;
  var maxMajorWidth = flipXY ? height : width;
  var majorSettings = resolved.major.settings;
  var minorProps = ['start', 'end', 'min', 'max', 'med'].filter(function (prop) {
    return typeof resolved.minor.settings[prop] !== 'undefined';
  });
  var numMinorProps = minorProps.length;
  var nonOobKeys = keys.filter(function (key) {
    return key !== 'oob';
  });
  var children;
  var major;
  var minorItem;
  var boxWidth;
  var boxPadding;
  var boxCenter;
  var isLowerOutOfBounds;
  var isHigherOutOfBounds;
  var isOutOfBounds;
  var numKeys = keys ? keys.length : 0;
  var numNonOobKeys = nonOobKeys ? nonOobKeys.length : 0;

  function addBox() {
    /* THE BOX */
    if (minorItem.box && isNumber(minorItem.start) && isNumber(minorItem.end)) {
      children.push(picasso_esm_box({
        item: minorItem,
        boxWidth: boxWidth,
        boxPadding: boxPadding,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addLine() {
    /* LINES MIN - START, END - MAX */
    if (isNumber(minorItem.min) && isNumber(minorItem.start)) {
      children.push(verticalLine({
        item: minorItem,
        from: minorItem.min,
        to: minorItem.start,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }

    if (isNumber(minorItem.max) && isNumber(minorItem.end)) {
      children.push(verticalLine({
        item: minorItem,
        from: minorItem.max,
        to: minorItem.end,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addMedian() {
    /* MEDIAN */
    if (minorItem.median && isNumber(minorItem.med)) {
      children.push(horizontalLine({
        item: minorItem,
        key: 'median',
        position: minorItem.med,
        width: boxWidth,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY
      }));
    }
  }

  function addWhisker() {
    /* WHISKERS */
    if (minorItem.whisker) {
      var whiskerWidth = boxWidth * minorItem.whisker.width;

      if (isNumber(minorItem.min)) {
        children.push(horizontalLine({
          item: minorItem,
          key: 'whisker',
          position: minorItem.min,
          width: whiskerWidth,
          boxCenter: boxCenter,
          rendWidth: rendWidth,
          rendHeight: rendHeight,
          flipXY: flipXY
        }));
      }

      if (isNumber(minorItem.max)) {
        children.push(horizontalLine({
          item: minorItem,
          key: 'whisker',
          position: minorItem.max,
          width: whiskerWidth,
          boxCenter: boxCenter,
          rendWidth: rendWidth,
          rendHeight: rendHeight,
          flipXY: flipXY
        }));
      }
    }
  }

  function addOutOfBounds() {
    /* OUT OF BOUNDS */
    if (isLowerOutOfBounds) {
      children.push(oob({
        item: minorItem,
        value: 0,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY,
        symbol: symbol
      }));
    } else if (isHigherOutOfBounds) {
      children.push(oob({
        item: minorItem,
        value: 1,
        boxCenter: boxCenter,
        rendWidth: rendWidth,
        rendHeight: rendHeight,
        flipXY: flipXY,
        symbol: symbol
      }));
    }
  }

  var addMarkerList = {
    box: addBox,
    line: addLine,
    median: addMedian,
    whisker: addWhisker
  };

  function checkOutOfBounds() {
    var value;
    var max = -Number.MAX_VALUE;
    var min = Number.MAX_VALUE;

    for (var n = 0; n < numMinorProps; n++) {
      value = minorItem[minorProps[n]];

      if (isNumber(value)) {
        if (max < value) {
          max = value;
        }

        if (min > value) {
          min = value;
        }
      }
    }

    isLowerOutOfBounds = max < 0 && max !== -Number.MAX_VALUE;
    isHigherOutOfBounds = min > 1 && min !== Number.MAX_VALUE;
    isOutOfBounds = isLowerOutOfBounds || isHigherOutOfBounds;
  }

  for (var i = 0, len = majorItems.length; i < len; i++) {
    children = [];
    major = null;
    var majorItem = majorItems[i];
    var d = majorItem.data;
    var majorVal = null;
    var majorEndVal = null;

    if (typeof majorSettings.binStart !== 'undefined') {
      // if start and end is defined
      majorVal = majorItem.binStart;
      majorEndVal = majorItem.binEnd;
      major = majorSettings.binStart.scale;
    } else {
      major = majorSettings.major.scale;
      majorVal = major ? majorItem.major : 0;
    }

    var bandwidth = 0;

    if (!major) {
      bandwidth = 1;
    } else if (major.bandwidth) {
      bandwidth = major.bandwidth();
      majorVal -= bandwidth / 2;
    } else {
      bandwidth = majorEndVal - majorVal;
    }

    minorItem = extend({}, {
      major: majorVal,
      majorEnd: majorEndVal
    }, resolved.minor.items[i]);

    for (var j = 0; j < numKeys; j++) {
      minorItem[keys[j]] = resolved[keys[j]].items[i];
    }

    boxWidth = getBoxWidth(bandwidth, minorItem, maxMajorWidth);
    boxPadding = (bandwidth - boxWidth) / 2;
    boxCenter = boxPadding + minorItem.major + boxWidth / 2;
    checkOutOfBounds();

    if (!isOutOfBounds) {
      for (var k = 0; k < numNonOobKeys; k++) {
        addMarkerList[nonOobKeys[k]]();
      }
    } else if (minorItem.oob) {
      addOutOfBounds();
    }

    var container = {
      type: 'container',
      data: d,
      collider: {
        type: 'bounds'
      },
      children: children
    };
    output.push(container);
  }

  return output;
}

/**
 * Resolve a complex object using the built-in resolver from this.resolver in component
 * @ignore
 */

function complexResolver(_ref) {
  var keys = _ref.keys,
      data = _ref.data,
      defaultSettings = _ref.defaultSettings,
      style = _ref.style,
      settings = _ref.settings,
      width = _ref.width,
      height = _ref.height,
      resolver = _ref.resolver;
  var defaults = extend(true, {}, defaultSettings || {}, style || {});
  var scaled = {
    major: settings.orientation === 'horizontal' ? height : width,
    minor: settings.orientation === 'horizontal' ? width : height
  };
  var majorSettings = settings.major;
  var majorResolved;

  if (picasso_esm_typeof(majorSettings) === 'object' && picasso_esm_typeof(majorSettings.ref) === 'object' && typeof majorSettings.ref.start !== 'undefined' && typeof majorSettings.ref.end !== 'undefined') {
    // temporary backwards compatibility
    majorResolved = resolver.resolve({
      data: data,
      defaults: {
        start: 0,
        end: 1
      },
      scaled: scaled,
      settings: extend(true, {}, {
        binStart: {
          scale: settings.major.scale,
          ref: settings.major.ref.start
        },
        binEnd: {
          scale: settings.major.scale,
          ref: settings.major.ref.end
        }
      })
    });
  } else if (picasso_esm_typeof(majorSettings) === 'object' && typeof majorSettings.binStart !== 'undefined' && typeof majorSettings.binEnd !== 'undefined') {
    majorResolved = resolver.resolve({
      data: data,
      defaults: {
        start: 0,
        end: 1
      },
      scaled: scaled,
      settings: extend(true, {}, {
        binStart: {
          scale: settings.major.scale,
          ref: 'binStart'
        },
        binEnd: {
          scale: settings.major.scale,
          ref: 'binEnd'
        }
      }, settings.major)
    });
  } else {
    majorResolved = resolver.resolve({
      data: data,
      scaled: scaled,
      defaults: {
        major: 0.5
      },
      settings: {
        major: settings.major
      }
    });
  }

  var minorSettings = settings.minor || {};
  var defaultMinorSettings = {};
  ['start', 'end', 'min', 'max', 'med'].forEach(function (prop) {
    if (minorSettings[prop] || data.items && data.items.length && data.items[0][prop]) {
      defaultMinorSettings[prop] = {
        scale: minorSettings.scale,
        ref: prop
      };
    }
  });
  var minorResolved = resolver.resolve({
    data: data,
    defaults: {
      start: 0,
      end: 1
    },
    scaled: scaled,
    settings: extend(true, {}, defaultMinorSettings, minorSettings)
  });
  var key;
  var ext = {
    major: majorResolved,
    minor: minorResolved
  };

  for (var ki = 0, len = keys.length; ki < len; ki++) {
    if (!settings[key] || settings[key].show !== false) {
      key = keys[ki];
      ext[key] = resolver.resolve({
        data: data,
        defaults: defaults[key],
        settings: settings[key],
        scaled: scaled
      });
    }
  }

  return ext;
}

var DEFAULT_DATA_SETTINGS = {
  oob: {
    show: true,
    type: 'n-polygon',
    fill: '#999',
    stroke: '#000',
    strokeWidth: 0,
    size: 10,
    sides: 3,
    startAngle: -90
  },
  box: {
    show: true,
    fill: '#fff',
    stroke: '#000',
    strokeWidth: 1,
    strokeLinejoin: 'miter',
    width: 1,
    maxWidthPx: undefined,
    minWidthPx: 1,
    minHeightPx: 1
  },
  line: {
    show: true,
    stroke: '#000',
    strokeWidth: 1
  },
  median: {
    show: true,
    stroke: '#000',
    strokeWidth: 1
  },
  whisker: {
    show: true,
    stroke: '#000',
    strokeWidth: 1,
    fill: '',
    type: 'line',
    width: 1
  }
};
var dataKeys = Object.keys(DEFAULT_DATA_SETTINGS);
var picasso_esm_component = {
  require: ['chart', 'resolver', 'symbol'],
  defaultSettings: {
    settings: {},
    data: {},
    style: {
      box: '$shape',
      line: '$shape-guide',
      whisker: '$shape-guide',
      median: '$shape-guide--inverted'
    }
  },
  created: function created() {
    this.state = {};
  },
  render: function render(_ref) {
    var _this = this;

    var data = _ref.data;
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    var flipXY = this.settings.settings.orientation === 'horizontal';
    var style = this.style,
        resolver = this.resolver,
        symbol = this.symbol;
    var keys = dataKeys.filter(function (key) {
      return !_this.settings.settings[key] || _this.settings.settings[key].show !== false;
    });
    var defaultSettings = {};
    keys.forEach(function (key) {
      return defaultSettings[key] = DEFAULT_DATA_SETTINGS[key];
    });
    var resolved = complexResolver({
      keys: keys,
      data: data,
      defaultSettings: defaultSettings,
      style: style,
      settings: this.settings.settings,
      width: width,
      height: height,
      resolver: resolver
    });
    var settings = resolved.settings,
        items = resolved.items;
    var shapes = buildShapes({
      items: items,
      settings: settings,
      width: width,
      height: height,
      flipXY: flipXY,
      resolved: resolved,
      keys: keys,
      symbol: symbol
    });
    return shapes;
  }
};

function box$1(picasso) {
  picasso.component('box', picasso_esm_component);
  picasso.component('box-marker', picasso_esm_component); // temporary backwards compatibility - DEPRECATED
}
/**
 * @typedef {object} component--box
 * @property {string} type - "box"
 * @property {component--box~data} data Box data
 * @property {component--box~settings} settings Box settings
 * @example
 * {
 *   type: "box",
 *   data: {
 *    mapTo: {
 *      min: { source: "/qHyperCube/qMeasureInfo/0" },
 *      start: { source: "/qHyperCube/qMeasureInfo/1" },
 *      med: { source: "/qHyperCube/qMeasureInfo/2" },
 *      end: { source: "/qHyperCube/qMeasureInfo/3" },
 *      max: { source: "/qHyperCube/qMeasureInfo/4" },
 *    },
 *    groupBy: {
 *      source: "/qHyperCube/qDimensionInfo/0"
 *    }
 *  },
 *  settings: {
 *    major: {
 *      scale: { source: "/qHyperCube/qDimensionInfo/0" }
 *    },
 *    minor: {
 *      scale: { source: ["/qHyperCube/qMeasureInfo/0",
 *               "/qHyperCube/qMeasureInfo/1",
 *               "/qHyperCube/qMeasureInfo/2",
 *               "/qHyperCube/qMeasureInfo/3",
 *               "/qHyperCube/qMeasureInfo/4"] }
 *    }
 *  }
 * }
 */

/**
 * @typedef {object} component--box~settings
 * @property {object} major
 * @property {string} major.scale The scale to use along the major (dimension) axis
 * @property {string|component--box~settings~majorReference} [major.ref='self'] Reference to the data property along the major axis
 * @property {object} minor
 * @property {string} minor.scale The scale to use along the minor (measure) axis
 * @property {string} [orientation='vertical'] Which orientation to use (vertical or horizontal)
 * @property {object} [box] Visual properties for the box shape in the box marker
 * @property {boolean} [box.show=true] Boolean for showing the box shape
 * @property {string} [box.fill='#fff']
 * @property {string} [box.stroke='#000']
 * @property {number} [box.strokeWidth=1]
 * @property {string} [box.strokeLinejoin='miter']
 * @property {number} [box.width=1]
 * @property {number} [box.maxWidthPx=100] Maximum width of the box in pixels (not applicable when using major start and end)
 * @property {number} [box.minWidthPx=1] Minimum width of the box in pixels (not applicable when using major start and end)
 * @property {number} [box.minHeightPx=1] Minimum height of the box shape
 * @property {object} [line] Visual properties for lines between min-start, end-max.
 * @property {boolean} [line.show=true]
 * @property {string} [line.stroke='#000']
 * @property {number} [line.strokeWidth=1]
 * @property {object} [whisker] All the visual properties for whiskers at min and max.
 * @property {boolean} [whisker.show=true]
 * @property {string} [whisker.stroke='#000']
 * @property {number} [whisker.strokeWidth=1]
 * @property {number} [whisker.width=1]
 * @property {object} [median] Visual properties for the median
 * @property {number} [median.show=true]
 * @property {string} [median.stroke='#000']
 * @property {number} [median.strokeWidth=1]
 * @property {object} [oob] EXPERIMENTAL: Out of bounds symbol utilizing the symbol API
 * @property {number} [oob.show=true]
 * @property {string} [oob.type='n-polygon'] Type of the symbol to be used
 * @property {string} [oob.fill='#999'] Fill color of the symbol
 * @property {string} [oob.stroke='#000'] Stroke color
 * @property {number} [oob.strokeWidth=0] Stroke width
 * @property {number} [oob.size=10] Size/width of the symbol in pixels
 * @property {number} [oob.sides=3] Number of sides for a n-polygon (3 for triangle)
 */

/**
 * @typedef {object} component--box~settings~majorReference
 * @property {string} start Reference to the data property of the start value along the major axis
 * @property {string} end Reference to the data property of the end value along the major axis
 */

/**
 * @typedef {object} component--box~data
 * @property {number} [min] Min
 * @property {number} [max] Max
 * @property {number} [start] Start of box
 * @property {number} [end] End of box
 * @property {number} [med] Median
 */

var DEFAULT_ERROR_SETTINGS = {
  errorShape: {
    shape: 'saltire',
    width: 2,
    size: 0.5,
    fill: '#333',
    stroke: '#333',
    strokeWidth: 0
  }
};
/**
  * @typedef {object}
  * @alias component--point.settings
  */

var DEFAULT_DATA_SETTINGS$1 = {
  /** Type of shape
   * @type {datum-string=} */
  shape: 'circle',
  label: '',

  /** Fill color
   * @type {datum-string=} */
  fill: '#333',

  /** Stroke color
   * @type {datum-string=} */
  stroke: '#ccc',

  /** Stroke width
   * @type {datum-number=} */
  strokeWidth: 0,

  /** Stroke line join
   * @type {string=} */
  strokeLinejoin: 'miter',

  /** Opacity of shape
   * @type {datum-number=} */
  opacity: 1,

  /** Normalized x coordinate
   * @type {datum-number=} */
  x: 0.5,

  /** Normalized y coordinate
   * @type {datum-number=} */
  y: 0.5,

  /** Normalized size of shape
   * @type {datum-number=} */
  size: 1,
  strokeDasharray: ''
};
/**
  * @typedef {object}
  * @alias component--point.settings.sizeLimits
  */

var SIZE_LIMITS = {
  /** Maximum size of shape, in pixels
   * @type {number=} */
  maxPx: 10000,

  /** Minimum size of shape, in pixels
   * @type {number=} */
  minPx: 1,

  /** Maximum size relative linear scale extent
   * @type {number=} */
  maxRelExtent: 0.1,

  /** Minimum size relative linear scale extent
   * @type {number=} */
  minRelExtent: 0.01,

  /** Maximum size relative discrete scale banwidth
   * @type {number=} */
  maxRelDiscrete: 1,

  /** Minimum size relative discrete scale banwidth
   * @type {number=} */
  minRelDiscrete: 0.1
};

function getPxSpaceFromScale(s, space) {
  if (s && typeof s.bandwidth === 'function') {
    // some kind of ordinal scale
    return {
      isBandwidth: true,
      value: Math.max(1, s.bandwidth() * space)
    };
  }

  return {
    isBandwidth: false,
    value: Math.max(1, space)
  };
}

function getPointSizeLimits(x, y, width, height, limits) {
  var xSpacePx = getPxSpaceFromScale(x ? x.scale : undefined, width, limits);
  var ySpacePx = getPxSpaceFromScale(y ? y.scale : undefined, height, limits);
  var maxSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'maxRelDiscrete' : 'maxRelExtent']);
  var minSizePx = Math.min(xSpacePx.value * limits[xSpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent'], ySpacePx.value * limits[ySpacePx.isBandwidth ? 'minRelDiscrete' : 'minRelExtent']);
  var min = Math.max(1, Math.floor(minSizePx));
  var max = Math.max(1, Math.floor(maxSizePx));
  return {
    min: min,
    max: max,
    maxGlobal: limits.maxPx,
    minGlobal: limits.minPx
  };
}

function createDisplayPoints(dataPoints, _ref, pointSize, shapeFn) {
  var width = _ref.width,
      height = _ref.height;
  return dataPoints.filter(function (p) {
    return !isNaN(p.x + p.y);
  }).map(function (p) {
    var s = notNumber(p.size) ? DEFAULT_ERROR_SETTINGS.errorShape : p;
    var size = pointSize.min + s.size * (pointSize.max - pointSize.min);
    var shapeSpec = {
      type: s.shape === 'rect' ? 'square' : s.shape,
      label: p.label,
      x: p.x * width,
      y: p.y * height,
      fill: s.fill,
      size: Math.min(pointSize.maxGlobal, Math.max(pointSize.minGlobal, size)),
      stroke: s.stroke,
      strokeWidth: s.strokeWidth,
      strokeDasharray: s.strokeDasharray,
      opacity: s.opacity
    };

    if (s === p.errorShape) {
      shapeSpec.width = s.width;
    }

    var shape = shapeFn(shapeSpec);
    shape.data = p.data;
    return shape;
  });
}

var component$1 = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    settings: {},
    data: {},
    animations: {
      enabled: false,
      trackBy: function trackBy(node) {
        return node.data.value;
      }
    },
    style: {
      item: '$shape'
    }
  },
  render: function render(_ref2) {
    var data = _ref2.data;
    var resolved = this.resolver.resolve({
      data: data,
      defaults: extend({}, DEFAULT_DATA_SETTINGS$1, this.style.item),
      settings: this.settings.settings,
      scaled: {
        x: this.rect.width,
        y: this.rect.height
      }
    });
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    var limits = extend({}, SIZE_LIMITS, this.settings.settings.sizeLimits);
    var points = resolved.items;
    var pointSize = getPointSizeLimits(resolved.settings.x, resolved.settings.y, width, height, limits);
    return createDisplayPoints(points, this.rect, pointSize, this.settings.shapeFn || create$3);
  }
};

/**
 * @typedef {object} component--point
 */

/**
 * @type {string}
 * @memberof component--point
 */

var picasso_esm_type = 'point';
function pointMarker(picasso) {
  picasso.component(picasso_esm_type, component$1);
  picasso.component('point-marker', component$1); // temporary backwards compatibility - DEPRECATED
}

/**
 * @typedef {object}
 * @alias component--pie-settings
 */

var DEFAULT_DATA_SETTINGS$2 = {
  /** Start angle of the pie, in radians
   * @type {number=} */
  startAngle: 0,

  /** End angle of the pie, in radians
   * @type {number=} */
  endAngle: 2 * Math.PI,

  /**
   * @typedef {object}
   */
  slice: {
    label: '',

    /** Absolute value of the slice's arc length
     * @type {number=} */
    arc: 1,

    /** Visibility of the slice
     * @type {boolean=} */
    show: true,

    /** Fill color of the slice
     * @type {string=} */
    fill: '#333',

    /** Stroke color of the slice
     * @type {string=} */
    stroke: '#ccc',

    /** Stroke width of the slice
     * @type {number=} */
    strokeWidth: 1,

    /** Stroke line join
     * @type {string=} */
    strokeLinejoin: 'round',

    /** Opacity of the slice
     * @type {number=} */
    opacity: 1,

    /** Inner radius of the slice
     * @type {number=} */
    innerRadius: 0,

    /** Outer radius of the slice
     * @type {number=} */
    outerRadius: 0.8,

    /** Corner radius of the slice, in pixels
     * @type {number=} */
    cornerRadius: 0,

    /** Radial offset of the slice
     * @type {number=} */
    offset: 0
  }
};
/**
 * @typedef {object} component--pie
 * @property {string} [type='pie']
 * @example
 * {
 *   type: 'pie',
 *   data: {
 *     extract: {
 *       field: 'Region',
 *       props: {
 *         num: { field: 'Population' }
 *       }
 *     }
 *   },
 *   settings: {
 *     startAngle: Math.PI / 2,
 *     endAngle: -Math.PI / 2,
 *     slice: {
 *       arc: { ref: 'num' },
 *       fill: 'green',
 *       stroke: 'red',
 *       strokeWidth: 2,
 *       strokeLinejoin: 'round',
 *       innerRadius: 0.6,
 *       outerRadius 0.8,
 *       opacity: 0.8,
 *       offset: 0.2
 *     }
 *   }
 * }
 */

function offsetSlice(centroid, offset, outerRadius, innerRadius) {
  var _centroid = _slicedToArray(centroid, 2),
      vx = _centroid[0],
      vy = _centroid[1];

  var vlen = Math.sqrt(vx * vx + vy * vy);
  vx /= vlen;
  vy /= vlen;
  var diff = outerRadius - innerRadius;
  return {
    x: vx * offset * diff,
    y: vy * offset * diff
  };
}

function createDisplayPies(arcData, _ref, slices, sum) {
  var x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height;
  var arcGen = arc();
  var center = {
    x: x + width / 2,
    y: y + height / 2
  };
  var innerRadius = Math.min(width, height) / 2;
  var outerRadius = Math.min(width, height) / 2;
  var cornerRadius = outerRadius / 100;
  return arcData.map(function (a, i) {
    var slice = slices[i];
    slice.type = 'path';
    var or = outerRadius * slice.outerRadius;
    var ir = innerRadius * slice.innerRadius;
    arcGen.innerRadius(ir);
    arcGen.outerRadius(or);
    arcGen.cornerRadius(cornerRadius * slice.cornerRadius);
    slice.d = arcGen(a);
    var centroid = arcGen.centroid(a);
    var offset = slice.offset ? offsetSlice(centroid, slice.offset, or, ir) : {
      x: 0,
      y: 0
    };
    slice.transform = "translate(".concat(offset.x, ", ").concat(offset.y, ") translate(").concat(center.x, ", ").concat(center.y, ")");
    slice.desc = {
      share: a.value / sum,
      slice: {
        start: a.startAngle,
        end: a.endAngle,
        innerRadius: ir,
        outerRadius: or,
        offset: {
          x: center.x + offset.x,
          y: center.y + offset.y
        }
      }
    };
    return slice;
  });
}

function arcValue(stngs, item) {
  if (stngs.slice && 'arc' in stngs.slice) {
    return item.arc;
  }

  return item.data.value;
}
var pieComponent = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    settings: {
      startAngle: 0,
      endAngle: 2 * Math.PI,
      padAngle: 0,
      slice: {}
    },
    style: {
      slice: '$shape'
    },
    data: {}
  },
  render: function render(_ref2) {
    var data = _ref2.data;
    var arcValues = [];
    var slices = [];
    var stngs = this.settings.settings;

    var _this$resolver$resolv = this.resolver.resolve({
      data: data,
      defaults: extend({}, DEFAULT_DATA_SETTINGS$2.slice, this.style.slice),
      settings: stngs.slice
    }),
        items = _this$resolver$resolv.items;

    var sum = 0;

    for (var i = 0, len = items.length; i < len; i++) {
      var val = arcValue(stngs, items[i]);

      if (val > 0 && items[i].outerRadius >= items[i].innerRadius) {
        arcValues.push(val);
        slices.push(items[i]);
        sum += val;
      }
    }

    var pieGen = picasso_esm_pie().sortValues(null);
    pieGen.startAngle(stngs.startAngle);
    pieGen.endAngle(stngs.endAngle);
    pieGen.padAngle(stngs.padAngle);
    var arcData = pieGen(arcValues);
    return createDisplayPies(arcData, extend({}, this.rect, {
      x: 0,
      y: 0
    }), slices, sum);
  }
};

function pie$1(picasso) {
  picasso.component('pie', pieComponent);
}

/**
 * Create a crispifier
 * @ignore
 *
 * @param  {Object} [crispMap] Optional crispmap if you need custom crisping.
 * @return {Function}          crispItem function
 *
 * @example
 * import { crispifierFactory } from "core/crispifier";
 *
 * let crispify = crispifierFactory(customCrispMap);
 *
 * // For a single item
 * crispify(myItem);
 *
 * // For multiple items
 * crispify.multiple(myArrayOfItems);
 */
function crispifierFactory(crispMap) {
  // Define the crispMap
  if (crispMap === undefined) {
    crispMap = {};
    crispMap.line = {
      append: ['x1', 'x2', 'y1', 'y2'],
      round: [],
      condition: function condition(item) {
        return item.x1 === item.x2 || item.y1 === item.y2;
      },
      conditionAppend: function conditionAppend(item) {
        return item.strokeWidth % 2 !== 0;
      }
    };
    crispMap.rect = {
      append: ['x', 'y'],
      round: ['width', 'height'],
      condition: function condition() {
        return true;
      },
      conditionAppend: function conditionAppend(item) {
        return item.strokeWidth % 2 !== 0;
      }
    };
  } // Re-map the crispmap


  Object.keys(crispMap).forEach(function (type) {
    var self = crispMap[type];
    self.items = [];
    self.append.forEach(function (toAppend) {
      self.items.push({
        key: toAppend,
        type: 'append'
      });
    });
    self.round.forEach(function (toAppend) {
      self.items.push({
        key: toAppend,
        type: 'round'
      });
    });
  });
  /**
   * Crispify a single item
   * @ignore
   * @param  {Object} item  Item with renderer variables such as X, Y, and type.
   * @return {Undefined}    Returns nothing, modifies the original item instead
   */

  function crispItem(item) {
    if (crispMap[item.type] && crispMap[item.type].condition(item)) {
      var self = crispMap[item.type];
      var doAppend = self.conditionAppend === undefined || self.conditionAppend(item);
      self.items.forEach(function (i) {
        var rounded = Math.round(item[i.key]);
        var diff = item[i.key] - rounded;
        item[i.key] = rounded;

        if (doAppend && i.type === 'append') {
          if (diff > 0) {
            item[i.key] += 0.5;
          } else {
            item[i.key] -= 0.5;
          }
        }
      });
    }
  }
  /**
   * Crispify multiple items
   * @ignore
   *
   * @param  {Array} items  Array of objects to crispify
   * @return {Undefined}    Returns nothing, modifies the original item instead
   */


  crispItem.multiple = function (items) {
    return items.forEach(function (item) {
      return crispItem(item);
    });
  };

  return crispItem;
}
var crispifier = crispifierFactory();

var Transposer =
/*#__PURE__*/
function () {
  /**
   * @private
   */
  function Transposer() {
    _classCallCheck$1(this, Transposer);

    this.reset();
    this.push.apply(this, arguments);
  }
  /**
   * Evaluate a key for a transposed coordinate
   *
   * @param  {String} key   Key
   * @return {String}         Actual key
   */


  _createClass$1(Transposer, [{
    key: "transposeCoordinate",

    /**
     * Transpose a coordinate according to this.flipXY and
     * the available rendering area
     *
     * @param  {String} key        The key of the coordinate to transpose
     * @param  {Number} coordinate The coordinate
     * @return {Number}            The actual location of the coordinate
     */
    value: function transposeCoordinate(key, coordinate, flipXY) {
      if (typeof coordinate === 'number' && isFinite(coordinate)) {
        var firstChar = key.substring(0, 1);

        if (firstChar === 'x' || key === 'cx') {
          return coordinate * this.width;
        }

        if (key === 'width') {
          return coordinate * this.width;
        }

        if (key === 'r') {
          return coordinate * (!flipXY ? this.width : this.height);
        }

        if (firstChar === 'y' || key === 'cy') {
          return coordinate * this.height;
        }

        if (key === 'height') {
          return coordinate * this.height;
        }
      }

      return coordinate;
    }
    /**
     * Push an item into the storage of the transposer
     *
     * @param  {Object} items An item to be drawed
     * @return {Object}       Can be chained
     */

  }, {
    key: "push",
    value: function push() {
      var _this$storage;

      (_this$storage = this.storage).push.apply(_this$storage, arguments);

      return this;
    }
  }, {
    key: "processItem",
    value: function processItem(item) {
      var newItem = {};
      var flipXY = typeof item.flipXY !== 'undefined' ? item.flipXY : this.flipXY;
      var crisp = typeof item.crisp !== 'undefined' ? item.crisp : this.crisp;

      if (item.fn && typeof item.fn === 'function') {
        var width = flipXY ? this.height : this.width;
        var height = flipXY ? this.width : this.height;
        item = item.fn({
          width: width,
          height: height,
          flipXY: flipXY
        });
        var objectKeys = Object.keys(item);

        for (var ki = 0, kl = objectKeys.length; ki < kl; ki++) {
          var key = objectKeys[ki];
          var nkey = Transposer.evaluateKey(key, flipXY);
          newItem[nkey] = item[key];
        }
      } else {
        var _objectKeys = Object.keys(item);

        for (var _ki = 0, _kl = _objectKeys.length; _ki < _kl; _ki++) {
          var _key = _objectKeys[_ki];

          var _nkey = Transposer.evaluateKey(_key, flipXY);

          var nval = this.transposeCoordinate(_nkey, item[_key], flipXY);
          newItem[_nkey] = nval;
        }
      }

      if (crisp) {
        crispifier(newItem);
      }

      return newItem;
    }
    /**
     * Get the output of the transposer
     *
     * @return {Array}   Array of objects
     */

  }, {
    key: "output",
    value: function output() {
      var items = [];

      for (var i = 0, l = this.storage.length; i < l; i++) {
        var newItem = this.processItem(this.storage[i]);
        items.push(newItem);
      }

      return items;
    }
    /**
     * Reset the transposer
     *
     * @return {Undefined}  Does not return anything
     */

  }, {
    key: "reset",
    value: function reset() {
      this.storage = [];
      this.flipXY = false;
      this.crisp = false;
      this.width = 0;
      this.height = 0;
    }
  }], [{
    key: "evaluateKey",
    value: function evaluateKey(key, flipXY) {
      if (flipXY) {
        var firstChar = key.substring(0, 1);
        var rest = key.substring(1);

        if (firstChar === 'x') {
          return "y".concat(rest);
        }

        if (firstChar === 'y') {
          return "x".concat(rest);
        }

        if (key === 'cx') {
          return 'cy';
        }

        if (key === 'cy') {
          return 'cx';
        }

        if (key === 'width') {
          return 'height';
        }

        if (key === 'height') {
          return 'width';
        }
      }

      return key;
    }
  }]);

  return Transposer;
}();

function transposer() {
  for (var _len = arguments.length, items = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    items[_key2] = arguments[_key2];
  }

  return _construct(Transposer, items);
}

/**
 * Generate array of lines (ticks) from scale
 *
 * @param {object} scale - A scale supplied by the chart
 * @param {object} settings - The settings object from the grid line component
 * @param {object} rect - The rect containing width and height to renderer in
 * @returns {array} - Returns an array of ticks
 * @ignore
 */

function lineGen(scale, distance) {
  if (!scale || !distance) {
    return [];
  }

  return scale.cachedTicks && scale.cachedTicks() || scale.ticks({
    distance: distance
  });
}

var gridLineComponent = {
  created: function created() {},
  require: ['chart', 'renderer', 'resolver'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    style: {
      // Theming style
      ticks: '$guide-line',
      minorTicks: '$guide-line--minor'
    }
  },
  beforeRender: function beforeRender() {
    this.blueprint = transposer();
    this.blueprint.width = this.rect.width;
    this.blueprint.height = this.rect.height;
    this.blueprint.x = this.rect.x;
    this.blueprint.y = this.rect.y;
    this.blueprint.crisp = true;
  },
  render: function render() {
    var _this = this;

    // Setup scales
    this.x = this.settings.x ? this.chart.scale(this.settings.x) : null;
    this.y = this.settings.y ? this.chart.scale(this.settings.y) : null;
    updateScaleSize(this, 'x', this.rect.width);
    updateScaleSize(this, 'y', this.rect.height); // Return an empty array to abort rendering when no scales are available to renderer

    if (!this.x && !this.y) {
      return [];
    }

    this.settings.ticks = extend({
      show: true
    }, this.style.ticks, this.settings.ticks || {});
    this.settings.minorTicks = extend({
      show: false
    }, this.style.minorTicks, this.settings.minorTicks || {}); // Setup lines for X and Y

    this.lines = {
      x: [],
      y: []
    }; // Use the lineGen function to generate appropriate ticks

    this.lines.x = lineGen(this.x, this.rect.width);
    this.lines.y = lineGen(this.y, this.rect.height); // Set all Y lines to flipXY by default
    // This makes the transposer flip them individually

    this.lines.y = this.lines.y.map(function (i) {
      return extend(i, {
        flipXY: true
      });
    });

    var addTicks = function addTicks(_ref) {
      var dir = _ref.dir,
          isMinor = _ref.isMinor;

      var items = _this.lines[dir].filter(function (tick) {
        return !!tick.isMinor === isMinor;
      });

      var settings = isMinor ? _this.settings.minorTicks : _this.settings.ticks;

      var ticks = _this.resolver.resolve({
        settings: settings,
        data: {
          items: items,
          dir: dir
        }
      }).items;

      ticks.forEach(function (style) {
        var p = style.data; // If the style's show is falsy, don't renderer this item (to respect axis settings).

        if (style.show) {
          // Use the transposer to handle actual positioning
          _this.blueprint.push({
            type: 'line',
            x1: p.position,
            y1: 0,
            x2: p.position,
            y2: 1,
            stroke: style.stroke || 'black',
            strokeWidth: typeof style.strokeWidth !== 'undefined' ? style.strokeWidth : 1,
            strokeDasharray: typeof style.strokeDasharray !== 'undefined' ? style.strokeDasharray : undefined,
            flipXY: p.flipXY || false // This flips individual points (Y-lines)

          });
        }
      });
    };

    addTicks({
      dir: 'x',
      isMinor: false
    });
    addTicks({
      dir: 'x',
      isMinor: true
    });
    addTicks({
      dir: 'y',
      isMinor: false
    });
    addTicks({
      dir: 'y',
      isMinor: true
    });
    return this.blueprint.output();
  }
};

/**
 * @typedef {object} component--grid-line-settings
 * @property {object} x
 * @property {string} x.scale - The scale to use along x
 * @property {object} y
 * @property {string} y.scale - The scale to use along y
 * @property {object} [ticks]
 * @property {boolean} [ticks.show=true]
 * @property {string} [ticks.stroke='black']
 * @property {number} [ticks.strokeWidth='1']
 * @property {string} [ticks.strokeDasharray]
 * @property {object} [minorTicks]
 * @property {boolean} [minorTicks.show=true]
 * @property {string} [minorTicks.stroke='black']
 * @property {number} [minorTicks.strokeWidth='1']
 * @property {string} [minorTicks.strokeDasharray]
 */

function gridLine(picasso) {
  picasso.component('grid-line', gridLineComponent);
}

/**
 * Return a D property for a SVG path to get a direction marker
 *
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {number} r - Radius
 * @param {string} [d='bottom'] - Direction
 * @returns {string} - Finished D property
 * @ignore
 */
function directionMarker(x, y, r) {
  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';
  r *= 0.8;

  if (d === 'left' || d === 'right') {
    var right = d === 'right';
    return "\n      M ".concat(x, " ").concat(y - r, "\n      A ").concat(r * 1.25, " ").concat(r * 1.25, ", 0, 1, ").concat(right ? 0 : 1, ", ").concat(x, " ").concat(y + r, "\n      L ").concat(right ? x + r : x - r, " ").concat(y, " Z\n    ");
  }

  var bottom = d === 'bottom';
  return "\n    M ".concat(x - r, " ").concat(y, "\n    A ").concat(r * 1.25, " ").concat(r * 1.25, ", 0, 1, ").concat(bottom ? 1 : 0, ", ").concat(x + r, " ").concat(y, "\n    L ").concat(x, " ").concat(bottom ? y + r : y - r, " Z\n  ");
}

function directionTriangle(x, y, r) {
  var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'bottom';
  r *= 0.75;

  if (d === 'left' || d === 'right') {
    var right = d === 'right';
    x += right ? r * 1.5 : -(r * 1.5);
    return "\n      M ".concat(x, " ").concat(y - r, "\n      L ").concat(x, " ").concat(y + r, "\n      L ").concat(right ? x + r : x - r, " ").concat(y, " Z\n    ");
  }

  var bottom = d === 'bottom';
  y += bottom ? r * 1.5 : -(r * 1.5);
  return "\n    M ".concat(x - r, " ").concat(y, "\n    L ").concat(x + r, " ").concat(y, "\n    L ").concat(x, " ").concat(bottom ? y + r : y - r, " Z\n  ");
}
/**
 * Handle out of bound shapes
 * Does not return anything, modifies "items" property instead (should be re-considered)
 *
 * @param {object} oob - Out of bounds object from parent
 * @param {object} settings - Settings object from parent
 * @param {object[]} items - Array of all items (for collision detection)
 * @ignore
 */


function oobManager(_ref) {
  var blueprint = _ref.blueprint,
      oob = _ref.oob,
      settings = _ref.settings,
      items = _ref.items;
  var oobKeys = Object.keys(oob);
  var style = settings.style.oob || {};

  var _loop = function _loop(i, len) {
    var key = oobKeys[i];
    var value = oob[key];

    if (value.length > 0) {
      var position = key.charAt(1);
      var flipXY = key.charAt(0) === 'y';
      var xPadding = style.padding.x + style.width;
      var yPadding = style.padding.y + style.width;
      var direction = 'bottom';

      if (flipXY) {
        direction = position === '1' ? 'bottom' : 'top';
      } else {
        direction = position === '1' ? 'right' : 'left';
      }

      var indicator = blueprint.processItem({
        fn: function fn(_ref2) {
          var width = _ref2.width,
              height = _ref2.height;

          /* eslint no-loop-func: 0 */
          var x = position * width + (position === '1' ? -xPadding : xPadding);
          var y = flipXY ? yPadding : height - yPadding;

          if (style.type === 'arc') {
            return {
              type: 'path',
              d: directionMarker(flipXY ? y : x, flipXY ? x : y, style.width, direction),
              x: x,
              y: y,
              stroke: style.stroke,
              fill: style.fill,
              strokeWidth: style.strokeWidth || 0
            };
          }

          return {
            type: 'circle',
            cx: x,
            cy: y,
            r: style.width,
            stroke: style.stroke,
            fill: style.fill,
            strokeWidth: style.strokeWidth || 0,
            opacity: style.opacity,
            data: value
          };
        },
        flipXY: flipXY
      });
      var x = indicator.cx || indicator.x;
      var y = indicator.cy || indicator.y;
      var text = {
        type: 'text',
        text: value.length || '',
        x: x - style.width * 0.4,
        y: y + style.width * 0.4,
        fontFamily: style.text.fontFamily,
        fontSize: "".concat(style.width * 1.3, "px"),
        stroke: style.text.stroke,
        fill: style.text.fill,
        strokeWidth: style.text.strokeWidth || 0,
        opacity: style.text.opacity
      };
      var triangle = {
        type: 'path',
        d: directionTriangle(x, y, style.width, direction),
        x: x,
        y: y,
        stroke: style.triangle.stroke,
        fill: style.triangle.fill,
        strokeWidth: style.triangle.strokeWidth || 0,
        opacity: style.triangle.opacity
      };
      items.push(indicator, text, triangle);
    }
  };

  for (var i = 0, len = oobKeys.length; i < len; i++) {
    _loop(i, len);
  }
}

function refLabelDefaultSettings() {
  return {
    fill: '#000',
    fontFamily: 'Arial',
    fontSize: '12px',
    opacity: 1,
    maxWidth: 1,
    maxWidthPx: 9999,
    padding: 5,
    background: {
      fill: '#fff',
      stroke: 'transparent',
      strokeWidth: 0,
      opacity: 0.5
    }
  };
}
/**
 * Converts a numerical OR string value to a normalized value
 *
 * @param {string|number} align -Description how to align (Numerical from 0-1 or 'top', 'left', 'center', 'middle', 'bottom' or 'right')
 * @returns {number} - Normalized value 0...1
 * @ignore
 */

function alignmentToNumber(align) {
  if (typeof align === 'undefined') {
    return 0;
  }

  if (typeof align === 'number' && isFinite(align)) {
    return align;
  }

  if (typeof align === 'string') {
    switch (align) {
      case 'center':
      case 'middle':
        return 0.5;

      case 'bottom':
      case 'right':
        return 1;

      case 'top':
      case 'left':
      default:
        return 0;
    }
  }

  return 0;
}
/**
 * Create line and label (if applicable)
 * Does not return anything, modifies "items" property instead (should be re-considered)
 *
 * @param {object} p - Current point
 * @param {object} style - Applicable line styling
 * @param {object} settings - Settings object derived from parent
 * @param {object[]} items - Array of all items (for collision detection)
 * @ignore
 */

function createLineWithLabel(_ref) {
  var chart = _ref.chart,
      blueprint = _ref.blueprint,
      renderer = _ref.renderer,
      p = _ref.p,
      settings = _ref.settings,
      items = _ref.items;
  var doesNotCollide = true;
  var line = false;
  var rect = false;
  var label = false;
  var value = false;
  var style = extend(true, {}, settings.style.line, p.line || {}); // Use the transposer to handle actual positioning

  line = blueprint.processItem({
    type: 'line',
    x1: p.position,
    y1: 0,
    x2: p.position,
    y2: 1,
    stroke: style.stroke || 'black',
    strokeWidth: style.strokeWidth || 1,
    flipXY: p.flipXY || false // This flips individual points (Y-lines)

  });

  if (p.label) {
    var item = extend(true, refLabelDefaultSettings(), settings.style.label || {}, {
      fill: style.stroke
    }, p.label);
    var formatter;
    var measuredValue = {
      width: 0,
      height: 0
    };
    var valueString = '';

    if (typeof p.formatter === 'string') {
      formatter = chart.formatter(p.formatter);
    } else if (picasso_esm_typeof(p.formatter) === 'object') {
      formatter = chart.formatter(p.formatter);
    } else if (typeof p.scale !== 'undefined' && p.scale.data) {
      // TODO - Add support for array as source into formatter
      var scaleData = p.scale.data() && p.scale.data().fields;
      formatter = scaleData && scaleData[0] ? scaleData[0].formatter() : null;
    }

    if (formatter) {
      valueString = " (".concat(formatter(p.value), ")");
    } else if (p.scale) {
      valueString = " (".concat(p.value, ")");
    }

    if (valueString) {
      measuredValue = renderer.measureText({
        text: valueString,
        fontFamily: item.fontFamily,
        fontSize: item.fontSize
      });
    } // Measure the label text


    var measuredLabel = renderer.measureText({
      text: item.text || '',
      fontFamily: item.fontFamily,
      fontSize: item.fontSize
    });
    var measured = {
      width: measuredLabel.width + measuredValue.width,
      height: Math.max(measuredLabel.height, measuredValue.height)
    };
    var labelPadding = item.padding; // let anchor = item.anchor === 'end' ? 'end' : 'start';

    var align = alignmentToNumber(p.flipXY ? item.vAlign : item.align);
    var vAlign = alignmentToNumber(p.flipXY ? item.align : item.vAlign);
    var calcWidth = Math.min(1 + measured.width + labelPadding * 2, item.maxWidth * blueprint.width, item.maxWidthPx);
    var calcHeight = measured.height + labelPadding * 2;
    var rectWidth = p.flipXY ? calcHeight : calcWidth;
    var rectHeight = p.flipXY ? calcWidth : calcHeight;
    rect = blueprint.processItem({
      fn: function fn(_ref2) {
        var width = _ref2.width,
            height = _ref2.height;
        var x = p.position * width - (p.flipXY ? calcHeight : calcWidth) * (1 - align);
        x = p.flipXY ? x : Math.max(x, 0);
        var y = Math.max(Math.abs(vAlign * height - rectHeight * vAlign), 0);
        return {
          type: 'rect',
          x: x,
          y: y,
          width: p.flipXY ? rectWidth : Math.min(rectWidth, blueprint.width - x),
          height: rectHeight,
          stroke: item.background.stroke,
          strokeWidth: item.background.strokeWidth,
          fill: item.background.fill,
          opacity: item.background.opacity
        };
      },
      flipXY: p.flipXY || false // This flips individual points (Y-lines)

    });

    if (rect.x < -1 || rect.x + rect.width > blueprint.width + 1 || rect.y < -1 || rect.y + rect.height > blueprint.height + 1) {
      // do not create labels if out of bounds
      rect = undefined;
    } else {
      // Labels are just basic objects attached to a corner of a rect,
      // and this rect needs to already be processed
      // so there is no blueprint.processItem required here
      label = {
        type: 'text',
        text: item.text || '',
        fill: item.fill,
        opacity: item.opacity,
        fontFamily: item.fontFamily,
        fontSize: item.fontSize,
        x: rect.x + labelPadding,
        y: rect.y + rect.height / 2 + measured.height / 3,
        maxWidth: rect.width - labelPadding * 2 - measuredValue.width,
        anchor: 'start'
      };

      if (valueString) {
        value = {
          type: 'text',
          text: valueString || '',
          fill: item.fill,
          opacity: item.opacity,
          fontFamily: item.fontFamily,
          fontSize: item.fontSize,
          x: label.x + 3 + (rect.width - (measuredValue.width + labelPadding * 2)),
          y: label.y
        };
      } // Detect collisions with other labels/rects or lines


      for (var i = 0, len = items.length; i < len; i++) {
        var curItem = items[i];

        if (curItem.type === 'rect') {
          // We only detect rects here, since rects are always behind labels,
          // and we wouldn't want to measure text one more time
          if (testRectRect(rect, curItem)) {
            doesNotCollide = false;
          }
        } else if (curItem.type === 'line') {
          // This will only collide when flipXY are the same for both objects,
          // So it only collides on objects on the same "axis"
          if (p.flipXY === curItem.flipXY && testRectLine(rect, curItem)) {
            doesNotCollide = false;
          }
        }
      }
    }
  } // Always push the line,
  // but this is done after collision detection,
  // because otherwise it would collide with it's own line


  items.push(line); // Only push rect & label if we haven't collided and both are defined

  if (doesNotCollide && rect && label) {
    items.push(rect, label);

    if (value) {
      items.push(value);
    }
  }
}

function createOobData(line) {
  var data = {
    value: line.value
  };

  if (line.label) {
    data.label = line.label.text;
  }

  return data;
}

function filterUndefinedValue(line) {
  return typeof line.value !== 'undefined';
}
/**
 * @typedef {object} component--ref-line
 * @experimental
 * @property {refline-generic-style} [style=refline-generic-style] - x coordinate
 * @property {object} lines - X & Y Lines
 * @property {reflines-x[]} [lines.x=refline-line[]] - lines along X
 * @property {reflines-y[]} [lines.y=refline-line[]] - lines along Y
 */

/**
 * @typedef {object} component--ref-line.style
 * @property {refline-oob-style} [oob=component--ref-line.style.oob] - Style for out of bounds object (oob)
 * @property {refline-line} [line=refline-line] - Generic style for lines
 * @property {refline-line-label} [label=refline-line-label] - Generic style for labels
 */

/**
 * @typedef {object} component--ref-line.style.oob
 * @property {boolean} [show=true] - Show out of bounds items
 * @property {string} [type=undefined] - EXPERIMENTAL:  Set this to 'arc' for an experimental out of bounds shape (only works with SVG)
 * @property {number} [width=10] - Width of the out of bounds object
 * @property {string} [fill='#1A1A1A'] - Fill color of the OOB object
 * @property {string} [stroke='transparent'] - Stroke of the OOB object
 * @property {number} [strokeWidth=0] - Stroke width of the OOB object
 * @property {number} [opacity=1] - Opacity of the OOB object
 * @property {refline-generic-text} [text=refline-generic-text] - Text configuration for out of bounds
 * @property {refline-generic-object} [triangle=refline-generic-object] - The triangle in OOB
 * @property {object} [padding] - Padding on X
 * @property {number} [padding.x=28] - Padding on X
 * @property {number} [padding.y=5] - Padding on X
 */

/**
 * @typedef {object} component--ref-line.generic-text
 * @property {string} [text=''] - Text (if applicable)
 * @property {string} [fontSize='12px'] - Font size (if applicable)
 * @property {string} [fontFamily='Arial'] - Font family
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 */

/**
 * @typedef {object} component--ref-line.line
 * @property {number} value - The value of the reference line. If a scale is specified, it is applied.
 * @property {Scale} [scale=undefined] - Scale to use (if undefined will use normalized value 0-1)
 * @property {refline-generic-object} [line=refline-generic-object] - The style of the line
 * @property {refline-line-label} [label=refline-line-label] - The label style of the line
 */

/**
 * @typedef {object} component--ref-line.line-label
 * @property {number} padding=5 - Padding inside the label
 * @property {string} [text=''] - Text
 * @property {string} [fontSize='12px'] - Font size
 * @property {string} [fontFamily='Arial'] - Font family
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 * @property {number|string} [align=0] - Alignment property left to right (0 = left, 1 = right). Also supports string ('left', 'center', 'middle', 'right')
 * @property {number|string} [vAlign=0] - Alignment property top to bottom (0 = top, 1 = bottom). Also supports string ('top', 'center', 'middle', 'bottom')
 * @property {number} [maxWidth=1] - The maximum relative width to the width of the rendering area (see maxWidthPx below aswell)
 * @property {number} [maxWidthPx=9999] - The maximum width in pixels.
 * @property {refline-line-label-background} [background=refline-line-label-background] - The background style (rect behind text)
 */

/**
 * @example
 * // Labels will be rendered with the maximum size of the smallest value of maxWidth and maxWidthPx size, so you may specify maxWidth 0.8 but maxWidthPx 100 and will never be over 100px and never over 80% of the renderable area.
 */

/**
 * @typedef {object} component--ref-line.line-label-background
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=0.5] - Opacity
 */

/**
 * @typedef {object} component--ref-line.generic-object
 * @property {string} [fill='#fff'] - Fill color
 * @property {string} [stroke='transparent'] - Stroke
 * @property {number} [strokeWidth=0] - Stroke width
 * @property {number} [opacity=1] - Opacity
 */


var refLineComponent = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    style: {
      oob: {
        show: true,
        width: 10,
        fill: '#1A1A1A',
        stroke: 'transparent',
        strokeWidth: 0,
        opacity: 1,
        text: {
          fontFamily: 'Arial',
          stroke: 'transparent',
          fill: '#fff',
          strokeWidth: 0,
          opacity: 1
        },
        triangle: {
          fill: '#4D4D4D',
          stroke: 'transparent',
          strokeWidth: 0,
          opacity: 1
        },
        padding: {
          x: 28,
          y: 5
        }
      },
      line: {
        stroke: '#000'
      },
      label: {
        strokeWidth: 0
      }
    }
  },
  preferredSize: function preferredSize() {
    return 30;
  },
  beforeRender: function beforeRender() {
    this.blueprint = transposer();
    this.blueprint.width = this.rect.width;
    this.blueprint.height = this.rect.height;
    this.blueprint.x = this.rect.x;
    this.blueprint.y = this.rect.y;
    this.blueprint.crisp = true;
  },
  render: function render() {
    var _this = this;

    var settings = this.settings; // Setup lines for X and Y

    this.lines = {
      x: [],
      y: []
    };
    this.lines.x = settings.lines && settings.lines.x || [];
    this.lines.y = settings.lines && settings.lines.y || [];

    if (this.lines.x.length === 0 && this.lines.y.length === 0) {
      return [];
    }

    var oob = {
      x0: [],
      x1: [],
      y0: [],
      y1: []
    }; // Convert a value to an actual position using the scale

    this.lines.x = this.lines.x.filter(filterUndefinedValue).map(function (line) {
      if (line.scale) {
        var scale = _this.chart.scale(line.scale);

        return extend(line, {
          scale: scale,
          position: scale(line.value)
        });
      }

      return extend(line, {
        position: line.value
      });
    }); // Set all Y lines to flipXY by default
    // This makes the transposer flip them individually

    this.lines.y = this.lines.y.filter(filterUndefinedValue).map(function (line) {
      if (line.scale) {
        var scale = _this.chart.scale(line.scale);

        return extend(line, {
          scale: scale,
          position: scale(line.value),
          flipXY: true
        });
      }

      return extend(line, {
        position: line.value,
        flipXY: true
      });
    }); // Move out of bounds lines (OOB) to separate rendering

    this.lines.x = this.lines.x.filter(function (line) {
      if (line.position < 0 || line.position > 1) {
        oob["x".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));
        return false;
      }

      return true;
    });
    this.lines.y = this.lines.y.filter(function (line) {
      if (line.position < 0 || line.position > 1) {
        oob["y".concat(line.position > 1 ? 1 : 0)].push(createOobData(line));
        return false;
      }

      return true;
    });
    var items = []; // Loop through all X and Y lines

    [].concat(_toConsumableArray$1(this.lines.x), _toConsumableArray$1(this.lines.y)).forEach(function (p) {
      var show = p.show === true || typeof p.show === 'undefined';

      if (show) {
        // Create line with labels
        createLineWithLabel({
          chart: _this.chart,
          blueprint: _this.blueprint,
          renderer: _this.renderer,
          p: p,
          settings: settings,
          items: items
        });
      }
    }); // Handle out of bounds

    if (settings.style.oob.show) {
      oobManager({
        blueprint: this.blueprint,
        oob: oob,
        settings: settings,
        items: items
      });
    }

    return items;
  }
};

function refLine(picasso) {
  picasso.component('ref-line', refLineComponent);
}

function appendStyle(struct, buildOpts) {
  extend(struct, buildOpts.style);
  var halfWidth = struct.strokeWidth / 2;

  if (buildOpts.align === 'top') {
    struct.y1 -= halfWidth;
    struct.y2 -= halfWidth;
  } else if (buildOpts.align === 'bottom') {
    struct.y1 += halfWidth;
    struct.y2 += halfWidth;
  } else if (buildOpts.align === 'left') {
    struct.x1 -= halfWidth;
    struct.x2 -= halfWidth;
  } else if (buildOpts.align === 'right') {
    struct.x1 += halfWidth;
    struct.x2 += halfWidth;
  }
}

function buildLine(buildOpts) {
  var struct = {
    type: 'line',
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 0,
    collider: {
      type: null
    }
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x1 = buildOpts.innerRect.x - buildOpts.outerRect.x;
    struct.x2 = buildOpts.innerRect.width + buildOpts.innerRect.x;
    struct.y1 = struct.y2 = buildOpts.align === 'top' ? buildOpts.innerRect.height - buildOpts.padding : buildOpts.padding;
  } else {
    struct.x1 = struct.x2 = buildOpts.align === 'left' ? buildOpts.innerRect.width - buildOpts.padding : buildOpts.padding;
    struct.y1 = buildOpts.innerRect.y - buildOpts.outerRect.y;
    struct.y2 = buildOpts.innerRect.height + buildOpts.innerRect.y;
  }

  appendStyle(struct, buildOpts);
  return struct;
}

function checkText(text) {
  return typeof text === 'string' || typeof text === 'number' ? text : '-';
}

function appendStyle$1(struct, buildOpts) {
  ['fill', 'fontSize', 'fontFamily'].forEach(function (style) {
    struct[style] = buildOpts.style[style];
  });
}

function clampEnds(struct, buildOpts) {
  if (buildOpts.tilted || buildOpts.stepSize) {
    return;
  }

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    var leftBoundary = 0;
    var rightBoundary = buildOpts.outerRect.width;
    var textWidth = Math.min(buildOpts.maxWidth / 2, buildOpts.textRect.width / 2);
    var leftTextBoundary = struct.x - textWidth;
    var rightTextBoundary = struct.x + textWidth;

    if (leftTextBoundary < leftBoundary) {
      struct.anchor = 'start';
      struct.x = buildOpts.innerRect.x - buildOpts.outerRect.x;
    } else if (rightTextBoundary > rightBoundary) {
      struct.anchor = 'end';
      struct.x = buildOpts.innerRect.width + buildOpts.innerRect.x;
    }
  } else {
    var topBoundary = 0;
    var bottomBoundary = buildOpts.outerRect.height;
    var textHeight = buildOpts.maxHeight / 2;
    var topTextBoundary = struct.y - textHeight;
    var bottomTextBoundary = struct.y + textHeight;

    if (topTextBoundary < topBoundary) {
      struct.y = buildOpts.innerRect.y - buildOpts.outerRect.y;
      struct.baseline = 'text-before-edge';
    } else if (bottomTextBoundary > bottomBoundary) {
      struct.y = buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);
      struct.baseline = 'text-after-edge';
    }
  }
}

function appendPadding(struct, buildOpts) {
  if (buildOpts.align === 'top') {
    struct.y -= buildOpts.padding;
  } else if (buildOpts.align === 'bottom') {
    struct.y += buildOpts.padding + buildOpts.maxHeight;
  } else if (buildOpts.align === 'left') {
    struct.x -= buildOpts.padding;
  } else if (buildOpts.align === 'right') {
    struct.x += buildOpts.padding;
  }
}

function appendTilting(struct, buildOpts) {
  if (buildOpts.tilted) {
    var r = -buildOpts.angle;
    var radians = r * (Math.PI / 180);

    if (buildOpts.align === 'bottom') {
      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 2;
      struct.y -= buildOpts.maxHeight;
      struct.y += buildOpts.maxHeight * Math.cos(radians) / 2;
    } else {
      struct.x -= buildOpts.maxHeight * Math.sin(radians) / 3;
    }

    struct.transform = "rotate(".concat(r, ", ").concat(struct.x, ", ").concat(struct.y, ")");
    struct.anchor = buildOpts.align === 'bottom' === buildOpts.angle < 0 ? 'start' : 'end'; // adjustForEnds

    var textWidth = Math.cos(radians) * buildOpts.maxWidth;

    if (buildOpts.align === 'bottom' === buildOpts.angle < 0) {
      // right
      var rightBoundary = buildOpts.outerRect.width - buildOpts.paddingEnd;
      var rightTextBoundary = struct.x + textWidth;

      if (rightTextBoundary > rightBoundary) {
        struct.maxWidth = (rightBoundary - struct.x - 10) / Math.cos(radians);
      }
    } else {
      // left
      var leftBoundary = buildOpts.paddingEnd;
      var leftTextBoundary = struct.x - textWidth;

      if (leftTextBoundary < leftBoundary) {
        struct.maxWidth = (struct.x - leftBoundary - 10) / Math.cos(radians);
      }
    }
  }
}

function bandwidthCollider(tick, struct, buildOpts) {
  if (buildOpts.align === 'bottom' || buildOpts.align === 'top') {
    var tickCenter = tick.position * buildOpts.innerRect.width;
    var leftBoundary = tickCenter + (buildOpts.innerRect.x - buildOpts.outerRect.x - buildOpts.stepSize / 2);
    struct.collider = {
      type: 'rect',
      x: leftBoundary,
      y: 0,
      width: leftBoundary < 0 ? buildOpts.stepSize + leftBoundary : buildOpts.stepSize,
      // Adjust collider so that it doesnt extend onto neighbor collider
      height: buildOpts.innerRect.height
    };
  } else {
    var _tickCenter = tick.position * buildOpts.innerRect.height;

    var topBoundary = _tickCenter + (buildOpts.innerRect.y - buildOpts.outerRect.y - buildOpts.stepSize / 2);
    struct.collider = {
      type: 'rect',
      x: 0,
      y: topBoundary,
      width: buildOpts.innerRect.width,
      height: topBoundary < 0 ? buildOpts.stepSize + topBoundary : buildOpts.stepSize // Adjust collider so that it doesnt extend onto neighbor collider

    };
  } // Clip edges of the collider, should not extend beyoned the outerRect


  var collider = struct.collider;
  collider.x = Math.max(collider.x, 0);
  collider.y = Math.max(collider.y, 0);
  var widthClip = collider.x + collider.width - (buildOpts.outerRect.x + buildOpts.outerRect.width);
  collider.width = widthClip > 0 ? collider.width - widthClip : collider.width;
  var heightClip = collider.y + collider.height - (buildOpts.outerRect.y + buildOpts.outerRect.height);
  collider.height = heightClip > 0 ? collider.height - heightClip : collider.height;
}

function boundsCollider(tick, struct) {
  struct.collider = {
    type: 'polygon',
    vertices: [{
      x: struct.boundingRect.x,
      y: struct.boundingRect.y
    }, {
      x: struct.boundingRect.x + struct.boundingRect.width,
      y: struct.boundingRect.y
    }, {
      x: struct.boundingRect.x + struct.boundingRect.width,
      y: struct.boundingRect.y + struct.boundingRect.height
    }, {
      x: struct.boundingRect.x,
      y: struct.boundingRect.y + struct.boundingRect.height
    }]
  };
}

function tiltedCollider(tick, struct, buildOpts) {
  var radians = buildOpts.angle * (Math.PI / 180);
  var halfWidth = Math.max(buildOpts.stepSize / 2, struct.boundingRect.height / 2); // Handle if bandwidth is zero

  var startAnchor = struct.anchor === 'start';
  var em = struct.anchor === 'end' && radians < 0;
  var sp = struct.anchor === 'start' && radians >= 0;
  var y = struct.boundingRect.y + (sp || em ? struct.boundingRect.height : 0); // Generate starting points at bandwidth boundaries

  var points = [{
    x: struct.x - halfWidth,
    y: y
  }, {
    x: struct.x + halfWidth,
    y: y
  }].map(function (p) {
    return rotate(p, radians, {
      x: struct.x,
      y: struct.y
    });
  }); // Rotate around center point to counteract labels rotation
  // Append points to wrap polygon around label

  var margin = 10; // extend slightly to handle single char labels better

  var leftPoint = {
    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,
    y: struct.boundingRect.y + struct.boundingRect.height
  };
  var rightPoint = {
    x: startAnchor ? struct.boundingRect.x + struct.boundingRect.width + margin : struct.boundingRect.x - margin,
    y: struct.boundingRect.y
  };
  var orderedPoints = radians >= 0 ? [leftPoint, rightPoint] : [rightPoint, leftPoint];
  points.push.apply(points, orderedPoints);
  struct.collider = {
    type: 'polygon',
    vertices: points
  };
}

function appendCollider(tick, struct, buildOpts) {
  if (buildOpts.layered || !buildOpts.stepSize) {
    boundsCollider(tick, struct);
  } else if (buildOpts.tilted) {
    tiltedCollider(tick, struct, buildOpts);
  } else {
    bandwidthCollider(tick, struct, buildOpts);
  }
}

function appendBounds(struct, buildOpts) {
  struct.boundingRect = buildOpts.textBounds(struct);
}

function wiggle(buildOpts, isVertical) {
  var a = isNaN(buildOpts.style.align) ? 0.5 : Math.min(Math.max(buildOpts.style.align, 0), 1);
  var w = 0;

  if (buildOpts.tilted) {
    w = buildOpts.stepSize * a;
  } else {
    var size = isVertical ? buildOpts.textRect.height : buildOpts.textRect.width;
    w = Math.max(0, buildOpts.stepSize - size) * a;
  }

  return w;
}

function buildNode(tick, buildOpts) {
  var struct = {
    type: 'text',
    text: checkText(tick.label),
    x: 0,
    y: 0,
    maxWidth: buildOpts.maxWidth,
    maxHeight: buildOpts.maxHeight
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x = tick.start * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x) + wiggle(buildOpts, false);
    struct.y = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;
    struct.anchor = buildOpts.stepSize ? 'start' : 'middle';
    struct.x += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;
  } else {
    struct.y = tick.start * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y) + wiggle(buildOpts, true);
    struct.x = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;
    struct.anchor = buildOpts.align === 'left' ? 'end' : 'start';
    struct.baseline = buildOpts.stepSize ? 'text-before-edge' : 'central';
    struct.y += isNaN(buildOpts.style.offset) ? 0 : +buildOpts.style.offset;
  }

  appendStyle$1(struct, buildOpts);
  clampEnds(struct, buildOpts);
  appendPadding(struct, buildOpts);
  appendTilting(struct, buildOpts);
  appendBounds(struct, buildOpts);
  appendCollider(tick, struct, buildOpts);
  return struct;
}

function appendStyle$2(struct, buildOpts) {
  extend(struct, buildOpts.style);
}

function appendPadding$1(struct, buildOpts) {
  if (buildOpts.align === 'top') {
    struct.y1 -= buildOpts.padding;
    struct.y2 -= buildOpts.padding;
  } else if (buildOpts.align === 'bottom') {
    struct.y1 += buildOpts.padding;
    struct.y2 += buildOpts.padding;
  } else if (buildOpts.align === 'left') {
    struct.x1 -= buildOpts.padding;
    struct.x2 -= buildOpts.padding;
  } else if (buildOpts.align === 'right') {
    struct.x1 += buildOpts.padding;
    struct.x2 += buildOpts.padding;
  }
}

function adjustForEnds(struct, buildOpts) {
  var halfWidth = struct.strokeWidth / 2;

  if (struct.x1 === buildOpts.innerRect.width) {
    // outer end tick
    struct.x1 -= halfWidth;
    struct.x2 -= halfWidth;
  } else if (struct.x1 === 0) {
    // outer start tick
    struct.x1 += halfWidth;
    struct.x2 += halfWidth;
  } else if (struct.y1 === buildOpts.innerRect.height) {
    struct.y1 -= halfWidth;
    struct.y2 -= halfWidth;
  } else if (struct.y1 === 0) {
    struct.y1 += halfWidth;
    struct.y2 += halfWidth;
  }
}

function buildNode$1(tick, buildOpts) {
  var struct = {
    type: 'line',
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 0,
    collider: {
      type: null
    }
  };

  if (buildOpts.align === 'top' || buildOpts.align === 'bottom') {
    struct.x1 = struct.x2 = tick.position * buildOpts.innerRect.width + (buildOpts.innerRect.x - buildOpts.outerRect.x);
    struct.y1 = buildOpts.align === 'top' ? buildOpts.innerRect.height : 0;
    struct.y2 = buildOpts.align === 'top' ? struct.y1 - buildOpts.tickSize : struct.y1 + buildOpts.tickSize;
  } else {
    struct.y1 = struct.y2 = tick.position * buildOpts.innerRect.height + (buildOpts.innerRect.y - buildOpts.outerRect.y);
    struct.x1 = buildOpts.align === 'left' ? buildOpts.innerRect.width : 0;
    struct.x2 = buildOpts.align === 'left' ? struct.x1 - buildOpts.tickSize : struct.x1 + buildOpts.tickSize;
  }

  appendStyle$2(struct, buildOpts);
  appendPadding$1(struct, buildOpts);
  adjustForEnds(struct, buildOpts);
  return struct;
}

function isMajorTick(tick) {
  return !tick.isMinor && tick.position >= 0 && tick.position <= 1;
}

function isVerticalLabelOverlapping(_ref) {
  var majorTicks = _ref.majorTicks,
      measureText = _ref.measureText,
      rect = _ref.rect;
  var size = rect.height;
  var textHeight = measureText('M').height;

  if (majorTicks.length < 2) {
    return false;
  }

  var d = size * Math.abs(majorTicks[0].position - majorTicks[1].position);

  if (d < textHeight) {
    return true;
  }

  return false;
}

function isHorizontalLabelOverlapping(_ref2) {
  var majorTicks = _ref2.majorTicks,
      measureText = _ref2.measureText,
      rect = _ref2.rect,
      state = _ref2.state;

  /*
   * Currently isn't any good way of doing a accurate measurement on size available (bandWidth * width) for labels.
   * It's a lifecycle limitation as components docked either left or right can affect the width available after the calculation is done.
   * <number of components docked left/right> * <width of components> => Less accurate ===> Can result in only ellips char rendered as labels.
   */
  var m = state.labels.activeMode === 'layered' ? 2 : 1;
  var size = rect.width;
  var tickSize = majorTicks.map(function (tick) {
    return tick.label;
  }).map(function (l) {
    return "".concat(l.slice(0, 1)).concat(l.length > 1 ? '…' : '');
  }) // Measure the size of 1 chars + the ellips char.
  .map(measureText).map(function (r) {
    return r.width;
  });

  for (var i = 0; i < majorTicks.length; ++i) {
    var tick = majorTicks[i];
    var d1 = m * size * Math.abs(tick.start - tick.end);
    var d2 = tickSize[i];

    if (d1 < d2) {
      return true;
    }
  }

  return false;
}

function shouldAutoTilt(_ref3) {
  var majorTicks = _ref3.majorTicks,
      measure = _ref3.measure,
      rect = _ref3.rect,
      state = _ref3.state,
      settings = _ref3.settings;
  var glyphCount = settings.labels.maxGlyphCount;
  var m = state.labels.activeMode === 'layered' ? 2 : 1;
  var magicSizeRatioMultipler = settings.labels.tiltThreshold ? settings.labels.tiltThreshold : 0.7; // So that if less the 70% of labels are visible, toggle on tilt or use variable tiltThreshold

  var ellipsCharSize = measure('…').width; // include ellipsed char in calc as it's generally large then the char it replaces

  var size = rect.width;
  var maxLabelWidth = 0;
  var d1 = 0;

  if (!isNaN(glyphCount)) {
    var minBandwidth = majorTicks.reduce(function (prev, curr) {
      return Math.min(Math.abs(curr.start - curr.end), prev);
    }, Infinity);
    d1 = m * size * minBandwidth;
    maxLabelWidth = measure('M').width * magicSizeRatioMultipler * glyphCount;

    if (maxLabelWidth + ellipsCharSize > d1) {
      return true;
    }
  } else {
    for (var i = 0; i < majorTicks.length; i++) {
      var tick = majorTicks[i];
      var label = tick.label;
      var width = measure(label).width * (label.length > 1 ? magicSizeRatioMultipler : 1);
      d1 = m * size * Math.abs(tick.start - tick.end);

      if (width + ellipsCharSize > d1) {
        return true;
      }
    }
  }

  return false;
}

function isTiltedLabelOverlapping(_ref4) {
  var majorTicks = _ref4.majorTicks,
      measureText = _ref4.measureText,
      rect = _ref4.rect,
      bleedSize = _ref4.bleedSize,
      angle = _ref4.angle;

  if (majorTicks.length < 2) {
    return false;
  }

  if (angle === 0) {
    return true; // TODO 0 angle should be considered non-tilted
  }

  var absAngle = Math.abs(angle);
  var size = rect.width - bleedSize;
  var stepSize = size * Math.abs(majorTicks[0].position - majorTicks[1].position);
  var textHeight = measureText('M').height;
  var reciprocal = 1 / stepSize; // 1 === Math.sin(90 * (Math.PI / 180))

  var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;
  return textHeight > distanceBetweenLabels;
}

function isToLarge(_ref5) {
  var rect = _ref5.rect,
      state = _ref5.state,
      majorTicks = _ref5.majorTicks,
      measure = _ref5.measure,
      horizontal = _ref5.horizontal;

  if (horizontal) {
    return isHorizontalLabelOverlapping({
      majorTicks: majorTicks,
      measureText: measure,
      rect: rect,
      state: state
    });
  }

  return isVerticalLabelOverlapping({
    majorTicks: majorTicks,
    measureText: measure,
    rect: rect,
    state: state
  });
}

function getClampedValue(_ref6) {
  var value = _ref6.value,
      maxValue = _ref6.maxValue,
      minValue = _ref6.minValue,
      range = _ref6.range,
      modifier = _ref6.modifier;

  if (!isNaN(range) && !isNaN(modifier)) {
    value = range * modifier;
  }

  if (value > maxValue) {
    value = maxValue;
  }

  if (value < minValue) {
    value = minValue;
  }

  return value;
}
function getSize(_ref7) {
  var isDiscrete = _ref7.isDiscrete,
      rect = _ref7.rect,
      formatter = _ref7.formatter,
      measureText = _ref7.measureText,
      scale = _ref7.scale,
      settings = _ref7.settings,
      state = _ref7.state;
  var size = 0;
  var edgeBleed = {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  };
  var _settings$labels = settings.labels,
      maxValue = _settings$labels.maxLengthPx,
      minValue = _settings$labels.minLengthPx;

  if (settings.labels.show) {
    var align = settings.align;
    var horizontal = align === 'top' || align === 'bottom';
    var distance = horizontal ? rect.width : rect.height;
    var majorTicks = scale.ticks({
      settings: settings,
      distance: distance,
      formatter: formatter
    }).filter(isMajorTick);

    var measure = function measure(text) {
      var m = measureText({
        text: text,
        fontSize: settings.labels.fontSize,
        fontFamily: settings.labels.fontFamily
      });
      m.width = getClampedValue({
        value: m.width,
        maxValue: maxValue,
        minValue: minValue
      });
      return m;
    };

    if (isDiscrete && horizontal && settings.labels.mode === 'auto') {
      if (shouldAutoTilt({
        majorTicks: majorTicks,
        measure: measure,
        rect: rect,
        state: state,
        settings: settings
      })) {
        state.labels.activeMode = 'tilted';
      } else {
        state.labels.activeMode = 'horizontal';
      }
    }

    if (!settings.labels.filterOverlapping && state.labels.activeMode !== 'tilted' && isToLarge({
      rect: rect,
      state: state,
      majorTicks: majorTicks,
      measure: measure,
      horizontal: horizontal
    })) {
      var toLargeSize = Math.max(rect.width, rect.height); // used to hide the axis

      return {
        size: toLargeSize,
        isToLarge: true
      };
    }

    var sizeFromTextRect;

    if (state.labels.activeMode === 'tilted') {
      var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians

      sizeFromTextRect = function sizeFromTextRect(r) {
        return getClampedValue({
          value: r.width,
          maxValue: maxValue,
          minValue: minValue
        }) * Math.sin(radians) + r.height * Math.cos(radians);
      };
    } else if (horizontal) {
      sizeFromTextRect = function sizeFromTextRect(r) {
        return r.height;
      };
    } else {
      sizeFromTextRect = function sizeFromTextRect(r) {
        return getClampedValue({
          value: r.width,
          maxValue: maxValue,
          minValue: minValue
        });
      };
    }

    var labels;

    if (horizontal && state.labels.activeMode !== 'tilted') {
      labels = ['M'];
    } else if (!isNaN(settings.labels.maxGlyphCount)) {
      var label = '';

      for (var i = 0; i < settings.labels.maxGlyphCount; i++) {
        label += 'M';
      }

      labels = [label];
    } else {
      labels = majorTicks.map(function (tick) {
        return tick.label;
      });
    }

    var tickMeasures = labels.map(measure);
    var labelSizes = tickMeasures.map(sizeFromTextRect);
    var textSize = Math.max.apply(Math, _toConsumableArray$1(labelSizes).concat([0]));
    size += textSize;
    size += settings.labels.margin;

    if (state.labels.activeMode === 'layered') {
      size *= 2;
    }

    if (state.labels.activeMode === 'tilted') {
      var extendLeft = settings.align === 'bottom' === settings.labels.tiltAngle >= 0;

      var _radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180); // angle in radians


      var h = measureText('M').height;
      var maxWidth = (textSize - h * Math.cos(_radians)) / Math.sin(_radians);

      var labelWidth = function labelWidth(r) {
        return Math.min(maxWidth, r.width) * Math.cos(_radians) + r.height;
      };

      var adjustByPosition = function adjustByPosition(s, i) {
        var pos = majorTicks[i] ? majorTicks[i].position : 0;

        if (extendLeft) {
          return s - pos * rect.width;
        }

        return s - (1 - pos) * rect.width;
      };

      var bleedSize = Math.min(settings.labels.maxEdgeBleed, Math.max.apply(Math, _toConsumableArray$1(tickMeasures.map(labelWidth).map(adjustByPosition)).concat([0]))) + settings.paddingEnd;
      var bleedDir = extendLeft ? 'left' : 'right';
      edgeBleed[bleedDir] = bleedSize;

      if (!settings.labels.filterOverlapping && isTiltedLabelOverlapping({
        majorTicks: majorTicks,
        measureText: measureText,
        rect: rect,
        bleedSize: bleedSize,
        angle: settings.labels.tiltAngle
      })) {
        return {
          size: Math.max(rect.width, rect.height),
          isToLarge: true
        };
      }
    }
  }

  return {
    size: size,
    edgeBleed: edgeBleed
  };
}

var PADDING = 2;

var tickDistance = function tickDistance(rect, start, end) {
  return rect.width * Math.abs(start.position - end.position);
};

var getLeftEdgeWidth = function getLeftEdgeWidth(_ref) {
  var innerRect = _ref.innerRect,
      outerRect = _ref.outerRect,
      tick = _ref.tick,
      nextWidth = _ref.nextWidth;
  var leftEdgeBleed = innerRect.x - outerRect.x;
  var left = innerRect.width * tick.position + leftEdgeBleed;
  var minDubble = Math.min(nextWidth, left) * 2;
  var minWidth = tick.position === 0 ? innerRect.width / 2 - PADDING : 0;
  return Math.max(nextWidth, minDubble, minWidth);
};

var getRightEdgeWidth = function getRightEdgeWidth(_ref2) {
  var innerRect = _ref2.innerRect,
      outerRect = _ref2.outerRect,
      tick = _ref2.tick,
      prevWidth = _ref2.prevWidth;
  var leftEdgeBleed = innerRect.x - outerRect.x;
  var rightEdgeBleed = outerRect.width - innerRect.width - leftEdgeBleed;
  var right = innerRect.width - innerRect.width * tick.position + rightEdgeBleed;
  var minDubble = Math.min(prevWidth, right) * 2;
  var minWidth = tick.position === 1 ? innerRect.width / 2 - PADDING : 0;
  return Math.max(prevWidth, minDubble, minWidth);
};

function getHorizontalWidth(_ref3) {
  var layered = _ref3.layered,
      major = _ref3.major,
      innerRect = _ref3.innerRect,
      outerRect = _ref3.outerRect,
      tick = _ref3.tick,
      index = _ref3.index;
  var step = layered ? 2 : 1;
  var prev = major[index - step];
  var next = major[index + step];
  var prevWidth = prev ? tickDistance(innerRect, tick, prev) / 2 - PADDING : Infinity;
  var nextWidth = next ? tickDistance(innerRect, tick, next) / 2 - PADDING : Infinity;

  if (major.length < 2) {
    return innerRect.width;
  }

  if (!prev) {
    return getLeftEdgeWidth({
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      nextWidth: nextWidth
    });
  }

  if (!next) {
    return getRightEdgeWidth({
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      prevWidth: prevWidth
    });
  }

  return Math.min(prevWidth, nextWidth) * 2;
}

function tickSpacing(settings) {
  var spacing = 0;
  spacing += settings.paddingStart;
  spacing += settings.line.show ? settings.line.strokeWidth : 0;
  spacing += settings.ticks.show ? settings.ticks.margin : 0;
  return spacing;
}

function tickMinorSpacing(settings) {
  return settings.line.strokeWidth + settings.minorTicks.margin;
}

function labelsSpacing(settings) {
  var spacing = 0;
  spacing += settings.ticks.show ? settings.ticks.tickSize : 0;
  spacing += tickSpacing(settings) + settings.labels.margin;
  return spacing;
}

function calcActualTextRect(_ref) {
  var style = _ref.style,
      measureText = _ref.measureText,
      tick = _ref.tick;
  return measureText({
    text: tick.label,
    fontSize: style.fontSize,
    fontFamily: style.fontFamily
  });
}

function majorTicks(ticks) {
  return ticks.filter(function (t) {
    return !t.isMinor;
  });
}

function minorTicks(ticks) {
  return ticks.filter(function (t) {
    return t.isMinor;
  });
}

function tickBuilder(ticks, buildOpts) {
  return ticks.map(function (tick) {
    return buildNode$1(tick, buildOpts);
  });
}

function tickBandwidth(scale, tick) {
  return tick ? Math.abs(tick.end - tick.start) : scale.bandwidth();
}

function labelBuilder(ticks, buildOpts, resolveTickOpts) {
  return ticks.map(function (tick, idx) {
    resolveTickOpts(tick, idx);
    var label = buildNode(tick, buildOpts);
    label.data = tick.data;
    return label;
  });
}

function layeredLabelBuilder(ticks, buildOpts, settings, resolveTickOpts) {
  var padding = buildOpts.padding;
  var spacing = labelsSpacing(settings);
  return ticks.map(function (tick, idx) {
    resolveTickOpts(tick, idx);
    var padding2 = spacing + buildOpts.maxHeight + settings.labels.margin;
    buildOpts.layer = idx % 2;
    buildOpts.padding = idx % 2 === 0 ? padding : padding2;
    var label = buildNode(tick, buildOpts);
    label.data = tick.data;
    return label;
  });
}

function filterOverlappingLabels(labels, ticks, buildOpts) {
  var isOverlapping = function isOverlapping(i, k) {
    var rect1 = expandRect(1, labels[i].boundingRect);
    var rect2 = expandRect(1, labels[k].boundingRect);
    return testRectRect(rect1, rect2);
  };

  if (buildOpts && buildOpts.tilted) {
    var absAngle = Math.abs(buildOpts.angle);

    isOverlapping = function isOverlapping(i, k) {
      var stepSize = Math.abs(labels[i].x - labels[k].x);
      var reciprocal = 1 / stepSize;
      var distanceBetweenLabels = Math.sin(absAngle * (Math.PI / 180)) / reciprocal;
      return labels[i].boundingRect.height > distanceBetweenLabels;
    };
  }

  for (var i = 0; i <= labels.length - 1; i++) {
    for (var k = i + 1; k <= Math.min(i + 5, i + (labels.length - 1)); k++) {
      // TODO Find a better way to handle exteme/layered labels then to iterare over ~5 next labels
      if (labels[i] && labels[k] && isOverlapping(i, k)) {
        if (k === labels.length - 1) {
          // On collition with last label, remove current label instead
          labels.splice(i, 1);

          if (ticks) {
            ticks.splice(i, 1);
          }
        } else {
          labels.splice(k, 1);

          if (ticks) {
            ticks.splice(k, 1);
          }
        }

        k--;
        i--;
      }
    }
  }
}

function discreteCalcMaxTextRect(_ref2) {
  var textMetrics = _ref2.textMetrics,
      settings = _ref2.settings,
      innerRect = _ref2.innerRect,
      scale = _ref2.scale,
      tilted = _ref2.tilted,
      layered = _ref2.layered,
      tick = _ref2.tick;
  var h = textMetrics.height;
  var bandwidth = tickBandwidth(scale, tick);
  var textRect = {
    width: 0,
    height: h
  };

  if (settings.align === 'left' || settings.align === 'right') {
    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;
  } else if (layered) {
    textRect.width = bandwidth * innerRect.width * 2;
  } else if (tilted) {
    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);
    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);
  } else {
    textRect.width = bandwidth * innerRect.width;
  }

  textRect.width = getClampedValue({
    value: textRect.width,
    maxValue: settings.labels.maxLengthPx,
    minValue: settings.labels.minLengthPx
  });
  return textRect;
}

function continuousCalcMaxTextRect(_ref3) {
  var textMetrics = _ref3.textMetrics,
      settings = _ref3.settings,
      innerRect = _ref3.innerRect,
      outerRect = _ref3.outerRect,
      tilted = _ref3.tilted,
      layered = _ref3.layered,
      tick = _ref3.tick,
      index = _ref3.index,
      major = _ref3.major;
  var h = textMetrics.height;
  var textRect = {
    width: 0,
    height: h
  };

  if (settings.align === 'left' || settings.align === 'right') {
    textRect.width = innerRect.width - labelsSpacing(settings) - settings.paddingEnd;
  } else if (tilted) {
    var radians = Math.abs(settings.labels.tiltAngle) * (Math.PI / 180);
    textRect.width = (innerRect.height - labelsSpacing(settings) - settings.paddingEnd - h * Math.cos(radians)) / Math.sin(radians);
  } else {
    textRect.width = getHorizontalWidth({
      layered: layered,
      major: major,
      innerRect: innerRect,
      outerRect: outerRect,
      tick: tick,
      index: index
    });
  }

  textRect.width = getClampedValue({
    value: textRect.width,
    maxValue: settings.labels.maxLengthPx,
    minValue: settings.labels.minLengthPx
  });
  return textRect;
}

function getStepSizeFn(_ref4) {
  var innerRect = _ref4.innerRect,
      scale = _ref4.scale,
      settings = _ref4.settings,
      tick = _ref4.tick;
  var size = settings.align === 'top' || settings.align === 'bottom' ? innerRect.width : innerRect.height;
  var bandwidth = tickBandwidth(scale, tick);
  return size * bandwidth;
}

function nodeBuilder(isDiscrete) {
  var resolveLabelRect;

  function continuous() {
    resolveLabelRect = continuousCalcMaxTextRect;
    return continuous;
  }

  function discrete() {
    resolveLabelRect = discreteCalcMaxTextRect;
    return discrete;
  }

  function build(_ref5) {
    var settings = _ref5.settings,
        scale = _ref5.scale,
        innerRect = _ref5.innerRect,
        outerRect = _ref5.outerRect,
        measureText = _ref5.measureText,
        ticks = _ref5.ticks,
        state = _ref5.state,
        textBounds = _ref5.textBounds;
    var nodes = [];
    var major = majorTicks(ticks);
    var minor = minorTicks(ticks);
    var buildOpts = {
      innerRect: innerRect,
      align: settings.align,
      outerRect: outerRect
    };
    var tilted = state.labels.activeMode === 'tilted';
    var layered = state.labels.activeMode === 'layered';
    var majorTickNodes;

    if (settings.line.show) {
      buildOpts.style = settings.line;
      buildOpts.padding = settings.paddingStart;
      nodes.push(buildLine(buildOpts));
    }

    if (settings.ticks.show) {
      buildOpts.style = settings.ticks;
      buildOpts.tickSize = settings.ticks.tickSize;
      buildOpts.padding = tickSpacing(settings);
      majorTickNodes = tickBuilder(major, buildOpts);
    }

    if (settings.labels.show) {
      var padding = labelsSpacing(settings);
      buildOpts.style = settings.labels;
      buildOpts.padding = padding;
      buildOpts.tilted = tilted;
      buildOpts.layered = layered;
      buildOpts.angle = settings.labels.tiltAngle;
      buildOpts.paddingEnd = settings.paddingEnd;
      buildOpts.textBounds = textBounds;

      var resolveTickOpts = function resolveTickOpts(tick, index) {
        buildOpts.textRect = calcActualTextRect({
          tick: tick,
          measureText: measureText,
          style: buildOpts.style
        });
        var maxSize = resolveLabelRect({
          textMetrics: buildOpts.textRect,
          settings: settings,
          innerRect: innerRect,
          outerRect: outerRect,
          scale: scale,
          tilted: tilted,
          layered: layered,
          tick: tick,
          major: major,
          index: index
        });
        buildOpts.maxWidth = maxSize.width;
        buildOpts.maxHeight = maxSize.height;
        buildOpts.stepSize = getStepSizeFn({
          innerRect: innerRect,
          scale: scale,
          ticks: ticks,
          settings: settings,
          tick: tick
        });
      };

      var labelNodes = [];

      if (layered && (settings.align === 'top' || settings.align === 'bottom')) {
        labelNodes = layeredLabelBuilder(major, buildOpts, settings, resolveTickOpts);
      } else {
        labelNodes = labelBuilder(major, buildOpts, resolveTickOpts);
      } // Remove labels (and paired tick) that are overlapping


      if (settings.labels.filterOverlapping) {
        filterOverlappingLabels(labelNodes, majorTickNodes, buildOpts);
      }

      nodes.push.apply(nodes, _toConsumableArray$1(labelNodes));
    }

    if (settings.minorTicks && settings.minorTicks.show && minor.length > 0) {
      buildOpts.style = settings.minorTicks;
      buildOpts.tickSize = settings.minorTicks.tickSize;
      buildOpts.padding = tickMinorSpacing(settings);
      nodes.push.apply(nodes, _toConsumableArray$1(tickBuilder(minor, buildOpts)));
    }

    if (majorTickNodes) {
      nodes.push.apply(nodes, _toConsumableArray$1(majorTickNodes));
    }

    return nodes;
  }

  continuous.build = build;
  discrete.build = build;
  return isDiscrete ? discrete() : continuous();
}

// const DEFAULT_LAYOUT_SETTINGS = { // TODO create dis and con specific settings
//   anchor: 'auto', // TODO re-name from align..
//   // orientation: 'auto', // TODO impl. v/h/auto
//   // direction: 'auto', // TODO impl. left/right/top/bottom/auto
//   padding: { // TODO use dock layout margin instead..
//     start: 0,
//     end: 10
//   },
//   maxGlyphCount: NaN,
//   maxEdgeBleed: Infinity
//   // labelMode: 'auto' // TODO move here? auto, horizontal, layered
// };

/**
 * Discrete axis settings
 * @typedef {object}
 * @alias component--axis-discrete
 */
var DEFAULT_DISCRETE_SETTINGS = {
  /**
   * @typedef {object}
   */
  labels: {
    /** Toggle labels on/off
    * @type {boolean=} */
    show: true,

    /** Tilting angle in degrees. Capped between -90 and 90. Only applicable when labels are in `tilted` mode.
    * @type {number=} */
    tiltAngle: 40,

    /** Threshold for toggle of tilted labels. Capped between 0 and 1. For example, if it is set to 0.7, then tilted labels will be toggled if less than 70% of the labels are visible.
    * @type {number=}
    * @experimental */
    tiltThreshold: 0.7,

    /** Control the amount of space (in pixels) that labes can occupy outside their docking area. Only applicable when labels are in `tilted` mode.
    * @type {number=} */
    maxEdgeBleed: Infinity,

    /** Space in pixels between the tick and label.
    * @type {number=} */
    margin: 4,

    /** Max length of labels in pixels
    * @type {number=} */
    maxLengthPx: 150,

    /** Min length of labels in pixels. Labels will always at least require this much space
    * @type {number=} */
    minLengthPx: 0,

    /** Control how labels arrange themself. Availabe modes are `auto`, `horizontal`, `layered` and `tilted`. When set to `auto` the axis determines the best possible layout in the current context.
    * @type {string=} */
    mode: 'auto',

    /** When only a sub-set of data is available, ex. when paging. This property can be used to let the axis estimate how much space the labels will consume, allowing it to give a consistent space estimate over the entire dataset when paging.
    * @type {number=} */
    maxGlyphCount: NaN,

    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth. Except when labels are tilted, then the align is a pure align that shifts the position of the label anchoring point.
    * @type {number=} */
    align: 0.5,

    /** Offset in pixels along the axis direction.
    * @type {number=} */
    offset: 0,

    /**
     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
     * @type {boolean=}
     */
    filterOverlapping: false
  },

  /**
   * @typedef {object}
   */
  ticks: {
    /** Toggle ticks on/off
    * @type {boolean=} */
    show: false,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 4
  },

  /**
   * @typedef {object}
   */
  line: {
    /** Toggle line on/off
    * @type {boolean=} */
    show: false
  },

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingStart: 0,

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingEnd: 10,

  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
    * @type {string=} */
  align: 'auto'
};
/**
 * Continuous axis settings
 * @typedef {object}
 * @alias component--axis-continuous
 */

var DEFAULT_CONTINUOUS_SETTINGS = {
  /**
   * @typedef {object}
   */
  labels: {
    /** Toggle labels on/off
    * @type {boolean=} */
    show: true,

    /** Space in pixels between the tick and label.
    * @type {number=} */
    margin: 4,

    /** Max length of labels in pixels
    * @type {number=} */
    maxLengthPx: 150,

    /** Min length of labels in pixels. Labels will always at least require this much space
    * @type {number=} */
    minLengthPx: 0,

    /** Align act as a slider for the text bounding rect over the item bandwidth, given that the item have a bandwidth.
    * @type {number=} */
    align: 0.5,

    /** Offset in pixels along the axis direction.
    * @type {number=} */
    offset: 0,

    /**
     * Toggle whether labels should be filtered if they are overlapping. Filtering may be applied in a non-sequential order.
     * If labels are overlapping and this setting is toggled off, the axis will automatically hide.
     * @type {boolean=}
     */
    filterOverlapping: true
  },

  /**
   * @typedef {object}
   */
  ticks: {
    /** Toggle ticks on/off
    * @type {boolean=} */
    show: true,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 8
  },

  /**
   * @typedef {object}
   */
  minorTicks: {
    /** Toggle minor-ticks on/off
    * @type {boolean=} */
    show: false,

    /** Size of the ticks in pixels.
    * @type {number=} */
    tickSize: 3,

    /** Space in pixels between the ticks and the line.
    * @type {number=} */
    margin: 0
  },

  /**
   * @typedef {object}
   */
  line: {
    /** Toggle line on/off
    * @type {boolean=} */
    show: true
  },

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingStart: 0,

  /** Padding in direction perpendicular to the axis
    * @type {number=} */
  paddingEnd: 10,

  /** Set the anchoring point of the axis. Avaialable options are `auto/left/right/bottom/top`. In `auto` the axis determines the best option. The options are restricted based on the axis orientation, a vertical axis may only anchor on `left` or `right`
    * @type {string=} */
  align: 'auto'
};

function calcRequiredSize(_ref) {
  var isDiscrete = _ref.isDiscrete,
      rect = _ref.rect,
      formatter = _ref.formatter,
      measureText = _ref.measureText,
      scale = _ref.scale,
      settings = _ref.settings,
      state = _ref.state;
  var size = 0;

  var _getLabelSize = getSize({
    isDiscrete: isDiscrete,
    rect: rect,
    formatter: formatter,
    measureText: measureText,
    scale: scale,
    settings: settings,
    state: state
  }),
      labelSize = _getLabelSize.size,
      edgeBleed = _getLabelSize.edgeBleed,
      isToLarge = _getLabelSize.isToLarge;

  size += labelSize;

  if (isToLarge) {
    return {
      size: size
    };
  }

  if (settings.ticks.show) {
    size += settings.ticks.margin;
    size += settings.ticks.tickSize;
  }

  if (settings.minorTicks && settings.minorTicks.show) {
    var minorTicksSize = settings.minorTicks.margin + settings.minorTicks.tickSize;

    if (minorTicksSize > size) {
      size = minorTicksSize;
    }
  }

  if (settings.line.show) {
    size += settings.line.strokeWidth;
  }

  size += settings.paddingStart;
  size += settings.paddingEnd;
  return {
    size: size,
    edgeBleed: edgeBleed
  };
}

function alignTransform(_ref) {
  var align = _ref.align,
      inner = _ref.inner;

  if (align === 'left') {
    return {
      x: inner.width + inner.x
    };
  }

  if (align === 'right' || align === 'bottom') {
    return inner;
  }

  return {
    y: inner.y + inner.height
  };
}

function resolveAlign(align, dock) {
  var horizontal = ['top', 'bottom'];
  var vertical = ['left', 'right'];

  if (horizontal.indexOf(align) !== -1 && vertical.indexOf(dock) === -1) {
    return align;
  }

  if (vertical.indexOf(align) !== -1 && horizontal.indexOf(dock) === -1) {
    return align;
  }

  return dock; // Invalid align, return current dock as default
}
/**
 * @ignore
 * @param {object} context - The component context
 */


function resolveLocalSettings(_ref2) {
  var state = _ref2.state,
      style = _ref2.style,
      settings = _ref2.settings;
  var defaultStgns = extend(true, {}, state.isDiscrete ? DEFAULT_DISCRETE_SETTINGS : DEFAULT_CONTINUOUS_SETTINGS, style);
  var localStgns = extend(true, {}, defaultStgns, settings.settings);
  var dock = settings.layout.dock || state.defaultDock;
  localStgns.dock = dock;
  localStgns.align = resolveAlign(settings.settings.align, dock);
  localStgns.labels.tiltAngle = Math.max(-90, Math.min(localStgns.labels.tiltAngle, 90));
  return localStgns;
}

function updateActiveMode(state, settings, isDiscrete) {
  var mode = settings.labels.mode;

  if (!isDiscrete || !state.isHorizontal) {
    return 'horizontal';
  }

  if (mode === 'auto') {
    return state.labels.activeMode;
  }

  if (['layered', 'tilted'].indexOf(settings.labels.mode) !== -1 && ['top', 'bottom'].indexOf(settings.dock) !== -1) {
    return mode;
  }

  return 'horizontal';
}

var axisComponent = {
  require: ['chart', 'renderer', 'dockConfig'],
  defaultSettings: {
    layout: {
      displayOrder: 0,
      prioOrder: 0
    },
    settings: {},
    style: {
      labels: '$label',
      ticks: '$guide-line',
      minorTicks: '$guide-line--minor',
      line: '$guide-line'
    }
  },
  created: function created() {
    // State is a representation of properties that are private to this component defintion and may be modified by only in this context.
    this.state = {
      isDiscrete: !!this.scale.bandwidth,
      isHorizontal: false,
      labels: {
        activeMode: 'horizontal'
      },
      ticks: [],
      innerRect: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      },
      outerRect: {
        width: 0,
        height: 0,
        x: 0,
        y: 0
      },
      defaultDock: undefined,
      concreteNodeBuilder: undefined,
      settings: undefined
    };

    if (this.state.isDiscrete) {
      this.state.defaultDock = 'bottom';
    } else {
      this.state.defaultDock = 'left';
    }

    this.setState(this.settings);
  },
  setState: function setState() {
    this.state.isDiscrete = !!this.scale.bandwidth;
    this.state.settings = resolveLocalSettings(this);
    this.state.concreteNodeBuilder = nodeBuilder(this.state.isDiscrete);
    this.dockConfig.dock(this.state.settings.dock); // Override the dock setting (TODO should be removed)

    this.state.isHorizontal = this.state.settings.align === 'top' || this.state.settings.align === 'bottom';
    this.state.labels.activeMode = updateActiveMode(this.state, this.state.settings, this.state.isDiscrete);
  },
  preferredSize: function preferredSize(opts) {
    var formatter = this.formatter,
        state = this.state,
        scale = this.scale;
    var distance = this.state.isHorizontal ? opts.inner.width : opts.inner.height;
    this.state.pxScale = scaleWithSize(scale, distance);
    var reqSize = calcRequiredSize({
      isDiscrete: this.state.isDiscrete,
      rect: opts.inner,
      formatter: formatter,
      measureText: this.renderer.measureText,
      scale: this.state.pxScale,
      settings: this.state.settings,
      state: state
    });
    return reqSize;
  },
  beforeUpdate: function beforeUpdate() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var settings = opts.settings;
    this.setState(settings);
  },
  resize: function resize(opts) {
    var inner = opts.inner,
        outer = opts.outer;
    var extendedInner = extend({}, inner, alignTransform({
      align: this.state.settings.align,
      inner: inner
    }));
    var finalOuter = outer || extendedInner;
    extend(this.state.innerRect, extendedInner);
    extend(this.state.outerRect, finalOuter);
    return outer;
  },
  beforeRender: function beforeRender() {
    var scale = this.scale,
        formatter = this.formatter;
    var distance = this.state.isHorizontal ? this.state.innerRect.width : this.state.innerRect.height;
    this.state.pxScale = scaleWithSize(scale, distance);
    this.state.ticks = this.state.pxScale.ticks({
      distance: distance,
      formatter: formatter
    }).filter(function (t) {
      return t.position >= 0 && t.position <= 1;
    });
  },
  render: function render() {
    var state = this.state;
    var nodes = [];
    nodes.push.apply(nodes, _toConsumableArray$1(this.state.concreteNodeBuilder.build({
      settings: this.state.settings,
      scale: this.state.pxScale,
      innerRect: this.state.innerRect,
      outerRect: this.state.outerRect,
      measureText: this.renderer.measureText,
      textBounds: this.renderer.textBounds,
      ticks: this.state.ticks,
      state: state
    })));
    crispifier.multiple(nodes);
    return nodes;
  }
};

/**
 * @typedef {object} component--axis
 */

/**
 * @type {string}
 * @memberof component--axis
 */

var type$1 = 'axis';
function picasso_esm_axis(picasso) {
  picasso.component(type$1, axisComponent);
}

function parseTitle(text, join, scale) {
  var title = '';

  if (typeof text === 'function') {
    title = text();
  } else if (typeof text === 'string') {
    title = text;
  } else if (scale) {
    var data = scale.data();
    var titles = (data.fields || []).map(function (field) {
      return field.title();
    });
    title = titles.join(join);
  }

  return title;
}

function getTextAnchor(dock, anchor) {
  var val = 'middle';

  if (dock === 'left') {
    if (anchor === 'top') {
      val = 'end';
    } else if (anchor === 'bottom') {
      val = 'start';
    }
  } else if (dock === 'right') {
    if (anchor === 'top') {
      val = 'start';
    } else if (anchor === 'bottom') {
      val = 'end';
    }
  } else if (anchor === 'left') {
    val = 'start';
  } else if (anchor === 'right') {
    val = 'end';
  }

  return val;
}

function generateTitle(_ref) {
  var title = _ref.title,
      definitionSettings = _ref.definitionSettings,
      dock = _ref.dock,
      rect = _ref.rect,
      measureText = _ref.measureText,
      style = _ref.style;
  var struct = {
    type: 'text',
    text: title,
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    anchor: getTextAnchor(dock, definitionSettings.anchor),
    baseline: 'alphabetical'
  };
  extend(struct, style.text);
  var textRect = measureText(struct);

  if (dock === 'top' || dock === 'bottom') {
    var x = rect.width / 2;

    if (definitionSettings.anchor === 'left') {
      x = definitionSettings.paddingLeft || 0;
    } else if (definitionSettings.anchor === 'right') {
      x = rect.width - (definitionSettings.paddingRight || 0);
    }

    struct.x = x;
    struct.y = dock === 'top' ? rect.height - definitionSettings.paddingStart : definitionSettings.paddingStart + textRect.height;
    struct.dy = dock === 'top' ? -(textRect.height / 6) : -(textRect.height / 3);
    struct.maxWidth = rect.width * 0.8;
  } else {
    var y = rect.height / 2;

    if (definitionSettings.anchor === 'top') {
      y = definitionSettings.paddingStart;
    } else if (definitionSettings.anchor === 'bottom') {
      y = rect.height - definitionSettings.paddingStart;
    }

    struct.y = y;
    struct.x = dock === 'left' ? rect.width - definitionSettings.paddingStart : definitionSettings.paddingStart;
    struct.dx = dock === 'left' ? -(textRect.height / 3) : textRect.height / 3;
    var rotation = dock === 'left' ? 270 : 90;
    struct.transform = "rotate(".concat(rotation, ", ").concat(struct.x + struct.dx, ", ").concat(struct.y + struct.dy, ")");
    struct.maxWidth = rect.height * 0.8;
  }

  if (!isNaN(definitionSettings.maxLengthPx)) {
    struct.maxWidth = Math.min(struct.maxWidth, definitionSettings.maxLengthPx);
  }

  return struct;
}
/**
 * @typedef {object} component--text
 * @property {string} [type='text']
 * @property {string|function} text
 * @property {component--text-settings} settings - Text settings
 * @example
 * {
 *  type: 'text',
 *  text: 'my title',
 *  dock: 'left',
 *  settings: {
 *    anchor: 'left',
 *    style: {
 *      fill: 'red'
 *    }
 *  }
 * }
 */

/**
 * @typedef {object} component--text-settings
 * @property {number} [paddingStart=5]
 * @property {number} [paddingEnd=5]
 * @property {number} [paddingLeft=0]
 * @property {number} [paddingRight=0]
 * @property {string} [anchor='center'] - Where to v- or h-align the text. Supports `left`, `right`, `top`, `bottom` and `center`
 * @property {string} [join=', '] - String to add when joining titles from multiple sources
 * @property {number} [maxLengthPx] - Limit the text length to this value in pixels
 */


var textComponent = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    layout: {
      dock: 'bottom',
      displayOrder: 0,
      prioOrder: 0
    },
    settings: {
      paddingStart: 5,
      paddingEnd: 5,
      paddingLeft: 0,
      paddingRight: 0,
      anchor: 'center',
      join: ', ',
      maxLengthPx: NaN
    },
    style: {
      text: '$title'
    }
  },
  created: function created() {
    this.definitionSettings = this.settings.settings;
    var text = this.settings.text;
    var join = this.definitionSettings.join;
    this.title = parseTitle(text, join, this.scale);
  },
  preferredSize: function preferredSize() {
    var height = this.renderer.measureText({
      text: this.title,
      fontSize: this.style.text.fontSize,
      fontFamily: this.style.text.fontFamily
    }).height;
    return height + this.definitionSettings.paddingStart + this.definitionSettings.paddingEnd;
  },
  render: function render() {
    var title = this.title,
        definitionSettings = this.definitionSettings,
        rect = this.rect;
    var nodes = [];
    nodes.push(generateTitle({
      title: title,
      dock: this.settings.layout.dock,
      definitionSettings: definitionSettings,
      rect: rect,
      measureText: this.renderer.measureText,
      style: this.style
    }));
    return nodes;
  },
  beforeUpdate: function beforeUpdate(opts) {
    if (opts.settings) {
      extend(this.settings, opts.settings);
      this.definitionSettings = opts.settings.settings;
    }

    var text = this.settings.text;
    var join = this.definitionSettings.join;
    this.title = parseTitle(text, join, this.scale);
  }
};

function picasso_esm_text(picasso) {
  picasso.component('text', textComponent);
}

/**
 * @typedef {object} component--scrollbar
 * @private
 */

/**
 * @typedef {object} component--scrollbar.settings
 * @property {boolean} [backgroundColor = '#eee']
 * @property {boolean} [thumbColor = '#ccc']
 * @property {boolean} [width = 16]
 */
function picasso_esm_start(_scrollbar, pos) {
  var dock = _scrollbar.settings.layout.dock;
  var invert = _scrollbar.settings.settings.invert;
  var horizontal = dock === 'top' || dock === 'bottom';
  var lengthAttr = horizontal ? 'width' : 'height';
  var length = _scrollbar.rect[lengthAttr];

  var scroll = _scrollbar.chart.scroll(_scrollbar.settings.scroll);

  var currentMove;
  {
    // local scope to allow reuse of variable names later
    var offset = pos[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    var scrollState = scroll.getState();
    currentMove = {
      startOffset: offset,
      startScroll: scrollState.start,
      swipe: false
    }; // Detect swipe start outsize the thumb & change startScroll to jump the scroll there.

    var scrollPoint = offset / length * (scrollState.max - scrollState.min) + scrollState.min;

    if (scrollPoint < scrollState.start) {
      currentMove.startScroll = scrollPoint;
    } else if (scrollPoint > scrollState.start + scrollState.viewSize) {
      currentMove.startScroll = scrollPoint - scrollState.viewSize;
    }
  }

  var update = function update(p) {
    var offset = p[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    if (!currentMove.swipe) {
      if (Math.abs(currentMove.startOffset - offset) <= 1) {
        return;
      }

      currentMove.swipe = true;
    }

    var scrollState = scroll.getState();
    var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);
    var scrollStart = currentMove.startScroll + scrollMove;
    scroll.moveTo(scrollStart);
  };

  var end = function end(p) {
    var offset = p[horizontal ? 'x' : 'y'];

    if (invert) {
      offset = length - offset;
    }

    var scrollState = scroll.getState();

    if (currentMove.swipe) {
      var scrollMove = (offset - currentMove.startOffset) / length * (scrollState.max - scrollState.min);
      var scrollStart = currentMove.startScroll + scrollMove;
      scroll.moveTo(scrollStart);
    } else {
      var scrollCenter = offset / length * (scrollState.max - scrollState.min) + scrollState.min;

      var _scrollStart = scrollCenter - scrollState.viewSize / 2;

      scroll.moveTo(_scrollStart);
    }
  };

  return {
    update: update,
    end: end
  };
}

function getLocalPos(event, renderer) {
  var containerRect = renderer.element().getBoundingClientRect();
  return {
    x: event.center.x - containerRect.left,
    y: event.center.y - containerRect.top
  };
}

var scrollbarComponent = {
  require: ['chart', 'renderer'],
  on: {
    panStart: function panStart(event) {
      var pos = getLocalPos(event, this.renderer);
      var startPos = {
        x: pos.x - event.deltaX,
        y: pos.y - event.deltaY
      };
      this.currentMove = picasso_esm_start(this, startPos);
      this.currentMove.update(pos);
    },
    panMove: function panMove(event) {
      if (!this.currentMove) {
        return;
      }

      var pos = getLocalPos(event, this.renderer);
      this.currentMove.update(pos);
    },
    panEnd: function panEnd(event) {
      if (!this.currentMove) {
        return;
      }

      var pos = getLocalPos(event, this.renderer);
      this.currentMove.end(pos);
      this.currentMove = null;
    },
    panCancel: function panCancel() {
      this.currentMove = null;
    },
    tap: function tap(event) {
      var pos = getLocalPos(event, this.renderer);
      var move = picasso_esm_start(this, pos);
      move.end(pos);
    }
  },
  defaultSettings: {
    settings: {
      backgroundColor: '#eee',
      thumbColor: '#ccc',
      width: 16 // 32 for touch

    }
  },
  preferredSize: function preferredSize(rect) {
    var scrollState = this.chart.scroll(this.settings.scroll).getState(); // hide the scrollbar if it is not possible to scroll

    if (scrollState.viewSize >= scrollState.max - scrollState.min) {
      var toLargeSize = Math.max(rect.width, rect.height);
      return toLargeSize;
    }

    return this.settings.settings.width;
  },
  render: function render(h) {
    var _style;

    var dock = this.settings.layout.dock;
    var invert = this.settings.settings.invert;
    var horizontal = dock === 'top' || dock === 'bottom';
    var lengthAttr = horizontal ? 'width' : 'height';
    var _rect = this.rect;
    var length = _rect[lengthAttr];
    var scrollState = this.chart.scroll(this.settings.scroll).getState();
    var thumbStart = length * (scrollState.start - scrollState.min) / (scrollState.max - scrollState.min);
    var thumbRange = length * scrollState.viewSize / (scrollState.max - scrollState.min);

    if (invert) {
      thumbStart = length - thumbStart - thumbRange;
    }

    return h('div', {
      style: {
        position: 'relative',
        width: '100%',
        height: '100%',
        background: this.settings.settings.backgroundColor,
        pointerEvents: 'auto'
      }
    }, [].concat(h('div', {
      class: 'scroller',
      style: (_style = {
        position: 'absolute'
      }, _defineProperty(_style, horizontal ? 'left' : 'top', "".concat(thumbStart, "px")), _defineProperty(_style, horizontal ? 'top' : 'left', '25%'), _defineProperty(_style, horizontal ? 'height' : 'width', '50%'), _defineProperty(_style, lengthAttr, "".concat(Math.max(1, thumbRange), "px")), _defineProperty(_style, "background", this.settings.settings.thumbColor), _style)
    })));
  },
  renderer: 'dom'
};
function scrollbar(picasso) {
  picasso.component('scrollbar', scrollbarComponent);
}

var TARGET_SIZE = 5;
var VERTICAL = 0;
var HORIZONTAL = 1;

function buildLine$1(_ref) {
  var h = _ref.h,
      isVertical = _ref.isVertical,
      value = _ref.value,
      pos = _ref.pos,
      align = _ref.align,
      borderHit = _ref.borderHit,
      state = _ref.state,
      idx = _ref.idx;
  var isAlignStart = align !== 'end';
  var alignStart = {
    left: '0',
    top: '0'
  };
  var alignEnd = {
    right: '0',
    bottom: '0'
  };
  var alignStyle = isAlignStart ? alignStart : alignEnd;
  var start = 0;
  var width = '100%';
  var height = '100%';

  if (state.targetRect && state.settings.bubbles.align === 'start') {
    width = "".concat(state.targetRect.x + state.targetRect.width, "px");
    height = "".concat(state.targetRect.y + state.targetRect.height, "px");
  } else if (state.targetRect && state.settings.bubbles.align === 'end') {
    start = isVertical ? state.targetRect.x : state.targetRect.y;
    width = "".concat(state.rect.width - start, "px");
    height = "".concat(state.rect.height - start, "px");
  }

  if (!isAlignStart) {
    pos -= borderHit;
  } // edge


  return h('div', {
    onmouseover: function onmouseover(e) {
      e.srcElement.children[0].style.backgroundColor = '#000';
      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '2px';
    },
    onmouseout: function onmouseout(e) {
      e.srcElement.children[0].style.backgroundColor = state.style.line.stroke;
      e.srcElement.children[0].style[isVertical ? 'height' : 'width'] = '1px';
    },
    'data-value': value,
    'data-key': [state.key, 'edge', idx].join('-'),
    style: {
      cursor: isVertical ? 'ns-resize' : 'ew-resize',
      position: 'absolute',
      left: isVertical ? "".concat(start, "px") : "".concat(pos, "px"),
      top: isVertical ? "".concat(pos, "px") : "".concat(start, "px"),
      height: isVertical ? "".concat(borderHit, "px") : height,
      width: isVertical ? width : "".concat(borderHit, "px"),
      pointerEvents: 'auto'
    }
  }, [// line
  h('div', {
    style: extend({
      backgroundColor: state.style.line.stroke,
      position: 'absolute',
      height: isVertical ? "".concat(1, "px") : '100%',
      width: isVertical ? '100%' : "".concat(1, "px"),
      pointerEvents: 'none'
    }, alignStyle)
  })]);
}

function buildBubble(_ref2) {
  var _style;

  var h = _ref2.h,
      isVertical = _ref2.isVertical,
      label = _ref2.label,
      otherValue = _ref2.otherValue,
      rangeIdx = _ref2.rangeIdx,
      idx = _ref2.idx,
      pos = _ref2.pos,
      align = _ref2.align,
      state = _ref2.state,
      value = _ref2.value;
  var isAlignStart = align !== 'end';
  var isOutside = state.settings.bubbles.placement === 'outside';
  var outside = 'none';
  var bubbleDock;

  if (isVertical) {
    bubbleDock = isAlignStart ? 'left' : 'right';

    if (isOutside) {
      outside = isAlignStart ? 'translate(-100%,  0px)' : 'translate(100%,  0px)';
    }
  } else {
    bubbleDock = isAlignStart ? 'top' : 'bottom';

    if (isOutside) {
      outside = isAlignStart ? 'translate(0px, -100%)' : 'translate(0px,  100%)';
    }
  }

  var inEdit = state.edit && state.edit.rangeIdx === rangeIdx && state.edit.bubbleIdx === idx;
  var bubbleStyle = {
    position: 'relative',
    borderRadius: "".concat(state.style.bubble.borderRadius, "px"),
    border: "".concat(state.style.bubble.strokeWidth, "px solid ").concat(state.style.bubble.stroke),
    backgroundColor: state.style.bubble.fill,
    color: state.style.bubble.color,
    fontFamily: state.style.bubble.fontFamily,
    fontSize: state.style.bubble.fontSize,
    padding: '4px 8px',
    textAlign: 'center',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    maxWidth: '150px',
    minWidth: '50px',
    minHeight: '1em',
    pointerEvents: 'auto',
    transform: isVertical ? 'translate(0,-50%)' : 'translate(-50%,0)',
    cursor: isVertical ? 'ns-resize' : 'ew-resize'
  };
  var currentBorderColor = state.style.bubble.stroke;
  var bubble = inEdit ? h('input', {
    type: 'text',
    value: value,
    style: _objectSpread({}, bubbleStyle, {
      textAlign: 'start',
      textOverflow: '',
      fontSize: '13px' // TODO - make it styleable

    }),
    onkeyup: function onkeyup(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        var newValue = parseFloat(e.target.value);

        if (isNaN(newValue)) {
          currentBorderColor = 'rgba(230, 78, 78, 0.6)';
          e.target.style.border = "".concat(state.style.bubble.strokeWidth, "px solid ").concat(currentBorderColor);
        } else {
          state.onEditConfirmed(rangeIdx, newValue, otherValue);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        state.onEditCanceled();
      }
    }
  }) : h('div', {
    'data-key': [state.key, 'bubble', rangeIdx].join('-'),
    'data-other-value': otherValue,
    'data-idx': rangeIdx,
    'data-bidx': idx,
    style: bubbleStyle
  }, [label]); // bubble wrapper

  return h('div', {
    style: (_style = {
      position: 'absolute'
    }, _defineProperty(_style, bubbleDock, '0'), _defineProperty(_style, isVertical ? 'top' : 'left', "".concat(pos, "px")), _defineProperty(_style, "transform", outside), _style)
  }, [// bubble
  bubble]);
}

function buildArea(_ref3) {
  var h = _ref3.h,
      isVertical = _ref3.isVertical,
      top = _ref3.top,
      height = _ref3.height,
      color = _ref3.color,
      on = _ref3.on,
      opacity = _ref3.opacity;
  return h('div', extend({
    style: {
      backgroundColor: color,
      opacity: opacity,
      position: 'absolute',
      left: isVertical ? 0 : "".concat(top, "px"),
      top: isVertical ? "".concat(top, "px") : 0,
      height: isVertical ? "".concat(height, "px") : '100%',
      width: isVertical ? '100%' : "".concat(height, "px"),
      pointerEvents: 'auto'
    }
  }, on), []);
}

function buildRange(_ref4) {
  var borderHit = _ref4.borderHit,
      els = _ref4.els,
      isVertical = _ref4.isVertical,
      state = _ref4.state,
      vStart = _ref4.vStart,
      vEnd = _ref4.vEnd,
      idx = _ref4.idx;
  var targetOffset = 0;

  if (state.targetRect) {
    targetOffset = isVertical ? state.targetRect.y : state.targetRect.x;
  }

  var hasScale = !!state.scale;
  var start = hasScale ? state.scale.norm(vStart) * state.size : vStart;
  var end = hasScale ? state.scale.norm(vEnd) * state.size : vEnd;
  var height = Math.abs(start - end);
  var top = Math.min(start, end) + targetOffset;
  var bottom = top + height;

  if (state.targetRect) {
    var target = state.targetFillRect || state.targetRect;
    var targetSize = isVertical ? target.height : target.width;
    var targetStart = hasScale ? state.scale.norm(vStart) * targetSize : vStart;
    var targetEnd = hasScale ? state.scale.norm(vEnd) * targetSize : vEnd;
    var targetHeight = Math.abs(targetStart - targetEnd);
    var targetTop = Math.min(targetStart, targetEnd);
    var targetArea = {
      h: state.h,
      isVertical: isVertical,
      top: targetTop,
      height: targetHeight,
      color: state.style.target.fill,
      opacity: state.style.target.opacity
    };

    if (state.style.target.opacity < 0.8) {
      targetArea.on = {
        onmouseover: function onmouseover(e) {
          e.srcElement.style.opacity = state.style.target.opacity + 0.1;
        },
        onmouseout: function onmouseout(e) {
          e.srcElement.style.opacity = state.style.target.opacity;
        }
      };
    }

    els.push(state.h('div', {
      style: {
        position: 'absolute',
        left: "".concat(target.x, "px"),
        top: "".concat(target.y, "px"),
        height: "".concat(target.height, "px"),
        width: "".concat(target.width, "px")
      }
    }, [buildArea(targetArea)]));
  } // active range area
  // els.push(buildArea({
  //   h: state.h,
  //   isVertical,
  //   top,
  //   height,
  //   color: state.settings.fill
  // }));


  var valStart = start < end ? vStart : vEnd;
  var valEnd = start < end ? vEnd : vStart;

  var _ref5 = hasScale ? state.scale.domain() : [Math.min(vStart, vEnd), Math.max(vStart, vEnd)],
      _ref6 = _slicedToArray(_ref5, 2),
      min = _ref6[0],
      max = _ref6[1];

  var isStartVisible = valStart + 1e-5 >= min && valStart - 1e-5 <= max; // accept minor floating point difference

  var isEndVisible = valEnd - 1e-5 <= max && valEnd + 1e-5 >= min;

  if (isStartVisible) {
    els.push(buildLine$1({
      h: state.h,
      isVertical: isVertical,
      borderHit: borderHit,
      value: valStart,
      pos: top,
      align: 'start',
      state: state,
      idx: idx
    }));
  }

  if (isEndVisible) {
    els.push(buildLine$1({
      h: state.h,
      isVertical: isVertical,
      borderHit: borderHit,
      value: valEnd,
      pos: bottom,
      align: 'end',
      state: state,
      idx: idx
    }));
  }

  var bubbles = state.settings.bubbles;

  if (bubbles && bubbles.show) {
    var fontSize = bubbles.fontSize;
    var fontFamily = bubbles.fontFamily;
    var fill = bubbles.fill;
    var style = {
      fontSize: fontSize,
      fontFamily: fontFamily,
      color: fill
    };
    var range = [vStart, vEnd];

    if (isStartVisible) {
      els.push(buildBubble({
        h: state.h,
        isVertical: isVertical,
        align: bubbles.align,
        style: style,
        rangeIdx: idx,
        idx: 0,
        otherValue: valEnd,
        value: valStart,
        label: "".concat(state.format(valStart, range)),
        pos: top,
        state: state
      }));
    }

    if (isEndVisible) {
      els.push(buildBubble({
        h: state.h,
        isVertical: isVertical,
        align: bubbles.align,
        style: style,
        rangeIdx: idx,
        idx: 1,
        otherValue: valStart,
        value: valEnd,
        label: "".concat(state.format(valEnd, range)),
        pos: bottom,
        state: state
      }));
    }
  }
}
function getMoveDelta(state) {
  var posDelta = state.active.limitHigh - state.active.end;
  var negDelta = state.active.limitLow - state.active.start;
  var delta = state.current - state.start;

  if (delta < 0) {
    delta = Math.max(delta, negDelta);
  } else {
    delta = Math.min(delta, posDelta);
  }

  return delta;
}
function nodes(state) {
  var els = [];
  var isVertical = state.direction === VERTICAL;

  if (Array.isArray(state.ranges)) {
    // add all other ranges
    state.ranges.forEach(function (r, i) {
      if (!state.active || i !== state.active.idx) {
        buildRange({
          borderHit: TARGET_SIZE,
          els: els,
          isVertical: isVertical,
          state: state,
          vStart: Math.min(r.min, r.max),
          vEnd: Math.max(r.min, r.max),
          idx: i
        });
      }
    });
  }

  if (state.active) {
    // add active range
    var vStart = state.start;
    var vEnd = state.current;

    if (state.active.idx !== -1) {
      if (state.active.mode === 'foo') {
        vStart = Math.min(state.active.start, state.active.end);
        vEnd = Math.max(state.active.start, state.active.end);
      } else if (state.active.mode === 'modify') {
        vStart = Math.min(state.start, state.current);
        vEnd = Math.max(state.start, state.current);
      } else {
        var delta = getMoveDelta(state);
        vStart = state.active.start + delta;
        vEnd = state.active.end + delta;
      }
    }

    buildRange({
      borderHit: TARGET_SIZE,
      els: els,
      isVertical: isVertical,
      state: state,
      vStart: vStart,
      vEnd: vEnd,
      idx: state.active.idx
    });
  }

  return els;
}

function rangelimits(state) {
  return {
    min: state.scale.min(),
    max: state.scale.max()
  };
}

function areaLimits(state) {
  return {
    min: 0,
    max: state.direction ? state.rect.width : state.rect.height
  };
}

function findActive(state, value, limits) {
  var rs = state.ranges;
  var i;
  var activeIdx = -1;

  for (i = 0; i < rs.length; i++) {
    if (rs[i].min <= value && value <= rs[i].max) {
      activeIdx = i;
      limits.min = i ? rs[i - 1].max : limits.min;
      limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
      break;
    } else if (value < rs[i].min) {
      limits.max = rs[i].min;
      limits.min = i ? rs[i - 1].max : limits.min;
      break;
    }
  }

  if (activeIdx === -1 && rs.length && i >= rs.length) {
    limits.min = rs[rs.length - 1].max;
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'foo'
    };
  }

  state.active = activeRange;
}

function startArea(_ref) {
  var state = _ref.state,
      e = _ref.e,
      renderer = _ref.renderer,
      ranges = _ref.ranges,
      targetSize = _ref.targetSize;

  if (state.started) {
    return;
  }

  var x = e.center.x - e.deltaX;
  var y = e.center.y - e.deltaY;
  var target = document.elementFromPoint(x, y);

  if (!renderer.element().contains(target)) {
    target = null;
  }

  var tempState = {
    started: true
  };
  state.offset = renderer.element().getBoundingClientRect();
  state.ranges = ranges(state);
  var relX = x - state.offset.left; // coordinate relative renderer

  var relY = y - state.offset.top;
  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];
  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  var v = relStart;
  var vStart = startPoint;
  tempState.start = startPoint;
  tempState.current = relStart;
  var rs = state.ranges;
  var limits = areaLimits(state);
  var i;
  var activeIdx = -1;

  if (target && target.hasAttribute('data-idx')) {
    activeIdx = parseInt(target.getAttribute('data-idx'), 10);
    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;
    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;
  } else {
    for (i = 0; i < rs.length; i++) {
      if (rs[i].min <= vStart && vStart <= rs[i].max) {
        activeIdx = i;
        limits.min = i ? rs[i - 1].max : limits.min;
        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
        break;
      } else if (vStart < rs[i].min) {
        limits.max = rs[i].min;
        limits.min = i ? rs[i - 1].max : limits.min;
        break;
      }
    }

    if (activeIdx === -1 && rs.length && i >= rs.length) {
      limits.min = rs[rs.length - 1].max;
    }
  }

  if (activeIdx === -1 && !state.multi) {
    tempState.ranges = [];
    limits.min = 0;
    limits.max = state.direction ? state.rect.width : state.rect.height;
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'move'
    };

    if (target && target.hasAttribute('data-other-value')) {
      tempState.start = parseFloat(target.getAttribute('data-other-value'));
      activeRange.mode = 'modify';
    } else {
      var pxStart = activeRange.start;
      var pxEnd = activeRange.end;

      if (Math.abs(startPoint - pxStart) <= targetSize) {
        tempState.start = activeRange.end;
        activeRange.mode = 'modify';
      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {
        tempState.start = activeRange.start;
        activeRange.mode = 'modify';
      }
    }
  } else {
    activeRange = {
      idx: -1,
      start: vStart,
      end: v,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'current'
    };
  }

  tempState.active = activeRange;

  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {
    x: relX,
    y: relY
  })) ; else {
    Object.keys(tempState).forEach(function (key) {
      return state[key] = tempState[key];
    });
  }
}
function start$1(_ref2) {
  var state = _ref2.state,
      e = _ref2.e,
      renderer = _ref2.renderer,
      ranges = _ref2.ranges,
      targetSize = _ref2.targetSize;

  if (state.started) {
    return;
  }

  state.edit = null;
  var x = e.center.x - e.deltaX;
  var y = e.center.y - e.deltaY;
  var target = document.elementFromPoint(x, y);

  if (!renderer.element().contains(target)) {
    target = null;
  }

  var tempState = {
    started: true
  };
  state.offset = extend({}, renderer.element().getBoundingClientRect());
  var relX = x - state.offset.left; // coordinate relative renderer

  var relY = y - state.offset.top;
  state.offset.left += state.targetRect ? state.targetRect.x : 0; // make offset relative to targetRect

  state.offset.top += state.targetRect ? state.targetRect.y : 0;
  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);
  var startPoint = e.center[state.cssCoord.coord] - e[state.cssCoord.pos] - state.offset[state.cssCoord.offset];
  var relStart = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  tempState.current = state.scale.normInvert(relStart / state.size);
  tempState.start = state.scale.normInvert(startPoint / state.size);
  var rs = state.ranges;
  var limits = rangelimits(state);
  var i;
  var activeIdx = -1;

  if (target && target.hasAttribute('data-idx')) {
    activeIdx = parseInt(target.getAttribute('data-idx'), 10);
    limits.min = activeIdx > 0 ? rs[activeIdx - 1].max : limits.min;
    limits.max = activeIdx + 1 < rs.length ? rs[activeIdx + 1].min : limits.max;
  } else {
    for (i = 0; i < rs.length; i++) {
      if (rs[i].min <= tempState.start && tempState.start <= rs[i].max) {
        activeIdx = i;
        limits.min = i ? rs[i - 1].max : limits.min;
        limits.max = i + 1 < rs.length ? rs[i + 1].min : limits.max;
        break;
      } else if (tempState.start < rs[i].min) {
        limits.max = rs[i].min;
        limits.min = i ? rs[i - 1].max : limits.min;
        break;
      }
    }

    if (activeIdx === -1 && rs.length && i >= rs.length) {
      limits.min = rs[rs.length - 1].max;
    }
  }

  if (activeIdx === -1 && !state.multi) {
    tempState.ranges = [];
    limits.min = state.scale.min();
    limits.max = state.scale.max();
  }

  var activeRange;

  if (activeIdx !== -1) {
    activeRange = {
      idx: activeIdx,
      start: rs[activeIdx].min,
      end: rs[activeIdx].max,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'move'
    };

    if (target && target.hasAttribute('data-other-value')) {
      tempState.start = parseFloat(target.getAttribute('data-other-value'));
      activeRange.mode = 'modify';
    } else {
      var pxStart = state.scale.norm(activeRange.start) * state.size;
      var pxEnd = state.scale.norm(activeRange.end) * state.size;

      if (Math.abs(startPoint - pxStart) <= targetSize) {
        tempState.start = activeRange.end;
        activeRange.mode = 'modify';
      } else if (Math.abs(startPoint - pxEnd) <= targetSize) {
        tempState.start = activeRange.start;
        activeRange.mode = 'modify';
      }
    }
  } else {
    activeRange = {
      idx: -1,
      start: tempState.start,
      end: tempState.current,
      limitLow: limits.min,
      limitHigh: limits.max,
      mode: 'current'
    };
  }

  tempState.active = activeRange;

  if (activeRange.mode !== 'modify' && state.targetRect && !testRectPoint(state.targetRect, {
    x: relX,
    y: relY
  })) ; else {
    Object.keys(tempState).forEach(function (key) {
      return state[key] = tempState[key];
    });
  }
}
function picasso_esm_end(state, ranges) {
  state.started = false;
  state.ranges = ranges(state, state.fauxBrushInstance || state.brushInstance);
  var limits = rangelimits(state);
  findActive(state, state.current, limits);
}
function endArea(state, ranges) {
  state.started = false;
  state.ranges = ranges(state);
  var limits = areaLimits(state);
  findActive(state, state.current, limits);
}
function move(state, e) {
  var relY = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  var rel = relY / state.size;
  var v = state.scale.normInvert(rel);
  state.current = Math.max(Math.min(v, state.active.limitHigh), state.active.limitLow);
}
function moveArea(state, e) {
  var rel = e.center[state.cssCoord.coord] - state.offset[state.cssCoord.offset];
  state.current = Math.max(Math.min(rel, state.active.limitHigh), state.active.limitLow);
}

function _render(state) {
  state.renderer.render(nodes(state));
}

function ranges(state, brush) {
  if (!brush || !brush.isActive()) {
    return [];
  }

  var sourceData = state.scale.data();
  var sourceFields = sourceData ? sourceData.fields || [] : [];
  var sources = sourceFields.map(function (field) {
    return field.id();
  });
  var rangeBrush = brush.brushes().filter(function (f) {
    return f.type === 'range' && sources.indexOf(f.id) !== -1;
  })[0];

  if (!rangeBrush) {
    return [];
  }

  return rangeBrush.brush.ranges();
}

function setRanges(state) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });

  if (state.active.idx !== -1) {
    if (state.active.mode === 'modify') {
      rs[state.active.idx].min = Math.min(state.start, state.current);
      rs[state.active.idx].max = Math.max(state.start, state.current);
    } else {
      var delta = getMoveDelta(state);
      rs[state.active.idx].min += delta;
      rs[state.active.idx].max += delta;
    }
  } else {
    rs.push({
      min: Math.min(state.start, state.current),
      max: Math.max(state.start, state.current)
    });
  }

  var scaleData = state.scale.data();

  if (scaleData && scaleData.fields) {
    scaleData.fields.forEach(function (field) {
      if (state.fauxBrushInstance) {
        var ordRS = ranges(state, state.fauxBrushInstance);
        var oldValues = state.findValues(ordRS);
        var values = state.findValues(rs);
        var addedValues = values.filter(function (v) {
          return oldValues.indexOf(v) === -1;
        });
        var removedValues = oldValues.filter(function (v) {
          return values.indexOf(v) === -1;
        });
        var addItems = addedValues.map(function (v) {
          return {
            key: field.id(),
            value: v
          };
        });
        var removeItems = removedValues.map(function (v) {
          return {
            key: field.id(),
            value: v
          };
        });
        state.brushInstance.addAndRemoveValues(addItems, removeItems);
        state.fauxBrushInstance.setRange(field.id(), rs);
      } else {
        state.brushInstance.setRange(field.id(), rs);
      }
    });
  }
}

function setEditedRanges(state, idx, startValue, endValue) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });
  var limitMin = state.scale.min();
  var limitMax = state.scale.max();
  rs[idx] = {
    min: Math.max(limitMin, Math.min(startValue, endValue)),
    max: Math.min(limitMax, Math.max(startValue, endValue))
  };
  state.ranges[idx] = _objectSpread({}, rs[idx]);
  var scaleData = state.scale.data();

  if (scaleData && scaleData.fields) {
    scaleData.fields.forEach(function (field) {
      if (!state.fauxBrushInstance) {
        state.brushInstance.setRange(field.id(), rs);
      }
    });
  }
}

function findClosest(value, scale) {
  var name;
  var minDist = Infinity;
  var domain = scale.domain();
  var halfBandwidth = scale.bandwidth() / 2;

  for (var i = 0; i < domain.length; ++i) {
    var d = Math.abs(value - halfBandwidth - scale(domain[i]));

    if (d < minDist) {
      minDist = d;
      name = domain[i];
    }
  }

  return name;
}

function findClosestLabel(value, scale) {
  var ticks = scale.ticks();
  var idx = scale.domain().indexOf(findClosest(value, scale));
  return idx !== -1 ? ticks[idx].label : '-';
}

function rangesOverlap(r1, r2) {
  return Math.min.apply(Math, _toConsumableArray$1(r1)) <= Math.max.apply(Math, _toConsumableArray$1(r2)) && Math.max.apply(Math, _toConsumableArray$1(r1)) >= Math.min.apply(Math, _toConsumableArray$1(r2));
}

function findValues(rangesValues, scale) {
  var domain = scale.domain();
  var scaleRange = scale.range();
  var values = [];
  rangesValues.forEach(function (range) {
    if (!rangesOverlap(scaleRange, [range.min, range.max])) {
      return;
    }

    var startIdx = domain.indexOf(findClosest(range.min, scale));
    var endIdx = domain.indexOf(findClosest(range.max, scale));
    values.push.apply(values, domain.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1));
    /* eslint prefer-spread:0 */
  });
  return values;
}

function resolveNodeBounds(targetNodes) {
  var points = targetNodes.reduce(function (ary, node) {
    ary.push.apply(ary, _toConsumableArray$1(rectToPoints(node.bounds)));
    return ary;
  }, []);
  return pointsToRect(points);
}

function resolveTarget(ctx) {
  var resolved = {
    targetRect: null,
    targetFillRect: null,
    scale: null,
    size: null
  };
  var stngs = ctx.settings.settings;
  var targets = stngs.target && (stngs.target.components || (stngs.target.component ? [stngs.target.component] : [])).map(function (c) {
    return ctx.chart.component(c);
  }).filter(function (c) {
    return !!c && !!c.rect;
  });
  var targetNodes = stngs.target && stngs.target.selector ? ctx.chart.findShapes(stngs.target.selector) : [];
  var targetFillNodes = stngs.target && stngs.target.fillSelector ? ctx.chart.findShapes(stngs.target.fillSelector) : [];

  if (targetNodes.length > 0) {
    var bounds = resolveNodeBounds(targetNodes);
    resolved.size = bounds[ctx.state.direction === VERTICAL ? 'height' : 'width'];
    resolved.scale = scaleWithSize(ctx.chart.scale(stngs.scale), resolved.size);
    resolved.targetRect = bounds;

    if (targetFillNodes.length > 0) {
      var fillBounds = resolveNodeBounds(targetFillNodes);
      resolved.targetFillRect = fillBounds;
    }
  } else if (targets && targets.length > 0) {
    var targetRect = targets.slice(1).reduce(function (prev, curr) {
      return {
        x0: Math.min(prev.x0, curr.rect.computedInner.x),
        y0: Math.min(prev.y0, curr.rect.computedInner.y),
        x1: Math.max(prev.x1, curr.rect.computedInner.x + curr.rect.computedInner.width),
        y1: Math.max(prev.y1, curr.rect.computedInner.y + curr.rect.computedInner.height)
      };
    }, {
      x0: targets[0].rect.computedInner.x,
      y0: targets[0].rect.computedInner.y,
      x1: targets[0].rect.computedInner.x + targets[0].rect.computedInner.width,
      y1: targets[0].rect.computedInner.y + targets[0].rect.computedInner.height
    });
    resolved.targetRect = {
      x: targetRect.x0 - ctx.state.rect.x,
      y: targetRect.y0 - ctx.state.rect.y,
      width: targetRect.x1 - targetRect.x0,
      height: targetRect.y1 - targetRect.y0
    };
  }

  return resolved;
}
/**
 * @typedef {object} component--brush-range-settings
 * @property {string|object} brush - Brush context to apply changes to
 * @property {string} scale - Scale to extract data from
 * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
 * @property {object} [bubbles]
 * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
 * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
 * @property {function} [bubbles.label] - Callback function for the labels
 * @property {object} [target]
 * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead
 * @property {string[]} [target.components] - Render matching overlay on target components
 * @property {string} [target.selector] - Instead of targeting a component, target one or more shapes
 * @property {string} [target.fillSelector] - Target a subset of the selector as fill area. Only applicable if `selector` property is set
 */

/**
 * @typedef {object} component--brush-range-style
 * @property {object} [bubble]
 * @property {string} [bubble.fontSize]
 * @property {string} [bubble.fontFamily]
 * @property {string} [bubble.fill]
 * @property {string} [bubble.color]
 * @property {string} [bubble.stroke]
 * @property {number} [bubble.strokeWidth]
 * @property {number} [bubble.borderRadius]
 * @property {object} [line]
 * @property {string} [line.stroke]
 * @property {number} [line.strokeWidth]
 * @property {object} [target]
 * @property {string} [target.fill]
 * @property {number} [target.strokeWidth]
 * @property {number} [target.opacity]
 */


var brushRangeComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {
      bubbles: {
        show: true,
        align: 'start'
      }
    },
    style: {
      bubble: '$label-overlay',
      line: '$shape-guide--inverted',
      target: '$selection-area-target'
    }
  },
  renderer: 'dom',
  on: {
    rangeStart: function rangeStart(e) {
      this.start(e);
    },
    rangeMove: function rangeMove(e) {
      this.move(e);
    },
    rangeEnd: function rangeEnd(e) {
      this.end(e);
    },
    rangeClear: function rangeClear(e) {
      this.clear(e);
    },
    bubbleStart: function bubbleStart(e) {
      this.bubbleStart(e);
    }
  },
  created: function created() {
    this.state = {
      key: this.settings.key || 'brush-range'
    };
  },
  beforeRender: function beforeRender(opts) {
    this.state.rect = opts.size.computedInner;
  },
  renderRanges: function renderRanges() {
    if (!this.state.started) {
      this.state.ranges = ranges(this.state, this.state.brushInstance);
      this.state.active = null;

      _render(this.state);
    }
  },
  render: function render(h) {
    var _this = this;

    var stngs = this.settings.settings;
    this.state.direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;
    var offset = this.renderer.element().getBoundingClientRect();
    var size = this.state.rect[this.state.direction === VERTICAL ? 'height' : 'width'];
    var scale = scaleWithSize(this.chart.scale(stngs.scale), size);
    var target = resolveTarget(this);
    scale = target.scale ? target.scale : scale;
    this.state.targetRect = target.targetRect;
    this.state.targetFillRect = target.targetFillRect;
    this.state.size = target.size === null ? size : target.size;
    this.state.settings = stngs;
    this.state.style = this.style;
    this.state.offset = offset;
    this.state.brush = picasso_esm_typeof(stngs.brush) === 'object' ? stngs.brush.context : stngs.brush;
    this.state.brushInstance = this.chart.brush(this.state.brush);
    this.state.renderer = this.renderer;
    this.state.multi = !!stngs.multiple;
    this.state.h = h;

    this.state.onEditConfirmed = function (rangeIdx, value, otherValue) {
      _this.state.edit = null;
      setEditedRanges(_this.state, rangeIdx, value, otherValue);

      _this.emit('bubbleEnd');

      _render(_this.state);
    };

    this.state.onEditCanceled = function () {
      _this.state.edit = null;

      _render(_this.state);
    };

    this.state.cssCoord = {
      offset: this.state.direction === VERTICAL ? 'top' : 'left',
      coord: this.state.direction === VERTICAL ? 'y' : 'x',
      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX'
    };
    this.state.format = typeof stngs.bubbles.label === 'function' ? function (v, r) {
      return stngs.bubbles.label.call(undefined, {
        datum: v,
        data: r,
        scale: scale,
        resources: {
          scale: _this.chart.scale,
          formatter: _this.chart.formatter
        }
      });
    } : false;

    if (!{}.hasOwnProperty.call(scale, 'norm')) {
      // Non-linear scale if norm method is unavailable
      this.state.editable = false;
      this.state.scale = scaleLinear();
      this.state.scale.data = scale.data;

      if (!this.state.format) {
        this.state.format = function (v, r) {
          if (!rangesOverlap(scale.range(), r)) {
            return '-';
          }

          return findClosestLabel(v, scale);
        };
      }

      this.state.fauxBrushInstance = brush();

      this.state.findValues = function (valueRanges) {
        return findValues(valueRanges, scale);
      };
    } else {
      this.state.editable = true;
      this.state.observeBrush = picasso_esm_typeof(stngs.brush) === 'object' ? stngs.brush.observe : false;
      this.state.fauxBrushInstance = null;
      this.state.findValues = null;
      this.state.scale = scale;
      var scaleData = this.state.scale.data();

      if (!this.state.format && scaleData && scaleData.fields && scaleData.fields[0]) {
        this.state.format = scaleData.fields[0].formatter();
      }
    }

    this.state.ranges = ranges(this.state, this.state.brushInstance);
    return this.state.observeBrush || this.state.sourcedFromThisComponent ? [nodes(this.state)] : [];
  },
  mounted: function mounted() {
    if (this.state.observeBrush && this.state.brushInstance) {
      this.state.brushInstance.on('update', this.renderRanges);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.state.observeBrush && this.state.brushInstance) {
      this.state.brushInstance.removeListener('update', this.renderRanges);
    }
  },
  start: function start(e) {
    start$1({
      e: e,
      state: this.state,
      renderer: this.renderer,
      ranges: ranges,
      targetSize: TARGET_SIZE
    });
  },
  end: function end$1() {
    if (!this.state.started) {
      return;
    }

    picasso_esm_end(this.state, ranges);

    _render(this.state);

    this.state.sourcedFromThisComponent = true;
    this.state.active = null;
  },
  move: function move$1(e) {
    if (!this.state.started) {
      return;
    }

    move(this.state, e);

    setRanges(this.state);

    _render(this.state);
  },
  clear: function clear() {
    if (this.state.fauxBrushInstance) {
      this.state.fauxBrushInstance.clear();
    }

    this.state.renderer.render([]);
    this.state.started = false;
    this.state.active = null;
    this.state.sourcedFromThisComponent = false;
  },
  bubbleStart: function bubbleStart(e) {
    if (!this.state.editable) {
      return;
    }

    var ee = e.srcEvent || e;
    var target = ee.target;
    var ed = {
      rangeIdx: parseInt(target.getAttribute('data-idx'), 10),
      bubbleIdx: parseInt(target.getAttribute('data-bidx'), 10)
    };

    if (isNaN(ed.rangeIdx) || JSON.stringify(ed) === JSON.stringify(this.state.edit)) {
      return;
    }

    this.state.edit = ed;
    ee.stopPropagation();
    ee.stopImmediatePropagation();
    ee.preventDefault();
    var wrapper = target.parentNode;

    _render(this.state);

    var inputEl = wrapper.querySelector('input');
    inputEl.focus();
    inputEl.select();
  }
};

function picasso_esm_render(state) {
  state.renderer.render(nodes(state));
}

function ranges$1(state) {
  return state.rc.ranges();
}

function shapesFromRange(state, brushRange) {
  var shapeAt = {
    x: state.direction ? brushRange.min + state.rect.x : state.rect.x,
    y: state.direction ? state.rect.y : brushRange.min + state.rect.y,
    width: state.direction ? brushRange.max - brushRange.min : state.rect.width + state.rect.x,
    height: state.direction ? state.rect.height + state.rect.y : brushRange.max - brushRange.min
  };
  return state.chart.shapesAt(shapeAt, state.settings.brush);
}

function brushFromShape(state, newShapes) {
  state.chart.brushFromShapes(newShapes, state.settings.brush);
}

function setRanges$1(state) {
  var rs = state.ranges.map(function (r) {
    return {
      min: r.min,
      max: r.max
    };
  });

  if (state.active.idx !== -1) {
    if (state.active.mode === 'modify') {
      rs[state.active.idx].min = Math.min(state.start, state.current);
      rs[state.active.idx].max = Math.max(state.start, state.current);
    } else {
      var delta = getMoveDelta(state);
      rs[state.active.idx].min = state.active.start + delta;
      rs[state.active.idx].max = state.active.end + delta;
    }
  } else {
    rs.push({
      min: Math.min(state.start, state.current),
      max: Math.max(state.start, state.current)
    });
  }

  state.rc.set(rs);
  var shapes = [];
  rs.forEach(function (range) {
    shapes.push.apply(shapes, _toConsumableArray$1(shapesFromRange(state, range)));
  });
  brushFromShape(state, shapes);
}

function getBubbleLabel(state, value, range) {
  var min = Math.min.apply(Math, _toConsumableArray$1(range));
  var max = Math.max.apply(Math, _toConsumableArray$1(range));
  var shapeAt = {
    x: state.direction ? min + state.rect.x : state.rect.x,
    y: state.direction ? state.rect.y : min + state.rect.y,
    width: state.direction ? max - min : state.rect.width + state.rect.x,
    height: state.direction ? state.rect.height + state.rect.y : max - min
  };
  var shapes = state.chart.shapesAt(shapeAt, state.settings.brush);

  if (shapes.length === 0) {
    return '-';
  }

  var labelShape = shapes.reduce(function (s0, s1) {
    // Min value
    var bounds0 = s0.bounds;
    var bounds1 = s1.bounds;

    if (value === min) {
      if (bounds0[state.cssCoord.coord] <= bounds1[state.cssCoord.coord]) {
        return s0;
      }

      return s1;
    } // Max value


    if (bounds0[state.cssCoord.coord] + bounds0[state.cssCoord.area] >= bounds1[state.cssCoord.coord] + bounds1[state.cssCoord.area]) {
      return s0;
    }

    return s1;
  });
  var compConfig = state.settings.brush.components.reduce(function (c0, c1) {
    return c0.key === labelShape.key ? c0 : c1;
  });

  if (typeof state.settings.bubbles.label === 'function') {
    return state.settings.bubbles.label(labelShape.data);
  }

  if (Array.isArray(compConfig.data) && compConfig.data.length) {
    return labelShape.data[compConfig.data[0]].label;
  }

  return labelShape.data && labelShape.data.label ? labelShape.data.label : '-';
}
/**
 * @typedef {object} component--brush-area-dir-settings
 * @property {object} brush
 * @property {array} brush.components
 * @property {object} brush.components[].key - Component key
 * @property {object} brush.components[].contexts[] - Brush context to apply changes to
 * @property {object} [brush.components[].data] - Data reference
 * @property {object} [brush.components[].action] - Type of brush action
 * @property {string} [direction=vertical] - Rendering direction [horizontal|vertical]
 * @property {object} [bubbles]
 * @property {boolean} [bubbles.show=true] - True to show label bubble, false otherwise
 * @property {string} [bubbles.align=start] - Where to anchor bubble [start|end]
 * @property {function} [bubbles.label] - Callback function for the labels
 * @property {object} [target]
 * @property {string} [target.component] - Render matching overlay on target component. @deprecated Use `components` instead
 * @property {string[]} [target.components] - Render matching overlay on target components
 */

/**
 * @typedef {object} component--brush-area-dir-style
 * @property {object} [bubble]
 * @property {string} [bubble.fontSize]
 * @property {string} [bubble.fontFamily]
 * @property {string} [bubble.fill]
 * @property {string} [bubble.color]
 * @property {string} [bubble.stroke]
 * @property {number} [bubble.strokeWidth]
 * @property {number} [bubble.borderRadius]
 * @property {object} [line]
 * @property {string} [line.stroke]
 * @property {number} [line.strokeWidth]
 * @property {object} [target]
 * @property {string} [target.fill]
 * @property {number} [target.strokeWidth]
 * @property {number} [target.opacity]
 */


var brushAreaDirectionalComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {
      bubbles: {
        show: true,
        align: 'start'
      }
    },
    style: {
      bubble: '$label-overlay',
      line: '$shape-guide--inverted',
      target: '$selection-area-target'
    }
  },
  renderer: 'dom',
  on: {
    areaStart: function areaStart(e) {
      this.start(e);
    },
    areaMove: function areaMove(e) {
      this.move(e);
    },
    areaEnd: function areaEnd(e) {
      this.end(e);
    },
    areaClear: function areaClear(e) {
      this.clear(e);
    }
  },
  created: function created() {
    this.state = {
      key: this.settings.key || 'brush-area-dir'
    };
  },
  render: function render(h) {
    var _this = this;

    this.state.rect = this.rect;
    var stngs = this.settings.settings;
    var direction = stngs.direction === 'vertical' ? VERTICAL : HORIZONTAL;
    var size = this.state.rect[direction === VERTICAL ? 'height' : 'width'];
    var offset = this.renderer.element().getBoundingClientRect();
    var targets = (stngs.target ? stngs.target.components || [stngs.target.component] : []).map(function (c) {
      return _this.chart.component(c);
    }).filter(function (c) {
      return !!c && !!c.rect;
    });
    var targetRect = targets[0] ? targets.slice(1).reduce(function (prev, curr) {
      return {
        x0: Math.min(prev.x0, curr.rect.x),
        y0: Math.min(prev.y0, curr.rect.y),
        x1: Math.max(prev.x1, curr.rect.x + curr.rect.width),
        y1: Math.max(prev.y1, curr.rect.y + curr.rect.height)
      };
    }, {
      x0: targets[0].rect.x,
      y0: targets[0].rect.y,
      x1: targets[0].rect.x + targets[0].rect.width,
      y1: targets[0].rect.y + targets[0].rect.height
    }) : null;
    this.state.targetRect = targetRect ? {
      x: targetRect.x0 - this.rect.x,
      y: targetRect.y0 - this.rect.y,
      width: targetRect.x1 - targetRect.x0,
      height: targetRect.y1 - targetRect.y0
    } : null;
    this.state.style = this.style;
    this.state.chart = this.chart;
    this.state.direction = direction;
    this.state.settings = stngs;
    this.state.offset = offset;
    this.state.rc = rangeCollection();
    this.state.renderer = this.renderer;
    this.state.multi = !!stngs.multiple;
    this.state.h = h;
    this.state.size = size;
    this.state.cssCoord = {
      offset: this.state.direction === VERTICAL ? 'top' : 'left',
      coord: this.state.direction === VERTICAL ? 'y' : 'x',
      pos: this.state.direction === VERTICAL ? 'deltaY' : 'deltaX',
      area: this.state.direction === VERTICAL ? 'height' : 'width'
    };

    this.state.format = function getFormat(v, r) {
      return getBubbleLabel(this, v, r);
    };

    return [];
  },
  start: function start(e) {
    startArea({
      e: e,
      state: this.state,
      renderer: this.renderer,
      ranges: ranges$1,
      targetSize: TARGET_SIZE
    });
  },
  end: function end() {
    if (!this.state.started) {
      return;
    }

    endArea(this.state, ranges$1);
    picasso_esm_render(this.state);
  },
  move: function move(e) {
    if (!this.state.started) {
      return;
    }

    moveArea(this.state, e);
    setRanges$1(this.state);
    picasso_esm_render(this.state);
  },
  clear: function clear() {
    if (this.state.rc) {
      this.state.rc.clear();
    }

    this.state.renderer.render([]);
  }
};

function rangeBrush(picasso) {
  picasso.component('brush-range', brushRangeComponent);
  picasso.component('brush-area-dir', brushAreaDirectionalComponent);
}

var FILL = '#ccc';
var OPACITY = 1;

function ranges$2(state) {
  var brush = state.brush;

  if (!brush || !brush.isActive()) {
    return [];
  }

  var sourceData = state.scale.data();
  var sourceFields = sourceData ? sourceData.fields || [] : [];
  var sources = sourceFields.map(function (field) {
    return field.id();
  });
  var rangeBrush = brush.brushes().filter(function (f) {
    return f.type === 'range' && sources.indexOf(f.id) !== -1;
  })[0];

  if (!rangeBrush) {
    return [];
  }

  return rangeBrush.brush.ranges();
}

function shapes(state) {
  var isVertical = state.direction === 'vertical';
  var size = state.rect[isVertical ? 'height' : 'width'];
  var otherSize = state.rect[isVertical ? 'width' : 'height'];
  return ranges$2(state).map(function (range) {
    var start = state.scale(range.min) * size;
    var end = state.scale(range.max) * size;
    var low = Math.min(start, end);
    var s = Math.abs(start - end);
    return {
      type: 'rect',
      fill: state.fill,
      opacity: state.opacity,
      x: isVertical ? 0 : low,
      width: isVertical ? otherSize : s,
      y: isVertical ? low : 0,
      height: isVertical ? s : otherSize
    };
  });
}

function onStart(state) {
  state.renderer.render(shapes(state));
}

function onUpdate(state) {
  state.renderer.render(shapes(state));
}

function onEnd(state) {
  state.renderer.render(shapes(state));
}

function setup(state, brush, scale, renderer) {
  state.brush = brush;

  if (!brush) {
    return;
  }

  function start() {
    onStart(state);
  }

  function update() {
    onUpdate(state);
  }

  function end() {
    onEnd(state);
  }

  brush.on('start', start);
  brush.on('update', update);
  brush.on('end', end);
  state.start = start;
  state.update = update;
  state.end = end;
  state.brush = brush;
  state.scale = scale;
  state.renderer = renderer;
}

function teardown(state) {
  if (state.brush) {
    state.brush.removeListener('start', state.start);
    state.brush.removeListener('update', state.update);
    state.brush.removeListener('end', state.end);
  }

  state.start = undefined;
  state.update = undefined;
  state.end = undefined;
  state.brush = undefined;
  state.scale = undefined;
  state.renderer = undefined;
}
/**
 * @typedef {object} component--range
 */

/**
 * @typedef {object} component--range.settings
 * @property {string} brush - Name of brush instance
 * @property {string} scale - Name of a scale
 * @property {string} [direction='horizontal'] - Direction of the brush
 * @property {string} [fill='#ccc'] - Fill color
 * @property {number} [opacity=1] - Layer opacity
 */


var rangeComponent = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    settings: {}
  },
  preferredSize: function preferredSize() {
    return 50;
  },
  created: function created() {
    this.state = {};
  },
  render: function render() {
    var stngs = this.settings.settings;
    var brush = this.chart.brush(stngs.brush);
    var direction = stngs.direction || 'horizontal';
    var distance = direction === 'horizontal' ? this.rect.width : this.rect.height;
    var scale = scaleWithSize(this.chart.scale(stngs.scale), distance);
    teardown(this.state);
    setup(this.state, brush, scale, this.renderer);
    this.state.rect = this.rect;
    this.state.fill = stngs.fill || FILL;
    this.state.opacity = typeof stngs.opacity !== 'undefined' ? stngs.opacity : OPACITY;
    this.state.direction = direction;
    return shapes(this.state);
  },
  beforeDestroy: function beforeDestroy() {
    teardown(this.state);
  }
};

function rangeBrush$1(picasso) {
  picasso.component('range', rangeComponent);
}

function getPoint(rendererBounds, event) {
  var eventOffsetX = event.center.x;
  var eventOffsetY = event.center.y;
  return {
    x: eventOffsetX - rendererBounds.left,
    y: eventOffsetY - rendererBounds.top
  }; // return {
  //   x: Math.min(Math.max(eventOffsetX - rendererBounds.left, 0), rendererBounds.width),
  //   y: Math.min(Math.max(eventOffsetY - rendererBounds.top, 0), rendererBounds.height)
  // };
}

function withinThreshold(p, state, settings) {
  var startPoint = state.points[0];
  var sqrDist = sqrDistance(p, startPoint);
  return sqrDist < Math.pow(settings.settings.snapIndicator.threshold, 2);
}

function appendToPath(state, p) {
  if (state.path.d == null) {
    state.path.d = "M".concat(p.x, " ").concat(p.y, " ");
  } else {
    state.path.d += "L".concat(p.x, " ").concat(p.y, " ");
  }

  state.points.push(p);
}

function render$1(state, renderer) {
  var nodes = [state.startPoint, state.path, state.snapIndicator].filter(function (node) {
    return node.visible;
  });
  renderer.render(nodes);
}

function setSnapIndictor(_ref) {
  var state = _ref.state,
      _ref$start = _ref.start,
      start = _ref$start === void 0 ? null : _ref$start,
      _ref$end = _ref.end,
      end = _ref$end === void 0 ? null : _ref$end;

  if (start !== null) {
    state.snapIndicator.x1 = start.x;
    state.snapIndicator.y1 = start.y;
  }

  if (end !== null) {
    state.snapIndicator.x2 = end.x;
    state.snapIndicator.y2 = end.y;
  }
}

function showSnapIndicator(state, show) {
  state.snapIndicator.visible = show;
}

function setStartPoint(state, p) {
  state.startPoint.cx = p.x;
  state.startPoint.cy = p.y;
}

function getComponentDelta(chart, rendererBounds) {
  var chartBounds = chart.element.getBoundingClientRect();
  return {
    x: rendererBounds.left - chartBounds.left,
    y: rendererBounds.top - chartBounds.top
  };
}

function doLineBrush(state, chart) {
  if (state.active) {
    var p1 = state.points[state.points.length - 2];
    var p2 = state.points[state.points.length - 1];
    state.lineBrushShape.x1 = p1.x + state.componentDelta.x;
    state.lineBrushShape.y1 = p1.y + state.componentDelta.y;
    state.lineBrushShape.x2 = p2.x + state.componentDelta.x;
    state.lineBrushShape.y2 = p2.y + state.componentDelta.y;
    var shapes = chart.shapesAt(state.lineBrushShape, {
      components: state.brushConfig
    });
    chart.brushFromShapes(shapes, {
      components: state.brushConfig
    });
  }
}

function doPolygonBrush(state, chart) {
  if (state.active) {
    var dx = state.componentDelta.x;
    var dy = state.componentDelta.y;
    var vertices = state.points.map(function (p) {
      return {
        x: p.x + dx,
        y: p.y + dy
      };
    });
    var shapes = chart.shapesAt({
      vertices: vertices
    }, {
      components: state.brushConfig
    });
    chart.brushFromShapes(shapes, {
      components: state.brushConfig
    });
  }
}

function initPath(stgns) {
  return {
    visible: true,
    type: 'path',
    d: null,
    fill: stgns.fill,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    opacity: stgns.opacity,
    strokeDasharray: stgns.strokeDasharray,
    collider: {
      type: null
    }
  };
}

function initSnapIndicator(stgns) {
  return {
    visible: false,
    type: 'line',
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    strokeDasharray: stgns.strokeDasharray,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    opacity: stgns.opacity,
    collider: {
      type: null
    }
  };
}

function initStartPoint(stgns) {
  return {
    visible: true,
    type: 'circle',
    cx: 0,
    cy: 0,
    r: stgns.r,
    fill: stgns.fill,
    opacity: stgns.opacity,
    stroke: stgns.stroke,
    strokeWidth: stgns.strokeWidth,
    collider: {
      type: null
    }
  };
}

function getBrushConfig(settings) {
  return settings.settings.brush.components.map(function (b) {
    return {
      key: b.key,
      contexts: b.contexts || ['lassoBrush'],
      data: b.data || [''],
      action: b.action || 'add'
    };
  });
}

function endBrush(state, chart) {
  state.brushConfig.forEach(function (config) {
    config.contexts.forEach(function (context) {
      chart.brush(context).end();
    });
  });
}

function resetState() {
  return {
    points: [],
    active: false,
    path: null,
    snapIndicator: null,
    startPoint: null,
    rendererBounds: null,
    componentDelta: null,
    brushConfig: null,
    lineBrushShape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0 // Keep a single shape instance to avoid instantiating a new object on each lookup

    }
  };
}
/**
 * @typedef {object} component--brush-lasso
 */

/**
 * @typedef {object} component--brush-lasso-settings
 * @property {object} [lasso] - Lasso style settings
 * @property {string} [lasso.fill='transparent']
 * @property {string} [lasso.stroke='black']
 * @property {number} [lasso.strokeWidth=2]
 * @property {number} [lasso.opacity=0.7]
 * @property {number} [lasso.strokeDasharray]
 * @property {object} [snapIndicator] - Snap indicator settings
 * @property {number} [snapIndicator.threshold=75] - The distance in pixel to show the snap indicator, if less then threshold the indicator is dispalyed
 * @property {string} [snapIndicator.strokeDasharray='5, 5']
 * @property {string} [snapIndicator.stroke='black']
 * @property {number} [snapIndicator.strokeWidth=2]
 * @property {number} [snapIndicator.opacity=0.5]
 * @property {object} [startPoint] - Start point style settings
 * @property {number} [startPoint.r=10] - Circle radius
 * @property {string} [startPoint.stroke='green']
 * @property {number} [startPoint.strokeWidth=1]
 * @property {number} [startPoint.opacity=1]
 * @property {object} [brush]
 * @property {object[]} brush.components - Array of components to brush on.
 * @property {string} [brush.components[].component.key] - Component key
 * @property {string[]} [brush.components[].component.contexts=['brushLasso']] - Name of the brushing contexts to affect
 * @property {string[]} [brush.components[].component.data=['']] - The mapped data properties to add to the brush
 * @property {string} [brush.components[].component.action='add'] - Type of action to respond with
 */


var brushLassoComponent = {
  require: ['chart', 'renderer', 'settings'],
  defaultSettings: {
    layout: {
      displayOrder: 0
    },
    settings: {
      brush: {
        components: []
      },
      snapIndicator: {
        threshold: 75,
        strokeDasharray: '5, 5',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.5
      },
      lasso: {
        fill: 'transparent',
        stroke: 'black',
        strokeWidth: 2,
        opacity: 0.7,
        strokeDasharray: '20, 10'
      },
      startPoint: {
        r: 10,
        fill: 'green',
        stroke: 'black',
        strokeWidth: 1,
        opacity: 1
      }
    }
  },
  on: {
    lassoStart: function lassoStart(e) {
      this.start(e);
    },
    lassoEnd: function lassoEnd(e) {
      this.end(e);
    },
    lassoMove: function lassoMove(e) {
      this.move(e);
    },
    lassoCancel: function lassoCancel() {
      this.cancel();
    }
  },
  created: function created() {
    this.state = resetState();
  },
  start: function start(e) {
    this.state.active = true;
    this.state.path = initPath(this.settings.settings.lasso);
    this.state.snapIndicator = initSnapIndicator(this.settings.settings.snapIndicator);
    this.state.startPoint = initStartPoint(this.settings.settings.startPoint);
    this.state.rendererBounds = this.renderer.element().getBoundingClientRect();
    this.state.componentDelta = getComponentDelta(this.chart, this.state.rendererBounds);
    this.state.brushConfig = getBrushConfig(this.settings);
    var p = getPoint(this.state.rendererBounds, e);
    appendToPath(this.state, p);
    setSnapIndictor({
      state: this.state,
      start: p
    });
    setStartPoint(this.state, p);
  },
  move: function move(e) {
    if (!this.state.active) {
      return;
    }

    var p = getPoint(this.state.rendererBounds, e);

    if (withinThreshold(p, this.state, this.settings)) {
      showSnapIndicator(this.state, true);
    } else {
      showSnapIndicator(this.state, false);
    }

    appendToPath(this.state, p);
    setSnapIndictor({
      state: this.state,
      end: p
    });
    render$1(this.state, this.renderer);
    doLineBrush(this.state, this.chart);
  },
  end: function end(e) {
    if (!this.state.active) {
      return;
    }

    showSnapIndicator(this.state, false);
    var p = getPoint(this.state.rendererBounds, e);
    var shouldSnap = withinThreshold(p, this.state, this.settings);

    if (shouldSnap) {
      doPolygonBrush(this.state, this.chart);
    }

    this.state = resetState();
    this.renderer.render([]);
  },
  cancel: function cancel() {
    if (!this.state.active) {
      return;
    }

    endBrush(this.state, this.chart);
    this.state = resetState();
    this.renderer.render([]);
  },
  render: function render() {// Do nothing
  }
};

function lassoBrush(picasso) {
  picasso.component('brush-lasso', brushLassoComponent);
}

/**
 * Using the basic example found here: https://en.wikipedia.org/wiki/Binary_search_algorithm
 *
 * Finds the first node that may intersect the label.
 * @private
 */

function binaryLeftSearch(labelBounds, ary, coord, side, extractBounds) {
  var left = 0;
  var right = ary.length - 1;
  var bounds;

  while (left < right) {
    var m = Math.floor((left + right) / 2);
    bounds = extractBounds(ary[m]);

    if (bounds[coord] + bounds[side] < labelBounds[coord]) {
      // label is on right side
      left = m + 1;
    } else {
      // label is on the left side
      right = m;
    }
  }

  return left;
}
/**
 * The purpose of this module is to act as a filtering function to remove any labels
 * that meets one of the following criterias:
 * -- The label is not fully inside the container, such that it would be fully or partially clipped if rendered
 * -- The label overlaps another label
 * -- The label overlaps another bar which is not the bar the label is originating from
 *
 * Assumes that the nodes are sorted from left/top to right/down, as that allows
 * some optimizations to be performed.
 * @private
 * @returns {function} Filter function, returns false if label be removed and true otherwise
 */

function filterOverlappingLabels$1(_ref) {
  var orientation = _ref.orientation,
      targetNodes = _ref.targetNodes,
      labels = _ref.labels,
      container = _ref.container;
  var findLeft = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : binaryLeftSearch;
  var renderLabels = [];
  var coord = orientation === 'v' ? 'x' : 'y';
  var side = orientation === 'v' ? 'width' : 'height';

  var getTextBounds = function getTextBounds(item) {
    return item.textBounds;
  };

  var getNodeBounds = function getNodeBounds(item) {
    return item.node.localBounds;
  };

  return function (doNotUse, labelIndex) {
    var _labels$labelIndex = labels[labelIndex],
        labelBounds = _labels$labelIndex.textBounds,
        labelNode = _labels$labelIndex.node; // ### Test if label is not fully inside container based on the orientation ###

    if (labelBounds[coord] < container[coord] || labelBounds[coord] + labelBounds[side] > container[coord] + container[side]) {
      return false;
    } // ### Test label to label collision ###


    var leftStartLabel = findLeft(labelBounds, renderLabels, coord, side, getTextBounds);

    for (var i = leftStartLabel; i < renderLabels.length; i++) {
      if (testRectRect(labelBounds, renderLabels[i].textBounds)) {
        return false;
      }
    } // ### Test label to node collision ###


    var leftStartNode = findLeft(labelBounds, targetNodes, coord, side, getNodeBounds);
    var labelRightBoundary = labelBounds[coord] + labelBounds[side];

    for (var _i = leftStartNode; _i < targetNodes.length; _i++) {
      var node = targetNodes[_i].node; // Do not test beyond this node, as they are assumed to not collide with the label

      if (labelRightBoundary < node.localBounds[coord]) {
        break;
      }

      if (testRectRect(labelBounds, node.localBounds) && labelNode !== node) {
        return false;
      }
    } // No collision occured, allow the label to be rendered


    renderLabels.push(labels[labelIndex]);
    return true;
  };
}

var PADDING$1 = 4; // const DOUBLE_PADDING = PADDING * 2;

function cbContext(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function isValidText(text) {
  var type = picasso_esm_typeof(text);

  return (type === 'string' || type === 'number') && text !== '';
}

function toBackground(label) {
  return _objectSpread({
    type: 'rect',
    rx: 2,
    ry: 2,
    fill: label.backgroundColor
  }, label.backgroundBounds);
}

function isTextInRect(rect, textMetrics, opts) {
  return opts.rotate ? !(rect.width < textMetrics.height || rect.height < textMetrics.width) : !(rect.width < textMetrics.width || rect.height < textMetrics.height);
}
function placeSegmentInSegment(majorSegmentPosition, majorSegmentSize, minorSegmentSize, align) {
  var majorSegmentCenter = majorSegmentPosition + majorSegmentSize * 0.5;
  var offset = (align - 0.5) * (majorSegmentSize - minorSegmentSize);
  var minorSegmentCenter = majorSegmentCenter + offset;
  var minorSegmentPosition = minorSegmentCenter - minorSegmentSize * 0.5;
  return minorSegmentPosition;
}
function placeTextInRect(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: opts.rotate ? rect.height : rect.width,
    x: 0,
    y: rect.y,
    dx: 0,
    dy: 0,
    fill: opts.fill,
    anchor: opts.rotate ? 'end' : 'start',
    baseline: 'central',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };
  var textMetrics = opts.textMetrics;

  if (!opts.overflow && !isTextInRect(rect, textMetrics, opts)) {
    return false;
  }

  var baseLineOffset = textMetrics.height * 0.5;

  if (opts.rotate) {
    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.height, opts.align) + baseLineOffset;
    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.width, opts.justify);
    label.transform = "rotate(-90, ".concat(label.x + label.dx, ", ").concat(label.y + label.dy, ")");
  } else {
    label.x = placeSegmentInSegment(rect.x, rect.width, textMetrics.width, opts.align);
    label.y = placeSegmentInSegment(rect.y, rect.height, textMetrics.height, opts.justify) + baseLineOffset;
  }

  return label;
}

function limitBounds(bounds, view) {
  var minY = Math.max(0, Math.min(bounds.y, view.height));
  var maxY = Math.max(0, Math.min(bounds.y + bounds.height, view.height));
  var minX = Math.max(0, Math.min(bounds.x, view.width));
  var maxX = Math.max(0, Math.min(bounds.x + bounds.width, view.width));
  bounds.x = minX;
  bounds.width = maxX - minX;
  bounds.y = minY;
  bounds.height = maxY - minY;
}

function pad$1(bounds) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _padding$top = padding.top,
      top = _padding$top === void 0 ? PADDING$1 : _padding$top,
      _padding$bottom = padding.bottom,
      bottom = _padding$bottom === void 0 ? PADDING$1 : _padding$bottom,
      _padding$left = padding.left,
      left = _padding$left === void 0 ? PADDING$1 : _padding$left,
      _padding$right = padding.right,
      right = _padding$right === void 0 ? PADDING$1 : _padding$right;
  bounds.x += left;
  bounds.width -= left + right;
  bounds.y += top;
  bounds.height -= top + bottom;
}

function getBarRect(_ref) {
  var bar = _ref.bar,
      view = _ref.view,
      direction = _ref.direction,
      position = _ref.position,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? PADDING$1 : _ref$padding;
  var bounds = {};
  extend(bounds, bar);

  if (!position || position === 'inside') ; else if (direction === 'up' || direction === 'down') {
    var start = Math.max(0, Math.min(bar.y, view.height));
    var end = Math.max(0, Math.min(bar.y + bar.height, view.height));

    if (position === 'outside' && direction === 'up' || position === 'opposite' && direction === 'down') {
      bounds.y = 0;
      bounds.height = start;
    } else if (position === 'outside' && direction === 'down' || position === 'opposite' && direction === 'up') {
      bounds.y = end;
      bounds.height = view.height - end;
    }
  } else {
    var _start = Math.max(0, Math.min(bar.x, view.width));

    var _end = Math.max(0, Math.min(bar.x + bar.width, view.width));

    if (position === 'outside' && direction === 'left' || position === 'opposite' && direction === 'right') {
      bounds.x = 0;
      bounds.width = _start;
    } else if (position === 'outside' && direction === 'right' || position === 'opposite' && direction === 'left') {
      bounds.x = _end;
      bounds.width = view.width - _end;
    }
  }

  limitBounds(bounds, view);
  pad$1(bounds, padding);
  return bounds;
}
function findBestPlacement(_ref2) {
  var direction = _ref2.direction,
      fitsHorizontally = _ref2.fitsHorizontally,
      measured = _ref2.measured,
      node = _ref2.node,
      orientation = _ref2.orientation,
      placementSettings = _ref2.placementSettings,
      rect = _ref2.rect;
  var barRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getBarRect;
  var largest;
  var bounds;
  var placement;
  var testBounds;
  var p;
  var boundaries = [];

  for (p = 0; p < placementSettings.length; p++) {
    placement = placementSettings[p];
    testBounds = barRect({
      bar: node.localBounds,
      view: rect,
      direction: direction,
      position: placement.position,
      padding: placement.padding
    });
    boundaries.push(testBounds);
    largest = !p || testBounds.height > largest.height ? testBounds : largest;

    if (orientation === 'v' && (fitsHorizontally && testBounds.height >= measured.height || !fitsHorizontally && testBounds.height >= measured.width && testBounds.width >= measured.height)) {
      bounds = testBounds;
      break;
    } else if (orientation === 'h' && testBounds.height >= measured.height && testBounds.width >= measured.width) {
      bounds = testBounds;
      break;
    }
  } // fallback strategy - place the text in the largest rectangle


  if (!bounds) {
    bounds = largest;
    p = boundaries.indexOf(bounds);
  }

  placement = placementSettings[p];
  return {
    bounds: bounds,
    placement: placement
  };
}

function approxTextBounds(label, textMetrics, rotated, rect) {
  var padding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  var _padding$top2 = padding.top,
      top = _padding$top2 === void 0 ? PADDING$1 : _padding$top2,
      _padding$bottom2 = padding.bottom,
      bottom = _padding$bottom2 === void 0 ? PADDING$1 : _padding$bottom2,
      _padding$left2 = padding.left,
      left = _padding$left2 === void 0 ? PADDING$1 : _padding$left2,
      _padding$right2 = padding.right,
      right = _padding$right2 === void 0 ? PADDING$1 : _padding$right2;
  var x0 = label.x + label.dx;
  var y0 = label.y + label.dy;
  var height = rotated ? Math.min(textMetrics.width, rect.height) : Math.min(textMetrics.height, rect.width);
  var width = rotated ? Math.min(textMetrics.height, rect.height) : Math.min(textMetrics.width, rect.width);
  var offset = textMetrics.height * 0.5;
  var PADDING_OFFSET = 1e-9; // Needed to support a case when multiple bars are on the same location

  var x = rotated ? x0 - offset : x0;
  var y = rotated ? y0 : y0 - offset;
  var bounds = {
    x: x - left - PADDING_OFFSET,
    y: y - top - PADDING_OFFSET,
    width: width + (left + right) - PADDING_OFFSET,
    height: height + (top + bottom) - PADDING_OFFSET
  };
  return bounds;
}

function placeInBars(_ref3) {
  var chart = _ref3.chart,
      targetNodes = _ref3.targetNodes,
      rect = _ref3.rect,
      fitsHorizontally = _ref3.fitsHorizontally,
      collectiveOrientation = _ref3.collectiveOrientation;
  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement;
  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextInRect;
  var postFilter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : filterOverlappingLabels$1;
  var labels = [];
  var postFilterContext = {
    container: rect,
    targetNodes: targetNodes,
    labels: [],
    orientation: collectiveOrientation
  };
  var label;
  var target;
  var node;
  var text;
  var justify;
  var bounds;
  var fill;
  var measured;
  var direction;
  var lblStngs;
  var placement;
  var placements;
  var arg;
  var orientation;

  for (var i = 0, len = targetNodes.length; i < len; i++) {
    bounds = null;
    target = targetNodes[i];
    node = target.node;
    arg = cbContext(node, chart);
    direction = target.direction;
    orientation = direction === 'left' || direction === 'right' ? 'h' : 'v';

    for (var j = 0; j < target.texts.length; j++) {
      text = target.texts[j];

      if (!isValidText(text)) {
        continue;
      }

      lblStngs = target.labelSettings[j];
      measured = target.measurements[j];
      placements = lblStngs.placements;
      var bestPlacement = findPlacement({
        direction: direction,
        fitsHorizontally: fitsHorizontally,
        lblStngs: lblStngs,
        measured: measured,
        node: node,
        orientation: orientation,
        placements: placements,
        placementSettings: target.placementSettings[j],
        rect: rect
      });
      bounds = bestPlacement.bounds;
      placement = bestPlacement.placement;

      if (bounds && placement) {
        justify = placement.justify;
        fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;
        var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;
        var overflow = typeof placement.overflow === 'function' ? placement.overflow(arg, i) : placement.overflow;

        if (direction === 'up') {
          justify = 1 - justify;
        }

        if (placement.position === 'opposite') {
          justify = 1 - justify;
        }

        if (direction === 'left') {
          justify = 1 - justify;
        }

        var isRotated = !(collectiveOrientation === 'h' || fitsHorizontally);
        label = placer(bounds, text, {
          fill: fill,
          justify: orientation === 'h' ? placement.align : justify,
          align: orientation === 'h' ? justify : placement.align,
          fontSize: lblStngs.fontSize,
          fontFamily: lblStngs.fontFamily,
          textMetrics: measured,
          rotate: isRotated,
          overflow: !!overflow
        });

        if (label) {
          if (typeof linkData !== 'undefined') {
            label.data = linkData;
          }

          if (picasso_esm_typeof(placement.background) === 'object') {
            label.backgroundColor = typeof placement.background.fill === 'function' ? placement.background.fill(arg, i) : placement.background.fill;

            if (typeof label.backgroundColor !== 'undefined') {
              label.backgroundBounds = approxTextBounds(label, measured, isRotated, bounds, placement.background.padding);
            }
          }

          labels.push(label);
          postFilterContext.labels.push({
            node: node,
            textBounds: approxTextBounds(label, measured, isRotated, bounds, placement.padding)
          });
        }
      }
    }
  }

  var filteredLabels = labels.filter(postFilter(postFilterContext));
  var backgrounds = filteredLabels.filter(function (lb) {
    return typeof lb.backgroundBounds !== 'undefined';
  }).map(toBackground);
  return [].concat(_toConsumableArray$1(backgrounds), _toConsumableArray$1(filteredLabels));
}
function precalculate(_ref4) {
  var nodes = _ref4.nodes,
      rect = _ref4.rect,
      chart = _ref4.chart,
      labelSettings = _ref4.labelSettings,
      placementSettings = _ref4.placementSettings,
      settings = _ref4.settings,
      renderer = _ref4.renderer;
  var labelStruct = {};
  var targetNodes = [];
  var target;
  var fitsHorizontally = true;
  var hasHorizontalDirection = false;
  var node;
  var text;
  var bounds;
  var measured;
  var lblStng;
  var direction;

  for (var i = 0; i < nodes.length; i++) {
    node = nodes[i];
    bounds = node.localBounds;

    if (!testRectRect(bounds, rect)) {
      continue;
    }

    var arg = cbContext(node, chart);
    target = {
      node: node,
      texts: [],
      measurements: [],
      labelSettings: [],
      placementSettings: [] // direction: 'up'

    };

    for (var j = 0; j < labelSettings.length; j++) {
      lblStng = labelSettings[j];
      text = typeof lblStng.label === 'function' ? lblStng.label(arg, i) : undefined;

      if (!isValidText(text)) {
        continue; // eslint-ignore-line
      }

      direction = typeof settings.direction === 'function' ? settings.direction(arg, i) : settings.direction || 'up';
      hasHorizontalDirection = hasHorizontalDirection || direction === 'left' || direction === 'right';
      labelStruct.fontFamily = lblStng.fontFamily;
      labelStruct.fontSize = "".concat(lblStng.fontSize, "px");
      labelStruct.text = text;
      measured = renderer.measureText(labelStruct);
      target.measurements.push(measured);
      target.texts.push(text);
      target.labelSettings.push(lblStng);
      target.placementSettings.push(placementSettings[j]);
      target.direction = direction;
      fitsHorizontally = fitsHorizontally && measured.width <= bounds.width - PADDING$1 * 2;
    }

    targetNodes.push(target);
  }

  return {
    targetNodes: targetNodes,
    fitsHorizontally: fitsHorizontally,
    hasHorizontalDirection: hasHorizontalDirection
  };
}
/**
 * @typedef {object} component--labels~label-strategy
 *
 */

/**
 * @typedef {object} component--labels~label-strategy.settings
 * @property {string|function} [direction='up'] - The direction in which the bars are growing: 'up', 'down', 'right' or 'left'.
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {Array<object>} labels[].placements
 * @property {string} labels[].placements[].position - 'inside' | 'outside' | 'opposite'
 * @property {number} [labels[].placements[].justify=0] - Placement of the label along the direction of the bar
 * @property {number} [labels[].placements[].align=0.5] - Placement of the label along the perpendicular direction of the bar
 * @property {string} [labels[].placements[].fill='#333'] - Color of the label
 * @property {boolean} [labels[].placements[].overflow=false] - True if the label is allowed to overflow the bar
 * @property {object} labels[].placements[].padding - Padding between the label and the bar
 * @property {number} [labels[].placements[].padding.top=4] - Padding-top between the label and the bar
 * @property {number} [labels[].placements[].padding.bottom=4] - Padding-bottom between the label and the bar
 * @property {number} [labels[].placements[].padding.left=4] - Padding-left between the label and the bar
 * @property {number} [labels[].placements[].padding.right=4] - Padding-right between the label and the bar
 * @property {object} labels[].placements[].background - Background of the label
 * @property {string|function} labels[].placements[].background.fill - Background color of the label
 * @property {object} labels[].placements[].background.padding - Padding between the label and the background
 * @property {number} [labels[].placements[].background.padding.top=4] - Padding-top between the label and the background
 * @property {number} [labels[].placements[].background.padding.bottom=4] - Padding-bottom between the label and the background
 * @property {number} [labels[].placements[].background.padding.left=4] - Padding-left between the label and the background
 * @property {number} [labels[].placements[].background.padding.right=4] - Padding-right between the label and the background
 */

function bars(_ref5) {
  var settings = _ref5.settings,
      chart = _ref5.chart,
      nodes = _ref5.nodes,
      rect = _ref5.rect,
      renderer = _ref5.renderer,
      style = _ref5.style;
  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeInBars;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    align: 0.5,
    justify: 0,
    fill: '#333'
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, defaults, settings, labelSetting);
  });
  var placementSettings = settings.labels.map(function (labelSetting) {
    return labelSetting.placements.map(function (placement) {
      return extend({}, defaults, settings, labelSetting, placement);
    });
  });

  var _precalculate = precalculate({
    nodes: nodes,
    chart: chart,
    renderer: renderer,
    settings: settings,
    rect: rect,
    labelSettings: labelSettings,
    placementSettings: placementSettings
  }),
      fitsHorizontally = _precalculate.fitsHorizontally,
      hasHorizontalDirection = _precalculate.hasHorizontalDirection,
      targetNodes = _precalculate.targetNodes;

  var coord = hasHorizontalDirection ? 'y' : 'x';
  var side = hasHorizontalDirection ? 'height' : 'width';
  targetNodes.sort(function (a, b) {
    return a.node.localBounds[coord] + a.node.localBounds[side] - (b.node.localBounds[coord] + b.node.localBounds[side]);
  });
  return placer({
    chart: chart,
    targetNodes: targetNodes,
    stngs: settings,
    rect: rect,
    fitsHorizontally: fitsHorizontally,
    collectiveOrientation: hasHorizontalDirection ? 'h' : 'v'
  });
}

function normalize$1(angle) {
  var PI2 = Math.PI * 2;
  return (angle % PI2 + PI2) % PI2; // normalize
}

function pad$2(bounds, padding) {
  bounds.x += padding;
  bounds.width -= padding * 2;
  bounds.y += padding;
  bounds.height -= padding * 2;
}

function getTopLeftBounds(bounds) {
  var x = bounds.x;
  var y = bounds.y - bounds.height / 2;
  return {
    x: x,
    y: y,
    width: bounds.width,
    height: bounds.height
  };
} // assume 0 <= angle < (PI / 2)


function getLineCircleIntersection(radius, offset, angle) {
  var x = offset.x,
      y = offset.y;

  if (x * x + y * y > radius * radius) {
    return null;
  }

  var dx = Math.sin(angle);
  var dy = Math.cos(angle);
  var D = x * dy - y * dx;
  var d = radius * radius - D * D;

  if (d < 0) {
    return null;
  }

  var sqrtD = Math.sqrt(d);
  return {
    x: D * dy + dx * sqrtD,
    y: -(D * dx) + dy * sqrtD
  };
} // assume 0 <= angle < (PI * 2)


function getRectFromCircleIntersection(_ref) {
  var radius = _ref.radius,
      size = _ref.size,
      angle = _ref.angle;
  var width = size.width,
      height = size.height;
  var lineOffset = {
    x: width / 2,
    y: height / 2
  };
  var section = Math.floor(angle / (Math.PI / 2));
  var intersection;
  var offset;

  switch (section) {
    case 0:
      intersection = getLineCircleIntersection(radius, lineOffset, angle);

      if (!intersection) {
        return null;
      }

      intersection.y *= -1;
      offset = {
        x: -width,
        y: 0
      };
      break;

    case 1:
      intersection = getLineCircleIntersection(radius, lineOffset, Math.PI - angle);

      if (!intersection) {
        return null;
      }

      offset = {
        x: -width,
        y: -height
      };
      break;

    case 2:
      intersection = getLineCircleIntersection(radius, lineOffset, angle - Math.PI);

      if (!intersection) {
        return null;
      }

      intersection.x *= -1;
      offset = {
        x: 0,
        y: -height
      };
      break;

    case 3:
      intersection = getLineCircleIntersection(radius, lineOffset, 2 * Math.PI - angle);

      if (!intersection) {
        return null;
      }

      intersection.x *= -1;
      intersection.y *= -1;
      offset = {
        x: 0,
        y: 0
      };
      break;

    default:
      throw new Error('invalid angle');
  }

  var bounds = {
    x: intersection.x + offset.x,
    y: intersection.y + offset.y,
    width: width,
    height: height
  };
  return bounds;
}

function getHorizontalInsideSliceRect(_ref2) {
  var slice = _ref2.slice,
      padding = _ref2.padding,
      measured = _ref2.measured;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius;
  var middle = normalize$1((start + end) / 2);
  var size = {
    width: measured.width + padding * 2,
    height: measured.height + padding * 2
  };
  var bounds = getRectFromCircleIntersection({
    radius: outerRadius,
    size: size,
    angle: middle
  });

  if (!bounds) {
    return null;
  }

  bounds.baseline = 'top';
  var startLine = {
    x1: 0,
    y1: 0,
    x2: Math.sin(start) * outerRadius,
    y2: -Math.cos(start) * outerRadius
  };

  if (testRectLine(bounds, startLine)) {
    return null;
  }

  var endLine = {
    x1: 0,
    y1: 0,
    x2: Math.sin(end) * outerRadius,
    y2: -Math.cos(end) * outerRadius
  };

  if (testRectLine(bounds, endLine)) {
    return null;
  }

  var circle = {
    cx: 0,
    cy: 0,
    r: innerRadius
  };

  if (testCircleRect(circle, bounds)) {
    return null;
  }

  pad$2(bounds, padding);
  return bounds;
} // TODO: this case can support a justify setting


function getRotatedInsideSliceRect(_ref3) {
  var slice = _ref3.slice,
      measured = _ref3.measured,
      padding = _ref3.padding;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius;
  var maxWidth = outerRadius - innerRadius - padding * 2;
  var size = end - start;

  if (size < Math.PI) {
    var x = (measured.height / 2 + padding) / Math.tan(size / 2);

    if (x > innerRadius) {
      maxWidth = outerRadius - x - padding * 2;
    }
  }

  if (maxWidth < 0) {
    return null;
  }

  var middle = normalize$1((start + end) / 2);
  var r = outerRadius - padding;
  var bounds = {
    x: Math.sin(middle) * r,
    y: -Math.cos(middle) * r,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.angle = middle - Math.PI / 2;
    bounds.anchor = 'end';
  } else {
    bounds.angle = middle + Math.PI / 2;
    bounds.anchor = 'start';
  }

  return bounds;
}

function getRotatedOusideSliceRect(_ref4) {
  var slice = _ref4.slice,
      measured = _ref4.measured,
      padding = _ref4.padding,
      view = _ref4.view;
  var start = slice.start,
      end = slice.end,
      outerRadius = slice.outerRadius,
      offset = slice.offset;
  var r = outerRadius + padding;
  var size = end - start;

  if (size < Math.PI) {
    var minR = (measured.height / 2 + padding) / Math.tan(size / 2);

    if (minR > r) {
      return null;
    }
  }

  var middle = normalize$1((start + end) / 2);
  var x = Math.sin(middle) * r;
  var y = -Math.cos(middle) * r;
  var maxWidth = measured.width;
  var v = middle % Math.PI;

  if (v > Math.PI / 2) {
    v = Math.PI - v;
  }

  if (Math.cos(v) > 0.001) {
    var edge = y < 0 ? view.y : view.y + view.height;
    var d = Math.abs(edge - offset.y);
    var w = d / Math.cos(v) - Math.tan(v) * (measured.height / 2) - padding * 2 - outerRadius;

    if (w < maxWidth) {
      maxWidth = w;
    }
  }

  if (Math.sin(v) > 0.001) {
    var _edge = x < 0 ? view.x : view.x + view.width;

    var _d = Math.abs(_edge - offset.x);

    var _w = _d / Math.sin(v) - measured.height / 2 / Math.tan(v) - padding * 2 - outerRadius;

    if (_w < maxWidth) {
      maxWidth = _w;
    }
  }

  if (maxWidth <= 0) {
    return 0;
  }

  var bounds = {
    x: x,
    y: y,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.angle = middle - Math.PI / 2;
    bounds.anchor = 'start';
  } else {
    bounds.angle = middle + Math.PI / 2;
    bounds.anchor = 'end';
  }

  return bounds;
}

function outOfSpace(context, section, view) {
  switch (section) {
    case 0:
      return context.q1maxY < 0;

    case 1:
      return context.q2minY > view.height;

    case 2:
      return context.q3minY > view.height;

    case 3:
      return context.q4maxY < 0;

    default:
      return true;
  }
}

function adjustBounds(bounds, context, slice) {
  var LINE_PADDING = 2;
  var LIMIT = 1;
  var start = slice.start,
      end = slice.end,
      offset = slice.offset,
      outerRadius = slice.outerRadius;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  switch (section) {
    case 0:
      if (context.q1maxY !== undefined) {
        var y = Math.min(bounds.y, context.q1maxY - bounds.height);
        var dy = bounds.y - y;
        bounds.y = y;

        if (dy > LIMIT) {
          var r = outerRadius + LINE_PADDING;
          bounds.line = {
            type: 'line',
            x1: bounds.x - LINE_PADDING,
            y1: bounds.y + LINE_PADDING,
            x2: offset.x + Math.sin(middle) * r,
            y2: offset.y - Math.cos(middle) * r,
            strokeWidth: 1
          };
        }
      }

      break;

    case 1:
      if (context.q2minY !== undefined) {
        var _y = Math.max(bounds.y, context.q2minY);

        var _dy = _y - bounds.y;

        bounds.y = _y;

        if (_dy > LIMIT) {
          var _r = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x - LINE_PADDING,
            y1: bounds.y - LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r,
            y2: offset.y - Math.cos(middle) * _r,
            strokeWidth: 1
          };
        }
      }

      break;

    case 2:
      if (context.q3minY !== undefined) {
        var _y2 = Math.max(bounds.y, context.q3minY);

        var _dy2 = _y2 - bounds.y;

        bounds.y = _y2;

        if (_dy2 > LIMIT) {
          var _r2 = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x + LINE_PADDING,
            y1: bounds.y - LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r2,
            y2: offset.y - Math.cos(middle) * _r2,
            strokeWidth: 1
          };
        }
      }

      break;

    case 3:
      if (context.q4maxY !== undefined) {
        var _y3 = Math.min(bounds.y, context.q4maxY - bounds.height);

        var _dy3 = bounds.y - _y3;

        bounds.y = _y3;

        if (_dy3 > LIMIT) {
          var _r3 = outerRadius + LINE_PADDING;

          bounds.line = {
            type: 'line',
            x1: bounds.x + LINE_PADDING,
            y1: bounds.y + LINE_PADDING,
            x2: offset.x + Math.sin(middle) * _r3,
            y2: offset.y - Math.cos(middle) * _r3,
            strokeWidth: 1
          };
        }
      }

      break;

    default:
      break;
  }
}

function updateContext(_ref5) {
  var context = _ref5.context,
      node = _ref5.node,
      bounds = _ref5.bounds;
  var PADDING = 2;
  var _node$desc$slice = node.desc.slice,
      start = _node$desc$slice.start,
      end = _node$desc$slice.end;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  switch (section) {
    case 0:
      context.q1maxY = bounds.y - PADDING;

      if (context.q2minY === undefined) {
        context.q2minY = bounds.y + bounds.height + PADDING;
      }

      break;

    case 1:
      context.q2minY = bounds.y + bounds.height + PADDING;
      break;

    case 2:
      context.q3minY = bounds.y + bounds.height + PADDING;
      break;

    case 3:
      context.q4maxY = bounds.y - PADDING;

      if (context.q3minY === undefined) {
        context.q3minY = bounds.y + bounds.height + PADDING;
      }

      break;

    default:
      break;
  }
}

function getHorizontalOusideSliceRect(_ref6) {
  var slice = _ref6.slice,
      measured = _ref6.measured,
      padding = _ref6.padding,
      view = _ref6.view,
      context = _ref6.context;
  var start = slice.start,
      end = slice.end,
      outerRadius = slice.outerRadius,
      offset = slice.offset;
  var middle = normalize$1((start + end) / 2);
  var section = Math.floor(middle / (Math.PI / 2));

  if (outOfSpace(context, section, view)) {
    return null;
  }

  var r = outerRadius + padding + measured.height / 2;
  var x = Math.sin(middle) * r;
  var y = -Math.cos(middle) * r;
  var maxWidth = measured.width;

  if (middle < Math.PI) {
    var w = Math.abs(view.x + view.width - (x + offset.x));

    if (w < maxWidth) {
      maxWidth = w;
    }
  } else {
    var _w2 = Math.abs(view.x - (x + offset.x));

    if (_w2 < maxWidth) {
      maxWidth = _w2;
    }
  }

  var bounds = {
    x: x,
    y: y,
    width: maxWidth,
    height: measured.height
  };

  if (middle < Math.PI) {
    bounds.anchor = 'start';
  } else {
    bounds.anchor = 'end';
  }

  return bounds;
}

function cbContext$1(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function placeTextOnPoint(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: rect.width,
    x: rect.x,
    y: rect.y + (rect.baseline === 'top' ? rect.height / 2 : 0),
    fill: opts.fill,
    anchor: rect.anchor || 'start',
    baseline: 'middle',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };

  if (!isNaN(rect.angle)) {
    var angle = rect.angle * (360 / (Math.PI * 2));
    label.transform = "rotate(".concat(angle, ", ").concat(label.x, ", ").concat(label.y, ")");
  }

  return label;
}

function getSliceRect(_ref7) {
  var slice = _ref7.slice,
      direction = _ref7.direction,
      position = _ref7.position,
      padding = _ref7.padding,
      measured = _ref7.measured,
      view = _ref7.view,
      context = _ref7.context;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      offset = slice.offset;
  var bounds;
  var s;

  switch (position) {
    case 'into':
      if (direction === 'rotate') {
        bounds = getRotatedInsideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding
        });
      } else {
        bounds = getHorizontalInsideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding
        });
      }

      break;

    case 'inside':
      s = {
        start: start,
        end: end,
        innerRadius: 0,
        outerRadius: innerRadius
      };

      if (direction === 'rotate') {
        bounds = getRotatedInsideSliceRect({
          slice: s,
          measured: measured,
          padding: padding
        });
      } else {
        bounds = getHorizontalInsideSliceRect({
          slice: s,
          measured: measured,
          padding: padding
        });
      }

      break;

    case 'outside':
      if (direction === 'rotate') {
        bounds = getRotatedOusideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding,
          view: view
        });
      } else {
        bounds = getHorizontalOusideSliceRect({
          slice: slice,
          measured: measured,
          padding: padding,
          view: view,
          context: context
        });
      }

      break;

    default:
      throw new Error('not implemented');
  }

  if (bounds) {
    bounds.x += offset.x;
    bounds.y += offset.y;

    if (position === 'outside' && direction !== 'rotate') {
      adjustBounds(bounds, context, slice);
    }
  }

  return bounds;
}

function findBestPlacement$1(_ref8) {
  var context = _ref8.context,
      direction = _ref8.direction,
      measured = _ref8.measured,
      node = _ref8.node,
      placementSettings = _ref8.placementSettings,
      rect = _ref8.rect;
  var sliceRect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSliceRect;

  for (var p = 0; p < placementSettings.length; p++) {
    var placement = placementSettings[p];
    var bounds = sliceRect({
      context: context,
      slice: node.desc.slice,
      view: rect,
      direction: direction,
      position: placement.position,
      measured: measured,
      padding: placement.padding
    });

    if (!bounds) {
      continue;
    }

    return {
      bounds: bounds,
      placement: placement
    };
  }

  return {
    bounds: null,
    placement: null
  };
}
/*
 * Sorts the nodes so that
 *   in each quarter sort nodes from the center (in y) outwards
 *   first quarter before the second
 *   forth quarter before the third
 */


function sortNodes(nodes) {
  var q1 = [];
  var q2 = [];
  var q3 = [];
  var q4 = [];

  for (var i = 0; i < nodes.length; ++i) {
    var _nodes$i$desc$slice = nodes[i].desc.slice,
        start = _nodes$i$desc$slice.start,
        end = _nodes$i$desc$slice.end;
    var middle = normalize$1((start + end) / 2);
    var section = Math.floor(middle / (Math.PI / 2));

    switch (section) {
      case 0:
        q1.push(nodes[i]);
        break;

      case 1:
        q2.push(nodes[i]);
        break;

      case 2:
        q3.push(nodes[i]);
        break;

      case 3:
        q4.push(nodes[i]);
        break;

      default:
        break;
    }
  }

  var sortFn = function sortFn(a, b) {
    var middleA = normalize$1((a.desc.slice.start + a.desc.slice.end) / 2);
    var middleB = normalize$1((b.desc.slice.start + b.desc.slice.end) / 2);
    return middleA - middleB;
  };

  var reverseSortFn = function reverseSortFn(a, b) {
    return sortFn(b, a);
  };

  q1.sort(reverseSortFn);
  q2.sort(sortFn);
  q3.sort(reverseSortFn);
  q4.sort(sortFn);
  return q1.concat(q2, q4, q3);
}
/**
 * @typedef {object} component--labels~slices-label-strategy
 *
 */

/**
 * @typedef {object} component--labels~slices-label-strategy.settings
 * @property {string|function} [direction='horizontal'] - The direction of the text: 'horizontal' or 'rotate'.
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {Array<object>} labels[].placements
 * @property {string} [labels[].placements[].position='into'] - 'inside' | 'into' | 'outside' (outside is not implmented yet)
 * @property {string} [labels[].placements[].fill='#333'] - Color of the label
 */


function slices(_ref9) {
  var settings = _ref9.settings,
      chart = _ref9.chart,
      nodes = _ref9.nodes,
      rect = _ref9.rect,
      renderer = _ref9.renderer,
      style = _ref9.style;
  var findPlacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : findBestPlacement$1;
  var placer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : placeTextOnPoint;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    fill: '#333',
    padding: 4,
    position: 'into'
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, defaults, settings, labelSetting);
  });
  var placementSettings = settings.labels.map(function (labelSetting) {
    return labelSetting.placements.map(function (placement) {
      return extend({}, defaults, settings, labelSetting, placement);
    });
  });
  var labelStruct = {};
  var labels = [];
  nodes = sortNodes(nodes);
  var context = {};

  for (var i = 0, len = nodes.length; i < len; i++) {
    var node = nodes[i];
    var arg = cbContext$1(node, chart);

    for (var j = 0; j < labelSettings.length; j++) {
      var lblStngs = labelSettings[j];
      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';

      if (!text) {
        continue;
      }

      var direction = typeof lblStngs.direction === 'function' ? lblStngs.direction(arg, i) : lblStngs.direction || 'horizontal';
      var linkData = typeof lblStngs.linkData === 'function' ? lblStngs.linkData(arg, i) : undefined;
      labelStruct.fontFamily = lblStngs.fontFamily;
      labelStruct.fontSize = "".concat(lblStngs.fontSize, "px");
      labelStruct.text = text;
      var measured = renderer.measureText(labelStruct);
      var bestPlacement = findPlacement({
        context: context,
        direction: direction,
        lblStngs: lblStngs,
        measured: measured,
        node: node,
        placementSettings: placementSettings[j],
        rect: rect
      });
      var bounds = bestPlacement.bounds;
      var placement = bestPlacement.placement;

      if (bounds && placement) {
        if (placement.position === 'outside' && direction !== 'rotate') {
          updateContext({
            context: context,
            node: node,
            bounds: bounds
          });
          var topLeftBounds = getTopLeftBounds(bounds);

          if (!rectContainsRect(topLeftBounds, rect)) {
            continue;
          }
        }

        var fill = typeof placement.fill === 'function' ? placement.fill(arg, i) : placement.fill;
        var label = placer(bounds, text, {
          fill: fill,
          fontSize: lblStngs.fontSize,
          fontFamily: lblStngs.fontFamily,
          textMetrics: measured
        });

        if (label) {
          if (typeof linkData !== 'undefined') {
            label.data = linkData;
          }

          labels.push(label);

          if (bounds.line) {
            bounds.line.stroke = fill;
            labels.push(bounds.line);
          }
        }
      }
    }
  }

  return labels;
}

var LINE_HEIGHT = 1.2;
var CIRCLE_FACTOR = 0.9;

function cbContext$2(node, chart) {
  return {
    node: node,
    data: node.data,
    scale: chart.scale,
    formatter: chart.formatter,
    dataset: chart.dataset
  };
}

function placeTextInRect$1(rect, text, opts) {
  var label = {
    type: 'text',
    text: text,
    maxWidth: rect.width,
    x: 0,
    y: rect.y,
    dx: 0,
    dy: 0,
    fill: opts.fill,
    anchor: 'start',
    baseline: 'alphabetical',
    fontSize: "".concat(opts.fontSize, "px"),
    fontFamily: opts.fontFamily
  };
  var textMetrics = opts.textMetrics;

  if (rect.width < opts.fontSize) {
    return false;
  }

  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);
  label.x = rect.x + opts.align * wiggleWidth;
  label.y = rect.y + textMetrics.height / LINE_HEIGHT;
  return label;
}

function getRectFromCircle(_ref) {
  var cx = _ref.cx,
      cy = _ref.cy,
      r = _ref.r;
  return {
    type: 'circle',
    bounds: {
      cx: cx,
      cy: cy,
      r: r
    }
  };
}

function getSliceBounds(slice) {
  var EPSILON = 1e-12;
  var start = slice.start,
      end = slice.end,
      innerRadius = slice.innerRadius,
      outerRadius = slice.outerRadius,
      offset = slice.offset;

  if (Math.abs(start + 2 * Math.PI - end) > EPSILON) {
    return {
      type: null,
      bounds: null
    };
  }

  var r = innerRadius !== 0 ? innerRadius : outerRadius;
  return getRectFromCircle({
    cx: offset.x,
    cy: offset.y,
    r: r
  });
}

function getBounds(node) {
  if (node.desc && node.desc.slice) {
    return getSliceBounds(node.desc.slice);
  }

  if (node.type === 'circle') {
    return getRectFromCircle(node.attrs);
  }

  if (node.type === 'rect') {
    return {
      type: 'rect',
      bounds: node.bounds
    };
  } // defualt to node.bounds ?


  return {
    type: null,
    bounds: null
  };
}
/**
 * @typedef {object} component--labels~rows-label-strategy
 *
 */

/**
 * @typedef {object} component--labels~rows-label-strategy.settings
 * @property {string} [fontFamily='Arial']
 * @property {number} [fontSize=12]
 * @property {number} [justify=0.5]
 * @property {number} [padding=4]
 * @property {Array<object>} labels
 * @property {string|function} labels[].label - The text value
 * @property {function} labels[].linkData - Link data to the label
 * @property {number} [labels[].align=0.5]
 * @property {string|function} [labels[].fill='#333']
 */


function rows(_ref2) {
  var settings = _ref2.settings,
      chart = _ref2.chart,
      nodes = _ref2.nodes,
      renderer = _ref2.renderer,
      style = _ref2.style;
  var placer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeTextInRect$1;
  var defaults = extend({
    fontSize: 12,
    fontFamily: 'Arial',
    fill: '#333',
    padding: 4,
    align: 0.5,
    justify: 0.5
  }, style.label);
  defaults.fontSize = parseInt(defaults.fontSize, 10);
  var rowSettings = extend({}, defaults, settings);
  var labelSettings = settings.labels.map(function (labelSetting) {
    return extend({}, rowSettings, labelSetting);
  });
  var labelStruct = {};
  var labels = [];

  for (var i = 0, len = nodes.length; i < len; i++) {
    var node = nodes[i];
    var arg = cbContext$2(node, chart);

    var _getBounds = getBounds(node),
        type = _getBounds.type,
        bounds = _getBounds.bounds;

    if (!bounds) {
      continue;
    }

    var totalHeight = 0;
    var measurements = [];
    var texts = [];
    var maxHeight = type === 'circle' ? 2 * bounds.r * CIRCLE_FACTOR : bounds.height;
    totalHeight += rowSettings.padding;
    var j = void 0;

    for (j = 0; j < labelSettings.length; j++) {
      var lblStngs = labelSettings[j];
      var text = typeof lblStngs.label === 'function' ? lblStngs.label(arg, i) : '';
      labelStruct.fontFamily = lblStngs.fontFamily;
      labelStruct.fontSize = "".concat(lblStngs.fontSize, "px");
      labelStruct.text = text;
      var measured = renderer.measureText(labelStruct);
      totalHeight += measured.height + lblStngs.padding;

      if (totalHeight > maxHeight) {
        break;
      }

      texts.push(text);
      measurements.push(measured);
    }

    var labelCount = j;
    var wiggleHeight = Math.max(0, maxHeight - totalHeight);
    var currentY = void 0;

    if (type === 'circle') {
      currentY = bounds.cy - bounds.r * CIRCLE_FACTOR;
    } else {
      currentY = bounds.y;
    }

    currentY += rowSettings.justify * wiggleHeight + rowSettings.padding;

    for (j = 0; j < labelCount; j++) {
      var _lblStngs = labelSettings[j];
      var rect = void 0;

      if (type === 'circle') {
        var maxYDistToCenter = Math.max(Math.abs(currentY - bounds.cy), Math.abs(currentY + measurements[j].height - bounds.cy));
        var halfWidth = Math.sqrt(bounds.r * bounds.r - maxYDistToCenter * maxYDistToCenter);
        rect = {
          x: bounds.cx - halfWidth + rowSettings.padding,
          y: currentY,
          width: 2 * halfWidth - 2 * rowSettings.padding,
          height: measurements[j].height
        };
      } else {
        rect = {
          x: bounds.x + rowSettings.padding,
          y: currentY,
          width: bounds.width - 2 * rowSettings.padding,
          height: measurements[j].height
        };
      }

      currentY += measurements[j].height + rowSettings.padding;
      var fill = typeof _lblStngs.fill === 'function' ? _lblStngs.fill(arg, i) : _lblStngs.fill;
      var linkData = typeof _lblStngs.linkData === 'function' ? _lblStngs.linkData(arg, i) : undefined;
      var label = placer(rect, texts[j], {
        fill: fill,
        align: _lblStngs.align,
        fontSize: _lblStngs.fontSize,
        fontFamily: _lblStngs.fontFamily,
        textMetrics: measurements[j]
      });

      if (label) {
        if (typeof linkData !== 'undefined') {
          label.data = linkData;
        }

        labels.push(label);
      }
    }
  }

  return labels;
}

var strategies = {
  bar: bars,
  slice: slices,
  rows: rows
};

/**
 * @typedef {object} component--labels
 * @property {string} [type='labels']
 */

/**
 * @typedef {object} component--labels.settings
 * @property {Array<object>} sources
 * @property {string} sources[].component
 * @property {string} sources[].selector
 * @property {component--labels~label-strategy} sources[].strategy
 */

function strategy(_ref, fn) {
  var chart = _ref.chart,
      source = _ref.source,
      rect = _ref.rect,
      renderer = _ref.renderer,
      style = _ref.style;
  var component = chart.component(source.component);

  if (!component) {
    return [];
  }

  var nodes = chart.findShapes(source.selector).filter(function (n) {
    return n.key === source.component;
  });
  return fn({
    chart: chart,
    settings: source.strategy.settings,
    nodes: nodes,
    rect: {
      x: 0,
      y: 0,
      width: rect.width,
      height: rect.height
    },
    renderer: renderer,
    style: style
  });
}
var labelsComponent = {
  require: ['chart', 'renderer', 'settings'],
  defaultSettings: {
    settings: {},
    style: {
      label: '$label'
    }
  },
  render: function render() {
    var _this = this;

    var stngs = this.settings.settings;
    var labels = [];
    (stngs.sources || []).forEach(function (source) {
      if (source.strategy && strategies[source.strategy.type] && source.component) {
        labels.push.apply(labels, _toConsumableArray$1(strategy({
          chart: _this.chart,
          rect: _this.rect,
          renderer: _this.renderer,
          source: source,
          style: _this.style
        }, strategies[source.strategy.type])));
      }
    });
    return labels;
  }
};

function picasso_esm_labels(picasso) {
  picasso.component('labels', labelsComponent);
}

/**
 * @typedef {object}
 * @alias component--legend-cat.settings
 */

var DEFAULT_SETTINGS$6 = {
  /**
   * @typedef {object=}
   */
  layout: {
    /**
     * Maximum number of columns (vertical) or rows (horizontal)
     * @type {number=}
     */
    size: 1,

    /**
     * Layout direction. Either `'ltr'` or `'rtl'`
     * @type {string=}
     */
    direction: 'ltr',

    /** Initial scroll offset
     * @type {number=} */
    scrollOffset: 0
  },

  /**
   * Settings applied per item
   * @typedef {object=}
   */
  item: {
    /** Whether to show the current item
     * @type {boolean=} */
    show: true,
    justify: 0.5,
    align: 0.5,

    /**
     * @typedef {object=} */
    label: {
      fontSize: '12px',
      fontFamily: 'Arial',
      fill: '#595959',

      /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
       * @type {string=} */
      wordBreak: 'none',

      /** Max number of lines allowed if label is broken into multiple lines (only applicable with wordBreak)
       * @type {number=} */
      maxLines: 2,

      /** Maximum width of label, in px
       * @type {number=} */
      maxWidth: 136,
      lineHeight: 1.2
    },

    /**
     * @typedef {object=} */
    shape: {
      /**
       * @type {string=} */
      type: 'square',

      /**
       * @type {number=} */
      size: 12
    }
  },

  /**
   * @typedef {object=} */
  title: {
    /** Whether to show the title
     * @type {boolean=} */
    show: true,

    /** Title text. Defaults to the title of the provided data field
     * @type {string=} */
    text: undefined,

    /** Horizontal alignment of the text. Allowed values are `'start'`, `'middle'` and `'end'`
     * @type {string}
     */
    anchor: 'start',
    fontSize: '16px',
    fontFamily: 'Arial',
    fill: '#595959',

    /** Word break rule, how to apply line break if label text overflows its maxWidth property. Either `'break-word'` or `'break-all'`
     * @type {string=} */
    wordBreak: 'none',

    /** Max number of lines allowed if label is broken into multiple lines, is only appled when `wordBreak` is not set to `'none'`
     * @type {number=} */
    maxLines: 2,

    /** Maximum width of title, in px
     * @type {number=} */
    maxWidth: 156,
    lineHeight: 1.25
  },

  /**
   * @typedef {object=} */
  navigation: {
    /**
     * @typedef {object=} */
    button: {
      /**
       * @type {object<string, boolean>=} */
      class: undefined,

      /**
       * @type {function} */
      content: undefined
    },

    /** Whether the button should be disabled or not
     * @type {boolean=} */
    disabled: false
  }
};
/**
 * Resolve settings based on input, defaults, and data
 *
 * @ignore
 * @param {legendComponent} comp - The component instance
 */

function resolveSettings$2(comp) {
  var domain = comp.scale.domain();
  var data = {
    items: []
  };
  var dock = comp.settings.layout.dock;

  if (comp.scale.type === 'threshold-color') {
    var fields = comp.scale.data().fields;
    var sourceField = fields[0];

    var formatter = function formatter(v) {
      return String(v);
    };

    if (comp.settings.formatter) {
      formatter = comp.chart.formatter(comp.settings.formatter);
    } else if (sourceField) {
      formatter = sourceField.formatter();
    }

    for (var i = 0; i < domain.length - 1; i++) {
      var it = {
        value: domain[i],
        label: "".concat(formatter(domain[i]), " - < ").concat(formatter(domain[i + 1]))
      };

      if (sourceField) {
        it.source = {
          field: sourceField.id()
        };
      }

      data.items.push(it);
    }

    var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';

    if (orientation === 'vertical') {
      data.items.reverse();
    }
  } else {
    var _labels = comp.scale.labels ? comp.scale.labels() : null;

    data.items = domain.map(function (d, idx) {
      var datum = comp.scale.datum ? extend({}, comp.scale.datum(d)) : {
        value: d
      };
      datum.value = d;

      if (comp.scale.label) {
        datum.label = comp.scale.label(d);
      } else if (_labels) {
        datum.label = _labels[idx];
      }

      return datum;
    });
  }

  var title = comp.resolver.resolve({
    data: {
      fields: comp.scale.data().fields
    },
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.title, comp.style.title),
    settings: comp.settings.settings.title
  });
  var layout = comp.resolver.resolve({
    data: {
      fields: comp.scale.data().fields
    },
    defaults: DEFAULT_SETTINGS$6.layout,
    settings: comp.settings.settings.layout
  });
  var labels = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.label, comp.style.item.label),
    settings: (comp.settings.settings.item || {}).label
  });
  var shapeSettings = extend(true, {}, (comp.settings.settings.item || {}).shape);

  if (typeof shapeSettings.fill === 'undefined' && comp.settings.scale) {
    shapeSettings.fill = {
      scale: comp.settings.scale
    };
  }

  var symbols = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, DEFAULT_SETTINGS$6.item.shape, comp.style.item.shape),
    settings: shapeSettings
  });
  var items = comp.resolver.resolve({
    data: data,
    defaults: extend(true, {}, {
      show: DEFAULT_SETTINGS$6.item.show
    }),
    settings: {
      show: (comp.settings.settings.item || {}).show
    }
  });

  function range(item, i) {
    var v = item.data.value;
    var next = domain[i + 1];
    item.data.value = [v, next];
  }

  if (comp.scale.type === 'threshold-color') {
    var _orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';

    if (_orientation === 'vertical') {
      items.items.reverse().forEach(range);
      items.items.reverse();
    } else {
      items.items.forEach(range);
    }
  }

  return {
    title: title,
    labels: labels,
    symbols: symbols,
    items: items,
    layout: layout
  };
}

/* eslint no-mixed-operators:0 */

function placeTextInRect$2(rect, label, opts) {
  var textMetrics = opts.textMetrics;

  if (rect.height < textMetrics.height) {
    return false;
  }

  var wiggleWidth = Math.max(0, rect.width - textMetrics.width);
  label.baseline = 'text-before-edge';
  var wiggleHeight = Math.max(0, rect.height - textMetrics.height);
  label.x = rect.x + opts.align * wiggleWidth;
  label.y = rect.y + opts.justify * wiggleHeight + parseInt(label.fontSize, 10) * 0.175; // 0.175 - basline offset

  return label;
}

function wiggleSymbol(container, size, opts) {
  var wiggleWidth = Math.max(0, container.width - size);
  var wiggleHeight = Math.max(0, container.height - size);
  return {
    x: container.x + size / 2 + opts.align * wiggleWidth,
    y: container.y + size / 2 + opts.justify * wiggleHeight
  };
}

function createRenderItem(_ref) {
  var _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      y = _ref.y,
      item = _ref.item,
      globalMetrics = _ref.globalMetrics,
      _ref$symbolFn = _ref.symbolFn,
      symbolFn = _ref$symbolFn === void 0 ? create$3 : _ref$symbolFn,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'ltr' : _ref$direction;
  var label = item.label.displayObject;
  var labelBounds = item.label.bounds;
  var symbolItem = item.symbol.meta;
  var rtl = direction === 'rtl';
  var labelRect = {
    x: rtl ? x + globalMetrics.maxLabelBounds.width : x + globalMetrics.maxSymbolSize + globalMetrics.spacing,
    y: y,
    width: globalMetrics.maxLabelBounds.width,
    height: Math.max(globalMetrics.maxSymbolSize, globalMetrics.maxLabelBounds.height)
  };
  var wiggled = wiggleSymbol({
    x: rtl ? x + globalMetrics.maxLabelBounds.width + globalMetrics.spacing : x,
    y: y,
    width: globalMetrics.maxSymbolSize,
    height: labelRect.height
  }, symbolItem.size, {
    align: typeof symbolItem.align === 'undefined' ? 0.5 : symbolItem.align,
    justify: typeof symbolItem.justify === 'undefined' ? 0.5 : symbolItem.justify
  });
  var symbol = symbolFn(extend({}, symbolItem, wiggled));
  delete symbol.collider;
  label.anchor = rtl ? 'end' : 'start';
  placeTextInRect$2(labelRect, label, {
    textMetrics: labelBounds,
    fontSize: parseInt(label.fontSize, 10),
    align: 0.0,
    justify: 0.5
  });
  var container = {
    type: 'container',
    data: item.label.displayObject.data,
    children: [symbol, label],
    collider: {
      type: 'rect',
      x: x,
      y: y,
      width: globalMetrics.maxItemBounds.width,
      height: globalMetrics.maxItemBounds.height
    }
  };
  return {
    item: container,
    metrics: labelRect
  };
}

function _getItemsToRender(_ref2, rect, _ref3) {
  var viewRect = _ref2.viewRect;
  var itemized = _ref3.itemized,
      _ref3$create = _ref3.create,
      create = _ref3$create === void 0 ? createRenderItem : _ref3$create,
      parallels = _ref3.parallels;
  var direction = itemized.layout.direction;
  var globalMetrics = itemized.globalMetrics;
  var legendItems = itemized.items;
  var isHorizontal = itemized.layout.orientation === 'horizontal';
  var s = 0;
  var renderItems = [];
  var fixedHeight = globalMetrics.maxItemBounds.height;
  var fixedWidth = globalMetrics.maxItemBounds.width;
  var rowHeight = itemized.layout.margin.vertical + fixedHeight;
  var columnWidth = itemized.layout.margin.horizontal + fixedWidth;
  var x = rect.x;
  var y = rect.y;
  var shift = viewRect.x - rect.x;

  for (var i = 0; i < legendItems.length; i++) {
    var renderItem = create({
      y: y,
      x: direction === 'rtl' ? viewRect.x + shift + viewRect.width - fixedWidth - (x - rect.x) : x,
      item: legendItems[i],
      globalMetrics: globalMetrics,
      direction: direction
    });

    if (isHorizontal && x >= viewRect.x - fixedWidth || !isHorizontal && y >= viewRect.y - fixedHeight) {
      renderItems.push(renderItem.item);
    }

    s++;

    if (s >= parallels) {
      s = 0;

      if (isHorizontal) {
        x += columnWidth; // next column

        y = rect.y; // reset y to first row
      } else {
        y += rowHeight; // next row

        x = rect.x; // reset x to first column
      }
    } else if (isHorizontal) {
      y += rowHeight; // next row
    } else {
      x += columnWidth; // next column
    }

    if (!isHorizontal && y > viewRect.y + viewRect.height) {
      break;
    } else if (isHorizontal && x > viewRect.x + viewRect.width) {
      break;
    }
  }

  return renderItems;
}

function _itemize(_ref4, renderer) {
  var resolved = _ref4.resolved,
      dock = _ref4.dock;
  var label;
  var items = [];
  var item;
  var sourceItems = resolved.items.items;
  var sourceSymbols = resolved.symbols.items;
  var sourceLabels = resolved.labels.items;
  var maxSymbolSize = 0;
  var maxLabelWidth = 0;
  var maxLabelHeight = 0;

  for (var i = 0; i < sourceItems.length; i++) {
    if (sourceItems[i].show === false) {
      continue;
    }

    var text = typeof sourceLabels[i].text !== 'undefined' ? sourceLabels[i].text : sourceLabels[i].data.label || '';
    label = extend({}, sourceLabels[i], {
      // create the displayObject here in order to measure it
      type: 'text',
      fontSize: "".concat(parseInt(sourceLabels[i].fontSize, 10), "px"),
      text: text,
      title: text
    });
    item = {
      symbol: {
        // can't create a displayObject here due to need to wiggle the center position of the symbol later on,
        // just store the object needed later on
        meta: sourceSymbols[i]
      },
      label: {
        displayObject: label,
        bounds: renderer.textBounds(label)
      }
    };
    items.push(item);
    maxSymbolSize = Math.max(sourceSymbols[i].size, maxSymbolSize);
    maxLabelWidth = Math.max(item.label.bounds.width, maxLabelWidth);
    maxLabelHeight = Math.max(item.label.bounds.height, maxLabelHeight);
  }

  return {
    items: items,
    globalMetrics: {
      spacing: 8,
      maxSymbolSize: maxSymbolSize,
      maxItemBounds: {
        height: Math.max(maxSymbolSize, maxLabelHeight),
        width: maxSymbolSize + 8 + maxLabelWidth
      },
      maxLabelBounds: {
        width: maxLabelWidth,
        height: maxLabelHeight
      }
    },
    layout: {
      margin: {
        vertical: typeof resolved.layout.item.vertical !== 'undefined' ? resolved.layout.item.vertical : 4,
        horizontal: typeof resolved.layout.item.horizontal !== 'undefined' ? resolved.layout.item.horizontal : 4
      },
      mode: resolved.layout.item.mode,
      size: resolved.layout.item.size,
      orientation: dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical',
      direction: resolved.layout.item.direction,
      scrollOffset: resolved.layout.item.scrollOffset
    }
  };
}

function _extent(itemized, parallels) {
  var count = itemized.items.length;
  var size = Math.ceil(count / parallels);
  var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
  var margin = property === 'width' ? 'horizontal' : 'vertical';
  return itemized.globalMetrics.maxItemBounds[property] * size + (size - 1) * itemized.layout.margin[margin];
}

function _spread(itemized, parallels) {
  var size = parallels;
  var property = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';
  var margin = property === 'width' ? 'horizontal' : 'vertical';
  return itemized.globalMetrics.maxItemBounds[property] * size + // expected vertical size of items
  (size - 1) * itemized.layout.margin[margin]; // expected spacing between items
}

function _parallelize(availableExtent, availableSpread, itemized) {
  var count = itemized.items.length;
  var extentProperty = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
  var margin = extentProperty === 'width' ? 'horizontal' : 'vertical';
  var extentInPx = itemized.globalMetrics.maxItemBounds[extentProperty] * count + (count - 1) * itemized.layout.margin[margin];
  var numNeeded = Math.ceil(extentInPx / availableExtent);

  if (availableSpread != null) {
    var spreadProperty = itemized.layout.orientation === 'horizontal' ? 'height' : 'width';
    var numAllowed = Math.floor(availableSpread / (4 + itemized.globalMetrics.maxItemBounds[spreadProperty]));
    numNeeded = Math.min(numNeeded, numAllowed);
  }

  var numInput = isNaN(itemized.layout.size) ? 1 : itemized.layout.size;
  return Math.max(1, Math.min(numNeeded, numInput));
}
function itemRendererFactory (legend, _ref5) {
  var _ref5$onScroll = _ref5.onScroll,
      onScroll = _ref5$onScroll === void 0 ? function () {} : _ref5$onScroll;
  var itemized;
  var parallels;
  var viewRect;
  var containerRect;
  var _offset = null;
  var overflow = 0;
  var api = {
    itemize: function itemize(obj) {
      itemized = _itemize(obj, legend.renderer);
      _offset = !isNaN(itemized.layout.scrollOffset) ? itemized.layout.scrollOffset : _offset; // Set the initial offset
    },
    getItemsToRender: function getItemsToRender(obj) {
      viewRect = obj.viewRect;
      overflow = api.getContentOverflow(viewRect);
      var ext = api.extent();
      _offset = Math.max(0, Math.min(_offset, overflow));
      containerRect = extend({}, viewRect);
      var offsetProperty = api.orientation() === 'horizontal' ? 'x' : 'y';
      containerRect[offsetProperty] -= _offset;
      containerRect[offsetProperty === 'x' ? 'width' : 'height'] = ext;
      return _getItemsToRender(obj, containerRect, {
        itemized: itemized,
        parallels: parallels
      });
    },
    parallelize: function parallelize(availableExtent, availableSpread) {
      parallels = _parallelize(availableExtent, availableSpread, itemized);
      return parallels;
    },
    hasContentOverflow: function hasContentOverflow() {
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      return _extent(itemized, parallels) > viewRect[property];
    },
    getContentOverflow: function getContentOverflow() {
      var rect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : viewRect;
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      return Math.max(0, _extent(itemized, parallels) - rect[property]);
    },
    getNextSize: function getNextSize() {
      // TODO - calculate the actual size to next item to ensure alignment
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      var margin = property === 'width' ? 'horizontal' : 'vertical';
      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];
    },
    getPrevSize: function getPrevSize() {
      // TODO - calculate the actual size to next item to ensure alignment
      var property = itemized.layout.orientation === 'horizontal' ? 'width' : 'height';
      var margin = property === 'width' ? 'horizontal' : 'vertical';
      return itemized.globalMetrics.maxItemBounds[property] + itemized.layout.margin[margin];
    },
    hasNext: function hasNext() {
      if (api.orientation() === 'horizontal') {
        return viewRect.x + viewRect.width < containerRect.x + containerRect.width;
      }

      return viewRect.y + viewRect.height < containerRect.y + containerRect.height;
    },
    hasPrev: function hasPrev() {
      if (api.orientation() === 'horizontal') {
        return containerRect.x < viewRect.x;
      }

      return containerRect.y < viewRect.y;
    },
    next: function next() {
      api.scroll(-api.getNextSize());
    },
    prev: function prev() {
      api.scroll(api.getPrevSize());
    },
    scroll: function scroll(delta) {
      var current = Math.max(0, Math.min(overflow, _offset - delta));

      if (current === _offset) {
        return;
      }

      _offset = current;
      onScroll();
    },
    offset: function offset() {
      return _offset;
    },
    orientation: function orientation() {
      return itemized.layout.orientation;
    },
    direction: function direction() {
      return itemized.layout.direction;
    },
    extent: function extent() {
      return _extent(itemized, parallels);
    },
    // total amount of space along orientation
    spread: function spread() {
      return _spread(itemized, parallels);
    } // total amount of space perpendicular to orientation

  };
  return api;
}

/**
 * Concatenate object keys into a space separated string. Use for transforming a 'class name map' into a class string
 * @private
 * @param  {Object} classMap Object with class names as keys and true or false values depending on if they should be in the returned class string or not
 * @return {String} Space separated string with class names
 */
function classString(classMap) {
  return Object.keys(classMap).filter(function (className) {
    return classMap[className];
  }).join(' ');
}

var DIR = {
  up: "\u25B2",
  right: "\u25B6",
  down: "\u25BC",
  left: "\u25C0"
};

function _itemize$1(_ref) {
  var dock = _ref.dock,
      navigation = _ref.navigation;
  return {
    layout: {
      orientation: dock === 'top' || dock === 'bottom' ? 'vertical' : 'horizontal'
    },
    navigation: navigation
  };
}

function btn(h, _ref2) {
  var size = _ref2.size,
      isActive = _ref2.isActive,
      direction = _ref2.direction,
      nav = _ref2.nav,
      attrs = _ref2.attrs;
  var c = {};
  var content = '';

  if (nav && nav.button) {
    if (typeof nav.button.class === 'function') {
      c = nav.button.class({
        direction: direction
      });
    } else if (nav.button.class) {
      c = nav.button.class;
    }

    if (typeof nav.button.content === 'function') {
      content = nav.button.content(h, {
        direction: direction
      });
    }
  }

  var style = {
    width: "".concat(size, "px"),
    minWidth: "".concat(size, "px"),
    height: "".concat(size, "px")
  };

  if (!Object.keys(c).length) {
    // if no classes are set, add some basic styling
    style.border = '0';
    style.background = 'none';
  }

  var attrsMerged = attrs;

  if (!isActive || nav && nav.disabled) {
    attrsMerged.disabled = 'disabled';
  }

  return h('button', extend({
    class: classString(c),
    style: style
  }, attrsMerged), [content || h('span', {
    style: {
      pointerEvents: 'none'
    }
  }, [DIR[direction]])]);
}

function _render$1(renderer, _ref3, itemized, legend) {
  var rect = _ref3.rect,
      itemRenderer = _ref3.itemRenderer;

  if (!renderer || !renderer.renderArgs) {
    return;
  }

  renderer.size(rect);
  var h = renderer.renderArgs[0];
  var isVertical = itemized.layout.orientation === 'vertical'; // orientation of the navigation (not the legend)

  var isRtl = itemRenderer.direction() === 'rtl';
  var hasNext = itemRenderer.hasNext();
  var hasPrev = itemRenderer.hasPrev();

  if (!hasPrev && !hasNext) {
    renderer.render([]);
    return;
  }

  var buttonSize = 32;
  var order = isVertical ? ['right', 'left'] : ['down', 'up'];

  if (isRtl && isVertical) {
    order.reverse();
  }

  var nodes = [h('div', {
    style: {
      position: 'relative',
      display: 'flex',
      'flex-direction': isVertical ? 'column' : 'row',
      'justify-content': 'center',
      height: '100%',
      pointerEvents: 'auto'
    },
    dir: isRtl && !isVertical ? 'rtl' : 'ltr'
  }, [btn(h, {
    size: buttonSize,
    isActive: hasNext,
    direction: order[0],
    attrs: {
      'data-action': 'next',
      'data-component-key': legend.settings.key
    },
    nav: itemized.navigation
  }), btn(h, {
    size: buttonSize,
    isActive: hasPrev,
    direction: order[1],
    attrs: {
      'data-action': 'prev',
      'data-component-key': legend.settings.key
    },
    nav: itemized.navigation
  })])];
  renderer.render(nodes);
}

function navigationRendererFactory (legend) {
  var itemized;
  var nav = {
    itemize: function itemize(obj) {
      itemized = _itemize$1(obj);
    },
    render: function render(obj) {
      return _render$1(nav.renderer, obj, itemized, legend);
    },
    extent: function extent() {
      return 32;
    },
    spread: function spread() {
      return 64;
    }
  };
  return nav;
}

function _itemize$2(_ref, legend) {
  var resolved = _ref.resolved;

  if (resolved.title.item.show === false) {
    return null;
  }

  var t = extend({}, resolved.title.item, {
    type: 'text'
  });

  if (resolved.layout.item.direction === 'rtl') {
    if (!t.anchor || t.anchor === 'start') {
      t.anchor = 'end';
    } else if (t.anchor === 'end') {
      t.anchor = 'start';
    }
  }

  if (typeof resolved.title.settings.text === 'undefined') {
    var fields = legend.scale.data().fields;
    t.text = fields && fields[0] ? fields[0].title() : '';
  }

  return {
    displayObject: t,
    bounds: legend.renderer.textBounds(t)
  };
}

function _render$2(_ref2, renderer, itemized) {
  var rect = _ref2.rect;

  if (!renderer) {
    return;
  }

  var nodes = [];
  renderer.size(rect);

  if (itemized) {
    var align = {
      start: 0,
      end: rect.width,
      middle: rect.width / 2
    };
    nodes.push(extend({}, itemized.displayObject, {
      x: align[itemized.displayObject.anchor] || 0,
      y: 0,
      baseline: 'text-before-edge',
      title: itemized.displayObject.text
    }));
  }

  renderer.render(nodes);
}

function titleRendererFactory (legend) {
  var itemized;
  var api = {
    itemize: function itemize(obj) {
      itemized = _itemize$2(obj, legend);
    },
    render: function render(obj) {
      _render$2(obj, api.renderer, itemized);
    },
    spread: function spread() {
      return itemized ? itemized.bounds.height : 0;
    },
    extent: function extent() {
      return itemized ? itemized.bounds.width : 0;
    }
  };
  return api;
}

/* eslint no-mixed-operators:0 */

function layout(rect, display, orientation, _ref) {
  var itemRenderer = _ref.itemRenderer,
      navigationRenderer = _ref.navigationRenderer,
      titleRenderer = _ref.titleRenderer,
      _ref$isPreliminary = _ref.isPreliminary,
      isPreliminary = _ref$isPreliminary === void 0 ? false : _ref$isPreliminary;
  var title;
  var content;
  var navigation;
  var preferredSize = 0;
  var paddedRect = {
    x: display.spacing,
    y: display.spacing,
    width: rect.width - 2 * display.spacing,
    height: rect.height - 2 * display.spacing
  };
  title = {
    x: paddedRect.x,
    y: paddedRect.y,
    width: paddedRect.width,
    height: titleRenderer.spread()
  };

  if (orientation === 'horizontal') {
    // const titleAtTop = false;
    // if (titleAtTop) { // this might be a nicer layout sometimes
    //   // |------------------|
    //   // |title             |
    //   // |------------|-----|
    //   // |content     | nav |
    //   // |------------|-----|
    //   // available space for items without navigation UI
    //   const availableExtentForItems = paddedRect.width;
    //   const availableSpreadForItems = paddedRect.height - (title.y + title.height) + 8;
    //   const isRtl = itemRenderer.direction() === 'rtl';
    //   itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);
    //   const navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;
    //   content = {
    //     x: paddedRect.x,
    //     y: title.y + title.height,
    //     width: paddedRect.width - navigationSize,
    //     height: availableSpreadForItems
    //   };
    //   navigation = {
    //     x: content.x + content.width,
    //     y: title.y + title.height,
    //     width: navigationSize,
    //     height: paddedRect.height - (title.y + title.height) + 8
    //   };
    //   if (isRtl) { // switch navigation and content
    //     navigation.x = content.x;
    //     content.x = navigation.x + navigation.width;
    //     // totalContent.x = navigation.x;
    //   }
    //   preferredSize = title.height + Math.max(navigationRenderer.spread(), itemRenderer.spread());
    // } else {
    // |-----|------------|-----|
    // |title|content     | nav |
    // |-----|------------|-----|
    title = {
      x: paddedRect.x,
      y: paddedRect.y,
      width: titleRenderer.extent(),
      height: titleRenderer.spread()
    }; // available space for items without navigation UI

    var availableExtentForItems = paddedRect.width - title.width - (title.width ? display.spacing : 0);
    var availableSpreadForItems = paddedRect.height;
    itemRenderer.parallelize(availableExtentForItems, isPreliminary ? undefined : availableSpreadForItems);
    var navigationSize = itemRenderer.extent() > availableExtentForItems ? navigationRenderer.extent() : 0;
    var spread = itemRenderer.spread();
    var navigationSpread = navigationSize ? navigationRenderer.spread() : 0;
    content = {
      x: title.x + title.width + (title.width ? display.spacing : 0),
      y: paddedRect.y + Math.max(0, (navigationSpread - spread) / 2),
      width: paddedRect.width - navigationSize - title.width - (navigationSize ? display.spacing : 0) - (title.width ? display.spacing : 0),
      height: availableSpreadForItems
    };
    navigation = {
      x: content.x + content.width + (navigationSize ? display.spacing : 0),
      y: paddedRect.y,
      width: navigationSize,
      height: paddedRect.height
    };
    title.y = content.y;
    var isRtl = itemRenderer.direction() === 'rtl';

    if (isRtl) {
      // switch title, content and navigation
      navigation.x = paddedRect.x;
      content.x = navigation.x + navigation.width + (navigation.width ? display.spacing : 0);
      title.x = content.x + content.width + (title.width ? display.spacing : 0);
    }

    preferredSize = Math.max(title.height, navigationSpread, itemRenderer.spread()); // }
  } else {
    // |------------|
    // |title       |
    // |------------|
    // |content     |
    // |------------|
    // |navigation  |
    // |------------|
    var _availableExtentForItems = paddedRect.height - title.height - (title.height ? display.spacing : 0);

    var _availableSpreadForItems = paddedRect.width;
    itemRenderer.parallelize(_availableExtentForItems, isPreliminary ? undefined : _availableSpreadForItems);

    var _navigationSize = itemRenderer.extent() > _availableExtentForItems ? navigationRenderer.extent() : 0;

    navigation = {
      x: paddedRect.x,
      y: paddedRect.y + paddedRect.height - _navigationSize,
      width: paddedRect.width,
      height: _navigationSize
    };
    content = {
      x: paddedRect.x,
      y: title.y + title.height + (title.height ? display.spacing : 0),
      width: paddedRect.width,
      height: paddedRect.height - title.height - (title.height ? display.spacing : 0) - navigation.height - (navigation.height ? display.spacing : 0)
    };
    preferredSize = Math.max(titleRenderer.extent(), _navigationSize ? navigationRenderer.spread() : 0, itemRenderer.spread());
  }

  content = extend({}, rect, {
    x: rect.x + content.x,
    y: rect.y + content.y,
    width: content.width,
    height: content.height
  });
  navigation.x += rect.x;
  navigation.y += rect.y;
  title.x += rect.x;
  title.y += rect.y;
  return {
    title: extend({}, rect, title),
    content: extend({}, rect, content),
    navigation: extend({}, rect, navigation),
    orientation: orientation,
    preferredSize: preferredSize
  };
}

function picasso_esm_update(comp) {
  comp.state.resolved = resolveSettings$2(comp);
  comp.titleRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center'
  });
  comp.itemRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center'
  });
  comp.navigationRenderer.itemize({
    resolved: comp.state.resolved,
    dock: comp.settings.layout.dock || 'center',
    navigation: comp.settings.settings.navigation
  });
  comp.state.display = {
    spacing: 8
  };
}

function _preferredSize(comp, size) {
  var s = 0;
  var dock = comp.settings.layout.dock || 'center';
  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';
  var d = comp.state.display;
  var tempLayout = layout(size.inner, d, orientation, {
    itemRenderer: comp.itemRenderer,
    navigationRenderer: comp.navigationRenderer,
    titleRenderer: comp.titleRenderer,
    isPreliminary: true
  });
  s += d.spacing; // start padding in both vertical and horizontal mode

  s += tempLayout.preferredSize;
  s += d.spacing; // end padding in both vertical and horizontal mode

  return s;
}

function _render$3(legend) {
  var rect = legend.rect,
      settings = legend.settings,
      state = legend.state,
      itemRenderer = legend.itemRenderer,
      navigationRenderer = legend.navigationRenderer,
      titleRenderer = legend.titleRenderer;
  var dock = settings.layout.dock;
  var orientation = dock === 'top' || dock === 'bottom' ? 'horizontal' : 'vertical';
  var l = layout(rect, state.display, orientation, {
    itemRenderer: itemRenderer,
    navigationRenderer: navigationRenderer,
    titleRenderer: titleRenderer
  });
  legend.renderer.size(l.content); // l.content.x = 0;
  // l.content.y = 0;
  // l.navigation.x += rect.x;
  // l.navigation.y += rect.y;
  // l.title.x += rect.x;
  // l.title.y += rect.y;

  var contentItems = itemRenderer.getItemsToRender({
    viewRect: extend({}, l.content, {
      x: 0,
      y: 0
    })
  });
  navigationRenderer.render({
    rect: l.navigation,
    itemRenderer: itemRenderer
  });
  titleRenderer.render({
    rect: l.title
  });
  legend.state.views = {
    layout: l
  };
  return contentItems;
}

var component$2 = {
  require: ['chart', 'settings', 'renderer', 'update', 'resolver', 'registries'],
  defaultSettings: {
    settings: {},
    style: {
      item: {
        label: '$label',
        shape: '$shape'
      },
      title: '$title'
    }
  },
  mounted: function mounted(renderElement) {
    if (renderElement && renderElement.parentNode) {
      this.navigationRenderer.renderer.appendTo(renderElement.parentNode);
      this.titleRenderer.renderer.appendTo(renderElement.parentNode);
      renderElement.parentNode.insertBefore(this.navigationRenderer.renderer.element(), renderElement);
      renderElement.parentNode.insertBefore(this.titleRenderer.renderer.element(), renderElement);
    }

    this.navigationRenderer.render({
      rect: this.state.views.layout.navigation,
      itemRenderer: this.itemRenderer
    });
    this.titleRenderer.render({
      rect: this.state.views.layout.title
    });
  },
  beforeUnmount: function beforeUnmount() {
    this.navigationRenderer.renderer.clear();
    this.titleRenderer.renderer.clear();
  },
  on: {
    panstart: function panstart() {
      if (this.state.interaction.started) {
        return;
      }

      var contentOverflow = this.itemRenderer.getContentOverflow();

      if (!contentOverflow) {
        return;
      }

      this.state.interaction.started = true;
      this.state.interaction.delta = 0;
    },
    panmove: function panmove(e) {
      if (!this.state.interaction.started) {
        return;
      }

      var delta = this.itemRenderer.orientation() === 'horizontal' ? (this.itemRenderer.direction() === 'rtl' ? -1 : 1) * e.deltaX : e.deltaY;
      this.itemRenderer.scroll(delta - this.state.interaction.delta);
      this.state.interaction.delta = delta;
    },
    panend: function panend() {
      this.state.interaction.started = false;
    },
    scroll: function scroll(delta) {
      this.itemRenderer.scroll(-delta);
    },
    next: function next() {
      this.itemRenderer.next();
    },
    prev: function prev() {
      this.itemRenderer.prev();
    }
  },
  created: function created() {
    var _this = this;

    this.state = {
      interaction: {}
    };

    this.onScroll = function () {
      var items = _render$3(_this);

      _this.update(items);
    };

    this.itemRenderer = itemRendererFactory(this, {
      onScroll: this.onScroll
    });
    this.navigationRenderer = navigationRendererFactory(this);
    this.titleRenderer = titleRendererFactory(this);
    this.navigationRenderer.renderer = this.registries.renderer('dom')();
    this.titleRenderer.renderer = this.registries.renderer(this.settings.renderer)();
    picasso_esm_update(this);
  },
  preferredSize: function preferredSize(obj) {
    return _preferredSize(this, obj);
  },
  beforeUpdate: function beforeUpdate() {
    picasso_esm_update(this);
  },
  render: function render() {
    return _render$3(this);
  },
  beforeDestroy: function beforeDestroy() {
    this.navigationRenderer.renderer.destroy();
    this.titleRenderer.renderer.destroy();
  },
  additionalElements: function additionalElements() {
    return [this.titleRenderer.renderer.element(), this.navigationRenderer.renderer.element()];
  },
  _DO_NOT_USE_getInfo: function _DO_NOT_USE_getInfo() {
    return {
      offset: this.itemRenderer.offset()
    };
  }
};

/**
 * @typedef {object} component--legend-cat
 * @property {string} scale
 */

/**
 * @type {string}
 * @memberof component--legend-cat
 */

var type$2 = 'legend-cat';
function categoricalLegend(picasso) {
  picasso.component(type$2, component$2);
}

function applyAlignJustify(ctx, node) {
  var wiggle = 0;
  var cmd = {
    type: ctx.state.isVertical ? 'justify' : 'align',
    coord: ctx.state.isVertical ? 'y' : 'x',
    pos: ctx.state.isVertical ? 'height' : 'width',
    fn: ctx.state.isVertical ? 'requiredHeight' : 'requiredWidth'
  };
  wiggle = ctx.state.rect[cmd.pos] - ctx.state.legend.length() - ctx.state.title[cmd.fn]();
  wiggle *= Math.min(1, Math.max(ctx.stgns[cmd.type], 0));
  node[cmd.coord] += wiggle;
}

function generateStopNodes(ctx) {
  var fillScale = ctx.state.legend.fillScale;
  var majorScale = ctx.state.legend.majorScale;
  var stops = fillScale.domain().map(function (d) {
    return {
      type: 'stop',
      color: fillScale(d),
      offset: Math.min(1, Math.max(0, majorScale.norm(d)))
    };
  });
  return stops.sort(function (a, b) {
    return a.offset - b.offset;
  });
}
function createTitleNode(ctx) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var isTickLeft = state.ticks.anchor === 'left';
  var isTickTop = state.ticks.anchor === 'top';
  var x = state.rect.x;
  var y = state.rect.y;
  var textAnchor = 'start';

  if (state.title.anchor === 'left') {
    x += state.title.requiredWidth() - settings.title.padding;
    y += state.title.textMetrics.height;
    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;
    textAnchor = 'end';
  } else if (state.title.anchor === 'right') {
    x += state.legend.length();
    x += settings.title.padding;
    y += state.title.textMetrics.height;
    y += isTickTop ? state.rect.height - state.title.textBounds.height : 0;
  } else if (state.title.anchor === 'top') {
    x += isTickLeft ? state.rect.width : 0;
    y += state.title.textMetrics.height;
    textAnchor = isTickLeft ? 'end' : 'start';
  }

  var node = {
    tag: 'legend-title',
    type: 'text',
    x: x,
    y: Math.min(y, state.rect.y + state.rect.height),
    text: settings.title.text,
    fill: settings.title.fill,
    fontSize: settings.title.fontSize,
    fontFamily: settings.title.fontFamily,
    maxWidth: settings.title.maxLengthPx,
    maxLines: settings.title.maxLines,
    wordBreak: settings.title.wordBreak,
    hyphens: settings.title.hyphens,
    lineHeight: settings.title.lineHeight,
    anchor: textAnchor,
    title: settings.title.text
  };
  applyAlignJustify(ctx, node);
  return node;
}
function createLegendRectNode(ctx, stops) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var container = state.rect;
  var x = container.x;
  var y = container.y;
  var width = state.isVertical ? settings.size : state.legend.length();
  var height = state.isVertical ? state.legend.length() : settings.size;

  if (state.ticks.anchor === 'left') {
    x += state.rect.width - settings.size;
  } else if (state.ticks.anchor === 'top') {
    y += state.rect.height - settings.size;
  }

  if (state.title.anchor === 'top') {
    y += state.title.requiredHeight();
  } else if (state.title.anchor === 'left') {
    x += state.title.requiredWidth();
  }

  var node = {
    type: 'rect',
    x: x,
    y: y,
    width: width,
    height: height,
    fill: {
      type: 'gradient',
      stops: stops,
      degree: state.isVertical ? 90 : 180
    }
  };
  applyAlignJustify(ctx, node);
  return node;
}
function createTickNodes(ctx, legendNode) {
  var state = ctx.state;
  var settings = ctx.stgns;
  var anchor = 'start';
  var rangeSelectorRect = {
    type: 'rect',
    x: legendNode.x,
    y: legendNode.y,
    width: state.isVertical ? 0 : legendNode.width,
    height: state.isVertical ? legendNode.height : 0,
    fill: 'transparent'
  };
  var nodes = state.ticks.values.map(function (tick) {
    var x = 0;
    var y = 0;
    var dx = 0;
    var dy = 0;
    var baseline = 'alphabetical';

    if (state.isVertical) {
      y = legendNode.y + legendNode.height * tick.pos;
      baseline = tick.pos === 0 ? 'text-before-edge' : 'text-after-edge';
    } else {
      x = legendNode.x + legendNode.width * tick.pos;
    }

    if (state.ticks.anchor === 'right') {
      x = legendNode.x + settings.size + settings.tick.padding;
      rangeSelectorRect.x = legendNode.x + legendNode.width;
    } else if (state.ticks.anchor === 'left') {
      x = legendNode.x - settings.tick.padding;
      anchor = 'end';
    } else if (state.ticks.anchor === 'top') {
      y = legendNode.y - settings.tick.padding;
      dy -= tick.textMetrics.height * 0.25;
      anchor = tick.pos === 0 ? 'start' : 'end';
    } else if (state.ticks.anchor === 'bottom') {
      y = legendNode.y + legendNode.height + settings.tick.padding;
      dy = tick.textMetrics.height * 0.8;
      anchor = tick.pos === 0 ? 'start' : 'end';
      rangeSelectorRect.y = legendNode.y + legendNode.height;
    }

    var node = {
      type: 'text',
      x: x,
      y: y,
      dx: dx,
      dy: dy,
      text: tick.label,
      fontSize: settings.tick.fontSize,
      fontFamily: settings.tick.fontFamily,
      fill: settings.tick.fill,
      maxWidth: state.isVertical ? settings.tick.maxLengthPx : Math.min(settings.tick.maxLengthPx, state.legend.length() / 2),
      anchor: anchor,
      textBoundsFn: ctx.renderer.textBounds,
      title: tick.label,
      baseline: baseline
    };
    return node;
  });
  return {
    type: 'container',
    id: 'legend-seq-ticks',
    children: [].concat(_toConsumableArray$1(nodes), [rangeSelectorRect])
  };
}

function resolveAnchor(dock, anchor, map) {
  var mapped = map[dock];

  if (picasso_esm_typeof(mapped) === 'object') {
    if (mapped.valid.indexOf(anchor) !== -1) {
      return anchor;
    }

    return mapped.default;
  }

  return map.default;
}

function resolveTickAnchor(settings) {
  var dock = settings.layout.dock;
  var anchor = settings.settings.tick.anchor;
  var dockAnchorMap = {
    left: {
      valid: ['left', 'right'],
      default: 'left'
    },
    right: {
      valid: ['left', 'right'],
      default: 'right'
    },
    top: {
      valid: ['top', 'bottom'],
      default: 'top'
    },
    bottom: {
      valid: ['top', 'bottom'],
      default: 'bottom'
    },
    default: 'right'
  };
  return resolveAnchor(dock, anchor, dockAnchorMap);
}

function resolveTitleAnchor(settings) {
  var dockAnchorMap = {
    left: {
      valid: ['top'],
      default: 'top'
    },
    right: {
      valid: ['top'],
      default: 'top'
    },
    top: {
      valid: ['left', 'right'],
      default: 'left'
    },
    bottom: {
      valid: ['left', 'right'],
      default: 'left'
    },
    default: 'top'
  };
  var dock = settings.layout.dock;
  var anchor = settings.settings.title.anchor;
  return resolveAnchor(dock, anchor, dockAnchorMap);
}

function initRect(ctx, size) {
  var rect = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  var padding = ctx.stgns.padding;
  rect.x = padding.left;
  rect.y = padding.top;
  rect.width = size.width - padding.left - padding.right;
  rect.height = size.height - padding.top - padding.bottom;
  return rect;
}

function getTicks(ctx, majorScale) {
  var values = majorScale.domain();
  var labels = values;
  var labelFn = ctx.stgns.tick.label;

  if (!labelFn && ctx.formatter) {
    labelFn = ctx.formatter;
  } else if (!labelFn && majorScale.data().fields) {
    labelFn = majorScale.data().fields[0].formatter();
  }

  if (typeof labelFn === 'function') {
    labels = values.map(labelFn).map(String);
  }

  var ticks = values.map(function (value, i) {
    var label = labels[i];
    return {
      value: value,
      label: label,
      pos: majorScale.norm(parseFloat(value, 10)),
      textMetrics: ctx.renderer.measureText({
        text: label,
        fontSize: ctx.stgns.tick.fontSize,
        fontFamily: ctx.stgns.tick.fontFamily
      })
    };
  });
  return ticks;
}

function initState(ctx) {
  var isVertical = ctx.settings.layout.dock !== 'top' && ctx.settings.layout.dock !== 'bottom';
  var titleStgns = ctx.stgns.title;
  var fillScale = ctx.chart.scale(ctx.stgns.fill);
  var majorScale = ctx.chart.scale(ctx.stgns.major);
  var tickValues = getTicks(ctx, majorScale);
  var tickAnchor = resolveTickAnchor(ctx.settings);

  if (typeof titleStgns.text === 'undefined') {
    var fields = majorScale.data().fields;
    titleStgns.text = fields && fields[0] ? fields[0].title() : '';
  }

  var titleTextMetrics = ctx.renderer.measureText({
    text: titleStgns.text,
    fontSize: titleStgns.fontSize,
    fontFamily: titleStgns.fontFamily
  });
  var titleTextBounds = ctx.renderer.textBounds({
    text: titleStgns.text,
    fontSize: titleStgns.fontSize,
    fontFamily: titleStgns.fontFamily,
    maxLines: titleStgns.maxLines,
    maxWidth: titleStgns.maxLengthPx,
    wordBreak: titleStgns.wordBreak,
    hyphens: titleStgns.hyphens,
    lineHeight: titleStgns.lineHeight
  });
  var state = {
    isVertical: isVertical,
    nodes: [],
    title: {
      anchor: resolveTitleAnchor(ctx.settings),
      textMetrics: titleTextMetrics,
      textBounds: titleTextBounds,
      requiredWidth: function requiredWidth() {
        if (!titleStgns.show) {
          return 0;
        }

        var w = titleTextBounds.width;
        var mw = titleStgns.maxLengthPx;

        if (!isVertical) {
          w += titleStgns.padding;
          mw += titleStgns.padding;
        }

        return Math.min(w, mw, state.rect.width);
      },
      requiredHeight: function requiredHeight() {
        if (!titleStgns.show) {
          return 0;
        }

        var h = titleTextBounds.height;

        if (isVertical) {
          h += titleStgns.padding;
        }

        return Math.min(h, state.rect.height);
      }
    },
    ticks: {
      values: tickValues,
      anchor: tickAnchor,
      length: Math.min(Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {
        return t.textMetrics.width;
      }))), ctx.stgns.tick.maxLengthPx),
      requiredHeight: function requiredHeight() {
        return tickAnchor === 'top' ? Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {
          return t.textMetrics.height;
        }))) + ctx.stgns.tick.padding : 0;
      },
      height: Math.max.apply(Math, _toConsumableArray$1(tickValues.map(function (t) {
        return t.textMetrics.height;
      })))
    },
    legend: {
      fillScale: fillScale,
      majorScale: majorScale,
      length: function length() {
        var pos = isVertical ? 'height' : 'width';
        var fnPos = isVertical ? 'requiredHeight' : 'requiredWidth';
        var len = Math.min(state.rect[pos], state.rect[pos] * ctx.stgns.length) - state.title[fnPos]();
        return Math.max(0, Math.min(len, ctx.stgns.maxLengthPx));
      }
    }
  };
  return state;
}
/**
 * @typedef {object} component--legend-seq
 * @property {string} fill - Reference to definition of sequential color scale
 * @property {string} major - Reference to definition of linear scale
 * @property {number} [size=15] - Size in pixels of the legend, if vertical is the width and height otherwise
 * @property {number} [length=1] - A value in the range 0-1 indicating the length of the legend node
 * @property {number} [maxLengthPx=250] - Max length in pixels
 * @property {number} [align=0.5] - A value in the range 0-1 indicating horizontal alignment of the legend's content. 0 aligns to the left, 1 to the right.
 * @property {number} [justify=0] - A value in the range 0-1 indicating vertical alignment of the legend's content. 0 aligns to the top, 1 to the bottom.
 * @property {object} [padding]
 * @property {number} [padding.left=5]
 * @property {number} [padding.right=5]
 * @property {number} [padding.top=5]
 * @property {number} [padding.bottom=5]
 * @property {object} [tick]
 * @property {function} [tick.label] - Function applied to all tick values, returned values are used as labels
 * @property {string} [tick.fill='#595959']
 * @property {string} [tick.fontSize='12px']
 * @property {string} [tick.fontFamily='Arial']
 * @property {number} [tick.maxLengthPx=150] - Max length in pixels
 * @property {string} [tick.anchor='right'] - Where to anchor the tick in relation to the legend node, supported values are [top, bottom, left and right]
 * @property {number} [tick.padding=5] - padding in pixels to the legend node
 * @property {object} [title] - Title settings
 * @property {boolean} [title.show=true] - Toggle title on/off
 * @property {string} [title.text=''] - Title text. Defaults to the title of the provided data field
 * @property {string} [title.fill='#595959']
 * @property {string} [title.fontSize='12px']
 * @property {string} [title.fontFamily='Arial']
 * @property {number} [title.maxLengthPx=100] - Max length in pixels
 * @property {number} [title.padding=5] - padding in pixels to the legend node
 * @property {string} [title.anchor='top'] - Where to anchor the title in relation to the legend node, supported values are [top, left and right]
 * @property {string} [title.wordBreak='none'] - How overflowing title is handled, if it should insert line breaks at word boundries (break-word) or character boundries (break-all)
 * @property {string} [title.hyphens='auto'] - How words should be hyphenated when text wraps across multiple lines (only applicable with wordBreak)
 * @property {number} [title.maxLines=2] - Number of allowed lines if title contains line breaks (only applicable with wordBreak)
 * @property {number} [title.lineHeight=1.2] - A multiplier defining the distance between lines (only applicable with wordBreak)
 */


var legendDef = {
  require: ['chart', 'settings', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 0,
      dock: 'right'
    },
    settings: {
      size: 15,
      length: 0.5,
      maxLengthPx: 250,
      align: 0.5,
      justify: 0,
      padding: {
        left: 5,
        right: 5,
        top: 5,
        bottom: 5
      },
      tick: {
        label: null,
        fill: '#595959',
        fontSize: '12px',
        fontFamily: 'Arial',
        maxLengthPx: 100,
        anchor: null,
        // Use default based on dock
        padding: 5
      },
      title: {
        show: true,
        text: undefined,
        fill: '#595959',
        fontSize: '12px',
        fontFamily: 'Arial',
        maxLengthPx: 100,
        padding: 5,
        maxLines: 2,
        wordBreak: 'none',
        lineHeight: 1.2,
        hyphens: 'auto',
        anchor: null // Use default based on dock

      }
    }
  },
  preferredSize: function preferredSize(opts) {
    var state = this.state;
    state.rect = initRect(this, opts.inner); // Init with size of legend

    var prefSize = this.stgns.size; // Append paddings

    var paddings = state.isVertical ? this.stgns.padding.left + this.stgns.padding.right : this.stgns.padding.top + this.stgns.padding.bottom;
    prefSize += paddings; // Append tick size

    var maxSize = Math.max(opts.inner.width, opts.inner.height);

    if (state.ticks.anchor === 'left' || state.ticks.anchor === 'right') {
      var tHeight = state.ticks.values.reduce(function (sum, t) {
        return sum + t.textMetrics.height;
      }, 0);

      if (tHeight > this.state.legend.length()) {
        return maxSize;
      }

      prefSize += state.ticks.length;
    } else {
      var tWidth = state.ticks.length;

      if (tWidth > this.state.legend.length()) {
        return maxSize;
      }

      prefSize += Math.max.apply(Math, _toConsumableArray$1(state.ticks.values.map(function (t) {
        return t.textMetrics.height;
      })));
    }

    prefSize += this.stgns.tick.padding; // Append or use title size

    if (this.stgns.title.show) {
      if (state.title.anchor === 'left' || state.title.anchor === 'right') {
        prefSize = Math.max(state.title.textBounds.height + paddings, prefSize);
      } else {
        prefSize = Math.max(prefSize, state.title.requiredWidth() + paddings);
      }
    }

    this.state.preferredSize = prefSize;
    return prefSize;
  },
  created: function created() {
    this.stgns = this.settings.settings;
    this.state = initState(this);
  },
  beforeUpdate: function beforeUpdate(opts) {
    this.stgns = opts.settings.settings;
    this.state = initState(this);
  },
  beforeRender: function beforeRender(opts) {
    this.state.nodes = [];
    this.state.rect = initRect(this, opts.size);

    if (this.stgns.title.show) {
      var titleNode = createTitleNode(this);
      this.state.nodes.push(titleNode);
    }

    var stopNodes = generateStopNodes(this);
    var rectNode = createLegendRectNode(this, stopNodes);
    var tickNodes = createTickNodes(this, rectNode);
    var targetNode = {
      // The target node enables range selection component to limit its range to a specific area
      id: 'legend-seq-target',
      type: 'container',
      children: [rectNode, tickNodes]
    };
    this.state.nodes.push(targetNode);
  },
  render: function render() {
    return this.state.nodes;
  }
};

function sequentialLegend(picasso) {
  picasso.component('legend-seq', legendDef);
}

var CURVES = {
  step: curveStep,
  stepAfter: stepAfter,
  stepBefore: stepBefore,
  linear: curveLinear,
  basis: curveBasis,
  cardinal: curveCardinal.tension(0),
  catmullRom: curveCatmullRom,
  monotonex: monotoneX,
  monotoney: monotoneY,
  natural: curveNatural
};
/**
 * @callback component--line~layerSort
 * @param {object} a
 * @param {string} a.id
 * @param {Array<datum-extract>} a.data
 * @param {object} b
 * @param {string} b.id
 * @param {Array<datum-extract>} b.data
 */

/**
 * @typedef {object}
 * @alias component--line-settings
 */

var SETTINGS = {
  /**
   * @typedef {object}
   */
  coordinates: {
    /**
     * @type {number} */
    minor: 0.5,

    /**
     * @type {number} */
    major: 0.5,

    /**
     * @type {number=} */
    layerId: 0
  },

  /**
   * @type {string=} */
  orientation: 'horizontal',

  /**
   * @typedef {object} */
  layers: {
    /**
     * @type {string=} */
    curve: 'linear',

    /**
     * @type {boolean=} */
    show: true,

    /**
     * @type {component--line~layerSort=} */
    sort: undefined,

    /**
     * @typedef {object} */
    line: {
      /**
       * @type {string=} */
      stroke: '#ccc',

      /**
       * @type {number=} */
      strokeWidth: 1,

      /**
       * @type {string=} */
      strokeLinejoin: 'miter',

      /**
       * @type {string=} */
      strokeDasharray: undefined,

      /**
       * @type {number=} */
      opacity: 1,

      /**
       * @type {boolean=} */
      show: true
    },

    /**
     * @typedef {object} */
    area: {
      /**
       * @type {string=} */
      fill: '#ccc',

      /**
       * @type {number=} */
      opacity: 0.8,

      /**
       * @type {boolean=} */
      show: true
    }
  }
};

function createDisplayLayer(points, _ref) {
  var generator = _ref.generator,
      item = _ref.item,
      data = _ref.data;
  var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var path = generator(points);
  var d = {
    type: 'path',
    d: path,
    opacity: item.opacity,
    stroke: item.stroke,
    strokeWidth: item.strokeWidth,
    strokeLinejoin: item.strokeLinejoin,
    fill: fill || item.fill,
    data: data
  };

  if (item.strokeDasharray) {
    d.strokeDasharray = item.strokeDasharray;
  }

  return d;
}

function createDisplayLayers(layers, _ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      missingMinor0 = _ref2.missingMinor0,
      stngs = _ref2.stngs;
  var nodes = [];
  var layerStngs = stngs.layers || {};
  layers.forEach(function (layer) {
    var lineObj = layer.lineObj,
        layerObj = layer.layerObj,
        areaObj = layer.areaObj,
        points = layer.points;
    var areaGenerator = picasso_esm_area();
    var lineGenerator;
    var secondaryLineGenerator;
    var minor = {
      size: height,
      p: 'y'
    };
    var major = {
      size: width,
      p: 'x'
    };

    if (stngs.orientation === 'vertical') {
      var temp = extend(true, {}, major);
      major = extend(true, {}, minor);
      minor = extend(true, {}, temp);
    }

    areaGenerator[major.p](function (d) {
      return d.major * major.size;
    }) // eslint-disable-line no-unexpected-multiline
    ["".concat(minor.p, "1")](function (d) {
      return d.minor * minor.size;
    }) // eslint-disable-line no-unexpected-multiline
    ["".concat(minor.p, "0")](function (d) {
      return d.minor0 * minor.size;
    }) // eslint-disable-line no-unexpected-multiline
    .defined(function (d) {
      return typeof d.minor === 'number' && !isNaN(d.minor);
    }).curve(CURVES[layerObj.curve === 'monotone' ? "monotone".concat(major.p) : layerObj.curve]);
    lineGenerator = areaGenerator["line".concat(minor.p.toUpperCase(), "1")]();
    secondaryLineGenerator = areaGenerator["line".concat(minor.p.toUpperCase(), "0")](); // area layer

    if (layerStngs.area && areaObj.show !== false) {
      nodes.push(createDisplayLayer(points, {
        data: layer.firstPoint,
        item: areaObj,
        generator: areaGenerator
      }));
    } // main line layer


    if (lineObj && lineObj.show !== false) {
      nodes.push(createDisplayLayer(points, {
        data: layer.firstPoint,
        item: lineObj,
        generator: lineGenerator
      }, 'none')); // secondary line layer, used only when rendering area

      if (!missingMinor0 && layerStngs.area && areaObj.show !== false) {
        nodes.push(createDisplayLayer(points, {
          data: layer.firstPoint,
          item: lineObj,
          generator: secondaryLineGenerator
        }, 'none'));
      }
    }
  });
  return nodes;
}

function resolve$1(_ref3) {
  var data = _ref3.data,
      stngs = _ref3.stngs,
      rect = _ref3.rect,
      resolver = _ref3.resolver,
      style = _ref3.style;
  var width = rect.width,
      height = rect.height;
  var coordinates = resolver.resolve({
    data: data,
    defaults: SETTINGS.coordinates,
    settings: stngs.coordinates || {},
    scaled: {
      major: stngs.orientation === 'vertical' ? height : width,
      minor: stngs.orientation === 'vertical' ? width : height
    }
  }); // collect points into layers

  var layerIds = {};
  var numLines = 0;

  for (var i = 0; i < coordinates.items.length; i++) {
    var p = coordinates.items[i];
    var lid = p.layerId;
    layerIds[lid] = layerIds[lid] || {
      order: numLines++,
      id: lid,
      items: [],
      firstPoint: p.data
    };
    layerIds[lid].items.push(p);
  }

  var metaLayers = Object.keys(layerIds).map(function (lid) {
    return layerIds[lid];
  });
  var layersData = {
    items: metaLayers.map(function (layer) {
      return layer.firstPoint;
    })
  };
  var layerStngs = stngs.layers || {};
  var layersResolved = resolver.resolve({
    data: layersData,
    defaults: {
      curve: SETTINGS.layers.curve,
      show: SETTINGS.layers.show
    },
    settings: {
      curve: layerStngs.curve,
      show: layerStngs.show
    }
  });
  var linesResolved = resolver.resolve({
    data: layersData,
    defaults: extend({}, SETTINGS.layers.line, style.line),
    settings: layerStngs.line
  });
  var areasResolved = resolver.resolve({
    data: layersData,
    defaults: extend({}, SETTINGS.layers.area, style.area),
    settings: layerStngs.area
  });
  return {
    coordinates: coordinates,
    metaLayers: metaLayers,
    layers: layersResolved,
    lines: linesResolved,
    areas: areasResolved
  };
}

function calculateVisibleLayers(opts) {
  var _resolve = resolve$1(opts),
      metaLayers = _resolve.metaLayers,
      coordinates = _resolve.coordinates,
      layers = _resolve.layers,
      lines = _resolve.lines,
      areas = _resolve.areas;

  var visibleLayers = [];
  metaLayers.forEach(function (layer, ix) {
    var layerObj = layers.items[ix];

    if (layerObj.show === false) {
      return;
    } // layerObj.points = [];


    layerObj.datum = layerObj.data;
    layerObj.data = [];
    layerObj.id = layer.id;
    var values = [];
    var points = [];
    var point;
    var pData;

    for (var i = 0; i < layer.items.length; i++) {
      point = layer.items[i];
      pData = point.data;

      if (isNaN(point.major)) {
        continue;
      }

      if (opts.missingMinor0) {
        point.minor0 = coordinates.settings.minor.scale ? coordinates.settings.minor.scale(pData.minor0 ? pData.minor0.value : 0) : 0;
      }

      if (!isNaN(point.minor)) {
        values.push(point.minor);
      }

      points.push(point);
      layerObj.data.push(point.data);
    }

    var median = values.sort(function (a, b) {
      return a - b;
    })[Math.floor((values.length - 1) / 2)];
    visibleLayers.push({
      layerObj: layerObj,
      lineObj: lines.items[ix],
      areaObj: areas.items[ix],
      median: median,
      points: points,
      firstPoint: layer.firstPoint
    });
  });
  return visibleLayers;
}

var lineMarkerComponent = {
  require: ['chart', 'resolver'],
  defaultSettings: {
    style: {
      area: '$shape',
      line: '$shape-outline'
    }
  },
  created: function created() {},
  render: function render(_ref4) {
    var data = _ref4.data;
    var _this$rect = this.rect,
        width = _this$rect.width,
        height = _this$rect.height;
    this.stngs = this.settings.settings || {};
    var missingMinor0 = !this.stngs.coordinates || typeof this.stngs.coordinates.minor0 === 'undefined';
    var visibleLayers = calculateVisibleLayers({
      data: data,
      stngs: this.stngs,
      rect: this.rect,
      resolver: this.resolver,
      style: this.style,
      missingMinor0: missingMinor0
    });

    if (this.stngs.layers && this.stngs.layers.sort) {
      var sortable = visibleLayers.map(function (v) {
        return {
          id: v.layerObj.id,
          data: v.layerObj.data
        };
      });
      sortable.sort(this.stngs.layers.sort).map(function (s) {
        return s.id;
      });
      visibleLayers.sort(function (a, b) {
        return sortable.indexOf(b.layerObj.id) - sortable.indexOf(a.layerObj.id);
      });
    } else {
      visibleLayers.sort(function (a, b) {
        return a.median - b.median;
      });
    } // generate visuals


    return createDisplayLayers(visibleLayers, {
      width: width,
      height: height,
      missingMinor0: missingMinor0,
      stngs: this.stngs
    });
  }
};

/**
 * @typedef {object} component--line
 */

/**
 * @type {string}
 * @memberof component--line
 */

var type$3 = 'line';
function line$2(picasso) {
  picasso.component(type$3, lineMarkerComponent);
}

/**
 * @typedef {object} component--brush-area-brush
 * @property {string} key - Component key
 * @property {string[]} [contexts] - Name of the brushing contexts to affect
 * @property {string[]} [data] - The mapped data properties to add to the brush
 * @property {string} [action='set'] - Type of action to respond with
 */

/**
  * @typedef {object}
  * @alias component--brush-area-settings
  */

var DEFAULT_SETTINGS$7 = {
  /**
   * @type {object}
   */
  brush: {
    /**
    * @type {Array<component--brush-area-brush>}
    */
    components: []
  }
};
/**
 * Transform the incoming event into point in the local coordinate system. That is the coordinate system of the component.
 * @private
 * @param {object} ctx - Context
 * @param {object} event - Incoming event, either native event or hammer event
 * @param {boolean} clamp - True to clamp the point inside the component bounds
 * @returns {point}
 */

function getLocalPoint(ctx, event) {
  var clamp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var x;
  var y;

  if (picasso_esm_typeof(event.center) === 'object') {
    x = event.center.x;
    y = event.center.y;
  } else {
    x = event.clientX;
    y = event.clientY;
  }

  var localX = x - ctx.state.boundingRect.left;
  var localY = y - ctx.state.boundingRect.top;
  return {
    x: clamp ? Math.max(0, Math.min(localX, ctx.rect.width)) : localX,
    y: clamp ? Math.max(0, Math.min(localY, ctx.rect.height)) : localY
  };
}
/**
 * Transform a local point into a point in the chart coordinate system.
 * @private
 * @param {object} ctx - Context
 * @param {object} p - Point to transform
 * @returns {point}
 */


function localToChartPoint(ctx, p) {
  return {
    x: p.x + ctx.rect.x,
    y: p.y + ctx.rect.y
  };
}
/**
 * Extract and apply default brush configuration.
 * @private
 * @param {object} settings
 * @returns {object[]} An Array of brush configurations
 */


function getBrushConfig$1(settings) {
  return settings.settings.brush.components.map(function (b) {
    return {
      key: b.key,
      contexts: b.contexts,
      data: b.data,
      action: b.action || 'set'
    };
  });
}
/**
 * End all active brush contexts.
 * @private
 * @param {oject} state
 * @param {object} chart - Chart instance
 */


function doEndBrush(state, chart) {
  state.brushConfig.forEach(function (config) {
    if (Array.isArray(config.contexts)) {
      config.contexts.forEach(function (context) {
        chart.brush(context).end();
      });
    }
  });
}
/**
 * Convert two points into a rectangle.
 * @private
 * @param {point} p0
 * @param {point} p1
 * @returns {rect}
 */


function toRect(p0, p1) {
  var xMin = Math.min(p0.x, p1.x);
  var yMin = Math.min(p0.y, p1.y);
  var xMax = Math.max(p0.x, p1.x);
  var yMax = Math.max(p0.y, p1.y);
  return {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
}
/**
 * Perform a brush on the given area.
 * @private
 * @param {object} ctx
 */


function doAreaBrush(ctx) {
  if (ctx.state.active) {
    var start = localToChartPoint(ctx, ctx.state.start);
    var end = localToChartPoint(ctx, ctx.state.end);
    var shapes = ctx.chart.shapesAt(toRect(start, end), {
      components: ctx.state.brushConfig
    });
    ctx.chart.brushFromShapes(shapes, {
      components: ctx.state.brushConfig
    });
  }
}

function render$2(ctx) {
  ctx.renderer.render([extend({
    type: 'rect'
  }, toRect(ctx.state.start, ctx.state.end), ctx.style.area)]);
}

function resetState$1() {
  return {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 0
    },
    active: false
  };
}

var definition = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    layout: {
      displayOrder: 99
    },
    settings: DEFAULT_SETTINGS$7,
    style: {
      area: '$selection-area-target'
    }
  },
  on: {
    areaStart: function areaStart(e) {
      this.start(e);
    },
    areaMove: function areaMove(e) {
      this.move(e);
    },
    areaEnd: function areaEnd(e) {
      this.end(e);
    },
    areaCancel: function areaCancel() {
      this.cancel();
    }
  },
  created: function created() {
    this.state = resetState$1();
  },
  preferredSize: function preferredSize() {
    return 0;
  },
  render: function render() {},
  start: function start(e) {
    this.state.boundingRect = this.renderer.element().getBoundingClientRect();
    var p = getLocalPoint(this, e, false); // Require event to be inside the component bounds

    if (!testRectPoint({
      x: 0,
      y: 0,
      width: this.rect.width,
      height: this.rect.height
    }, p)) {
      return;
    }

    this.state.brushConfig = getBrushConfig$1(this.settings);
    this.state.start = getLocalPoint(this, e);
    this.state.active = true;
  },
  move: function move(e) {
    if (!this.state.active) {
      return;
    }

    this.state.end = getLocalPoint(this, e);
    doAreaBrush(this);
    render$2(this);
  },
  end: function end() {
    if (!this.state.active) {
      return;
    }

    this.state = resetState$1();
    this.renderer.render([]);
  },
  cancel: function cancel() {
    if (!this.state.active) {
      return;
    }

    doEndBrush(this.state, this.chart);
    this.state = resetState$1();
    this.renderer.render([]);
  }
};

function areaBrush(picasso) {
  picasso.component('brush-area', definition);
}

function extractor(nodes, _ref) {
  var chart = _ref.chart,
      scale = _ref.scale,
      props = _ref.props,
      h = _ref.h;
  var dataCtx = {
    resources: {
      dataset: chart.dataset,
      scale: chart.scale,
      formatter: chart.formatter
    },
    scale: scale,
    h: h
  };
  var data = [];
  nodes.forEach(function (node) {
    if (typeof props.extract === 'function') {
      var ctx = extend({
        node: node
      }, dataCtx);
      data.push(props.extract(ctx));
    }
  });
  return data;
}

function resolveClasses(props, opts) {
  return {
    tooltip: typeof props.tooltipClass === 'function' ? props.tooltipClass({
      dock: opts.dock
    }) : props.tooltipClass,
    content: typeof props.contentClass === 'function' ? props.contentClass({
      dock: opts.dock
    }) : props.contentClass,
    arrow: typeof props.arrowClass === 'function' ? props.arrowClass({
      dock: opts.dock
    }) : props.arrowClass
  };
}

function resolveContent(h, data, style, props) {
  return props.content({
    h: h,
    style: style,
    data: data
  });
}

function render$3(data, placement, _ref) {
  var renderer = _ref.renderer,
      style = _ref.style,
      props = _ref.props,
      h = _ref.h;
  var classes = resolveClasses(props, placement);
  var content = resolveContent(h, data, style, props);
  var tooltipDefaultStyle = {
    position: 'relative',
    display: 'inline-block'
  };
  var tooltipNode = h("div", {
    dir: props.direction,
    class: classString(extend({
      'pic-tooltip': true
    }, classes.tooltip)),
    style: extend(tooltipDefaultStyle, placement.computedTooltipStyle)
  }, h("div", {
    style: style.content,
    class: classString(extend({
      'pic-tooltip-content': true
    }, classes.content))
  }, content), h("div", {
    class: classString(extend({
      'pic-tooltip-arrow': true
    }, classes.arrow)),
    style: extend({}, style.arrow, style["arrow-".concat(placement.dock)], placement.computedArrowStyle)
  }));
  renderer.render(tooltipNode);
  return renderer.element().children[0];
}

// Successfull flow: pending -> active -> fulfilled (only with duration)
// Cancelled flow: pending -> active -> cancelled
// Rejected flow: pending -> rejected
// Debounced flow: pending -> debounced -> pending -> [rejected|fulfilled]
function dispatcherState() {
  var fn = function fn() {};

  var on = {
    pending: [],
    debounced: [],
    active: [],
    cancelled: [],
    rejected: [],
    fulfilled: []
  };
  var state;

  fn.set = function (s) {
    state = s;
    on[state].forEach(function (event) {
      return event(s);
    });
  };

  fn.on = function (key, event) {
    if (Array.isArray(key)) {
      key.forEach(function (k) {
        return on[k].push(event);
      });
    } else {
      on[key].push(event);
    }
  };

  fn.destroy = function () {
    Object.keys(on).forEach(function (key) {
      on[key].length = 0;
    });
  }; // fn.on(['pending', 'debounced', 'active', 'cancelled', 'rejected', 'fulfilled'], (e) => {
  //   console.log(e);
  // });


  return fn;
}

function timeSpanDispatcher(_ref) {
  var defaultDuration = _ref.defaultDuration,
      defaultDelay = _ref.defaultDelay;
  var actionId = null;
  var fulfilledId = null;
  var isActive = false;
  var state = dispatcherState();

  var fn = function fn() {};

  var fulfilled = function fulfilled() {
    actionId = null;
    fulfilledId = null;
    isActive = false;
    state.set('fulfilled');
  };

  fn.invoke = function (action) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultDuration;
    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDelay;

    if (actionId) {
      clearTimeout(actionId);
      state.set('debounced');
    }

    state.set('pending');
    actionId = setTimeout(function () {
      action();
      isActive = true;
      actionId = null;
      state.set('active');
    }, delay);

    if (duration > 0) {
      if (fulfilledId) {
        clearTimeout(fulfilledId);
      }

      fulfilledId = setTimeout(fulfilled, duration + Math.max(delay, 0));
    }
  };

  fn.clear = function () {
    if (isActive) {
      state.set('cancelled');
    } else if (actionId) {
      clearTimeout(actionId);
      state.set('rejected');
    }

    if (fulfilledId) {
      clearTimeout(fulfilledId);
    }

    actionId = null;
    fulfilledId = null;
    isActive = false;
  };

  fn.on = function (key, event) {
    state.on(key, event);
  };

  fn.destroy = function () {
    fn.clear();
    state.destroy();
  };

  return fn;
}

function getDockTransform() {
  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return {
    left: "translate(-100%,-50%) translateX(".concat(-offset, "px)"),
    right: "translate(".concat(offset, "px, -50%)"),
    top: "translate(-50%, -100%) translateY(".concat(-offset, "px)"),
    bottom: "translate(-50%, ".concat(offset, "px)")
  };
}

function getDockOffset(width, height) {
  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return {
    left: {
      x: -width - offset,
      y: -height / 2
    },
    right: {
      x: offset,
      y: -height / 2
    },
    top: {
      x: -width / 2,
      y: -height - offset
    },
    bottom: {
      x: -width / 2,
      y: offset
    }
  };
}

function getComputedArrowStyle(offset) {
  return {
    left: {
      left: '100%',
      top: "calc(50% - ".concat(offset, "px)"),
      borderWidth: "".concat(offset, "px")
    },
    right: {
      left: "".concat(-offset * 2, "px"),
      top: "calc(50% - ".concat(offset, "px)"),
      borderWidth: "".concat(offset, "px")
    },
    top: {
      left: "calc(50% - ".concat(offset, "px)"),
      top: '100%',
      borderWidth: "".concat(offset, "px")
    },
    bottom: {
      left: "calc(50% - ".concat(offset, "px)"),
      top: "".concat(-offset * 2, "px"),
      borderWidth: "".concat(offset, "px")
    }
  };
}

function isInsideArea(area, vx, vy, width, height, offset) {
  var rect = {
    x: vx + offset.x,
    y: vy + offset.y,
    width: width,
    height: height
  };

  if (rect.x < 0 || rect.y < 0) {
    return false;
  }

  if (rect.x + rect.width > area.width || rect.y + rect.height > area.height) {
    return false;
  }

  return true;
}
/**
 * @param {vx} vx X-coordinate realative to the area
 * @param {vy} vy Y-coordinate realative to the area
 */


function calcOffset(_ref) {
  var area = _ref.area,
      vx = _ref.vx,
      vy = _ref.vy,
      width = _ref.width,
      height = _ref.height,
      offset = _ref.offset;
  var rect = {
    x: vx + offset.x,
    y: vy + offset.y,
    width: width,
    height: height
  };
  var offsetX = rect.x < 0 ? -rect.x : 0;
  var offsetY = rect.y < 0 ? -rect.y : 0;
  offsetX += rect.x + rect.width > area.width ? -(rect.x + rect.width - area.width) : 0;
  offsetY += rect.y + rect.height > area.height ? -(rect.y + rect.height - area.height) : 0;
  return {
    x: offsetX,
    y: offsetY
  };
}

function alignToBounds(_ref2) {
  var resources = _ref2.resources,
      nodes = _ref2.nodes,
      pointer = _ref2.pointer,
      elmWidth = _ref2.width,
      elmHeight = _ref2.height,
      options = _ref2.options;
  var targetBounds = pointer.targetBounds;

  var _resources$getNodeBou = resources.getNodeBoundsRelativeToTarget(nodes[0]),
      x = _resources$getNodeBou.x,
      y = _resources$getNodeBou.y,
      width = _resources$getNodeBou.width,
      height = _resources$getNodeBou.height;

  var docks = {
    left: {
      x: x,
      y: y + height / 2
    },
    right: {
      x: x + width,
      y: y + height / 2
    },
    top: {
      x: x + width / 2,
      y: y
    },
    bottom: {
      x: x + width / 2,
      y: y + height
    }
  }; // Check if explicit dock

  var dockTransforms = getDockTransform(options.offset);
  var transform = dockTransforms[options.dock];

  if (transform) {
    return {
      computedTooltipStyle: {
        left: "".concat(docks[options.dock].x, "px"),
        top: "".concat(docks[options.dock].y, "px"),
        transform: transform
      },
      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],
      dock: options.dock
    };
  }

  var area = {
    width: options.area === 'target' ? targetBounds.width : window.innerWidth,
    height: options.area === 'target' ? targetBounds.height : window.innerHeight
  };
  var dockOffsets = getDockOffset(elmWidth, elmHeight, options.offset);
  var dockOrder = ['top', 'left', 'right', 'bottom'];

  for (var i = 0; i < dockOrder.length; i += 1) {
    var dock = dockOrder[i];
    var vx = options.area === 'target' ? docks[dock].x : targetBounds.left + docks[dock].x;
    var vy = options.area === 'target' ? docks[dock].y : targetBounds.top + docks[dock].y;

    if (isInsideArea(area, vx, vy, elmWidth, elmHeight, dockOffsets[dock])) {
      return {
        computedTooltipStyle: {
          left: "".concat(docks[dock].x, "px"),
          top: "".concat(docks[dock].y, "px"),
          transform: dockTransforms[dock]
        },
        computedArrowStyle: getComputedArrowStyle(options.offset)[dock],
        dock: dock
      };
    }
  }

  return {
    computedTooltipStyle: {
      left: "".concat(docks.top.x, "px"),
      top: "".concat(docks.top.y, "px"),
      transform: dockTransforms.top
    },
    computedArrowStyle: getComputedArrowStyle(options.offset).top,
    dock: 'top'
  };
}

function alignToPoint(_ref3) {
  var options = _ref3.options,
      pointer = _ref3.pointer,
      width = _ref3.width,
      height = _ref3.height,
      dockOrder = _ref3.dockOrder,
      x = _ref3.x,
      y = _ref3.y;
  var targetBounds = pointer.targetBounds; // Check if explicit dock

  var dockTransforms = getDockTransform(options.offset);
  var transform = dockTransforms[options.dock];

  if (transform) {
    return {
      computedTooltipStyle: {
        left: "".concat(x, "px"),
        top: "".concat(y, "px"),
        transform: transform
      },
      computedArrowStyle: getComputedArrowStyle(options.offset)[options.dock],
      dock: options.dock
    };
  }

  var area = {
    width: options.area === 'target' ? targetBounds.width : window.innerWidth,
    height: options.area === 'target' ? targetBounds.height : window.innerHeight
  };
  var dockOffsets = getDockOffset(width, height, options.offset);
  var results = [];
  var edgeMargin = 20;
  var vx = options.area === 'target' ? x : targetBounds.left + x;
  var vy = options.area === 'target' ? y : targetBounds.top + y;

  for (var i = 0; i < dockOrder.length; i += 1) {
    var dock = dockOrder[i];
    var offset = calcOffset({
      area: area,
      vx: vx,
      vy: vy,
      width: width,
      height: height,
      offset: dockOffsets[dock]
    });
    var computedTooltipStyle = {
      left: "".concat(x, "px"),
      top: "".concat(y, "px"),
      transform: dockTransforms[dock]
    };
    var computedArrowStyle = getComputedArrowStyle(options.offset)[dock];

    if (offset.x !== 0) {
      computedTooltipStyle.width = "".concat(width - edgeMargin - Math.abs(offset.x), "px");

      if (dock === 'top' || dock === 'bottom') {
        computedTooltipStyle.left = "".concat(x + offset.x, "px");
        computedArrowStyle.left = "calc(50% ".concat(offset.x > 0 ? '-' : '+', " ").concat(Math.abs(offset.x), "px)");
      }
    }

    var result = {
      computedTooltipStyle: computedTooltipStyle,
      computedArrowStyle: computedArrowStyle,
      dock: dock,
      rect: {
        width: width,
        height: height
      }
    };

    if (offset.x === 0 && offset.y === 0) {
      return result;
    }

    result.offset = offset;
    results.push(result);
  }

  results.sort(function (a, b) {
    return Math.abs(a.offset.x) - Math.abs(b.offset.x);
  });
  return results[0];
}

function alignToPointer(_ref4) {
  var options = _ref4.options,
      pointer = _ref4.pointer,
      width = _ref4.width,
      height = _ref4.height;
  var x = pointer.x,
      y = pointer.y;
  return alignToPoint({
    x: x,
    y: y,
    pointer: pointer,
    width: width,
    height: height,
    options: options,
    dockOrder: ['top', 'left', 'right', 'bottom']
  });
}

function alignToSlice(_ref5) {
  var options = _ref5.options,
      pointer = _ref5.pointer,
      width = _ref5.width,
      height = _ref5.height,
      nodes = _ref5.nodes,
      resources = _ref5.resources;
  var node = nodes[0];
  var dx = pointer.dx,
      dy = pointer.dy;
  var componentBounds = resources.getComponentBoundsFromNode(node); // cx and cy relative to targetBounds

  var center = {
    x: dx + componentBounds.x + componentBounds.width / 2,
    y: dy + componentBounds.y + componentBounds.height / 2
  };
  var _node$desc$slice = node.desc.slice,
      start = _node$desc$slice.start,
      end = _node$desc$slice.end,
      outerRadius = _node$desc$slice.outerRadius; // Node origin is at 12 o clock, clockwise, but Math uses 3 a clock, so it's transformed to origin at 3 a clock

  var middle = (start + end) / 2 - Math.PI / 2;
  var PI2 = Math.PI * 2;
  var radians = (middle % PI2 + PI2) % PI2;
  var dockOrder = ['top', 'left', 'right', 'bottom'];

  if (options.dock === 'auto') {
    if (radians <= Math.PI / 4 || radians >= Math.PI * 7 / 4) {
      dockOrder = ['right', 'top', 'bottom', 'left'];
    } else if (radians <= Math.PI * 3 / 4) {
      dockOrder = ['bottom', 'left', 'right', 'top'];
    } else if (radians <= Math.PI * 5 / 4) {
      dockOrder = ['left', 'top', 'bottom', 'right'];
    } else {
      dockOrder = ['top', 'left', 'right', 'bottom'];
    }
  }

  return alignToPoint({
    x: center.x + outerRadius * componentBounds.scaleRatio.x * Math.cos(radians),
    y: center.y + outerRadius * componentBounds.scaleRatio.y * Math.sin(radians),
    pointer: pointer,
    width: width,
    height: height,
    options: options,
    dockOrder: dockOrder
  });
}

function _getComponentBoundsFromNode(node, pointer, chart) {
  var comp = node.key ? chart.component(node.key) : chart.componentsFromPoint({
    x: pointer.clientX,
    y: pointer.clientY
  })[0];

  if (!comp) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      scaleRatio: {
        x: 1,
        y: 1
      }
    };
  }

  var componentSize = comp.rect;
  return extend({
    scaleRatio: componentSize.scaleRatio
  }, componentSize.computedInner);
}

function _getNodeBoundsRelativeToTarget(node, pointer, chart) {
  var componentBounds = _getComponentBoundsFromNode(node, pointer, chart);

  var bounds = node.bounds;
  return {
    x: componentBounds.x + pointer.dx + bounds.x,
    y: componentBounds.y + pointer.dy + bounds.y,
    width: bounds.width,
    height: bounds.height
  };
}

var STRATEGIES = {
  bounds: alignToBounds,
  pointer: alignToPointer,
  slice: alignToSlice
};
function placement(_ref6, _ref7) {
  var width = _ref6.width,
      height = _ref6.height;
  var chart = _ref7.chart,
      state = _ref7.state,
      props = _ref7.props;
  var propCtx = {
    resources: {
      formatter: chart.formatter,
      scale: chart.scale,
      component: chart.component,
      getComponentBoundsFromNode: function getComponentBoundsFromNode(node) {
        return _getComponentBoundsFromNode(node, state.pointer, chart);
      },
      getNodeBoundsRelativeToTarget: function getNodeBoundsRelativeToTarget(node) {
        return _getNodeBoundsRelativeToTarget(node, state.pointer, chart);
      }
    },
    nodes: state.activeNodes,
    pointer: state.pointer,
    width: width,
    height: height
  };

  var type = picasso_esm_typeof(props.placement);

  if (type === 'object' && typeof props.placement.fn === 'function') {
    // Custom placement strategy function
    return props.placement.fn(propCtx);
  }

  var opts = {
    type: 'pointer',
    offset: 8,
    dock: 'auto',
    area: 'viewport'
  };

  if (type === 'function') {
    // Custom placement function
    opts = extend(opts, props.placement(propCtx));
  }

  if (type === 'object' && STRATEGIES[props.placement.type]) {
    // Predefined placement function with options
    opts = extend(opts, props.placement);
  } else if (type === 'string' && STRATEGIES[props.placement]) {
    // Predefined placement function without options
    opts = extend(opts, {
      type: props.placement
    });
  }

  propCtx.options = opts;
  var plcm = STRATEGIES[opts.type](propCtx);

  var _propCtx$resources$ge = propCtx.resources.getComponentBoundsFromNode(propCtx.nodes[0]),
      minX = _propCtx$resources$ge.x,
      minY = _propCtx$resources$ge.y,
      maxX = _propCtx$resources$ge.width,
      maxY = _propCtx$resources$ge.height;

  minX += propCtx.pointer.dx;
  maxX += minX;
  minY += propCtx.pointer.dy;
  maxY += minY; // Clamp tooltip position

  plcm.computedTooltipStyle.left = "".concat(Math.min(Math.max(0, minX, parseFloat(plcm.computedTooltipStyle.left)), maxX), "px");
  plcm.computedTooltipStyle.top = "".concat(Math.min(Math.max(0, minY, parseFloat(plcm.computedTooltipStyle.top)), maxY), "px");
  return plcm;
}

var instance;
function setActive(action) {
  instance = action;
}
function removeActive(action) {
  if (instance === action) {
    instance = null;
    return true;
  }

  return false;
}
function cancelActive(a) {
  if (instance && instance !== a) {
    instance();
  }
}
function remove$1() {
  instance = null;
}

/**
 * @typedef {object}
 * @alias component--tooltip.settings
 */

var DEFAULT_SETTINGS$8 = {
  /**
   * How long the tooltip is visible, in milliseconds
   * @type {number=}
   */
  duration: 8000,

  /**
   * Delay before the tooltip is rendered, in milliseconds
   * @type {number=}
   */
  delay: 500,

  /**
   * Reduce incoming nodes to only a set of applicable nodes. Is called as a part of the `show` event.
   * @type {function=}
   * @returns {array} An array of nodes
   */
  filter: function filter(nodes) {
    return nodes.filter(function (node) {
      return node.data && typeof node.data.value !== 'undefined';
    });
  },

  /**
   * Extract data from a node.
   * @type {function=}
   * @returns {object} An array of data
   */
  extract: function extract(ctx) {
    return ctx.node.data.value;
  },

  /**
   * Content generator. Extracted data is available in the `data` property, where each value in the area is the extracted datum from a node.
   * @type {function=}
   * @returns {object[]} Array of h objects
   */
  content: function content(_ref) {
    var h = _ref.h,
        data = _ref.data;
    return data.map(function (datum) {
      return h('div', {}, datum);
    });
  },

  /**
   * Comparison function. If evaluted to true, the incoming nodes in the `show` event are ignored. If evaluated to false, any active tooltip is cleared and a new tooltip is queued.
   *
   * The function gets two parameters, the first is the currently active set of nodes, if any, and the second is the incoming set of nodes. By default the two set of nodes are considered equal if their data attributes are the same.
   * @type {function=}
   * @returns {boolean}
   */
  isEqual: function isEqual(prev, curr) {
    return prev.length && prev.length === curr.length && prev.every(function (p, i) {
      return curr[i] && JSON.stringify(p.data) === JSON.stringify(curr[i].data);
    });
  },

  /**
   * @typedef {object=}
   */
  placement: {
    /**
     * Available types: [pointer | bounds | slice]
     * @type {string=}
     */
    type: 'pointer',

    /**
     * Docking position of the tooltip. Available positions: [left | right | top | bottom | auto]
     * @type {string=}
     */
    dock: 'auto',

    /**
     * Distance from the content area to the tooltip position, in px.
     * @type {number=}
     */
    offset: 8,

    /**
     * Specify the limiting area, where target is the component area unless the appendTo property is set, in which case it referes to the appendTo element. Viewport is the browser viewport.
     *
     * Available options are: [viewport | target]
     * @type {number=}
     */
    area: 'viewport'
  },

  /**
   * Set tooltip class.
  * @type {object<string, boolean>=}
  */
  tooltipClass: {},

  /**
   * Set content class.
  * @type {object<string, boolean>=}
  */
  contentClass: {},

  /**
   * Set arrow class.
  * @type {object<string, boolean>=}
  */
  arrowClass: {},

  /**
   * Content direction [ltr | rtl]
   * @type {string=}
   */
  direction: 'ltr',

  /**
   * Explicitly set a target element. This allows the tooltip to attach itself outside the picasso container.
   * @type {HTMLElement=}
   */
  appendTo: undefined,

  /**
   * Component lifecycle hook. Called before the tooltip is displayed.
   * @type {function=}
   */
  beforeShow: undefined,

  /**
   * Component lifecycle hook. Called after the tooltip have been displayed.
   * @type {function=}
   */
  afterShow: undefined,

  /**
   * Component lifecycle hook. Called before the tooltip is hidden.
   * @type {function=}
   */
  beforeHide: undefined,

  /**
   * Component lifecycle hook. Called when the toolip is hidden. By default this deletes the tooltip element.
   * @type {function=}
   */
  onHide: undefined,

  /**
   * Component lifecycle hook. Called after the tooltip is hidden.
   * @type {function=}
   */
  afterHide: undefined
};
var DEFAULT_STYLE = {
  tooltip: {},
  content: {
    backgroundColor: '$gray-25',
    color: '$font-color--inverted',
    fontFamily: '$font-family',
    fontSize: '$font-size',
    lineHeight: '$line-height',
    borderRadius: '4px',
    padding: '8px',
    opacity: 0.9
  },
  arrow: {
    position: 'absolute',
    width: '0px',
    height: '0px',
    borderStyle: 'solid',
    color: '$gray-25',
    opacity: 0.9
  },
  'arrow-bottom': {
    borderTopColor: 'transparent',
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent'
  },
  'arrow-top': {
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent'
  },
  'arrow-right': {
    borderTopColor: 'transparent',
    borderLeftColor: 'transparent',
    borderBottomColor: 'transparent'
  },
  'arrow-left': {
    borderTopColor: 'transparent',
    borderBottomColor: 'transparent',
    borderRightColor: 'transparent'
  }
};

function toPoint(event, _ref2) {
  var chart = _ref2.chart,
      state = _ref2.state;
  var x = 0;
  var y = 0;

  if (event.center) {
    x += event.center.x;
    y += event.center.y;
  } else {
    x += event.clientX;
    y += event.clientY;
  } // TODO Don't do getBoundingClientRect lookup here. It's performance heavy.


  var chartBounds = chart.element.getBoundingClientRect();
  var targetBounds = state.targetElement.getBoundingClientRect();
  var clientX = x;
  var clientY = y;
  var dx = chartBounds.left - targetBounds.left;
  var dy = chartBounds.top - targetBounds.top;
  var cx = x - chartBounds.left;
  var cy = y - chartBounds.top;
  x -= targetBounds.left;
  y -= targetBounds.top;
  return {
    x: x,
    // Target point relative to the target bounds
    y: y,
    dx: dx,
    // Delta from target bounds to the chart bounds
    dy: dy,
    cx: cx,
    // Target point relative to the chart bounds
    cy: cy,
    clientX: clientX,
    clientY: clientY,
    targetBounds: targetBounds,
    // Target bounding rect
    chartBounds: chartBounds // Chart bounding rect

  };
}

var component$3 = {
  require: ['chart', 'renderer'],
  defaultSettings: {
    settings: DEFAULT_SETTINGS$8,
    style: DEFAULT_STYLE
  },
  renderer: 'dom',
  on: {
    hide: function hide() {
      this.hide();
    },
    show: function show(event) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.show(event, opts);
    },
    prevent: function prevent(p) {
      this.prevent(p);
    }
  },
  hide: function hide() {
    this.dispatcher.clear();
    this.state.activeNodes = [];
    this.state.pointer = {};
  },
  show: function show(event) {
    var _this = this;

    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        nodes = _ref3.nodes,
        duration = _ref3.duration,
        delay = _ref3.delay;

    if (this.state.prevent) {
      return;
    } // Set pointer here to always expose latest pointer to invokeRenderer


    this.state.pointer = toPoint(event, this);
    var fNodes;

    if (Array.isArray(nodes)) {
      fNodes = this.props.filter(nodes);
    } else {
      fNodes = this.props.filter(this.chart.shapesAt({
        x: this.state.pointer.cx,
        y: this.state.pointer.cy
      }));
    }

    if (this.props.isEqual(this.state.activeNodes, fNodes)) {
      return;
    }

    this.dispatcher.clear();
    this.state.activeNodes = fNodes;

    if (this.state.activeNodes.length) {
      this.dispatcher.invoke(function () {
        return _this.invokeRenderer(_this.state.activeNodes);
      }, duration, delay);
    }
  },
  prevent: function prevent(p) {
    this.state.prevent = !!p;
  },
  init: function init(settings) {
    var _this2 = this;

    this.state = {
      activeNodes: [],
      pointer: {},
      targetElement: null,
      prevent: false
    };
    this.props = settings.settings;
    this.dispatcher = timeSpanDispatcher({
      defaultDuration: this.props.duration,
      defaultDelay: this.props.delay
    });
    var instanceId = this.dispatcher.clear;
    this.dispatcher.on('pending', function () {
      // Cancel only if the active is another instance
      cancelActive(instanceId);
      setActive(instanceId);

      if (typeof _this2.props.beforeShow === 'function') {
        _this2.props.beforeShow.call(undefined, {
          resources: {
            formatter: _this2.chart.formatter,
            scale: _this2.chart.scale
          }
        });
      }
    });
    this.dispatcher.on(['cancelled', 'fulfilled'], function () {
      var listenerCtx = {
        resources: {
          formatter: _this2.chart.formatter,
          scale: _this2.chart.scale
        }
      };

      if (typeof _this2.props.beforeHide === 'function') {
        _this2.props.beforeHide.call(undefined, extend({
          element: _this2.state.tooltipElm
        }, listenerCtx));
      }

      if (typeof _this2.props.onHide === 'function') {
        _this2.props.onHide.call(undefined, extend({
          element: _this2.state.tooltipElm
        }, listenerCtx));
      } else {
        _this2.renderer.clear([]); // Hide tooltip

      }

      if (typeof _this2.props.afterHide === 'function') {
        _this2.props.afterHide.call(undefined, listenerCtx);
      }

      removeActive(instanceId);
      _this2.state.tooltipElm = undefined;
    });
    this.dispatcher.on('active', function () {
      if (typeof _this2.props.afterShow === 'function') {
        _this2.props.afterShow.call(undefined, {
          element: _this2.state.tooltipElm,
          resources: {
            formatter: _this2.chart.formatter,
            scale: _this2.chart.scale
          }
        });
      }
    });
  },
  created: function created() {
    this.init(this.settings);
  },
  beforeUpdate: function beforeUpdate(_ref4) {
    var settings = _ref4.settings;

    if (this.dispatcher) {
      this.dispatcher.destroy();
      remove$1();
    }

    this.init(settings);
  },
  render: function render(h) {
    this.h = h;
    return []; // Nothing to render initially.
  },
  beforeDestroy: function beforeDestroy() {
    this.dispatcher.destroy();
    remove$1();
  },
  appendTo: function appendTo() {
    if (this.props.appendTo) {
      this.state.targetElement = typeof this.props.appendTo === 'function' ? this.props.appendTo({
        resources: {
          formatter: this.chart.formatter,
          scale: this.chart.scale
        }
      }) : this.props.appendTo;

      var _this$state$targetEle = this.state.targetElement.getBoundingClientRect(),
          width = _this$state$targetEle.width,
          height = _this$state$targetEle.height;

      this.renderer.destroy();
      this.renderer.size({
        width: width,
        height: height
      });
      this.renderer.appendTo(this.state.targetElement);
    } else {
      this.state.targetElement = this.renderer.element();
    }
  },
  mounted: function mounted() {
    this.appendTo();
  },
  updated: function updated() {
    // Append here to, otherwise the picasso displayOrder logic screw things up
    this.appendTo();
  },
  invokeRenderer: function invokeRenderer(nodes) {
    var items = extractor(nodes, this);
    var pseudoElement = render$3(items, {
      style: {
        left: '0px',
        top: '0px',
        visibility: 'hidden'
      }
    }, this);
    var pos = placement(pseudoElement.getBoundingClientRect(), this);
    this.state.tooltipElm = render$3(items, pos, this);
  }
};

/**
 * @typedef {object} component--tooltip
 */

/**
 * @type {string}
 * @memberof component--tooltip
 */

var type$4 = 'tooltip';
function addTooltip(picasso) {
  picasso.component(type$4, component$3);
}

var debugColliderDef = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    settings: {
      target: '',
      selector: '*',
      fill: 'rgba(0, 255, 0, 0.1)',
      stroke: 'lime',
      opacity: 1,
      useOuterRect: false
    }
  },
  on: {
    update: function update() {
      this.draw();
    }
  },
  draw: function draw() {
    var _this = this;

    var shapes = this.chart.findShapes(this.props.selector).filter(function (s) {
      return s.key === _this.props.target;
    }); // Find all shapes

    var colliders = shapes.filter(function (s) {
      return s.collider;
    }).map(function (s) {
      return s.collider;
    });
    colliders.forEach(function (c) {
      c.fill = _this.props.fill;
      c.stroke = _this.props.stroke;
      c.opacity = _this.props.opacity;
      c.collider = {
        type: null
      };
    });
    this.renderer.render(colliders);
  },
  created: function created() {
    this.props = this.settings.settings;
  },
  resize: function resize(_ref) {
    var outer = _ref.outer,
        inner = _ref.inner;

    if (this.props.useOuterRect) {
      return outer;
    }

    return inner;
  },
  render: function render() {},
  mounted: function mounted() {
    this.draw();
  },
  updated: function updated() {
    this.props = this.settings.settings;
    this.draw();
  }
};

var PI_X2 = Math.PI * 2;
/**
 * Implementation of F.6.5 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
 * @ignore
 * @param {number} rx - Arc x-radius
 * @param {number} ry - Arc y-radius
 * @param {number} rotation - Arc rotation in degrees (0-360)
 * @param {boolean} largeArcFlag
 * @param {boolean} sweepFlag
 * @param {number} endX - X-coordinate for end of arc
 * @param {number} endY - Y-coordinate for end of arc
 * @param {number} startX - X-coordinate for start of arc
 * @param {number} startY - Y-coordinate for start of arc
 * @returns {object}
 */

function arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY) {
  var startAngle;
  var endAngle;
  var sweepAngle;
  var cx;
  var cy;
  var radiusRatio;
  var rad = toRadians(rotation % 360); // F.6.5.1

  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var hdx = (startX - endX) / 2;
  var hdy = (startY - endY) / 2;
  var x1d = cos * hdx + sin * hdy;
  var y1d = cos * hdy - sin * hdx; // F.6.6

  rx = Math.abs(rx);
  ry = Math.abs(ry);
  radiusRatio = Math.pow(x1d, 2) / Math.pow(rx, 2) + Math.pow(y1d, 2) / Math.pow(ry, 2);

  if (radiusRatio > 1) {
    radiusRatio = Math.sqrt(radiusRatio);
    rx *= radiusRatio;
    ry *= radiusRatio;
  } // F.6.5.2


  var rxry = rx * ry;
  var rxy1d = rx * y1d;
  var ryx1d = ry * x1d;
  var den = Math.pow(rxy1d, 2) + Math.pow(ryx1d, 2);
  var num = Math.pow(rxry, 2) - den;
  var frac = Math.sqrt(Math.max(num / den, 0));

  if (largeArcFlag === sweepFlag) {
    frac = -frac;
  }

  var cxd = frac * (rxy1d / ry);
  var cyd = frac * -(ryx1d / rx); // F.6.5.3

  var mx = (startX + endX) / 2;
  var my = (startY + endY) / 2;
  cx = cos * cxd - sin * cyd + mx;
  cy = sin * cxd + cos * cyd + my; // F.6.5.6 clockwise angle

  var ux = (x1d - cxd) / rx;
  var uy = (y1d - cyd) / ry;
  var vx = (-x1d - cxd) / rx;
  var vy = (-y1d - cyd) / ry;
  startAngle = Math.atan2(uy, ux);
  startAngle += startAngle < 0 ? PI_X2 : 0;
  endAngle = Math.atan2(vy, vx);
  endAngle += endAngle < 0 ? PI_X2 : 0;
  sweepAngle = endAngle - startAngle;

  if (!sweepFlag && startAngle < endAngle) {
    sweepAngle -= PI_X2;
  } else if (sweepFlag && endAngle < startAngle) {
    sweepAngle += PI_X2;
  }

  sweepAngle %= PI_X2;
  return {
    startAngle: startAngle,
    sweepAngle: sweepAngle,
    cx: cx,
    cy: cy,
    rx: rx,
    ry: ry
  };
}

/**
 * Measure the flatnass of a cubic bezier curve
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp1 - First control point
 * @param {point} cp2 - Second control point
 * @param {point} e - End point
 */
function flatness(s, cp1, cp2, e) {
  var ux = Math.abs(s.x + cp2.x - (cp1.x + cp1.x));
  var uy = Math.abs(s.y + cp2.y - (cp1.y + cp1.y));
  var vx = Math.abs(cp1.x + e.x - (cp2.x + cp2.x));
  var vy = Math.abs(cp1.y + e.y - (cp2.y + cp2.y));
  return ux + uy + vx + vy;
}

function mid(p0, p1) {
  return {
    x: (p0.x + p1.x) / 2,
    y: (p0.y + p1.y) / 2
  };
}

function interpolate(t, s, cp1, cp2, e) {
  var td = 1 - t;
  var t0 = Math.pow(td, 3) * s;
  var t1 = 3 * Math.pow(td, 2) * t * cp1;
  var t2 = 3 * td * Math.pow(t, 2) * cp2;
  var t3 = Math.pow(t, 3) * e;
  return t0 + t1 + t2 + t3;
}
/**
 * Recursive subdivision of a curve using de Casteljau algorithm.
 * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp1 - First control point
 * @param {point} cp2 - Second control point
 * @param {point} e - End point
 * @param {array} points - Initial set of points
 * @returns {point[]} Array of points
 */


function toPoints(s, cp1, cp2, e) {
  var points = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

  if (flatness(s, cp1, cp2, e) <= 10) {
    // Poor man's Set
    if (points.indexOf(s) === -1) {
      points.push(s);
    }

    if (points.indexOf(e) === -1) {
      points.push(e);
    }

    return points;
  }

  var t = 0.5;
  var m0 = mid(s, cp1);
  var m1 = mid(cp1, cp2);
  var m2 = mid(cp2, e);
  var b = {
    // Split curve at point
    x: interpolate(t, s.x, cp1.x, cp2.x, e.x),
    y: interpolate(t, s.y, cp1.y, cp2.y, e.y)
  };
  var q0 = mid(m0, m1); // New cp2 for left curve

  var q1 = mid(m1, m2); // New cp1 for right curve

  toPoints(s, m0, q0, b, points); // left curve

  toPoints(b, q1, m2, e, points); // Right curve

  return points;
}

function toCubic(s, cp, e) {
  var cp1x = s.x + 2 / 3 * (cp.x - s.x);
  var cp1y = s.y + 2 / 3 * (cp.y - s.y);
  var cp2x = e.x + 2 / 3 * (cp.x - e.x);
  var cp2y = e.y + 2 / 3 * (cp.y - e.y);
  var cp1 = {
    x: cp1x,
    y: cp1y
  };
  var cp2 = {
    x: cp2x,
    y: cp2y
  };
  return {
    cp1: cp1,
    cp2: cp2
  };
}
/**
 * Recursive subdivision of a curve using de Casteljau algorithm.
 * Splits the curve into multiple line segments where each segments is choosen based on a level of flatness.
 * @ignore
 * @param {point} s - Start point
 * @param {point} cp - Control point
 * @param {point} e - End point
 * @returns {point[]} Array of points
 */


function toPoints$1(s, cp, e) {
  var _toCubic = toCubic(s, cp, e),
      cp1 = _toCubic.cp1,
      cp2 = _toCubic.cp2;

  return toPoints(s, cp1, cp2, e);
}

var EPSILON$1 = 1e-12;

function removeDuplicates(points) {
  for (var i = 0; i < points.length - 1; i++) {
    var p0 = points[i];
    var p1 = points[i + 1];

    if (Math.abs(p0.x - p1.x) < EPSILON$1 && Math.abs(p0.y - p1.y) < EPSILON$1) {
      points.splice(i, 1);
      i--;
    }
  }
}
/**
 * Transform an arc to a set of points a long the arc.
 * Specifiction F.6 (https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes)
 * @ignore
 * @param {array} s - Segments
 * @param {number} startX - X-coordinate for start of arc
 * @param {number} startY - Y-coordinate for start of arc
 */


function arcToPoints(s, startX, startY) {
  var points = [];
  var largeArcFlag = !!s[4]; // F.6.3

  var sweepFlag = !!s[5]; // F.6.3

  var rotation = s[3];
  var endX = s[6];
  var endY = s[7];
  var rx = s[1];
  var ry = s[2];
  var cx;
  var cy;
  var sweepAngle;
  var startAngle;

  if (s[0] === 'a') {
    endX += startX;
    endY += startY;
  } // F.6.2


  if (startX === endY && startY === endY) {
    return points;
  } // Given no radius, threat as lineTo command


  if (!rx || !ry) {
    points.push({
      x: endX,
      y: endY
    });
    return points;
  }

  var _arcToCenter = arcToCenter(rx, ry, rotation, largeArcFlag, sweepFlag, endX, endY, startX, startY);

  cx = _arcToCenter.cx;
  cy = _arcToCenter.cy;
  rx = _arcToCenter.rx;
  ry = _arcToCenter.ry;
  sweepAngle = _arcToCenter.sweepAngle;
  startAngle = _arcToCenter.startAngle;
  // Approximation of perimeter
  var p = Math.abs(sweepAngle * Math.sqrt((Math.pow(rx, 2) + Math.pow(ry, 2)) / 2)); // Generate a point every 10th pixel. Scaling of the node should probably be included in this calculation

  var res = Math.ceil(p / 10);
  var resAngle = sweepAngle / res;

  for (var k = 1; k <= res; k++) {
    var deltaAngle = resAngle * k;
    var radians = (startAngle + deltaAngle) % PI_X2;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians); // F.6.3 https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes

    points.push({
      x: cx + cos * rx + -sin * cos,
      y: cy + sin * ry + cos * sin
    });
  } // points.push({ x: cx, y: cy });


  return points;
}
/**
 * Converts a SVG path data string into a set of points.
 * @ignore
 * @param {string} path
 * @returns {Array<point[]>} Array of points
 */


function pathToPoints(path) {
  var commands = parsePath_1(path);
  var segments = [];
  var points = [];
  var x = 0; // Current point

  var y = 0;
  var cpx = null; // Last control point on a cubic curve

  var cpy = null;
  var qcpx = null; // Last control point on a quad curve

  var qcpy = null;

  for (var i = 0; i < commands.length; ++i) {
    var cmd = commands[i];
    var pathType = cmd[0]; // Reset control point if command is not cubic

    if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {
      cpx = null;
      cpy = null;
    }

    if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {
      qcpx = null;
      qcpy = null;
    }

    switch (pathType) {
      case 'm':
        if (points.length) {
          segments.push(points.splice(0));
        }

      // Fall through

      case 'l':
        // eslint-disable-line no-fallthrough
        x += cmd[1];
        y += cmd[2];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'M':
        if (points.length) {
          segments.push(points.splice(0));
        }

      // Fall through

      case 'L':
        // eslint-disable-line no-fallthrough
        x = cmd[1];
        y = cmd[2];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'H':
        x = cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'h':
        x += cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'V':
        y = cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'v':
        y += cmd[1];
        points.push({
          x: x,
          y: y
        });
        break;

      case 'a':
        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));
        x += cmd[6];
        y += cmd[7];
        break;

      case 'A':
        points.push.apply(points, _toConsumableArray$1(arcToPoints(cmd, x, y)));
        x = cmd[6];
        y = cmd[7];
        break;

      case 'c':
        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        }, {
          x: cmd[5] + x,
          y: cmd[6] + y
        })));
        cpx = cmd[3] + x; // Last control point

        cpy = cmd[4] + y;
        x += cmd[5];
        y += cmd[6];
        break;

      case 'C':
        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        }, {
          x: cmd[5],
          y: cmd[6]
        })));
        cpx = cmd[3]; // Last control point

        cpy = cmd[4];
        x = cmd[5];
        y = cmd[6];
        break;

      case 's':
        if (cpx === null || cpx === null) {
          cpx = x;
          cpy = y;
        }

        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: 2 * x - cpx,
          y: 2 * y - cpy
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        })));
        cpx = cmd[1] + x; // last control point

        cpy = cmd[2] + y;
        x += cmd[3];
        y += cmd[4];
        break;

      case 'S':
        if (cpx === null || cpx === null) {
          cpx = x;
          cpy = y;
        }

        points.push.apply(points, _toConsumableArray$1(toPoints({
          x: x,
          y: y
        }, {
          x: 2 * x - cpx,
          y: 2 * y - cpy
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        })));
        cpx = cmd[1]; // last control point

        cpy = cmd[2];
        x = cmd[3];
        y = cmd[4];
        break;

      case 'Q':
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: cmd[1],
          y: cmd[2]
        }, {
          x: cmd[3],
          y: cmd[4]
        })));
        qcpx = cmd[1]; // last control point

        qcpy = cmd[2];
        x = cmd[3];
        y = cmd[4];
        break;

      case 'q':
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        }, {
          x: cmd[3] + x,
          y: cmd[4] + y
        })));
        qcpx = cmd[1] + x; // last control point

        qcpy = cmd[2] + y;
        x += cmd[3];
        y += cmd[4];
        break;

      case 'T':
        if (qcpx === null || qcpx === null) {
          qcpx = x;
          qcpy = y;
        }

        qcpx = 2 * x - qcpx; // last control point

        qcpy = 2 * y - qcpy;
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: qcpx,
          y: qcpy
        }, {
          x: cmd[1],
          y: cmd[2]
        })));
        x = cmd[1];
        y = cmd[2];
        break;

      case 't':
        if (qcpx === null || qcpx === null) {
          qcpx = x;
          qcpy = y;
        }

        qcpx = 2 * x - qcpx; // last control point

        qcpy = 2 * y - qcpy;
        points.push.apply(points, _toConsumableArray$1(toPoints$1({
          x: x,
          y: y
        }, {
          x: qcpx,
          y: qcpy
        }, {
          x: cmd[1] + x,
          y: cmd[2] + y
        })));
        x += cmd[1];
        y += cmd[2];
        break;

      case 'z':
      case 'Z':
        if (points.length) {
          points.push({
            x: points[0].x,
            y: points[0].y
          });
        }

        break;

      default: // Do nothing

    }
  }

  removeDuplicates(points);
  segments.push(points.splice(0));
  return segments;
}

var debugPathToPointsDef = {
  require: ['renderer', 'chart'],
  defaultSettings: {
    settings: {
      target: '',
      fill: 'transparent',
      stroke: 'lime',
      opacity: 1,
      radius: 2,
      useOuterRect: false
    }
  },
  on: {
    update: function update() {
      this.draw();
    }
  },
  draw: function draw() {
    var _this = this;

    var shapes = this.chart.findShapes('path').filter(function (s) {
      return s.key === _this.props.target;
    }); // Find all shapes

    var circles = [];
    shapes.forEach(function (s) {
      pathToPoints(s.attrs.d).forEach(function (segment) {
        segment.forEach(function (p) {
          circles.push({
            type: 'circle',
            cx: p.x,
            cy: p.y,
            r: _this.props.radius,
            fill: _this.props.fill,
            stroke: _this.props.stroke,
            opacity: _this.props.opacity,
            collider: {
              type: null
            }
          });
        });
      });
    });
    this.renderer.render(circles);
  },
  created: function created() {
    this.props = this.settings.settings;
  },
  resize: function resize(_ref) {
    var outer = _ref.outer,
        inner = _ref.inner;

    if (this.props.useOuterRect) {
      return outer;
    }

    return inner;
  },
  render: function render() {},
  mounted: function mounted() {
    this.draw();
  },
  updated: function updated() {
    this.props = this.settings.settings;
    this.draw();
  }
};

function debugCollider(picasso) {
  picasso.component('debug-collider', debugColliderDef);
}
function debugPathToPoints(picasso) {
  picasso.component('debug-path-to-points', debugPathToPointsDef);
}

var components = [box$1, pointMarker, pie$1, gridLine, refLine, picasso_esm_axis, picasso_esm_text, scrollbar, rangeBrush, rangeBrush$1, lassoBrush, picasso_esm_labels, categoricalLegend, sequentialLegend, line$2, areaBrush, addTooltip, debugCollider, debugPathToPoints];

var Node =
/*#__PURE__*/
function () {
  /**
   * @private
   */
  function Node(type) {
    _classCallCheck$1(this, Node);

    this._parent = null;
    this._children = [];
    this._ancestors = null;
    this.type = type;
    this.data = null;
  }
  /**
   * Detaches this node from its parent, if such exists.
   * @returns {Node}
   */


  _createClass$1(Node, [{
    key: "detach",
    value: function detach() {
      if (this._parent) {
        this._parent.removeChild(this);
      }

      return this;
    }
    /**
     * Parent of this node.
     * @readonly
     * @type {Node}
     */

  }, {
    key: "equals",

    /**
     *
     * @returns {Boolean}
     */
    value: function equals(n) {
      var children = this.children;
      var nChildren = n.children;

      if (children.length !== nChildren.length) {
        return false;
      } // Requires deterministic child order


      for (var i = 0; i < children.length; i++) {
        if (!children[i].equals(nChildren[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: this.type,
        children: this.children.map(function (ch) {
          return ch.toJSON();
        })
      };
    }
  }, {
    key: "parent",
    get: function get() {
      return this._parent;
    }
    /**
     * Checks whether this node is a branch.
     *
     * True if this node has children, false otherwise.
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isBranch",
    get: function get() {
      return this._children && this._children.length;
    }
    /**
     * Children of this node.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "children",
    get: function get() {
      return this._children;
    }
    /**
     * Ancestors of this node, including parent.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "ancestors",
    get: function get() {
      if (!this._ancestors) {
        this._ancestors = [];

        if (this.parent) {
          var _this$_ancestors;

          (_this$_ancestors = this._ancestors).push.apply(_this$_ancestors, [this.parent].concat(_toConsumableArray$1(this.parent.ancestors)));
        }
      }

      return this._ancestors;
    }
    /**
     * Descendants of this node.
     * @readonly
     * @type {Node[]}
     */

  }, {
    key: "descendants",
    get: function get() {
      var r = [];
      var len = this.children.length;
      var i;
      var c;

      for (i = 0, len; i < len; i++) {
        c = this.children[i];
        r.push(c);

        if (c.children.length) {
          r.push.apply(r, _toConsumableArray$1(c.descendants));
        }
      }

      return r;
    }
  }]);

  return Node;
}();

/**
 * Construct a new GeoRect instance
 * @private
 */

var GeoRect =
/*#__PURE__*/
function () {
  function GeoRect() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$width = _ref.width,
        width = _ref$width === void 0 ? 0 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === void 0 ? 0 : _ref$height,
        _ref$minWidth = _ref.minWidth,
        minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth,
        _ref$minHeight = _ref.minHeight,
        minHeight = _ref$minHeight === void 0 ? 0 : _ref$minHeight;

    _classCallCheck$1(this, GeoRect);

    this.set({
      x: x,
      y: y,
      width: width,
      height: height,
      minWidth: minWidth,
      minHeight: minHeight
    });
  }

  _createClass$1(GeoRect, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$x = _ref2.x,
          x = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === void 0 ? 0 : _ref2$y,
          _ref2$width = _ref2.width,
          width = _ref2$width === void 0 ? 0 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === void 0 ? 0 : _ref2$height,
          _ref2$minWidth = _ref2.minWidth,
          minWidth = _ref2$minWidth === void 0 ? 0 : _ref2$minWidth,
          _ref2$minHeight = _ref2.minHeight,
          minHeight = _ref2$minHeight === void 0 ? 0 : _ref2$minHeight;

      this.type = 'rect';

      if (width >= 0) {
        this.x = x;
        this.width = Math.max(width, minWidth);
      } else {
        this.x = x + Math.min(width, -minWidth);
        this.width = -Math.min(width, -minWidth);
      }

      if (height >= 0) {
        this.y = y;
        this.height = Math.max(height, minHeight);
      } else {
        this.y = y + Math.min(height, -minHeight);
        this.height = -Math.min(height, -minHeight);
      }
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return testRectPoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testRectLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testRectRect(this, rect);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleRect(c, this);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testPolygonRect(polygon, this);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.x,
        y: this.y
      }, {
        x: this.x + this.width,
        y: this.y
      }, {
        x: this.x + this.width,
        y: this.y + this.height
      }, {
        x: this.x,
        y: this.y + this.height
      }];
    }
  }]);

  return GeoRect;
}();

function create$4() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoRect, args);
}

/**
 * Construct a new GeoCircle instance
 * @private
 */

var GeoCircle =
/*#__PURE__*/
function () {
  function GeoCircle() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$cx = _ref.cx,
        cx = _ref$cx === void 0 ? 0 : _ref$cx,
        _ref$cy = _ref.cy,
        cy = _ref$cy === void 0 ? 0 : _ref$cy,
        _ref$r = _ref.r,
        r = _ref$r === void 0 ? 0 : _ref$r,
        _ref$minRadius = _ref.minRadius,
        minRadius = _ref$minRadius === void 0 ? 0 : _ref$minRadius;

    _classCallCheck$1(this, GeoCircle);

    this.set({
      cx: cx,
      cy: cy,
      r: r,
      minRadius: minRadius
    });
  }

  _createClass$1(GeoCircle, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$cx = _ref2.cx,
          cx = _ref2$cx === void 0 ? 0 : _ref2$cx,
          _ref2$cy = _ref2.cy,
          cy = _ref2$cy === void 0 ? 0 : _ref2$cy,
          _ref2$r = _ref2.r,
          r = _ref2$r === void 0 ? 0 : _ref2$r,
          _ref2$minRadius = _ref2.minRadius,
          minRadius = _ref2$minRadius === void 0 ? 0 : _ref2$minRadius;

      this.type = 'circle';
      this.cx = cx;
      this.cy = cy;
      this.r = Math.max(r, minRadius);
      this.vector = {
        x: this.cx,
        y: this.cy
      };
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return testCirclePoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testCircleLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testCircleRect(this, rect);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleCircle(this, c);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testCirclePolygon(this, polygon);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.cx,
        y: this.cy
      }];
    }
  }]);

  return GeoCircle;
}();

function create$5() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoCircle, args);
}

/**
 * Construct a new GeoLine instance
 * @private
 */

var GeoLine =
/*#__PURE__*/
function () {
  function GeoLine() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x1,
        x1 = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y1,
        y1 = _ref$y === void 0 ? 0 : _ref$y,
        _ref$x2 = _ref.x2,
        x2 = _ref$x2 === void 0 ? 0 : _ref$x2,
        _ref$y2 = _ref.y2,
        y2 = _ref$y2 === void 0 ? 0 : _ref$y2,
        _ref$tolerance = _ref.tolerance,
        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance;

    _classCallCheck$1(this, GeoLine);

    this.set({
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      tolerance: tolerance
    });
  }

  _createClass$1(GeoLine, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$x = _ref2.x1,
          x1 = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y1,
          y1 = _ref2$y === void 0 ? 0 : _ref2$y,
          _ref2$x2 = _ref2.x2,
          x2 = _ref2$x2 === void 0 ? 0 : _ref2$x2,
          _ref2$y2 = _ref2.y2,
          y2 = _ref2$y2 === void 0 ? 0 : _ref2$y2,
          _ref2$tolerance = _ref2.tolerance,
          tolerance = _ref2$tolerance === void 0 ? 0 : _ref2$tolerance;

      this.type = 'line';
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.tolerance = Math.max(0, Math.round(tolerance));
      this.vectors = this.points();
      this.zeroSize = x1 === x2 && y1 === y2;
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      if (this.tolerance > 0) {
        var c = {
          cx: p.x,
          cy: p.y,
          r: this.tolerance
        };
        return testCircleLine(c, this);
      }

      return testLinePoint(this, p);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var line = pointsToLine(points);
      return testLineLine(this, line);
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return testRectLine(rect, this);
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return testCircleLine(c, this);
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return testPolygonLine(polygon, this);
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return [{
        x: this.x1,
        y: this.y1
      }, {
        x: this.x2,
        y: this.y2
      }];
    }
  }]);

  return GeoLine;
}();

function create$6() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeoLine, args);
}

function picasso_esm_close(vertices) {
  var first = vertices[0];
  var last = vertices[vertices.length - 1];

  if (first.x !== last.x || first.y !== last.y) {
    vertices.push(first);
  }
}

function removeDuplicates$1(vertices) {
  for (var i = 0; i < vertices.length - 1; i++) {
    var v0 = vertices[i];
    var v1 = vertices[i + 1];

    if (v0.x === v1.x && v0.y === v1.y) {
      vertices.splice(i, 1);
      i--;
    }
  }
}
/**
 * Construct a new GeoPolygon instance
 * @private
 */


var GeoPolygon =
/*#__PURE__*/
function () {
  function GeoPolygon() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$vertices = _ref.vertices,
        vertices = _ref$vertices === void 0 ? [] : _ref$vertices;

    _classCallCheck$1(this, GeoPolygon);

    this.set({
      vertices: vertices
    });
  }
  /**
   * Set the vertices.
   * If vertices doesn't close the polygon, a closing vertice is appended.
   * @param {object} input An object with a vertices property
   * @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.
   */


  _createClass$1(GeoPolygon, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$vertices = _ref2.vertices,
          vertices = _ref2$vertices === void 0 ? [] : _ref2$vertices;

      this.type = 'polygon';
      this.vertices = vertices.slice();
      this.edges = [];
      removeDuplicates$1(this.vertices);

      if (this.vertices.length <= 2) {
        return;
      }

      picasso_esm_close(this.vertices);
      this.xMin = NaN;
      this.yMin = NaN;
      this.xMax = NaN;
      this.yMax = NaN;

      for (var i = 0; i < this.vertices.length; i++) {
        if (i < this.vertices.length - 1) {
          this.edges.push([this.vertices[i], this.vertices[i + 1]]);
        }

        this.xMin = isNaN(this.xMin) ? this.vertices[i].x : Math.min(this.xMin, this.vertices[i].x);
        this.xMax = isNaN(this.xMax) ? this.vertices[i].x : Math.max(this.xMax, this.vertices[i].x);
        this.yMin = isNaN(this.yMin) ? this.vertices[i].y : Math.min(this.yMin, this.vertices[i].y);
        this.yMax = isNaN(this.yMax) ? this.vertices[i].y : Math.max(this.yMax, this.vertices[i].y);
      }

      this._bounds = null;
      this._boundingRect = null;
    }
    /**
     * Check if a point is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return testPolygonPoint(this, point);
    }
    /**
     * Check if circle is inside the area of the polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return testCirclePolygon(circle, this);
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      return testPolygonLine(this, pointsToLine(points));
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      return testPolygonRect(this, pointsToRect(points));
    }
    /**
     * Check if polygon intersects another polygon.
     * Supports convex, concave and self-intersecting polygons (filled area).
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      // This is a unoptimized solution and should be replaced by a more efficient algorithm.
      if (!testRectRect(this.boundingRect(), polygon.boundingRect())) {
        return false;
      }

      var intersects = false;

      for (var i = 0, len = this.edges.length; i < len; i++) {
        intersects = testPolygonLine(polygon, pointsToLine(this.edges[i]));

        if (intersects === true) {
          break;
        }
      }

      return intersects;
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return this.vertices;
    }
    /**
     * Get the bounds of the polygon, as an array of points
     * @returns {point[]}
     */

  }, {
    key: "bounds",
    value: function bounds() {
      if (!this._bounds) {
        this._bounds = [{
          x: this.xMin,
          y: this.yMin
        }, {
          x: this.xMax,
          y: this.yMin
        }, {
          x: this.xMax,
          y: this.yMax
        }, {
          x: this.xMin,
          y: this.yMax
        }];
      }

      return this._bounds;
    }
    /**
     * Get the bounding rect of the polygon
     * @returns {rect}
     */

  }, {
    key: "boundingRect",
    value: function boundingRect() {
      if (!this._boundingRect) {
        this._boundingRect = {
          x: this.xMin,
          y: this.yMin,
          width: this.xMax - this.xMin,
          height: this.yMax - this.yMin
        };
      }

      return this._boundingRect;
    }
  }]);

  return GeoPolygon;
}();
/**
* Construct a new GeoPolygon instance
* @param {object} input An object with a vertices property
* @param {point[]} [input.vertices=[]] Vertices are represented as an array of points.
* @returns {GeoPolygon} GeoPolygon instance
* @private
*/


function create$7() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(GeoPolygon, a);
}

function pointsAreNotEqual(p0, p1) {
  return p0.x !== p1.x || p0.y !== p1.y;
}
/**
 * Construct a new GeoPolyline instance
 * @private
 */


var GeoPolyline =
/*#__PURE__*/
function () {
  function GeoPolyline() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$points = _ref.points,
        points = _ref$points === void 0 ? [] : _ref$points;

    _classCallCheck$1(this, GeoPolyline);

    this.set({
      points: points
    });
  }

  _createClass$1(GeoPolyline, [{
    key: "set",
    value: function set() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$points = _ref2.points,
          points = _ref2$points === void 0 ? [] : _ref2$points;

      this.type = 'polyline';
      this.segments = [];
      this._points = points.slice();

      if (this._points.length > 1) {
        for (var i = 0, len = this._points.length - 1; i < len; i++) {
          if (pointsAreNotEqual(this._points[i], this._points[i + 1])) {
            this.segments.push({
              x1: this._points[i].x,
              y1: this._points[i].y,
              x2: this._points[i + 1].x,
              y2: this._points[i + 1].y
            });
          }
        }
      }
    }
    /**
     * @param {point} point
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(point) {
      return this.segments.some(function (line) {
        return testLinePoint(line, point);
      });
    }
    /**
     * @param {circle} circle
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return this.segments.some(function (line) {
        return testCircleLine(circle, line);
      });
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      var testLine = pointsToLine(points);
      return this.segments.some(function (line) {
        return testLineLine(line, testLine);
      });
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      var rect = pointsToRect(points);
      return this.segments.some(function (line) {
        return testRectLine(rect, line);
      });
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      // This is a unoptimized solution and should be replaced by a more efficient algorithm.
      return this.segments.some(function (line) {
        return testPolygonLine(polygon, line);
      });
    }
    /**
     * Get the points
     * @returns {point[]}
     */

  }, {
    key: "points",
    value: function points() {
      return this._points;
    }
  }]);

  return GeoPolyline;
}();

function create$8() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(GeoPolyline, a);
}

var reg$3 = registryFactory();
reg$3.add('rect', create$4);
reg$3.add('circle', create$5);
reg$3.add('line', create$6);
reg$3.add('polygon', create$7);
reg$3.add('polyline', create$8);
function create$9(type, input) {
  // eslint-disable-line import/prefer-default-export
  return reg$3.get(type)(input);
}
/**
 * @typedef {object} rect
 * @property {number} x - X-coordinate
 * @property {number} y - Y-coordinate
 * @property {number} width - Width
 * @property {number} height - Height
 */

/**
 * @typedef {object} line
 * @property {number} x1 - Start x-coordinate
 * @property {number} y1 - Start y-coordinate
 * @property {number} x2 - End x-coordinate
 * @property {number} y2 - End y-coordinate
 */

/**
 * @typedef {object} point
 * @property {number} x - X-coordinate
 * @property {number} y - Y-coordinate
 */

/**
 * @typedef {object} circle
 * @property {number} cx - Center x-coordinate
 * @property {number} cy - Center y-coordinate
 * @property {number} r - Circle radius
 */

/**
 * @typedef {object} polygon
 * @property {Array<point>} points - Array of connected points
 */

/**
 * @typedef {object} polyline
 * @property {Array<point>} points - Array of connected points
 */

/**
 * @typedef {object} path
 * @property {string} d - Path definition
 */

/**
 * Construct a new GeometryCollection instance
 * @private
  */

var GeometryCollection =
/*#__PURE__*/
function () {
  function GeometryCollection() {
    var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    _classCallCheck$1(this, GeometryCollection);

    this.set(collection);
  }

  _createClass$1(GeometryCollection, [{
    key: "set",
    value: function set() {
      var _this = this;

      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.geometries = [];
      collection.forEach(function (geo) {
        var geoInstance = create$9(geo.type, geo);

        if (geoInstance) {
          _this.geometries.push(geoInstance);
        }
      });
    }
    /**
     * @param {point} p
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return this.geometries.some(function (geo) {
        return geo.containsPoint(p);
      });
    }
    /**
     * @param {point[]} points - Line start and end point as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsLine",
    value: function intersectsLine(points) {
      return this.geometries.some(function (geo) {
        return geo.intersectsLine(points);
      });
    }
    /**
     * @param {point[]} points - Rect vertices as an array of points
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsRect",
    value: function intersectsRect(points) {
      return this.geometries.some(function (geo) {
        return geo.intersectsRect(points);
      });
    }
    /**
     * @param {circle} c
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(c) {
      return this.geometries.some(function (geo) {
        return geo.intersectsCircle(c);
      });
    }
    /**
     * @param {GeoPolygon} polygon
     * @returns {boolean} True if there is an intersection, false otherwise
     */

  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return this.geometries.some(function (geo) {
        return geo.intersectsPolygon(polygon);
      });
    }
  }]);

  return GeometryCollection;
}();

function create$a() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return _construct(GeometryCollection, args);
}

var Matrix =
/*#__PURE__*/
function () {
  /**
   * Creates a matrix with identity values.
   * @private
   */
  function Matrix() {
    _classCallCheck$1(this, Matrix);

    this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    this._stack = [];
  }
  /**
   * Creates a new matrix with a copy of the current values.
   */


  _createClass$1(Matrix, [{
    key: "clone",
    value: function clone() {
      var mt = new Matrix();
      return mt.multiply(this);
    }
    /**
    * Sets the matrix values
    * @param {Number[][]} arr A 3x3 array.
    */

  }, {
    key: "set",
    value: function set(arr) {
      this._elements = arr;
      return this;
    }
    /**
    * Saves the current matrix values to a stack.
    */

  }, {
    key: "save",
    value: function save() {
      this._stack.push(this.elements);

      return this;
    }
    /**
    * Sets the current matrix values to the last ones saved on to the stack.
    */

  }, {
    key: "restore",
    value: function restore() {
      if (this._stack.length) {
        this._elements = this._stack.pop(); // TODO - use a copy instead
      }

      return this;
    }
    /**
    * Adds a scalar value to each element in the matrix.
    * @param {Number} value
    */

  }, {
    key: "add",
    value: function add(value) {
      // assume scalar
      var i, j;

      for (i = 0; i < this._elements.length; i++) {
        for (j = 0; j < this._elements[i].length; j++) {
          this._elements[i][j] += value;
        }
      }

      return this;
    }
    /**
    * Translates the current matrix along the x and y axis.
    * @param {Number} x
    * @param {Number} y
    */

  }, {
    key: "translate",
    value: function translate(x, y) {
      this.multiply([[1, 0, x], [0, 1, y], [0, 0, 1]]);
      return this;
    }
    /**
    * Rotates the current matrix.
    * @param {Number} radianAngle Angle in radians.
    */

  }, {
    key: "rotate",
    value: function rotate(radianAngle) {
      var cos = Math.cos(-radianAngle),
          sin = Math.sin(-radianAngle);
      this.multiply([[cos, sin, 0], [-sin, cos, 0], [0, 0, 1]]);
      return this;
    }
    /**
    *
    * If value is a number; multiplies each element in the matrix by the given value.
    * If value is a matrix; multiplies the two matrices.
    * @param {Number|Array|Matrix} value
    */

  }, {
    key: "multiply",
    value: function multiply(value) {
      var i, j, m, k;

      if (value instanceof Matrix) {
        value = value._elements;
      }

      if (Array.isArray(value)) {
        // matrix multiplication
        m = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];

        for (i = 0; i < this._elements.length; i++) {
          // row
          for (j = 0; j < this._elements[i].length; j++) {
            // column
            for (k = 0; k < 3; k++) {
              // row
              m[i][j] += this._elements[i][k] * value[k][j];
            }
          }
        }

        this._elements = m;
      } else {
        // scalar multiplication
        for (i = 0; i < this._elements.length; i++) {
          for (j = 0; j < this._elements[i].length; j++) {
            this._elements[i][j] *= value;
          }
        }
      }

      return this;
    }
    /**
    * Scales the matrix along x and y axis.
    * @param {Number} x The value to scale the matrix with along the x direction
    * @param {Number} [y=x] The value to scale the matrix with along the y direction.
    */

  }, {
    key: "scale",
    value: function scale(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      // if ( arguments.length < 2 || typeof y === "undefined" ) {
      //  y = x;
      // }
      this.multiply([[x, 0, 0], [0, y, 0], [0, 0, 1]]);
      return this;
    }
    /**
     * Multiples the matrix with the supplied transformation values
     * @param {Number} a Horizontal scaling
     * @param {Number} b Horizontal skewing
     * @param {Number} c Vertical skewing
     * @param {Number} d Vertical scaling
     * @param {Number} e Horizontal moving
     * @param {Number} f Vertical scaling
     */

  }, {
    key: "transform",
    value: function transform(a, b, c, d, e, f) {
      this.multiply([[a, c, e], [b, d, f], [0, 0, 1]]);
      return this;
    }
    /**
    * Gets the value of the determinant.
    * @return {Number}
    */

  }, {
    key: "determinant",
    value: function determinant() {
      var a = this._elements[0][0],
          b = this._elements[0][1],
          c = this._elements[0][2],
          d = this._elements[1][0],
          e = this._elements[1][1],
          f = this._elements[1][2],
          g = this._elements[2][0],
          h = this._elements[2][1],
          i = this._elements[2][2],
          p = 0;
      p = a * e * i + b * f * g + c * d * h - c * e * g - b * d * i - a * f * h;
      return p;
    }
    /**
    * Inverts the matrix.
    */

  }, {
    key: "invert",
    value: function invert() {
      var dt = this.determinant(),
          a = this._elements[0][0],
          b = this._elements[0][1],
          c = this._elements[0][2],
          d = this._elements[1][0],
          e = this._elements[1][1],
          f = this._elements[1][2],
          g = this._elements[2][0],
          h = this._elements[2][1],
          k = this._elements[2][2];
      this._elements = [[e * k - f * h, c * h - b * k, b * f - c * e], [f * g - d * k, a * k - c * g, c * d - a * f], [d * h - e * g, g * b - a * h, a * e - b * d]];
      this.multiply(1 / dt); // TODO - handle when dt === 0 ?

      return this;
    }
    /**
    * Transposes the elements of the matrix.
    */

  }, {
    key: "transpose",
    value: function transpose() {
      var m = Object.create(this._elements); // ?

      this._elements = [[m[0][0], m[1][0], m[2][0]], [m[0][1], m[1][1], m[2][1]], [m[0][2], m[1][2], m[2][2]]];
      return this;
    }
    /**
    * Resets the inner elements of the matrix to identity values.
    */

  }, {
    key: "identity",
    value: function identity() {
      this._elements = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this._elements.map(function (r) {
        return r.join('\t');
      }).join('\n'));
    }
  }, {
    key: "isIdentity",
    value: function isIdentity() {
      var m = this._elements;
      return m[0][0] === 1 && m[0][1] === 0 && m[0][2] === 0 && m[1][0] === 0 && m[1][1] === 1 && m[1][2] === 0 && m[2][0] === 0 && m[2][1] === 0 && m[2][2] === 1;
    }
    /**
     * Transforms the given point by this matrix and returns a new point
     */

  }, {
    key: "transformPoint",
    value: function transformPoint(p) {
      var vec = [p.x, p.y, 1],
          i,
          j,
          e = this._elements,
          m = [0, 0, 0];

      for (i = 0; i < this._elements.length; i++) {
        // row
        for (j = 0; j < this._elements[i].length; j++) {
          // column
          m[i] += vec[j] * e[i][j];
        }
      }

      return {
        x: m[0],
        y: m[1]
      };
    }
    /**
     * Transforms the given points by this matrix and returns the new points
     */

  }, {
    key: "transformPoints",
    value: function transformPoints(array) {
      var vec,
          i,
          j,
          k,
          m,
          e = this._elements,
          ret = [];

      for (k = 0; k < array.length; k++) {
        vec = [array[k].x, array[k].y, 1];
        m = [0, 0, 0];

        for (i = 0; i < this._elements.length; i++) {
          // row
          for (j = 0; j < this._elements[i].length; j++) {
            // column
            m[i] += vec[j] * e[i][j];
          }
        }

        ret.push({
          x: m[0],
          y: m[1]
        });
      }

      return ret;
    }
  }, {
    key: "elements",
    get: function get() {
      var m = this._elements;
      return [[m[0][0], m[0][1], m[0][2]], [m[1][0], m[1][1], m[1][2]], [m[2][0], m[2][1], m[2][2]]];
    }
  }]);

  return Matrix;
}();

var transformRegEx = /(translate|scale|rotate|matrix)\(([0-9,.eE+-\s]+)(?:,|\s?)+\)/g;

function parseTransform(transform) {
  var m,
      commands = [];

  while ((m = transformRegEx.exec(transform)) !== null) {
    // eslint-disable-line no-cond-assign
    var argsStr = m[2].trim();
    var args = argsStr.indexOf(',') === -1 ? argsStr.split(' ') : argsStr.split(',');
    commands.push({
      cmd: m[1],
      args: args.filter(function (a) {
        return a.trim().length > 0;
      }).map(function (a) {
        return Number(a);
      })
    });
  }

  return commands;
}

function resolveRotateCmd(matrix, transform) {
  var radians = transform.args[0] * (Math.PI / 180);

  if (transform.args.length > 2) {
    var x = transform.args[1];
    var y = transform.args[2];
    matrix.translate(x, y);
    matrix.rotate(radians);
    matrix.translate(-x, -y);
  } else if (transform.args.length === 1) {
    matrix.rotate(radians);
  }
}

function resolveScaleCmd(matrix, transform) {
  var x = transform.args[0];
  var y = isNaN(transform.args[1]) ? transform.args[0] : transform.args[1];
  matrix.scale(x, y);
}

function resolveTranslateCmd(matrix, transform) {
  var x = transform.args[0];
  var y = isNaN(transform.args[1]) ? 0 : transform.args[1];
  matrix.translate(x, y);
}

function resolveMatrixCmd(matrix, transform) {
  if (transform.args.length >= 6) {
    matrix.transform.apply(matrix, _toConsumableArray$1(transform.args));
  }
}

function resolveTransform(t, matrix) {
  var transforms = parseTransform(t);
  var transform;

  for (var i = 0, len = transforms.length; i < len; i++) {
    transform = transforms[i];

    if (transform.cmd === 'rotate') {
      resolveRotateCmd(matrix, transform);
    } else if (transform.cmd === 'scale') {
      resolveScaleCmd(matrix, transform);
    } else if (transform.cmd === 'matrix') {
      resolveMatrixCmd(matrix, transform);
    } else if (transform.cmd === 'translate') {
      resolveTranslateCmd(matrix, transform);
    }
  }
}

/* eslint-disable no-useless-escape */
var SELECTOR_MAPS = {
  type: /^\w[\w-]+/,
  attr: /^\[\w(?:[\w\._-]+)?(?:[!]?=['\"][\w\s*#_-]*['\"])?\]/,
  universal: /^(\*)/,
  tag: /^\.(\w+)/
};
var FILTERS = {
  type: function type(c, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var type = o.type;

      if (type) {
        return type.toLowerCase() === c.toLowerCase();
      }

      return false;
    });
  },
  attr: function attr(_attr, operator, value, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var v = o.attrs[_attr];

      if (!operator) {
        // TODO handle undefined differently for != operator? As display object may very well have a default rendering color
        return typeof v !== 'undefined';
      }

      if (typeof v === 'undefined') {
        return false;
      }

      switch (operator) {
        case '=':
          return value === String(v);

        case '!=':
          return value !== String(v);

        default:
          return false;
      }
    });
  },
  universal: function universal(objects) {
    return objects;
  },
  tag: function tag(selector, objects) {
    // eslint-disable-line arrow-body-style
    return objects.filter(function (o) {
      var tag = o.tag;

      if (tag) {
        return tag.trim().split(/\s+/).indexOf(selector.replace('.', '')) !== -1;
      }

      return false;
    });
  }
};
/**
* Filters out objects of given type and value
* @ignore
* @example
* filter(
*   {type:'type', value:'Circle'},
*   [new Circle(), new Rectangle()]
* )
* // [Circle]
* @param {Object} token
* @param {Array} objects
* @returns {Object[]} Objects that fulfill the type and value
*/

function filter(token, objects) {
  if (!objects || !objects.length || !token || typeof FILTERS[token.type] !== 'function') {
    return [];
  }

  switch (token.type) {
    case 'type':
      return FILTERS[token.type](token.value, objects);

    case 'attr':
      return FILTERS[token.type](token.attribute, token.operator, token.attributeValue, objects);

    case 'universal':
      return FILTERS[token.type](objects);

    case 'tag':
      return FILTERS[token.type](token.value, objects);

    default:
      return [];
  }
}
/**
* Tokenizes a string into supported selectors
* @ignore
*
* @example
* tokenize("Circle[color='red']")
*
* @param {String} s
*/

function tokenize(s) {
  var groups = [];
  var sub;
  var info;
  var match;
  var validSelector;
  s.split(/\s*,\s*/).forEach(function (group) {
    group = group.trim();
    sub = [];

    var selectorMapsIterator = function selectorMapsIterator(key) {
      match = group.match(SELECTOR_MAPS[key]);

      if (match) {
        validSelector = true;
        group = group.slice(match[0].length);
        info = {
          type: key,
          value: match[0]
        };

        if (key === 'attr') {
          // extract parts of attribute from e.g. [color='red'] => (color, =, red)
          match = match[0].match(/\[(\w[\w\._-]+)?(?:([!]?=)['\"]([\w\s#_-]*)['\"])?\]/);
          info.attribute = match[1];
          info.operator = match[2];
          info.attributeValue = match[3];
        }

        sub.push(info);
      }
    };

    while (group) {
      validSelector = false;
      match = group.match(/^\s*([>+~]|\s)\s*/);

      if (match) {
        validSelector = true;
        sub.push({
          type: ' ',
          value: match[0]
        });
        group = group.slice(match[0].length);
      }

      Object.keys(SELECTOR_MAPS).forEach(selectorMapsIterator);

      if (sub && sub.length && groups.indexOf(sub) < 0) {
        groups.push(sub);
      }

      if (!validSelector) {
        break;
      }
    }
  });
  return groups;
}

function find(s, object) {
  var result = [];
  var groupResults = [];
  var groups;
  var descendants;

  if (object.isBranch) {
    groups = tokenize(s);
    descendants = object.descendants;
    var tokens;

    var _loop = function _loop(gi, glen) {
      tokens = groups[gi];
      var levels = [];
      var filtered = descendants.slice();
      var hasRemainder = false;
      tokens.reverse().forEach(function (token) {
        if (token.type === ' ') {
          levels.push(filtered);
          filtered = descendants.slice();
          hasRemainder = false;
          return;
        }

        filtered = filter(token, filtered);
        hasRemainder = true;
      });

      if (hasRemainder) {
        levels.push(filtered);
      }

      var selected = levels[0].filter(function (node) {
        var ancestor = node.parent;
        var idx;

        for (var _i = 1; _i < levels.length; _i++) {
          idx = levels[_i].indexOf(ancestor);

          while (ancestor && idx < 0) {
            ancestor = ancestor.parent;
            idx = levels[_i].indexOf(ancestor);
          }

          if (idx < 0) {
            return false;
          }
        }

        return true;
      });
      groupResults.push(selected);
    };

    for (var gi = 0, glen = groups.length; gi < glen; gi++) {
      _loop(gi, glen);
    }

    for (var i = 0, len = groupResults.length; i < len; i++) {
      for (var ni = 0, nlen = groupResults[i].length; ni < nlen; ni++) {
        if (result.indexOf(groupResults[i][ni]) < 0) {
          result.push(groupResults[i][ni]);
        }
      }
    }
  }

  return result || [];
}

var nodeSelector = {
  find: find
};

function appendDpi(points, dpi) {
  for (var i = 0, len = points.length; i < len; i++) {
    points[i].x /= dpi;
    points[i].y /= dpi;
  }
}

function geometryToDef(geometry, dpi, mvm) {
  var type = geometry.type;
  var points = mvm ? mvm.transformPoints(geometry.points()) : geometry.points();
  appendDpi(points, dpi);
  var def = null;

  if (type === 'rect' || type === 'bounds') {
    def = pointsToRect(points);
    def.type = type;
  } else if (type === 'circle') {
    def = pointsToCircle(points, geometry.r);
    def.type = type;
  } else if (type === 'line') {
    def = pointsToLine(points);
    def.type = type;
  } else if (type === 'polygon' || type === 'polyline') {
    var path = pointsToPath(points, type === 'polygon');
    def = {
      type: 'path',
      d: path
    };
  }

  return def;
}
/**
 * @ignore
 * @returns {object} Returns a node definition of the collider
 */


function colliderToShape(node, dpi) {
  if (node.collider) {
    var mvm = node.modelViewMatrix;
    var isCollection = node.colliderType === 'collection';

    if (isCollection) {
      var children = node.collider.geometries.map(function (geometry) {
        return geometryToDef(geometry, dpi, mvm);
      });
      return {
        type: 'container',
        children: children
      };
    }

    return geometryToDef(node.collider, dpi, mvm);
  }

  return null;
}
/**
 * Read-only object representing a node on the scene.
 */


var SceneNode =
/*#__PURE__*/
function () {
  function SceneNode(node) {
    var _this = this;

    _classCallCheck$1(this, SceneNode);

    this._bounds = function () {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      var _ref = node.boundingRect ? node.boundingRect(includeTransform) : {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
          x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height;

      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };

    this._attrs = node.attrs;
    this._type = node.type;
    this._data = node.data;
    this._dpi = node.stage ? node.stage.dpi : 1;

    this._collider = function () {
      return colliderToShape(node, _this._dpi);
    };

    this._desc = node.desc;
    this._tag = node.tag;

    this._children = function () {
      return node.children.map(function (n) {
        return new SceneNode(n);
      });
    };

    this._parent = function () {
      return node.parent ? new SceneNode(node.parent) : null;
    };

    this._cache = {
      elementBoundingRect: null
    };

    this._getElementBoundingRect = function () {
      if (!_this._cache.elementBoundingRect && _this.element) {
        _this._cache.elementBoundingRect = _this.element.getBoundingClientRect();
      }

      return _this._cache.elementBoundingRect || {
        left: 0,
        top: 0
      };
    };
  }
  /**
   * Get child nodes
   * @type {SceneNode[]}
   */


  _createClass$1(SceneNode, [{
    key: "boundsRelativeTo",

    /**
     * Bounding rectangle of the node, relative a target.
     *
     * If target is an HTMLElement, the bounds are relative to the HTMLElement.
     * Any other target type will return the bounds relative to the viewport of the browser.
     *
     * @param {HTMLElement|any} target
     * @param {boolean} includeTransform - Whether to include any applied transforms on the node
     * @returns {rect}
     * @example
     *
     * node.boundsRelativeTo($('div'));
     * node.boundsRelativeTo('viewport');
     */
    value: function boundsRelativeTo(target) {
      var includeTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var type = picasso_esm_typeof(target);

      var bounds = includeTransform ? this.bounds : this.localBounds;

      var selfRect = this._getElementBoundingRect();

      var dx = selfRect.left;
      var dy = selfRect.top;

      if (type === 'object' && target !== null && typeof target.getBoundingClientRect === 'function') {
        var _target$getBoundingCl = target.getBoundingClientRect(),
            _target$getBoundingCl2 = _target$getBoundingCl.left,
            left = _target$getBoundingCl2 === void 0 ? 0 : _target$getBoundingCl2,
            _target$getBoundingCl3 = _target$getBoundingCl.top,
            top = _target$getBoundingCl3 === void 0 ? 0 : _target$getBoundingCl3;

        dx -= left;
        dy -= top;
      }

      bounds.x += dx;
      bounds.y += dy;
      return bounds;
    }
    /**
     * Collider of the node. Transform on the node has been applied to the collider shape, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     *
     * If node has no collider, null is returned.
     * @type {line|rect|circle|path}
     */

  }, {
    key: "children",
    get: function get() {
      return this._children();
    }
    /**
     * Get parent node
     * @type {SceneNode}
     */

  }, {
    key: "parent",
    get: function get() {
      return this._parent();
    }
    /**
     * Node type
     * @type {string}
     */

  }, {
    key: "type",
    get: function get() {
      return this._type;
    }
    /**
     * Get the associated data
     * @type {any}
     */

  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
    /**
     * Node attributes
     * @type {object}
     */

  }, {
    key: "attrs",
    get: function get() {
      return this._attrs;
    }
    /**
     * Element the scene is attached to
     * @type {HTMLElement}
     * @private
     */

  }, {
    key: "element",
    set: function set(e) {
      this._cache.elementBoundingRect = null;
      this._element = e;
    }
    /**
     * Element the scene is attached to
     * @type {HTMLElement}
     */
    ,
    get: function get() {
      return this._element;
    }
    /**
    * Key of the component this shape belongs to
    * @type {string}
    * @private
    */

  }, {
    key: "key",
    set: function set(k) {
      this._key = k;
    }
    /**
    * Key of the component this shape belongs to
    * @type {string}
    */
    ,
    get: function get() {
      return this._key;
    }
    /**
     * Bounding rectangle of the node. After any transform has been applied, if any, but excluding scaling transform related to devicePixelRatio.
     * Origin is in the top-left corner of the scene element.
     * @type {rect}
     */

  }, {
    key: "bounds",
    get: function get() {
      var bounds = this._bounds();

      bounds.x /= this._dpi;
      bounds.y /= this._dpi;
      bounds.width /= this._dpi;
      bounds.height /= this._dpi;
      return bounds;
    }
    /**
     * Bounding rectangle of the node withing it's local coordinate system.
     * Origin is in the top-left corner of the scene element.
     * @type {rect}
     */

  }, {
    key: "localBounds",
    get: function get() {
      var bounds = this._bounds(false);

      return bounds;
    }
  }, {
    key: "collider",
    get: function get() {
      return this._collider();
    }
    /**
     * Node description
     * @type {object}
     */

  }, {
    key: "desc",
    get: function get() {
      return this._desc;
    }
    /**
     * Node tag
     * @type {string}
     */

  }, {
    key: "tag",
    get: function get() {
      return this._tag;
    }
  }]);

  return SceneNode;
}();

function create$b() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(SceneNode, a);
}

var Collision =
/*#__PURE__*/
function () {
  function Collision(node) {
    _classCallCheck$1(this, Collision);

    this._node = create$b(node);
    this._parent = null;
    this._input = null;
  }

  _createClass$1(Collision, [{
    key: "node",
    get: function get() {
      return this._node;
    }
  }, {
    key: "parent",
    set: function set(p) {
      this._parent = p;
    },
    get: function get() {
      return this._parent;
    }
  }, {
    key: "input",
    set: function set(i) {
      this._input = i;
    },
    get: function get() {
      return this._input;
    }
  }]);

  return Collision;
}();
function create$c() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(Collision, a);
}

function appendParentNode(node, collision) {
  var p = node.parent;

  if (p && p.type !== 'stage') {
    collision.parent = create$c(p);
    var pp = p.parent;

    if (pp && pp.type !== 'stage') {
      appendParentNode(pp, collision.parent);
    }
  }
}

function appendInputShape(shape, collisions) {
  for (var i = 0, len = collisions.length; i < len; i++) {
    collisions[i].input = shape;
  }
}

function resolveFrontChildCollision(node, type, input) {
  var num = node.descendants.length;

  for (var i = num - 1; i >= 0; i--) {
    var desc = node.descendants[i];

    if (desc.collider === null) {
      continue;
    }

    if (desc.collider[type](input)) {
      var collision = create$c(desc);
      appendParentNode(desc, collision);
      return collision;
    }
  }

  return null;
}

function resolveGeometryCollision(node, type, input) {
  if (node.collider[type](input)) {
    var c = create$c(node);
    appendParentNode(node, c);
    return c;
  }

  return null;
}

function inverseTransform(node, input) {
  var transformedInput = {};

  if (node.modelViewMatrix) {
    if (Array.isArray(input)) {
      // Rect or Line
      transformedInput = node.inverseModelViewMatrix.transformPoints(input);
    } else if (!isNaN(input.r)) {
      // Circle
      var p = {
        x: input.cx,
        y: input.cy
      };

      var _node$inverseModelVie = node.inverseModelViewMatrix.transformPoint(p);

      transformedInput.cx = _node$inverseModelVie.x;
      transformedInput.cy = _node$inverseModelVie.y;
      transformedInput.r = input.r;
    } else if (Array.isArray(input.vertices)) {
      // Polygon
      transformedInput.vertices = node.inverseModelViewMatrix.transformPoints(input.vertices);
    } else {
      // Point
      transformedInput = node.inverseModelViewMatrix.transformPoint(input);
    }
  } else {
    transformedInput = input;
  }

  if (Array.isArray(transformedInput.vertices)) {
    transformedInput = create$7(transformedInput); // TODO Shouldn't have to do this here, currently its beacause a collision algorithm optimization, i.e. caching of polygon bounds
  }

  return transformedInput;
}

function resolveCollision(node, intersectionType, input) {
  if (node.colliderType === null) {
    return null;
  }

  var transformedInput = inverseTransform(node, input);

  if (node.colliderType === 'frontChild') {
    return resolveFrontChildCollision(node, intersectionType, transformedInput);
  }

  return resolveGeometryCollision(node, intersectionType, transformedInput);
}

function findAllCollisions(nodes, intersectionType, ary, input) {
  var num = nodes.length;

  for (var i = 0; i < num; i++) {
    var node = nodes[i];
    var collision = resolveCollision(node, intersectionType, input);

    if (collision) {
      ary.push(collision);
    } // Only traverse children if no match is found on parent and it doesnt have any custom collider


    if (node.children && !collision && !node.collider) {
      findAllCollisions(node.children, intersectionType, ary, input);
    }
  }
}

function hasCollision(nodes, intersectionType, input) {
  var num = nodes.length;

  for (var i = 0; i < num; i++) {
    var node = nodes[i];
    var collision = resolveCollision(node, intersectionType, input);

    if (collision !== null) {
      return true;
    }

    if (node.children && !node.collider) {
      return hasCollision(node.children, intersectionType, input);
    }
  }

  return false;
}

function resolveShape(shape) {
  var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var type = getShapeType(shape);
  var _shape = {};

  switch (type) {
    case 'circle':
      _shape.cx = shape.cx * ratio;
      _shape.cy = shape.cy * ratio;
      _shape.r = shape.r;
      return ['intersectsCircle', _shape];

    case 'rect':
      _shape = rectToPoints(shape).map(function (p) {
        return scalarMultiply(p, ratio);
      });
      return ['intersectsRect', _shape];

    case 'line':
      _shape = lineToPoints(shape).map(function (p) {
        return scalarMultiply(p, ratio);
      });
      return ['intersectsLine', _shape];

    case 'point':
      _shape = scalarMultiply(shape, ratio);
      return ['containsPoint', _shape];

    case 'polygon':
      _shape.vertices = shape.vertices.map(function (vertex) {
        return scalarMultiply(vertex, ratio);
      });
      return ['intersectsPolygon', _shape];

    default:
      return [];
  }
}

function resolveCollionsOnNode(node, shape) {
  var _resolveShape = resolveShape(shape, node.dpi),
      _resolveShape2 = _slicedToArray(_resolveShape, 2),
      intersectionType = _resolveShape2[0],
      _shape = _resolveShape2[1];

  var collisions = [];

  if (intersectionType) {
    findAllCollisions([node], intersectionType, collisions, _shape);
    appendInputShape(shape, collisions);
  }

  return collisions;
}
function hasCollisionOnNode(node, shape) {
  var _resolveShape3 = resolveShape(shape, node.dpi),
      _resolveShape4 = _slicedToArray(_resolveShape3, 2),
      intersectionType = _resolveShape4[0],
      _shape = _resolveShape4[1];

  return hasCollision([node], intersectionType, _shape);
}

/**
 * @typedef {object} node-def
 * @property {string} type
 * @property {string|gradient-def|pattern-def} [fill] - {@link https://www.w3.org/TR/fill-stroke-3/#fill-shorthand}
 * @property {string|gradient-def|pattern-def} [stroke] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke}
 * @property {number} [strokeWidth] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-width}
 * @property {string|number[]} [strokeDasharray] - {@link https://www.w3.org/TR/fill-stroke-3/#propdef-stroke-dasharray}
 * @property {number} [opacity] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
 * @property {string} [transform] - {@link https://www.w3.org/TR/SVG/coords.html#TransformAttribute}
 * @property {object} [data] - Data object, may contain any properties
 * @property {object} [desc] - Meta-data object, may contain any properties
 * @property {string} [tag] - White-space seperated list of tags
 * @property {string} [id] - Unique identifier of the node
 * @property {object} [collider]
 */

var DisplayObject =
/*#__PURE__*/
function (_Node) {
  _inherits(DisplayObject, _Node);

  function DisplayObject(type) {
    var _this;

    _classCallCheck$1(this, DisplayObject);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DisplayObject).call(this, type));
    _this._stage = null;
    _this._collider = {
      type: null,
      definition: null,
      fn: null
    };
    _this._attrs = {};
    _this._node = null;
    return _this;
  }

  _createClass$1(DisplayObject, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.node = v;
      var data = v.data,
          desc = v.desc,
          tag = v.tag,
          strokeReference = v.strokeReference,
          fillReference = v.fillReference;
      assignMappedAttribute(this.attrs, v);

      if (typeof data !== 'undefined') {
        this.data = data;
      }

      if (picasso_esm_typeof(desc) === 'object') {
        this.desc = extend(true, {}, desc);
      }

      if (typeof tag === 'string') {
        this.tag = tag;
      }

      if (typeof strokeReference === 'string') {
        this.strokeReference = strokeReference;
      }

      if (typeof fillReference === 'string') {
        this.fillReference = fillReference;
      }
    }
  }, {
    key: "findShapes",
    value: function findShapes(selector) {
      return nodeSelector.find(selector, this).map(function (node) {
        return create$b(node);
      });
    }
  }, {
    key: "getItemsFrom",
    value: function getItemsFrom(shape) {
      return resolveCollionsOnNode(this, shape);
    }
  }, {
    key: "containsPoint",
    value: function containsPoint(p) {
      return hasCollisionOnNode(this, p);
    }
  }, {
    key: "intersectsLine",
    value: function intersectsLine(line) {
      return hasCollisionOnNode(this, line);
    }
  }, {
    key: "intersectsRect",
    value: function intersectsRect(rect) {
      return hasCollisionOnNode(this, rect);
    }
  }, {
    key: "intersectsCircle",
    value: function intersectsCircle(circle) {
      return hasCollisionOnNode(this, circle);
    }
  }, {
    key: "intersectsPolygon",
    value: function intersectsPolygon(polygon) {
      return hasCollisionOnNode(this, polygon);
    }
  }, {
    key: "resolveLocalTransform",
    value: function resolveLocalTransform() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();

      if (typeof this.attrs.transform !== 'undefined') {
        resolveTransform(this.attrs.transform, m);
      }

      this.modelViewMatrix = m.clone();
    }
  }, {
    key: "resolveGlobalTransform",
    value: function resolveGlobalTransform() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();
      var a = this.ancestors;

      if (a.length > 0) {
        for (var i = a.length - 1; i >= 0; i--) {
          a[i].resolveLocalTransform(m);
          m = a[i].modelViewMatrix;
        }
      }

      this.resolveLocalTransform(m);
    }
    /**
     * Returns the value of attribute a.
     * @private
     * @param a
     * @returns {*} The value of attribute a.
     */

  }, {
    key: "attr",
    value: function attr(a) {
      return this.attrs[a];
    }
  }, {
    key: "equals",
    value: function equals(d) {
      var attrs = this.attrs;
      var attrKeys = Object.keys(attrs);
      var dAttrs = d.attrs;
      var dAttrKeys = Object.keys(dAttrs);

      if (attrKeys.length !== dAttrKeys.length) {
        return false;
      }

      for (var i = 0; i < attrKeys.length; i++) {
        var key = attrKeys[i];

        if (!Object.hasOwnProperty.call(dAttrs, key)) {
          return false;
        }

        if (attrs[key] !== dAttrs[key]) {
          return false;
        }
      }

      return _get(_getPrototypeOf(DisplayObject.prototype), "equals", this).call(this, d);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = _get(_getPrototypeOf(DisplayObject.prototype), "toJSON", this).call(this);

      json.attrs = this.attrs;
      return json;
    }
  }, {
    key: "attrs",
    get: function get() {
      return this._attrs;
    }
  }, {
    key: "stage",
    get: function get() {
      if (this._parent && !this._stage) {
        // lazy evaluation
        this._stage = this._parent.stage;
      } else if (!this._parent && this._stage !== this) {
        this._stage = null;
      }

      return this._stage;
    }
  }, {
    key: "modelViewMatrix",
    set: function set(m) {
      this._mvm = m;
      this._imvm = null;
    },
    get: function get() {
      return this._mvm;
    }
  }, {
    key: "inverseModelViewMatrix",
    get: function get() {
      this._imvm = this._imvm ? this._imvm : this._mvm.clone().invert();
      return this._imvm;
    }
  }, {
    key: "node",
    set: function set(n) {
      this._node = n;
    },
    get: function get() {
      return this._node;
    }
  }, {
    key: "collider",
    set: function set(definition) {
      var type = Array.isArray(definition) ? 'collection' : definition && definition.type;

      if (typeof type !== 'string') {
        // Non string type definition resets the collider
        this._collider.type = null;
        this._collider.definition = null;
        this._collider.fn = null;
        return;
      } // Check if a collider of the same type is already defined, if so, do an update


      if (this._collider !== null && this._collider.type === type && this._collider.fn !== null) {
        this._collider.fn.set(definition);

        this._collider.definition = definition;
        return;
      } // Store the definition so that it can be lazy evaluated


      this._collider.type = type;
      this._collider.definition = definition;
    },
    get: function get() {
      // Resolve geometry function from cache
      if (this._collider.fn !== null) {
        return this._collider.fn;
      } // Resolve geometry function and store it in cache


      switch (this._collider.type) {
        case 'collection':
          this._collider.fn = create$a(this._collider.definition);
          break;

        case 'frontChild':
          // TODO Deprecate
          // Front child is not resolved by a function on this node, but instead on one of its child nodes
          return true;

        case 'bounds':
          this._collider.fn = create$9('rect', this.boundingRect());
          break;

        case 'line':
        case 'rect':
        case 'circle':
        case 'polygon':
        case 'polyline':
          this._collider.fn = create$9(this._collider.type, this._collider.definition);
          break;

        default:
          return null;
      }

      return this._collider.fn;
    }
  }, {
    key: "colliderType",
    get: function get() {
      return this._collider.type;
    }
  }]);

  return DisplayObject;
}(Node);

var NodeContainer =
/*#__PURE__*/
function (_Node) {
  _inherits(NodeContainer, _Node);

  function NodeContainer() {
    _classCallCheck$1(this, NodeContainer);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodeContainer).apply(this, arguments));
  }

  _createClass$1(NodeContainer, [{
    key: "addChild",
    value: function addChild(c) {
      if (!c || !(c instanceof Node)) {
        throw new TypeError("Expecting a Node as argument, but got ".concat(c));
      }

      if (c === this) {
        throw new Error('Can not add itself as child!');
      }

      if (c._children && c._children.length && this.ancestors.indexOf(c) >= 0) {
        throw new Error('Can not add an ancestor as child!');
      }

      if (c._parent && c._parent !== this) {
        c._parent.removeChild(c);
      }

      this._children.push(c);

      c._parent = this;
      c._ancestors = null;
      return this;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var i,
          num = children ? children.length : 0;

      for (i = 0; i < num; i++) {
        this.addChild(children[i]);
      }

      return this;
    }
    /**
     * Removes given child node from this node.
     * @private
     * @param {Node} c
     * @returns {Node} This object, for chaining purposes.
     */

  }, {
    key: "removeChild",
    value: function removeChild(c) {
      var indx = this._children.indexOf(c);

      if (indx >= 0) {
        this._children.splice(indx, 1);

        c._parent = null;
        c._ancestors = null;
      }

      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      var i, num;

      if (!this._children) {
        return this;
      }

      if (children) {
        num = children.length;

        for (i = 0; i < num; i++) {
          this.removeChild(children[i]);
        }
      } else {
        while (this._children.length) {
          this.removeChild(this._children[0]);
        }
      }

      return this;
    }
  }]);

  return NodeContainer;
}(Node);

/**
 * @extends node-def
 * @typedef {object} node--container-def
 * @property {node-def[]} children - Array of child nodes
 */

var NC = NodeContainer.prototype;

var Container =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Container, _DisplayObject);

  function Container() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, Container);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, type));

    _this.set(s);

    return _this;
  }

  _createClass$1(Container, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(Container.prototype), "set", this).call(this, v);

      var collider = v.collider;
      var opts = extend({
        type: null
      }, collider);
      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "appendChildRect",
    value: function appendChildRect(child, includeTransform) {
      if (typeof child.bounds !== 'undefined') {
        var rect = this.__boundingRect[includeTransform] || {};

        var _child$bounds = child.bounds(includeTransform),
            _child$bounds2 = _slicedToArray(_child$bounds, 3),
            p0 = _child$bounds2[0],
            p2 = _child$bounds2[2];

        var xMin = p0.x,
            yMin = p0.y;
        var xMax = p2.x,
            yMax = p2.y;

        var _xMax = isNaN(rect.width) ? xMax : Math.max(xMax, rect.width + rect.x);

        var _yMax = isNaN(rect.height) ? yMax : Math.max(yMax, rect.height + rect.y);

        rect.x = isNaN(rect.x) ? xMin : Math.min(xMin, rect.x);
        rect.y = isNaN(rect.y) ? yMin : Math.min(yMin, rect.y);
        rect.width = _xMax - rect.x;
        rect.height = _yMax - rect.y;
        this.__boundingRect[includeTransform] = rect;
      }
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var num = this.children.length;

      for (var i = 0; i < num; i++) {
        this.appendChildRect(this.children[i], includeTransform);
      }

      this.__boundingRect[includeTransform] = extend({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, this.__boundingRect[includeTransform]);
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC.addChild.call(this, c);

      if (this._collider && this._collider.type === 'bounds') {
        this.appendChildRect(c, true);
        var opts = extend({
          type: 'bounds',
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, this.__boundingRect.true);
        this.collider = opts;
      }

      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC.addChildren.call(this, children);
      var num = children.length;

      if (this._collider && this._collider.type === 'bounds' && num > 0) {
        for (var i = 0; i < num; i++) {
          this.appendChildRect(children[i], true);
        }

        var opts = extend({
          type: 'bounds',
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }, this.__boundingRect.true);
        this.collider = opts;
      }

      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC.removeChild.call(this, c);

      if (this._collider && this._collider.type === 'bounds') {
        this.__boundingRect = {
          true: null,
          false: null
        };
        this.__bounds = {
          true: null,
          false: null
        };
        var opts = extend(this.boundingRect(true), {
          type: 'bounds'
        });
        this.collider = opts;
      }

      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC.removeChildren.call(this, children);

      if (this._collider && this._collider.type === 'bounds') {
        this.__boundingRect = {
          true: null,
          false: null
        };
        this.__bounds = {
          true: null,
          false: null
        };
        var opts = extend(this.boundingRect(true), {
          type: 'bounds'
        });
        this.collider = opts;
      }

      return this;
    }
  }]);

  return Container;
}(DisplayObject);
function create$d() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Container, s);
}

var Stage =
/*#__PURE__*/
function (_Container) {
  _inherits(Stage, _Container);

  function Stage(dpi) {
    var _this;

    _classCallCheck$1(this, Stage);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Stage).call(this, 'stage'));
    _this._stage = _assertThisInitialized(_this);
    _this._dpiRatio = dpi || 1;
    return _this;
  }

  _createClass$1(Stage, [{
    key: "dpi",
    get: function get() {
      return this._dpiRatio;
    }
  }]);

  return Stage;
}(Container);
function create$e() {
  for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
    a[_key] = arguments[_key];
  }

  return _construct(Stage, a);
}

/**
 * @typedef {object} gradient-def
 * @property {string} type
 * @property {object[]} stops
 * @property {string} [stops[].type=linearGradient] - radialGradient|linearGradient
 * @property {string} stops[].color - {@link https://www.w3.org/TR/SVG/types.html#DataTypeColor}
 * @property {string} [stops[].opacity=1] - {@link https://www.w3.org/TR/css-color-4/#propdef-opacity}
 * @property {number} stops[].offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
 * @property {number} [degree] - Gradient rotation angle
 */

/**
 * @typedef {object} node--gradient-item-def
 * @property {string} id - Gradient identifier
 * @property {number} x1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX1Attribute}
 * @property {number} y1 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY1Attribute}
 * @property {number} x2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementX2Attribute}
 * @property {number} y2 - {@link https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementY2Attribute}
 * @property {number} offset - {@link https://www.w3.org/TR/SVG/pservers.html#StopElementOffsetAttribute}
 * @property {object} style - {@link https://www.w3.org/TR/SVG/styling.html#StyleAttribute}
 */

var NC$1 = NodeContainer.prototype;
var allowedAttrs = ['x1', 'x2', 'y1', 'y2', 'id', 'offset', 'style'];

var GradientItem =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(GradientItem, _DisplayObject);

  function GradientItem() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, GradientItem);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(GradientItem).call(this, type));

    _this.set(s);

    _this._boundingRect = {};
    return _this;
  }

  _createClass$1(GradientItem, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(GradientItem.prototype), "set", this).call(this, v);

      var attrs = this.attrs;
      var attrKey = '';

      for (var i = 0, len = allowedAttrs.length; i !== len; i++) {
        attrKey = allowedAttrs[i];

        if (typeof v[attrKey] !== 'undefined') {
          attrs[attrKey] = v[attrKey];
        }
      }
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC$1.addChild.call(this, c);
      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC$1.addChildren.call(this, children);
      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC$1.removeChild.call(this, c);
      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC$1.removeChildren.call(this, children);
      return this;
    }
  }]);

  return GradientItem;
}(DisplayObject);
function create$f() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(GradientItem, s);
}

/**
 * @experimental
 * @typedef {object} pattern-def
 * @property {'pattern'} type
 * @property {string} fill
 * @property {number} width
 * @property {number} height
 * @property {object[]} shapes
 * @example
 * Stripe pattern
 * ```js
 * {
 *   type: 'pattern',
 *   fill: 'red',
 *   width: 4,
 *   height: 4,
 *   shapes: [
 *     { type: 'rect', x: 3, y: 0, width: 1, height: 1 },
 *     { type: 'rect', x: 2, y: 1, width: 1, height: 1 },
 *     { type: 'rect', x: 1, y: 2, width: 1, height: 1 },
 *     { type: 'rect', x: 0, y: 3, width: 1, height: 1 },
 *   ]
 * }
 * ```
 */

var NC$2 = NodeContainer.prototype;
var allowedAttrs$1 = ['patternUnits', 'x', 'y', 'width', 'height', 'id'];

var PatternItem =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(PatternItem, _DisplayObject);

  function PatternItem() {
    var _this;

    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck$1(this, PatternItem);

    var _s$type = s.type,
        type = _s$type === void 0 ? 'container' : _s$type;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PatternItem).call(this, type));

    _this.set(s);

    _this._boundingRect = {};
    return _this;
  }

  _createClass$1(PatternItem, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(PatternItem.prototype), "set", this).call(this, v);

      var attrs = this.attrs;
      var attrKey = '';

      for (var i = 0, len = allowedAttrs$1.length; i !== len; i++) {
        attrKey = allowedAttrs$1[i];

        if (typeof v[attrKey] !== 'undefined') {
          attrs[attrKey] = v[attrKey];
        }
      }
    }
  }, {
    key: "addChild",
    value: function addChild(c) {
      var r = NC$2.addChild.call(this, c);
      return r;
    }
  }, {
    key: "addChildren",
    value: function addChildren(children) {
      var r = NC$2.addChildren.call(this, children);
      return r;
    }
  }, {
    key: "removeChild",
    value: function removeChild(c) {
      c._stage = null;
      var desc = c.descendants,
          num = desc ? desc.length : 0,
          i; // remove reference to stage from all descendants

      for (i = 0; i < num; i++) {
        desc[i]._stage = null;
      }

      NC$2.removeChild.call(this, c);
      return this;
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(children) {
      NC$2.removeChildren.call(this, children);
      return this;
    }
  }]);

  return PatternItem;
}(DisplayObject);
function create$g() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(PatternItem, s);
}

/**
 * @extends node-def
 * @typedef {object} node--rect-def
 * @property {number} x - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementXAttribute}
 * @property {number} y - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementYAttribute}
 * @property {number} width - {@link https://www.w3.org/TR/SVG/shapes.html#RectElementWidthAttribute}
 * @property {number} height- {@link https://www.w3.org/TR/SVG/shapes.html#RectElementHeightAttribute}
 */

var Rect =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Rect, _DisplayObject);

  function Rect() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Rect);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, 'rect'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Rect, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x,
          x = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y,
          y = _v$y === void 0 ? 0 : _v$y,
          _v$width = v.width,
          width = _v$width === void 0 ? 0 : _v$width,
          _v$height = v.height,
          height = _v$height === void 0 ? 0 : _v$height,
          _v$rx = v.rx,
          rx = _v$rx === void 0 ? 0 : _v$rx,
          _v$ry = v.ry,
          ry = _v$ry === void 0 ? 0 : _v$ry,
          collider = v.collider;
      var opts = extend({
        type: 'rect',
        x: x,
        y: y,
        width: width,
        height: height
      }, collider);

      _get(_getPrototypeOf(Rect.prototype), "set", this).call(this, v);

      if (width >= 0) {
        this.attrs.x = x;
        this.attrs.width = width;
      } else {
        this.attrs.x = x + width;
        this.attrs.width = -width;
      }

      if (height >= 0) {
        this.attrs.y = y;
        this.attrs.height = height;
      } else {
        this.attrs.y = y + height;
        this.attrs.height = -height;
      }

      if (rx > 0) {
        this.attrs.rx = rx;
      }

      if (ry > 0) {
        this.attrs.ry = ry;
      }

      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var p = rectToPoints(this.attrs);
      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: xMax - xMin,
        height: yMax - yMin
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Rect;
}(DisplayObject);
function create$h() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Rect, s);
}

/**
 * @extends node-def
 * @typedef {object} node--circle-def
 * @property {number} cx - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCXAttribute}
 * @property {number} cy - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementCYAttribute}
 * @property {number} r - {@link https://www.w3.org/TR/SVG/shapes.html#CircleElementRAttribute}
 */

var Circle =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Circle, _DisplayObject);

  function Circle() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Circle);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, 'circle'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Circle, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$cx = v.cx,
          cx = _v$cx === void 0 ? 0 : _v$cx,
          _v$cy = v.cy,
          cy = _v$cy === void 0 ? 0 : _v$cy,
          _v$r = v.r,
          r = _v$r === void 0 ? 0 : _v$r,
          collider = v.collider;
      var opts = extend({
        type: 'circle',
        cx: cx,
        cy: cy,
        r: r
      }, collider);

      _get(_getPrototypeOf(Circle.prototype), "set", this).call(this, v);

      this.attrs.cx = cx;
      this.attrs.cy = cy;
      this.attrs.r = r;
      this.collider = opts;
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle
      // Current solution only rotate the bounds, giving a larger boundingRect if rotated


      var p = this.bounds(includeTransform);
      this.__boundingRect[includeTransform] = {
        x: p[0].x,
        y: p[0].y,
        width: p[2].x - p[0].x,
        height: p[2].y - p[0].y
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      } // TODO Handle Circle bounds correctly for a circle transformed to an non axis aligned ellipse/circle


      var _this$attrs = this.attrs,
          cx = _this$attrs.cx,
          cy = _this$attrs.cy,
          rX = _this$attrs.r,
          rY = _this$attrs.r;
      var x = cx - rX;
      var y = cy - rY;
      var w = rX * 2;
      var h = rY * 2;
      var p = [{
        x: x,
        y: y
      }, {
        x: x + w,
        y: y
      }, {
        x: x + w,
        y: y + h
      }, {
        x: x,
        y: y + h
      }];

      if (includeTransform && this.modelViewMatrix) {
        p = this.modelViewMatrix.transformPoints(p);

        var _getMinMax = getMinMax(p),
            _getMinMax2 = _slicedToArray(_getMinMax, 4),
            xMin = _getMinMax2[0],
            yMin = _getMinMax2[1],
            xMax = _getMinMax2[2],
            yMax = _getMinMax2[3];

        w = xMax - xMin;
        h = yMax - yMin;
        this.__bounds[includeTransform] = [{
          x: xMin,
          y: yMin
        }, {
          x: xMin + w,
          y: yMin
        }, {
          x: xMin + w,
          y: yMin + h
        }, {
          x: xMin,
          y: yMin + h
        }];
      } else {
        this.__bounds[includeTransform] = p;
      }

      return this.__bounds[includeTransform];
    }
  }]);

  return Circle;
}(DisplayObject);
function create$i() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Circle, s);
}

/**
 * @extends node-def
 * @typedef {object} node--line-def
 * @property {number} x1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX1Attribute}
 * @property {number} y1 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY1Attribute}
 * @property {number} x2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementX2Attribute}
 * @property {number} y2 - {@link https://www.w3.org/TR/SVG/shapes.html#LineElementY2Attribute}
 */

var Line =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Line, _DisplayObject);

  function Line() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Line);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, 'line'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Line, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x1,
          x1 = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y1,
          y1 = _v$y === void 0 ? 0 : _v$y,
          _v$x2 = v.x2,
          x2 = _v$x2 === void 0 ? 0 : _v$x2,
          _v$y2 = v.y2,
          y2 = _v$y2 === void 0 ? 0 : _v$y2,
          collider = v.collider;

      _get(_getPrototypeOf(Line.prototype), "set", this).call(this, v);

      this.attrs.x1 = x1;
      this.attrs.y1 = y1;
      this.attrs.x2 = x2;
      this.attrs.y2 = y2;
      var defaultCollider = {
        type: 'line',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      };
      this.collider = extend(defaultCollider, collider);
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var p = lineToPoints(this.attrs);

      if (includeTransform && this.modelViewMatrix) {
        p = this.modelViewMatrix.transformPoints(p);
      }

      var _getMinMax = getMinMax(p),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      var hasSize = xMin !== xMax || yMin !== yMax;
      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: hasSize ? Math.max(1, xMax - xMin) : 0,
        height: hasSize ? Math.max(1, yMax - yMin) : 0
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Line;
}(DisplayObject);
function create$j() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Line, s);
}

var PI_2 = Math.PI / 2;

function lineAngle(p0, p1) {
  var t = Math.atan2(p1.y - p0.y, p1.x - p0.x);
  return t < 0 ? t + Math.PI * 2 : t;
} // TODO Find a more accurate method to find the open and closed points


function rotatePoint$1(p, angle, radius) {
  return {
    x: p.x + Math.cos(angle) * radius,
    y: p.y + Math.sin(angle) * radius
  };
}

function polylineToPolygonCollider(points, radius) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var open = [];
  var close = []; // TODO handle case if points.length === 2

  if (opts.forceOrientation === 'h') {
    var start = points[0].x < points[1].x ? -1 : 1;
    var end = points[points.length - 1].x > points[points.length - 2].x ? 1 : -1;
    points.unshift({
      x: points[0].x + start,
      y: points[0].y
    });
    points.push({
      x: points[points.length - 1].x + end,
      y: points[points.length - 1].y
    });
  } else if (opts.forceOrientation === 'v') {
    var _start = points[0].y < points[1].y ? -1 : 1;

    var _end = points[points.length - 1].y > points[points.length - 2].y ? 1 : -1;

    points.unshift({
      x: points[0].x,
      y: points[0].y + _start
    });
    points.push({
      x: points[points.length - 1].x,
      y: points[points.length - 1].y + _end
    });
  }

  var len = points.length - 1;

  for (var i = 1; i < len; i++) {
    var prev = points[i - 1];
    var curr = points[i];
    var next = points[i + 1];
    var currToPrev = lineAngle(curr, prev);
    var currToNext = lineAngle(curr, next);
    var openAngle = (currToPrev + currToNext) / 2;
    var closeAngle = openAngle + Math.PI;
    var maxAngle = Math.max(openAngle, closeAngle);
    var minAngle = Math.min(openAngle, closeAngle);
    var openClose = currToPrev > currToNext;

    if (i === 1) {
      var prevToCurr = lineAngle(prev, curr);
      open.push(rotatePoint$1(prev, prevToCurr - PI_2, radius));
      close.unshift(rotatePoint$1(prev, prevToCurr + PI_2, radius));
    }

    var opened = openClose ? maxAngle : minAngle;
    var closed = openClose ? minAngle : maxAngle;
    open.push(rotatePoint$1(curr, opened, radius));
    close.unshift(rotatePoint$1(curr, closed, radius));

    if (i === len - 1) {
      var nextToCurr = lineAngle(next, curr);
      open.push(rotatePoint$1(next, nextToCurr + PI_2, radius));
      close.unshift(rotatePoint$1(next, nextToCurr - PI_2, radius));
    }
  }

  return {
    type: 'polygon',
    vertices: [].concat(open, close)
  };
}

function flatten2d(ary) {
  var newAry = [];
  var a;
  var len = ary.length;

  for (var i = 0; i < len; i++) {
    a = ary[i];

    for (var k = 0; k < a.length; k++) {
      newAry.push(a[k]);
    }
  }

  return newAry;
}

var EPSILON$2 = 1e-12;
/**
 * @extends node-def
 * @typedef {object} node--path-def
 * @property {string} d - {@link https://www.w3.org/TR/SVG/paths.html#DAttribute}
 */

function isClosed(points) {
  if (points.length < 2) {
    return false;
  }

  var p0 = points[0];
  var p1 = points[points.length - 1];
  return Math.abs(p0.x - p1.x) < EPSILON$2 && Math.abs(p0.y - p1.y) < EPSILON$2;
}

var Path$1 =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Path, _DisplayObject);

  function Path() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Path);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, 'path'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Path, [{
    key: "set",
    value: function set() {
      var _this3 = this;

      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _get(_getPrototypeOf(Path.prototype), "set", this).call(this, v);

      this.segments = [];
      this.points = [];
      this.attrs.d = v.d;

      if (Array.isArray(v.collider) || picasso_esm_typeof(v.collider) === 'object' && typeof v.collider.type !== 'undefined') {
        this.collider = v.collider;
      } else if (v.d) {
        this.segments = pathToPoints(v.d);
        this.segments.forEach(function (segment) {
          if (segment.length <= 1) ; else if (isClosed(segment)) {
            _this3.collider = extend({
              type: 'polygon',
              vertices: segment
            }, v.collider);
          } else if (picasso_esm_typeof(v.collider) === 'object' && v.collider.visual) {
            var size = _this3.attrs['stroke-width'] / 2;
            _this3.collider = polylineToPolygonCollider(segment, size, v.collider);
          } else {
            _this3.collider = extend({
              type: 'polyline',
              points: segment
            }, v.collider);
          }
        });
      }

      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      if (!this.points.length) {
        this.segments = this.segments.length ? this.segments : pathToPoints(this.attrs.d);
        this.points = flatten2d(this.segments);
      }

      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(this.points) : this.points;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin || 0,
        y: yMin || 0,
        width: xMax - xMin || 0,
        height: yMax - yMin || 0
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Path;
}(DisplayObject);
function create$k() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Path$1, s);
}

function hasData(_ref) {
  var data = _ref.data,
      _boundingRect = _ref._boundingRect,
      _textBoundsFn = _ref._textBoundsFn;
  return typeof data !== 'undefined' && data !== null && (_boundingRect || _textBoundsFn);
}
/**
 * @extends node-def
 * @typedef {object} node--text-def
 * @property {string} text
 * @property {number} x - {@link https://www.w3.org/TR/SVG/text.html#TextElementXAttribute}
 * @property {number} y - {@link https://www.w3.org/TR/SVG/text.html#TextElementYAttribute}
 * @property {number} [dx] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDXAttribute}
 * @property {number} [dy] - {@link https://www.w3.org/TR/SVG/text.html#TextElementDYAttribute}
 * @property {string} [fontSize] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
 * @property {string} [fontFamily] - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
 * @property {rect} [boundingRect] - Explicitly set the bounding rectangle of the node. Has predence over textBoundsFn
 * @property {function} [textBoundsFn] - Implicitly set the bounding rectangle of the node, the function must return an object with x, y, width and height attributes
 * @property {string} [baseline] - Alias for dominantBaseline
 * @property {string} [dominantBaseline] - {@link https://www.w3.org/TR/SVG/text.html#BaselineAlignmentProperties}
 * @property {string} [anchor] - Alias for textAnchor
 * @property {string} [textAnchor] - {@link https://www.w3.org/TR/SVG/text.html#TextAnchorProperty}
 * @property {string} [wordBreak] - Word-break option
 * @property {number} [maxWidth] - Maximum allowed text width
 * @property {number} [maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
 * @property {number} [maxLines] - Maximum number of lines allowed
 * @property {number} [lineHeight=1.2] - Line height
 */


var Text =
/*#__PURE__*/
function (_DisplayObject) {
  _inherits(Text, _DisplayObject);

  function Text() {
    var _this2;

    var _this;

    _classCallCheck$1(this, Text);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, 'text'));

    (_this2 = _this).set.apply(_this2, arguments);

    return _this;
  }

  _createClass$1(Text, [{
    key: "set",
    value: function set() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _v$x = v.x,
          x = _v$x === void 0 ? 0 : _v$x,
          _v$y = v.y,
          y = _v$y === void 0 ? 0 : _v$y,
          _v$dx = v.dx,
          dx = _v$dx === void 0 ? 0 : _v$dx,
          _v$dy = v.dy,
          dy = _v$dy === void 0 ? 0 : _v$dy,
          textBoundsFn = v.textBoundsFn,
          text = v.text,
          title = v.title,
          collider = v.collider,
          boundingRect = v.boundingRect;

      _get(_getPrototypeOf(Text.prototype), "set", this).call(this, v);

      this.attrs.x = x;
      this.attrs.y = y;
      this.attrs.dx = dx;
      this.attrs.dy = dy;
      this.attrs.text = text;

      if (typeof title !== 'undefined') {
        this.attrs.title = String(title);
      }

      if (picasso_esm_typeof(boundingRect) === 'object') {
        this._textBoundsFn = function () {
          return boundingRect;
        };
      } else if (typeof textBoundsFn === 'function') {
        this._textBoundsFn = textBoundsFn;
      }

      this.collider = extend({
        type: hasData(this) ? 'bounds' : null
      }, collider);
      this.__boundingRect = {
        true: null,
        false: null
      };
      this.__bounds = {
        true: null,
        false: null
      };
    }
  }, {
    key: "boundingRect",
    value: function boundingRect() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__boundingRect[includeTransform] !== null) {
        return this.__boundingRect[includeTransform];
      }

      var rect;

      if (typeof this._textBoundsFn === 'function') {
        rect = this._textBoundsFn(this.attrs);
      } else {
        return {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      var p = rectToPoints(rect);
      var pt = includeTransform && this.modelViewMatrix ? this.modelViewMatrix.transformPoints(p) : p;

      var _getMinMax = getMinMax(pt),
          _getMinMax2 = _slicedToArray(_getMinMax, 4),
          xMin = _getMinMax2[0],
          yMin = _getMinMax2[1],
          xMax = _getMinMax2[2],
          yMax = _getMinMax2[3];

      this.__boundingRect[includeTransform] = {
        x: xMin,
        y: yMin,
        width: xMax - xMin,
        height: yMax - yMin
      };
      return this.__boundingRect[includeTransform];
    }
  }, {
    key: "bounds",
    value: function bounds() {
      var includeTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.__bounds[includeTransform] !== null) {
        return this.__bounds[includeTransform];
      }

      var rect = this.boundingRect(includeTransform);
      this.__bounds[includeTransform] = [{
        x: rect.x,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y
      }, {
        x: rect.x + rect.width,
        y: rect.y + rect.height
      }, {
        x: rect.x,
        y: rect.y + rect.height
      }];
      return this.__bounds[includeTransform];
    }
  }]);

  return Text;
}(DisplayObject);
function create$l() {
  for (var _len = arguments.length, s = new Array(_len), _key = 0; _key < _len; _key++) {
    s[_key] = arguments[_key];
  }

  return _construct(Text, s);
}

var reg$4 = registryFactory();
reg$4.add('rect', create$h);
reg$4.add('circle', create$i);
reg$4.add('text', create$l);
reg$4.add('line', create$j);
reg$4.add('path', create$k);
reg$4.add('stage', create$e);
reg$4.add('container', create$d);
reg$4.add('defs', create$d);
reg$4.add('linearGradient', create$f);
reg$4.add('radialGradient', create$f);
reg$4.add('stop', create$f);
reg$4.add('pattern', create$g);
function create$m(type, input) {
  // eslint-disable-line import/prefer-default-export
  return reg$4.get(type)(input);
}

/**
 * Creates a context. Input an array of strings that should be inherited by the context.
 * @private
 *
 * @param  {Array}  [whitelist=[]]  An array of whitelisted string keys to inherit
 * @return {Function}               A context function
 */

function contextFactory() {
  var whitelist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var states = [{}];
  /**
   * Returns the current context as an object. The object is mutable.
   * @private
   *
   * @return {Object}   Current context
   */

  function context() {
    // Returns the current context, the last in the stack.
    var item = states[states.length - 1];
    return item;
  }
  /**
   * Call context.save() to save the current context and move down the stack.
   *
   * @param  {Object} [item={}]   Optional item to save.
   * @return {Object}             The current context, just as context()
   */


  context.save = function save() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var current = context();
    var obj = {};
    var key = ''; // Only inherit whitelisted properties

    for (var i = 0; i < whitelist.length; i++) {
      key = whitelist[i];

      if (typeof current[key] !== 'undefined') {
        obj[key] = current[key];
      }
    } // Extend the new object with the saved item


    extend(obj, item); // Push it to the stack

    states.push(obj); // Return the new current context

    return context();
  };
  /**
   * Restore the previous context. Returns the context.
   *
   * @return {Undefined}   Returns nothing
   */


  context.restore = function restore() {
    // Remove the last element from the stack
    states.splice(states.length - 1, 1);
  };

  return context;
}

var styleContext = contextFactory(['stroke', 'fill', 'strokeWidth', 'opacity', 'fontFamily', 'fontSize', 'baseline']);

function doEvent(state, listeners) {
  if (!Array.isArray(listeners)) {
    return;
  }

  for (var i = 0, len = listeners.length; i < len; i++) {
    listeners[i](state);
  }
}

function updateState(state, index, nodes) {
  state.node = nodes[index];
  state.index = index;
}

function traverse(items, parent, matrix, on) {
  var disabled = false;
  var state = {
    siblings: items,
    node: null,
    index: 0
  };

  for (var i = 0, len = items.length; i < len; i++) {
    updateState(state, i, items);
    doEvent(state, on.create);
    disabled = typeof state.node.disabled === 'function' ? state.node.disabled() : state.node.disabled;

    if (disabled) {
      continue;
    } // Save the current style context to be able to inherit styles


    state.node = styleContext.save(state.node);
    var displayNode = create$m(state.node.type, state.node);

    if (displayNode) {
      if (state.node.transform) {
        matrix.save();
        resolveTransform(state.node.transform, matrix);
      }

      if (!matrix.isIdentity()) {
        displayNode.modelViewMatrix = matrix.clone();
      }

      parent.addChild(displayNode);

      if (state.node.children) {
        traverse(state.node.children, displayNode, matrix, on);
      }

      if (state.node.transform) {
        matrix.restore();
      }
    } // Revert to previous style context


    styleContext.restore();
  }
}

function scene(_ref) {
  var items = _ref.items,
      stage = _ref.stage,
      dpi = _ref.dpi,
      _ref$on = _ref.on,
      on = _ref$on === void 0 ? {} : _ref$on;

  if (!stage) {
    stage = create$m('stage', dpi);
  }

  traverse(items, stage, new Matrix(), on);
  return stage;
}

var LINEBREAK_REGEX = /\n+|\r+|\r\n/;
var WHITESPACE_REGEX = /\s/;
var HYPHEN_REGEX = /[a-zA-Z\u00C0-\u00F6\u00F8-\u00FF\u00AD]/;
var NO_BREAK = 0;
var MANDATORY = 1;
var BREAK_ALLOWED = 2;
function includesLineBreak(c) {
  if (typeof c === 'string') {
    return c.search(LINEBREAK_REGEX) !== -1;
  }

  return String(c).search(LINEBREAK_REGEX) !== -1;
}

function includesWhiteSpace(c) {
  return c.search(WHITESPACE_REGEX) !== -1;
}

function hyphenationAllowed(c) {
  /* Latin character set. Excluding numbers, sign and symbol characters, but including soft hyphen */
  return c.search(HYPHEN_REGEX) !== -1;
}

function resolveBreakOpportunity(chunk, i, chunks, mandatory, noBreakAllowed) {
  if (mandatory.some(function (fn) {
    return fn(chunk, i, chunks);
  })) {
    return MANDATORY;
  }

  if (noBreakAllowed.some(function (fn) {
    return fn(chunk, i, chunks);
  })) {
    return NO_BREAK;
  }

  return BREAK_ALLOWED;
}

function cleanEmptyChunks(chunks) {
  if (chunks[0] === '') {
    chunks.shift();
  }

  if (chunks[chunks.length - 1] === '') {
    chunks.pop();
  }
}

function clamp$1(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

function stringTokenizer() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      string = _ref.string,
      _ref$separator = _ref.separator,
      separator = _ref$separator === void 0 ? '' : _ref$separator,
      _ref$reverse = _ref.reverse,
      reverse = _ref$reverse === void 0 ? false : _ref$reverse,
      _ref$measureText = _ref.measureText,
      measureText = _ref$measureText === void 0 ? function (text) {
    return {
      width: text.length,
      height: 1
    };
  } : _ref$measureText,
      _ref$mandatoryBreakId = _ref.mandatoryBreakIdentifiers,
      mandatoryBreakIdentifiers = _ref$mandatoryBreakId === void 0 ? [includesLineBreak] : _ref$mandatoryBreakId,
      _ref$noBreakAllowedId = _ref.noBreakAllowedIdentifiers,
      noBreakAllowedIdentifiers = _ref$noBreakAllowedId === void 0 ? [] : _ref$noBreakAllowedId,
      _ref$suppressIdentifi = _ref.suppressIdentifier,
      suppressIdentifier = _ref$suppressIdentifi === void 0 ? [includesWhiteSpace, includesLineBreak, function (chunk) {
    return chunk === '';
  }] : _ref$suppressIdentifi,
      _ref$hyphenationIdent = _ref.hyphenationIdentifiers,
      hyphenationIdentifiers = _ref$hyphenationIdent === void 0 ? [hyphenationAllowed] : _ref$hyphenationIdent;

  var chunks = String(string).split(separator);
  cleanEmptyChunks(chunks);
  var length = chunks.length;
  var isNotDone = reverse ? function (p) {
    return p >= 0;
  } : function (p) {
    return p < length;
  };
  var position = reverse ? length : -1; // Set init position 1 step before or after to make first next call go to first position

  function peek(peekAt) {
    var i = clamp$1(peekAt, 0, length - 1);
    var chunk = chunks[i];
    var textMeasure = measureText(chunk);
    var opportunity = resolveBreakOpportunity(chunk, i, chunks, mandatoryBreakIdentifiers, noBreakAllowedIdentifiers);
    return {
      index: i,
      value: chunk,
      breakOpportunity: opportunity,
      suppress: suppressIdentifier.some(function (fn) {
        return fn(chunk, i, chunks);
      }),
      hyphenation: hyphenationIdentifiers.some(function (fn) {
        return fn(chunk, i, chunks);
      }),
      width: textMeasure.width,
      height: textMeasure.height,
      done: false
    };
  }

  function next(jumpToPosition) {
    if (isNaN(jumpToPosition)) {
      if (reverse) {
        position--;
      } else {
        position++;
      }
    } else {
      position = clamp$1(jumpToPosition, 0, length - 1);
    }

    if (isNotDone(position)) {
      return peek(position);
    }

    return {
      done: true
    };
  }

  return {
    next: next,
    peek: peek,
    length: length
  };
}

var HYPHENS_CHAR = "\u2010";
var ELLIPSIS_CHAR = '…';

var BASE = 24;
var PAD = 4;
var BUMP = 1e-12;
var DEFAULT_FONT_HEIGHT = 16;
var DEFAULT_LINE_HEIGHT = 1.2;
var TEXT_REGEX = /^\s*\d+(\.\d+)?px\s*$/i;

function isValidFontSize(val) {
  var type = picasso_esm_typeof(val);

  if (type === 'string') {
    return TEXT_REGEX.test(val);
  }

  return false;
}

function fontSizeToHeight(fontSize) {
  if (isValidFontSize(fontSize)) {
    var size = parseFloat(fontSize);
    var m = PAD * Math.ceil((size + BUMP) / BASE);
    return size + m;
  }

  return DEFAULT_FONT_HEIGHT;
}
function fontSizeToLineHeight(node) {
  var fontSize = node['font-size'] || node.fontSize;

  if (isValidFontSize(fontSize)) {
    return parseFloat(fontSize) * Math.max(isNaN(node.lineHeight) ? DEFAULT_LINE_HEIGHT : node.lineHeight, 0);
  }

  return DEFAULT_FONT_HEIGHT * DEFAULT_LINE_HEIGHT;
}

function resolveMaxAllowedLines(node) {
  var maxHeight = node.maxHeight;
  var maxLines = Math.max(node.maxLines, 1) || Infinity;

  if (isNaN(maxHeight)) {
    return maxLines;
  }

  var computedLineHeight = fontSizeToLineHeight(node);
  return Math.max(1, Math.min(Math.floor(maxHeight / computedLineHeight), maxLines));
}

function initState$1(node, measureText) {
  return {
    lines: [],
    line: '',
    width: 0,
    maxLines: resolveMaxAllowedLines(node),
    maxWidth: node.maxWidth,
    hyphens: {
      enabled: node.hyphens === 'auto',
      char: HYPHENS_CHAR,
      metrics: measureText(HYPHENS_CHAR)
    }
  };
}

function newLine(state) {
  state.lines.push(state.line);
  state.line = '';
  state.width = 0;
}

function appendToLine(state, token) {
  state.line += token.value;
  state.width += token.width;
}

function insertHyphenAndJump(state, token, iterator) {
  if (token.width > state.maxWidth) {
    return token;
  }

  var startIndex = token.index;

  for (var i = 1; i < 5; i++) {
    var pairToken = iterator.peek(token.index - 1);

    if (!token.hyphenation || !pairToken.hyphenation || token.index === 0) {
      return token;
    }

    if (state.width + state.hyphens.metrics.width <= state.maxWidth) {
      state.line += state.hyphens.char;
      return token;
    }

    if (state.line.length === 1) {
      return token;
    }

    token = iterator.next(startIndex - i);
    state.line = state.line.slice(0, -1);
    state.width -= token.width;
  }

  return token;
}

function breakSequence(state, token, measureText) {
  var charTokenIterator = stringTokenizer({
    string: token.value,
    measureText: measureText
  });

  while (state.lines.length < state.maxLines) {
    var charToken = charTokenIterator.next();

    if (charToken.done) {
      break;
    } else if (state.width + charToken.width > state.maxWidth && charToken.breakOpportunity === BREAK_ALLOWED && state.line.length > 0) {
      charToken = state.hyphens.enabled ? insertHyphenAndJump(state, charToken, charTokenIterator) : charToken;
      newLine(state);
      appendToLine(state, charToken);
    } else {
      appendToLine(state, charToken);
    }
  }
}

function breakAll(node, measureText) {
  var text = node.text;
  var iterator = stringTokenizer({
    string: text,
    separator: '',
    measureText: measureText,
    noBreakAllowedIdentifiers: [function (chunk, i) {
      return i === 0;
    }]
  });
  var state = initState$1(node, measureText);
  var reduced = true;

  while (state.lines.length < state.maxLines) {
    var token = iterator.next();

    if (token.done) {
      newLine(state);
      reduced = false;
      break;
    } else if (token.breakOpportunity === MANDATORY) {
      newLine(state);
    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {
      if (token.suppress) {
        // Token is suppressable and can be ignored
        state.width += token.width;
      } else {
        token = state.hyphens.enabled ? insertHyphenAndJump(state, token, iterator) : token;
        newLine(state);
        appendToLine(state, token);
      }
    } else {
      appendToLine(state, token);
    }
  }

  return {
    lines: state.lines,
    reduced: reduced
  };
}
function breakWord(node, measureText) {
  var text = node.text;
  var iterator = stringTokenizer({
    string: text,
    separator: /(\s|-|\u2010)/,
    measureText: measureText
  });
  var state = initState$1(node, measureText);
  var reduced = true;

  while (state.lines.length < state.maxLines) {
    var token = iterator.next();

    if (token.done) {
      newLine(state);
      reduced = false;
      break;
    } else if (token.breakOpportunity === MANDATORY) {
      newLine(state);
    } else if (state.width + token.width > state.maxWidth && token.breakOpportunity === BREAK_ALLOWED) {
      if (token.suppress) {
        // Token is suppressable and can be ignored
        newLine(state);
      } else if (token.width > state.maxWidth) {
        // Single sequence is wider then maxWidth, break sequence into multiple lines
        breakSequence(state, token, measureText);
      } else {
        newLine(state);
        appendToLine(state, token);
      }
    } else {
      appendToLine(state, token);
    }
  }

  return {
    lines: state.lines,
    reduced: reduced
  };
}

function generateLineNodes(result, item, halfLead, height) {
  var container = {
    type: 'container',
    children: []
  };

  if (typeof item.id !== 'undefined') {
    // TODO also inherit data attribute and more?
    container.id = item.id;
  }

  var currentY = 0;
  result.lines.forEach(function (line, i) {
    var node = extend({}, item);
    node.text = line;
    node._lineBreak = true; // Flag node as processed to avoid duplicate linebreak run

    currentY += halfLead; // leading height above

    if (result.reduced && i === result.lines.length - 1) {
      node.text += ELLIPSIS_CHAR;
    } else {
      delete node.maxWidth;
    }

    node.dy = isNaN(node.dy) ? currentY : node.dy + currentY;
    currentY += height;
    currentY += halfLead; // Leading height below

    container.children.push(node);
  });
  return container;
}

function shouldLineBreak(item) {
  // If type text and not already broken into lines
  return item.type === 'text' && !item._lineBreak;
}

function wrappedMeasureText(node, measureText) {
  return function (text) {
    return measureText({
      text: text,
      fontSize: node.fontSize,
      fontFamily: node.fontFamily
    });
  };
}

function resolveLineBreakAlgorithm(node) {
  var WORDBREAK = {
    'break-all': breakAll,
    'break-word': breakWord
  };
  return WORDBREAK[node.wordBreak];
}
/**
 * Apply wordBreak rules to text nodes.
 * @ignore
 * @param {function} measureText
 * @returns {function} Event function to convert a text node into multiple nodes
 */

function onLineBreak(measureText) {
  return function (state) {
    var item = state.node;

    if (shouldLineBreak(item)) {
      var wordBreakFn = resolveLineBreakAlgorithm(item);

      if (!wordBreakFn) {
        return;
      }

      var tm = measureText(item);

      if (tm.width > item.maxWidth || includesLineBreak(item.text)) {
        var diff = fontSizeToLineHeight(item) - tm.height;
        var halfLead = diff / 2;
        var result = wordBreakFn(item, wrappedMeasureText(item, measureText));
        state.node = generateLineNodes(result, item, halfLead, tm.height); // Convert node to container
      }
    }
  };
}

function ellipsText(_ref, measureText) {
  var text = _ref.text,
      fontSize = _ref['font-size'],
      fontFamily = _ref['font-family'],
      maxWidth = _ref.maxWidth;
  // eslint-disable-line import/prefer-default-export
  text = typeof text === 'string' ? text : "".concat(text);

  if (maxWidth === undefined) {
    return text;
  }

  var textWidth = measureText({
    text: text,
    fontSize: fontSize,
    fontFamily: fontFamily
  }).width;

  if (textWidth <= maxWidth) {
    return text;
  }

  var min = 0;
  var max = text.length - 1;

  while (min <= max) {
    var reduceIndex = Math.floor((min + max) / 2);
    var reduceText = text.substr(0, reduceIndex) + ELLIPSIS_CHAR;
    textWidth = measureText({
      text: reduceText,
      fontSize: fontSize,
      fontFamily: fontFamily
    }).width;

    if (textWidth <= maxWidth) {
      min = reduceIndex + 1;
    } else {
      // textWidth > maxWidth
      max = reduceIndex - 1;
    }
  }

  return text.substr(0, max) + ELLIPSIS_CHAR;
}

/**
 * Currently some browsers, IE11 and Edge confirmed, doesn't support the dominant-baseline svg-attribute and
 * the browser that does, have different implementations. Thus giving an unpredictable result when rendering'
 * text and predicting it's position (ex. in collision detection).
 *
 * To supplement and the aid in aligning/positioning text with various items, this function can be used
 * to follow a common heuristic across supported renderers.
 * @ignore
 * @param {object} textNode
 * @param {string|number} [textNode['font-size']=0] - String in px format or number
 * @param {string} [textNode['dominant-baseline']] - If baseline is omitted dominant-baseline is used
 * @param {string} [textNode.baseline]
 * @returns {number} Delta-y required to adjust for baseline
 */
function baselineHeuristic(textNode) {
  var baseline = textNode.baseline || textNode['dominant-baseline'];
  var dy = 0;
  var fontSize = parseInt(textNode.fontSize || textNode['font-size'], 10) || 0;

  switch (baseline) {
    case 'hanging':
      dy = fontSize * 0.75;
      break;

    case 'text-before-edge':
      dy = fontSize * 0.85;
      break;

    case 'middle':
      dy = fontSize * 0.25;
      break;

    case 'central':
      dy = fontSize * 0.35;
      break;

    case 'mathemetical':
      dy = fontSize / 2;
      break;

    case 'text-after-edge':
    case 'ideographic':
      dy = -fontSize * 0.2;
      break;

    default:
      dy = 0;
      break;
  }

  return dy;
}

var heightCache = {};
var widthCache = {};
var contextCache = {
  fontSize: undefined,
  fontFamily: undefined
};
var context;

function setContext() {
  context = context || document.createElement('canvas').getContext('2d');
}

function setFont(fontSize, fontFamily) {
  if (contextCache.fontSize === fontSize && contextCache.fontFamily === fontFamily) {
    return;
  }

  context.font = fontSize + ' ' + fontFamily; // eslint-disable-line

  contextCache.fontSize = fontSize;
  contextCache.fontFamily = fontFamily;
}

function measureTextWidth(text, fontSize, fontFamily) {
  var key = text + fontSize + fontFamily;

  if (typeof widthCache[key] !== 'number') {
    setContext();
    setFont(fontSize, fontFamily);
    widthCache[key] = context.measureText(text).width;
  }

  return widthCache[key];
}

function measureTextHeight(fontSize) {
  if (typeof heightCache[fontSize] !== 'number') {
    heightCache[fontSize] = fontSizeToHeight(fontSize);
  }

  return heightCache[fontSize];
}
/**
 * @private
 * @param {object} opts
 * @param {string} opts.text - Text to measure
 * @param {string} opts.fontSize - Font size with a unit definition, ex. 'px' or 'em'
 * @param {string} opts.fontFamily - Font family
 * @return {object} Width and height of text in pixels
 * @example
 * measureText({
 *  text: 'my text',
 *  fontSize: '12px',
 *  fontFamily: 'Arial'
 * }); // returns { width: 20, height: 12 }
 */


function measureText(_ref) {
  var text = _ref.text,
      fontSize = _ref.fontSize,
      fontFamily = _ref.fontFamily;
  var w = measureTextWidth(text, fontSize, fontFamily);
  var h = measureTextHeight(fontSize);
  return {
    width: w,
    height: h
  };
}
/**
 * Calculates the bounding rectangle of a text node.
 * The bounding rectangle is a approximate of the "em square" seen here (http://www.w3resource.com/html5-canvas/html5-canvas-text.php)
 * @ignore
 * @param {object} attrs - Text node definition
 * @param {number} [attrs.x] - X-coordinate
 * @param {number} [attrs.y] - Y-coordinate
 * @param {number} [attrs.dx] - Delta x-coordinate
 * @param {number} [attrs.dy] - Delta y-coordinate
 * @param {string} [attrs.anchor] - Text anchor
 * @param {number} [attrs.maxWidth] - Maximum allowed text width
 * @return {object} The bounding rectangle
 */

function calcTextBounds(attrs) {
  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText;
  var fontSize = attrs['font-size'] || attrs.fontSize;
  var fontFamily = attrs['font-family'] || attrs.fontFamily;
  var textMeasure = measureFn({
    text: attrs.text,
    fontFamily: fontFamily,
    fontSize: fontSize
  });
  var calWidth = Math.min(attrs.maxWidth || textMeasure.width, textMeasure.width); // Use actual value if max is not set

  var x = attrs.x || 0;
  var y = attrs.y || 0;
  var dx = attrs.dx || 0;
  var dy = (attrs.dy || 0) + baselineHeuristic(attrs);
  var boundingRect = {
    x: 0,
    y: y + dy - textMeasure.height * 0.75,
    // Magic number for alphabetical baseline
    width: calWidth,
    height: textMeasure.height
  };
  var anchor = attrs['text-anchor'] || attrs.anchor;

  if (anchor === 'middle') {
    boundingRect.x = x + dx - calWidth / 2;
  } else if (anchor === 'end') {
    boundingRect.x = x + dx - calWidth;
  } else {
    boundingRect.x = x + dx;
  }

  return boundingRect;
}
/**
 * Calculates the bounding rectangle of a text node. Including any line breaks.
 * @ignore
 * @param {object} node
 * @param {string} node.text - Text to measure
 * @param {number} [node.x=0] - X-coordinate
 * @param {number} [node.y=0] - Y-coordinate
 * @param {number} [node.dx=0] - Delta x-coordinate
 * @param {number} [node.dy=0] - Delta y-coordinate
 * @param {string} [node.anchor='start'] - Text anchor
 * @param {string} [node.fontSize] - Font size
 * @param {string} [node.fontFamily] - Font family
 * @param {string} [node['font-size']] - Font size
 * @param {string} [node['font-family']] - Font family
 * @param {string} [node.wordBreak] - Word-break option
 * @param {number} [node.maxWidth] - Maximum allowed text width
 * @param {number} [node.maxHeight] - Maximum allowed text height. If both maxLines and maxHeight are set, the property that results in the fewest number of lines is used
 * @param {number} [node.maxLines] - Maximum number of lines allowed.
 * @param {number} [node.lineHeight=1.2] - Line height
 * @param {function} [measureFn] - Optional text measure function
 * @return {object} The bounding rectangle
 */


function textBounds(node) {
  var measureFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : measureText;
  var lineBreakFn = resolveLineBreakAlgorithm(node);
  var fontSize = node['font-size'] || node.fontSize;
  var fontFamily = node['font-family'] || node.fontFamily;
  var tm = measureFn({
    text: node.text,
    fontFamily: fontFamily,
    fontSize: fontSize
  });

  if (lineBreakFn && (tm.width > node.maxWidth || includesLineBreak(node.text))) {
    var resolvedLineBreaks = lineBreakFn(node, function (text) {
      return measureFn({
        text: text,
        fontFamily: fontFamily,
        fontSize: fontSize
      });
    });
    var nodeCopy = extend({}, node);
    var maxWidth = 0;
    var widestLine = '';

    for (var i = 0, len = resolvedLineBreaks.lines.length; i < len; i++) {
      var line = resolvedLineBreaks.lines[i];
      line += i === len - 1 && resolvedLineBreaks.reduced ? ELLIPSIS_CHAR : '';
      var width = measureFn({
        text: line,
        fontSize: fontSize,
        fontFamily: fontFamily
      }).width;

      if (width >= maxWidth) {
        maxWidth = width;
        widestLine = line;
      }
    }

    nodeCopy.text = widestLine;
    var bounds = calcTextBounds(nodeCopy, measureFn);
    bounds.height = fontSizeToLineHeight(node) * resolvedLineBreaks.lines.length;
    return bounds;
  }

  return calcTextBounds(node, measureFn);
}

/**
 * Get or create a gradient
 * @ignore
 * @param  {Object} g        Canvas 2d context
 * @param  {Object} node    Current node (for width/height properties)
 * @param  {Object} gradient The gradient properties
 * @return {Object}          A canvas compatible radial or linear gradient object
 */

function createCanvasGradient(g, node, gradient) {
  var orientation = gradient.orientation,
      degree = gradient.degree,
      _gradient$stops = gradient.stops,
      stops = _gradient$stops === void 0 ? [] : _gradient$stops;
  var newGradient = null;

  if (orientation === 'radial') {
    var bounds = node.boundingRect();
    newGradient = g.createRadialGradient(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, 1e-5, bounds.x + bounds.width / 2, bounds.y + bounds.height / 2, Math.max(bounds.width, bounds.height) / 2);
  } else {
    var points = degreesToPoints(degree);

    var _bounds = node.boundingRect();

    newGradient = g.createLinearGradient(_bounds.x + points.x1 * _bounds.width, _bounds.y + points.y1 * _bounds.height, _bounds.x + points.x2 * _bounds.width, _bounds.y + points.y2 * _bounds.height);
  }

  for (var i = 0, len = stops.length; i < len; i++) {
    var stop = stops[i];
    newGradient.addColorStop(stop.offset, stop.color);
  }

  return newGradient;
}

function getPattern(pattern, dummyCanvas, ctx) {
  dummyCanvas.width = pattern.width;
  dummyCanvas.height = pattern.height;
  ctx.save();
  ctx.fillStyle = pattern.fill;
  pattern.shapes.forEach(function (s) {
    switch (s.type) {
      case 'rect':
        ctx.rect(s.x, s.y, s.width, s.height);
        break;

      default:
        break;
    }
  });
  ctx.fill();
  ctx.restore();
  return ctx.createPattern(dummyCanvas, 'repeat');
}

function patternizer(document) {
  var dummyCanvas = document.createElement('canvas');
  var ctx = dummyCanvas.getContext('2d');
  var cache = {};
  return {
    create: function create(pattern) {
      var key = pattern.key;

      if (key) {
        cache[key] = cache[key] || getPattern(pattern, dummyCanvas, ctx);
        return cache[key];
      }

      return getPattern(pattern, dummyCanvas, ctx);
    },
    clear: function clear() {
      cache = {};
    }
  };
}

/**
 * @typedef {object} renderer-container-def
 * @property {number} [x] - x-coordinate
 * @property {number} [y] - y-coordinate
 * @property {number} [width] - Width
 * @property {number} [height] - Height
 * @property {object} [scaleRatio]
 * @property {number} [scaleRatio.x] - Scale ratio on x-axis
 * @property {number} [scaleRatio.y] - Scale ratio on y-axis
 * @property {object} [margin]
 * @property {number} [margin.left] - Left margin
 * @property {number} [margin.top] - Top margin
 */

/**
 * Create the renderer box
 * @private
 * @param {renderer-container-def} [opts]
 * @returns {renderer-container-def} A svg renderer instance
 */
function createRendererBox() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      x = _ref.x,
      y = _ref.y,
      width = _ref.width,
      height = _ref.height,
      scaleRatio = _ref.scaleRatio,
      margin = _ref.margin,
      edgeBleed = _ref.edgeBleed;

  var box = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    scaleRatio: {
      x: 1,
      y: 1
    },
    margin: {
      left: 0,
      top: 0
    },
    edgeBleed: {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      bool: false
    }
  };
  box.x = isNaN(x) ? box.x : x;
  box.y = isNaN(y) ? box.y : y;
  box.width = isNaN(width) ? box.width : width;
  box.height = isNaN(height) ? box.height : height;

  if (typeof scaleRatio !== 'undefined') {
    box.scaleRatio.x = isNaN(scaleRatio.x) ? box.scaleRatio.x : scaleRatio.x;
    box.scaleRatio.y = isNaN(scaleRatio.y) ? box.scaleRatio.y : scaleRatio.y;
  }

  if (typeof margin !== 'undefined') {
    box.margin.left = isNaN(margin.left) ? 0 : margin.left;
    box.margin.top = isNaN(margin.top) ? 0 : margin.top;
  }

  if (picasso_esm_typeof(edgeBleed) === 'object') {
    ['left', 'right', 'top', 'bottom'].forEach(function (prop) {
      if (!isNaN(edgeBleed[prop]) && edgeBleed[prop] > 0) {
        box.edgeBleed[prop] = edgeBleed[prop];
        box.edgeBleed.bool = true;
      }
    });
  }

  box.computedPhysical = {
    x: Math.round(box.margin.left + (box.x - box.edgeBleed.left) * box.scaleRatio.x),
    y: Math.round(box.margin.top + (box.y - box.edgeBleed.top) * box.scaleRatio.y),
    width: Math.round((box.width + box.edgeBleed.left + box.edgeBleed.right) * box.scaleRatio.x),
    height: Math.round((box.height + box.edgeBleed.top + box.edgeBleed.bottom) * box.scaleRatio.y)
  };
  return box;
}

/**
 * Base renderer factory
 * @private
 */

function create$n() {
  /**
  * @interface
  * @alias renderer
  */
  var renderer = {
    /**
    * Get the element this renderer is attached to
    * @returns {HTMLElement}
    */
    element: function element() {},

    /**
     * Get the root element of the renderer
     * @returns {HTMLElement}
     */
    root: function root() {},

    /**
    * @param {HTMLElement} element - Element to attach renderer to
    * @returns {HTMLElement} Root element of the renderer
    */
    appendTo: function appendTo() {},

    /**
     * @param {node-def[]} nodes - Nodes to render
     * @returns {boolean} True if the nodes where rendered, otherwise false
     */
    render: function render() {
      return false;
    },

    /**
     * Get nodes renderer at area
     * @param {point|circle|rect|line|polygon} geometry - Get nodes that intersects with geometry
     * @returns {SceneNode[]}
     */
    itemsAt: function itemsAt() {
      return [];
    },

    /**
     * Get all nodes matching the provided selector
     * @param {string} selector CSS selector [type, attribute, universal, class]
     * @returns {SceneNode[]} Array of objects containing matching nodes
     */
    findShapes: function findShapes() {
      return [];
    },

    /**
     * Clear all child elements from the renderer root element
     * @returns {renderer} The renderer instance
     */
    clear: function clear() {},

    /**
     * Remove the renderer root element from its parent element
     */
    destory: function destory() {},

    /**
     * Set or Get the size definition of the renderer container.
     * @param {renderer-container-def} [opts] - Size definition
     * @returns {renderer-container-def} The current size definition
     */
    size: function size() {},

    /**
     * @function
     * @param {object} opts
     * @param {string} opts.text - Text to measure
     * @param {string} opts.fontSize - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
     * @param {string} opts.fontFamily - {@link https://www.w3.org/TR/SVG/text.html#FontPropertiesUsedBySVG}
     * @returns {object} Width and height of text
     * @example
     * measureText({
     *  text: 'my text',
     *  fontSize: '12px',
     *  fontFamily: 'Arial'
     * }); // returns { width: 20, height: 12 }
     */
    measureText: measureText,

    /**
     * Calculates the bounding rectangle of a text node. Including any potential line breaks.
     * @function
     * @param {node--text-def} node
     * @return {rect} The bounding rectangle
     */
    textBounds: textBounds,
    setKey: function setKey(key) {
      renderer.element().setAttribute('data-key', key);
    }
  };
  return renderer;
}

function hasData$1(data) {
  return typeof data !== 'undefined' && data !== null;
}

function injectTextBoundsFn(renderer) {
  return function (_ref) {
    var node = _ref.node;

    if (node.type === 'text' && hasData$1(node.data) && !node.textBoundsFn) {
      node.textBoundsFn = renderer.textBounds;
    }
  };
}

var reg$5 = registryFactory();

function toLineDash(p) {
  if (Array.isArray(p)) {
    return p;
  }

  if (typeof p === 'string') {
    if (p.indexOf(',') !== -1) {
      return p.split(',');
    }

    return p.split(' ');
  }

  return [];
}

function dpiScale(g) {
  var dpr = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  var backingStorePixelRatio = g.webkitBackingStorePixelRatio || g.mozBackingStorePixelRatio || g.msBackingStorePixelRatio || g.oBackingStorePixelRatio || g.backingStorePixelRatio || 1;
  return dpr / backingStorePixelRatio;
}

function resolveMatrix(p, g) {
  g.setTransform(p[0][0], p[1][0], p[0][1], p[1][1], p[0][2], p[1][2]);
}

function applyContext(g, s, shapeToCanvasMap) {
  var computed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var computedKeys = Object.keys(computed);

  for (var i = 0, len = shapeToCanvasMap.length; i < len; i++) {
    var cmd = shapeToCanvasMap[i];
    var shapeCmd = cmd[0];
    var canvasCmd = cmd[1];
    var convertCmd = cmd[2];

    if (shapeCmd in s.attrs && !(canvasCmd in computed) && g[canvasCmd] !== s.attrs[shapeCmd]) {
      var val = convertCmd ? convertCmd(s.attrs[shapeCmd]) : s.attrs[shapeCmd];

      if (typeof g[canvasCmd] === 'function') {
        g[canvasCmd](val);
      } else {
        g[canvasCmd] = val;
      }
    }
  }

  for (var _i = 0, _len = computedKeys.length; _i < _len; _i++) {
    var key = computedKeys[_i];
    g[key] = computed[key];
  }
}

function renderShapes(shapes, g, shapeToCanvasMap, deps) {
  for (var i = 0, len = shapes.length; i < len; i++) {
    var shape = shapes[i];
    var computed = {};
    g.save();

    if (shape.attrs && (shape.attrs.fill || shape.attrs.stroke)) {
      if (shape.attrs.fill && picasso_esm_typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'gradient') {
        computed.fillStyle = createCanvasGradient(g, shape, shape.attrs.fill);
      } else if (shape.attrs.fill && picasso_esm_typeof(shape.attrs.fill) === 'object' && shape.attrs.fill.type === 'pattern') {
        computed.fillStyle = deps.patterns.create(shape.attrs.fill);
      }

      if (shape.attrs.stroke && picasso_esm_typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'gradient') {
        computed.strokeStyle = createCanvasGradient(g, shape, shape.attrs.stroke);
      } else if (shape.attrs.stroke && picasso_esm_typeof(shape.attrs.stroke) === 'object' && shape.attrs.stroke.type === 'pattern') {
        computed.strokeStyle = deps.patterns.create(shape.attrs.stroke);
      }
    }

    applyContext(g, shape, shapeToCanvasMap, computed);

    if (shape.modelViewMatrix) {
      resolveMatrix(shape.modelViewMatrix.elements, g);
    }

    if (reg$5.has(shape.type)) {
      reg$5.get(shape.type)(shape.attrs, {
        g: g,
        doFill: 'fill' in shape.attrs && shape.attrs.fill !== 'none',
        doStroke: 'stroke' in shape.attrs && shape.attrs['stroke-width'] !== 0
      });
    }

    if (shape.children) {
      renderShapes(shape.children, g, shapeToCanvasMap, deps);
    }

    g.restore();
  }
}
/**
 * Create a new canvas renderer
 * @typedef {function} canvasRendererFactory
 * @param {function} sceneFn - Scene factory
 * @returns {renderer} A canvas renderer instance
 */


function renderer() {
  var sceneFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : scene;
  var el;
  var scene$1;
  var hasChangedRect = false;
  var rect = createRendererBox();
  var shapeToCanvasMap = [['fill', 'fillStyle'], ['stroke', 'strokeStyle'], ['opacity', 'globalAlpha'], ['globalAlpha', 'globalAlpha'], ['stroke-width', 'lineWidth'], ['stroke-linejoin', 'lineJoin'], ['stroke-dasharray', 'setLineDash', toLineDash]];
  var patterns;
  var canvasRenderer = create$n();

  canvasRenderer.element = function () {
    return el;
  };

  canvasRenderer.root = function () {
    return el;
  };

  canvasRenderer.appendTo = function (element) {
    if (!el) {
      el = element.ownerDocument.createElement('canvas');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
    }

    element.appendChild(el);
    return el;
  };

  canvasRenderer.render = function (shapes) {
    if (!el) {
      return false;
    }

    if (!patterns) {
      patterns = patternizer(el.ownerDocument);
    }

    var g = el.getContext('2d');
    var dpiRatio = dpiScale(g);
    var scaleX = rect.scaleRatio.x;
    var scaleY = rect.scaleRatio.y;

    if (hasChangedRect) {
      el.style.left = "".concat(rect.computedPhysical.x, "px");
      el.style.top = "".concat(rect.computedPhysical.y, "px");
      el.style.width = "".concat(rect.computedPhysical.width, "px");
      el.style.height = "".concat(rect.computedPhysical.height, "px");
      el.width = Math.round(rect.computedPhysical.width * dpiRatio);
      el.height = Math.round(rect.computedPhysical.height * dpiRatio);
    }

    var sceneContainer = {
      type: 'container',
      children: shapes,
      transform: rect.edgeBleed.bool ? "translate(".concat(rect.edgeBleed.left * dpiRatio * scaleX, ", ").concat(rect.edgeBleed.top * dpiRatio * scaleY, ")") : ''
    };

    if (dpiRatio !== 1 || scaleX !== 1 || scaleY !== 1) {
      sceneContainer.transform += "scale(".concat(dpiRatio * scaleX, ", ").concat(dpiRatio * scaleY, ")");
    }

    var newScene = sceneFn({
      items: [sceneContainer],
      dpi: dpiRatio,
      on: {
        create: [onLineBreak(canvasRenderer.measureText), injectTextBoundsFn(canvasRenderer)]
      }
    });
    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;
    patterns.clear();
    var doRender = hasChangedRect || hasChangedScene;

    if (doRender) {
      canvasRenderer.clear();
      renderShapes(newScene.children, g, shapeToCanvasMap, {
        patterns: patterns
      });
    }

    hasChangedRect = false;
    scene$1 = newScene;
    return doRender;
  };

  canvasRenderer.itemsAt = function (input) {
    return scene$1 ? scene$1.getItemsFrom(input) : [];
  };

  canvasRenderer.findShapes = function (selector) {
    return scene$1 ? scene$1.findShapes(selector) : [];
  };

  canvasRenderer.clear = function () {
    if (el) {
      el.width = el.width;
    }

    scene$1 = null;
    return canvasRenderer;
  };

  canvasRenderer.size = function (opts) {
    if (opts) {
      var newRect = createRendererBox(opts);

      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {
        hasChangedRect = true;
        rect = newRect;
      }
    }

    return rect;
  };

  canvasRenderer.destroy = function () {
    if (el) {
      if (el.parentElement) {
        el.parentElement.removeChild(el);
      }

      el = null;
    }

    scene$1 = null;
  };

  return canvasRenderer;
}
function register(type, renderFn) {
  reg$5.add(type, renderFn);
}

function clampRadius(max, value) {
  return Math.max(0, Math.min(max, value));
}
/**
 * Implementation details follow rx/ry restrictions from https://svgwg.org/svg2-draft/geometry.html#RX
 *
 * Using Quadratic Bézier curve it's not possible accurately represent a circle or ellipse but should for the case of a rounded rectangle be sufficent.
 * @private
 */


function quadraticRoundedRect(g, x, y, width, height, rx, ry) {
  rx = clampRadius(width / 2, rx > 0 ? rx : ry);
  ry = clampRadius(height / 2, ry > 0 ? ry : rx);
  g.moveTo(x, y + ry);
  g.lineTo(x, y + height - ry);
  g.quadraticCurveTo(x, y + height, x + rx, y + height);
  g.lineTo(x + width - rx, y + height);
  g.quadraticCurveTo(x + width, y + height, x + width, y + height - ry);
  g.lineTo(x + width, y + ry);
  g.quadraticCurveTo(x + width, y, x + width - rx, y);
  g.lineTo(x + rx, y);
  g.quadraticCurveTo(x, y, x, y + ry);
}

function render$4(rect, _ref) {
  var g = _ref.g,
      doFill = _ref.doFill,
      doStroke = _ref.doStroke;
  g.beginPath();

  if (rect.rx > 0 || rect.ry > 0) {
    quadraticRoundedRect(g, rect.x, rect.y, rect.width, rect.height, rect.rx, rect.ry);
  } else {
    g.rect(rect.x, rect.y, rect.width, rect.height);
  }

  if (doFill) {
    g.fill();
  }

  if (doStroke) {
    g.stroke();
  }
}

function render$5(circle, _ref) {
  var g = _ref.g,
      doFill = _ref.doFill,
      doStroke = _ref.doStroke;
  g.beginPath();
  g.moveTo(circle.cx + circle.r, circle.cy);
  g.arc(circle.cx, circle.cy, circle.r, 0, Math.PI * 2, false);

  if (doFill) {
    g.fill();
  }

  if (doStroke) {
    g.stroke();
  }
}

function render$6(line, _ref) {
  var g = _ref.g,
      doStroke = _ref.doStroke;
  g.beginPath();
  g.moveTo(line.x1, line.y1);
  g.lineTo(line.x2, line.y2);

  if (doStroke) {
    g.stroke();
  }
}

// Source: https://en.wikipedia.org/wiki/Bi-directional_text and http://www.unicode.org/Public/6.0.0/ucd/UnicodeData.txt
// 3 types of strong direction characters: L (strong left-to-right), R(strong right-to-left, Hebrew) and AL(strong right-to-left, Arabic language)
var rangesOfLChars = "[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u037D\u0386\u0388-\u03F5\u03F7-\u0482\u048A-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u097F\u0982-\u09B9\u09BD-\u09C0\u09C7-\u09CC\u09CE-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u0A03-\u0A39\u0A3E-\u0A40\u0A59-\u0A6F\u0A72-\u0A74\u0A83-\u0AB9\u0ABD-\u0AC0\u0AC9-\u0ACC\u0AD0-\u0AE1\u0AE6-\u0AEF\u0B02-\u0B39\u0B3D-\u0B3E\u0B40\u0B47-\u0B4C\u0B57-\u0B61\u0B66-\u0B77\u0B83-\u0BBF\u0BC1-\u0BCC\u0BD0-\u0BF2\u0C01-\u0C3D\u0C41-\u0C44\u0C58-\u0C61\u0C66-\u0C6F\u0C7F-\u0CB9\u0CBD-\u0CCB\u0CD5-\u0CE1\u0CE6-\u0D40\u0D46-\u0D4C\u0D4E-\u0D61\u0D66-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0E30\u0E32-\u0E33\u0E40-\u0E46\u0E4F-\u0EB0\u0EB2-\u0EB3\u0EBD-\u0EC6\u0ED0-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u102C\u1031\u1038\u103B-\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083-\u1084\u1087-\u108C\u108E-\u109C\u109E-\u135A\u1360-\u138F\u13A0-\u13F4\u1401-\u167F\u1681-\u169A\u16A0-\u1711\u1720-\u1731\u1735-\u1751\u1760-\u1770\u1780-\u17B6\u17BE-\u17C5\u17C7-\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u18A8\u18AA-\u191C\u1923-\u1926\u1929-\u1931\u1933-\u1938\u1946-\u19DA\u1A00-\u1A16\u1A19-\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1A80-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6-\u1BA7\u1BAA-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1C2B\u1C34-\u1C35\u1C3B-\u1C7F\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1DBF\u1E00-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E-\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2D00-\u2D70\u2D80-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA66E\uA680-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA925\uA92E-\uA946\uA952-\uA97C\uA983-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uAA28\uAA2F-\uAA30\uAA33-\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2-\uABE4\uABE6-\uABE7\uABE9-\uABEC\uABF0-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFDC]";
var rangesOfRChars = "[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u07C0-\u07EA\u07F4-\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB4F]";
var rangesOfALChars = "[\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u070D\u0710\u0712-\u072F\u074D-\u07A5\u07B1\uFB50-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]"; // let rangesOfNChars = '[\u0009-\u000D\u001C-\u0022\u0026-\u002A\u003B-\u0040\u005B-\u0060\u007B-\u007E\u0085\u00A1\u00A6-\u00A9\u00AB-\u00AC\u00AE-\u00AF\u00B4\u00B6-\u00B8\u00BB-\u00BF\u00D7\u00F7\u02B9-\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u02FF\u0374-\u0375\u037E-\u0385\u0387\u03F6\u058A\u0606-\u0607\u060E-\u060F\u06DE\u06E9\u07F6-\u07F9\u0BF3-\u0BF8\u0BFA\u0C78-\u0C7E\u0F3A-\u0F3D\u1390-\u1399\u1400\u1680\u169B-\u169C\u17F0-\u180A\u180E\u1940-\u1945\u19DE-\u19FF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD-\u200A\u2010-\u2029\u2035-\u2043\u2045-\u205F\u207C-\u207E\u208C-\u208E\u2100-\u2101\u2103-\u2106\u2108-\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u213A-\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u2211\u2214-\u2335\u237B-\u2394\u2396-\u2487\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B59\u2CE5-\u2CEA\u2CF9-\u2CFF\u2E00-\u3004\u3008-\u3020\u3030\u3036-\u3037\u303D-\u303F\u309B-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D-\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE-\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA673\uA67E-\uA67F\uA700-\uA721\uA788\uA828-\uA82B\uA874-\uA877\uFD3E-\uFD3F\uFDFD\uFE10-\uFE19\uFE30-\uFE4F\uFE51\uFE54\uFE56-\uFE5E\uFE60-\uFE61\uFE64-\uFE68\uFE6B\uFF01-\uFF02\uFF06-\uFF0A\uFF1B-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE2-\uFFE4\uFFE8-\uFFFD]';

var rangesOfLRgExp = new RegExp(rangesOfLChars);
var rangesOfRRgExp = new RegExp(rangesOfRChars);
var rangesOfALRgExp = new RegExp(rangesOfALChars); // let rangesOfNRgExp = new RegExp(rangesOfNChars);
// let lrm = String.fromCharCode(8206); // left-to-right marker
// let rlm = String.fromCharCode(8207); // right-to-left marker

function isLtrChar(c) {
  return rangesOfLRgExp.test(c);
}

function isRtlChar(c) {
  return rangesOfRRgExp.test(c) || rangesOfALRgExp.test(c);
}

function detectTextDirection(s) {
  var n = s ? s.length : 0,
      i,
      c;

  for (i = 0; i < n; i++) {
    c = s[i];

    if (isLtrChar(c)) {
      return 'ltr';
    }

    if (isRtlChar(c)) {
      return 'rtl';
    }
  }

  return 'ltr';
}
var textAnchorRTLMap = {
  start: 'end',
  end: 'start',
  center: 'center',
  middle: 'middle'
};
/* let flippedTextAnchor = true;
let detected = false;
export function detectRtlSvgSupport(ns, ownerDoc) {
  if (!detected) {
    const body = ownerDoc.body;
    if (body) {
      const rtlTestSVG = ownerDoc.createElementNS(ns, 'svg');
      const textNode = ownerDoc.createElementNS(ns, 'text');
      const group = ownerDoc.createElementNS(ns, 'g');

      rtlTestSVG.setAttribute('xmlns', ns);
      rtlTestSVG.setAttribute('style', 'position: absolute; width: 100px; height: 100px; top: -100px; left: 0px');

      textNode.setAttribute('text-anchor', 'start');
      textNode.setAttribute('direction', 'rtl');
      textNode.setAttribute('font-size', '14px');
      textNode.setAttribute('x', 50);
      textNode.setAttribute('y', 50);
      textNode.textContent = 'ثعبان';

      group.appendChild(textNode);
      rtlTestSVG.appendChild(group);
      body.appendChild(rtlTestSVG);

      flippedTextAnchor = textNode.getBoundingClientRect().left < 50;
      body.removeChild(rtlTestSVG);
    }
  }
  detected = true;
} */

function flipTextAnchor(value, dir) {
  if (dir === 'rtl') {
    return textAnchorRTLMap[value];
  }

  return value;
}

function render$7(t, _ref) {
  var g = _ref.g;
  var text = ellipsText(t, measureText);
  g.font = "".concat(t['font-size'], " ").concat(t['font-family']);
  var dir = detectTextDirection(t.text);

  if (g.canvas.dir !== dir) {
    g.canvas.dir = dir;
  }

  var textAnchor = t['text-anchor'] === 'middle' ? 'center' : t['text-anchor'];
  var textAlign = flipTextAnchor(textAnchor, g.canvas.dir);

  if (textAlign && g.textAlign !== textAlign) {
    g.textAlign = textAlign;
  }

  var bdy = baselineHeuristic(t);
  g.fillText(text, t.x + t.dx, t.y + t.dy + bdy);
}

function render$8(path, _ref) {
  var g = _ref.g,
      doStroke = _ref.doStroke,
      doFill = _ref.doFill;
  var p = new Path2D(path.d);

  if (doFill) {
    g.fill(p);
  }

  if (doStroke) {
    g.stroke(p);
  }
}

register('rect', render$4);
register('circle', render$5);
register('line', render$6);
register('path', render$8);
register('text', render$7);
function rendererComponent(picasso) {
  picasso.renderer('canvas', renderer);
}

function diff$1(from, to) {
  var added = [];
  var items;
  var removed = [];
  var updatedNew = [];
  var updatedOld = [];
  var fromIds;
  var toIds;

  var idMapper = function idMapper(a) {
    return a.id;
  };

  var nodeMapper = function nodeMapper(node, i) {
    var id;

    if (picasso_esm_typeof(node) === 'object') {
      if ('id' in node) {
        id = node.id;
      } else {
        id = i;
      }
    } else {
      id = node;
    }

    return {
      content: node,
      id: "".concat(id, "__").concat(node.type || '')
    };
  };

  if (!from.isTree) {
    from = from.map(nodeMapper);
  }

  to = to.map(nodeMapper);
  fromIds = from.map(idMapper);
  toIds = to.map(idMapper); // TODO - handle duplicate values
  // added = to.filter( v => fromIds.indexOf( v.id ) < 0 );
  // updatedNew = to.filter( v => fromIds.indexOf( v.id ) >= 0 );
  // removed = from.filter( v => toIds.indexOf( v.id ) < 0 );
  // updatedOld = from.filter( v => toIds.indexOf( v.id ) >= 0 );

  for (var i = 0, len = to.length; i < len; i++) {
    var idx = fromIds.indexOf(to[i].id);

    if (idx === -1) {
      added.push(to[i]);
    } else {
      updatedNew.push(to[i]);
    }
  }

  for (var _i = 0, _len = from.length; _i < _len; _i++) {
    var _idx = toIds.indexOf(from[_i].id);

    if (_idx === -1) {
      removed.push(from[_i]);
    } else {
      updatedOld.push(from[_i]);
    }
  }

  for (var _i2 = 0, _len2 = added.length; _i2 < _len2; _i2++) {
    if (added[_i2].content.children) {
      added[_i2].diff = diff$1([], added[_i2].content.children);
      added[_i2].children = added[_i2].diff.updatedNew.concat(added[_i2].diff.added);
      added[_i2].children.isTree = true;
    }
  }

  for (var _i3 = 0, _len3 = updatedNew.length; _i3 < _len3; _i3++) {
    updatedNew[_i3].diff = diff$1(updatedOld[_i3].children || [], updatedNew[_i3].content.children || []);
    updatedNew[_i3].object = updatedOld[_i3].object;
    updatedNew[_i3].children = updatedNew[_i3].diff.items;
  }

  items = updatedNew.concat(added);
  added.isTree = true;
  removed.isTree = true;
  updatedNew.isTree = true;
  updatedOld.isTree = true;
  items.isTree = true;
  return {
    added: added,
    updatedNew: updatedNew,
    updatedOld: updatedOld,
    removed: removed,
    items: items
  };
}

function createNodes(nodes, parent, create) {
  for (var i = 0, len = nodes.length; i < len; i++) {
    nodes[i].object = create(nodes[i].content.type, parent);
  }
}

function destroyNodes(nodes, destroy) {
  for (var i = 0, len = nodes.length; i < len; i++) {
    if (nodes[i].object !== null && typeof nodes[i].object !== 'undefined') {
      destroy(nodes[i].object);
      nodes[i].object = null;
    }
  }
}

function updateNodes(nodes, creator, maintainer, destroyer) {
  var item;

  for (var i = 0, len = nodes.length; i < len; i++) {
    item = nodes[i];

    if (item.object !== null && typeof item.object !== 'undefined') {
      maintainer(item.object, item.content);

      if (item.diff) {
        createNodes(item.diff.added, item.object, creator);
        destroyNodes(item.diff.removed, destroyer);
        updateNodes(item.diff.items, creator, maintainer, destroyer);
      }
    }
  }
}

function createTree(oldItems, newItems, root, creator, maintainer, destroyer) {
  var d = diff$1(oldItems, newItems);
  createNodes(d.added, root, creator);
  destroyNodes(d.removed, destroyer);
  updateNodes(d.items, creator, maintainer, destroyer);
  return d.items;
}

var svgNs = 'http://www.w3.org/2000/svg';

var creator = function creator(type, parent) {
  if (!type || typeof type !== 'string') {
    throw new Error("Invalid type: ".concat(type));
  }

  var el = parent.ownerDocument.createElementNS(svgNs, type === 'container' ? 'g' : type);
  parent.appendChild(el);
  return el;
};

var destroyer = function destroyer(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};

var maintainer = function maintainer(element, item) {
  for (var attr in item.attrs) {
    if (attr === 'stroke' && item.strokeReference) {
      element.setAttribute('stroke', item.strokeReference);
    } else if (attr === 'fill' && item.fillReference) {
      element.setAttribute('fill', item.fillReference);
    } else if (attr === 'text') {
      element.setAttribute('style', 'white-space: pre');
      element.textContent = ellipsText(item.attrs, measureText);
      var dir = detectTextDirection(item.attrs.text);

      if (dir === 'rtl') {
        element.setAttribute('direction', 'rtl');
        element.setAttribute('dir', 'rtl');
        element.setAttribute('text-anchor', flipTextAnchor(element.getAttribute('text-anchor'), dir));
      }
    } else if (item.type === 'text' && (attr === 'dy' || attr === 'dominant-baseline')) {
      var dy = +element.getAttribute(attr) || 0;
      var val = 0;

      if (attr === 'dominant-baseline') {
        val = baselineHeuristic(item.attrs);
      } else {
        val = item.attrs[attr];
      }

      element.setAttribute('dy', val + dy);
    } else if (item.type === 'text' && attr === 'title' && item.attrs.title) {
      var t = element.ownerDocument.createElementNS(svgNs, 'title');
      t.textContent = item.attrs.title;
      element.appendChild(t);
    } else {
      element.setAttribute(attr, item.attrs[attr]);
    }
  }

  if (typeof item.data === 'string' || typeof item.data === 'number' || typeof item.data === 'boolean') {
    element.setAttribute('data', item.data);
  } else if (picasso_esm_typeof(item.data) === 'object' && item.data !== null) {
    for (var d in item.data) {
      if (typeof item.data[d] === 'string' || typeof item.data[d] === 'number' || typeof item.data[d] === 'boolean') {
        element.setAttribute("data-".concat(d), item.data[d]);
      }
    }
  }
};

var TreeItemRenderer =
/*#__PURE__*/
function () {
  /**
   * Constructor
   * @private
   * @param  {TreeCreator} treeCreator - Function used to create the DOM tree..
   * @param  {SVGCreator} nodeCreator - Function used to create nodes.
   * @param  {SVGMaintainer} nodeMaintainer - Function used to update nodes.
   * @param  {SVGDestroyer} nodeDestroyer - Function used to destroy nodes.
   */
  function TreeItemRenderer(treeCreator, nodeCreator, nodeMaintainer, nodeDestroyer) {
    _classCallCheck$1(this, TreeItemRenderer);

    this.create = treeCreator;
    this.nodeCreator = nodeCreator;
    this.nodeMaintainer = nodeMaintainer;
    this.nodeDestroyer = nodeDestroyer;
  }

  _createClass$1(TreeItemRenderer, [{
    key: "render",
    value: function render(newItems, root) {
      return this.create([], newItems, root, this.nodeCreator, this.nodeMaintainer, this.nodeDestroyer);
    }
  }]);

  return TreeItemRenderer;
}();

function tree() {
  return new TreeItemRenderer(createTree, creator, maintainer, destroyer);
}
/**
 * Create an SVGElement and attach to parent.
 * @private
 * @callback SVGCreator
 * @param {String} type - The type of element to create.
 * @param {SVGElement} parent - The parent element to append the new element to.
 * @return {SVGElement} The created element
 */

/**
 * Update the element with content from item.
 * @private
 * @callback SVGMaintainer
 * @param {SVGElement} el - The element to update
 * @param {Object} item - The object to use as input for the update
 */

/**
 * Detach element from its parent.
 * @private
 * @callback SVGDestroyer
 * @param {SVGElement} el - Element to destroy.
 */

/**
 * Create, update and destroy nodes.
 * @private
 * @callback TreeCreator
 * @param {Object[]} existing - The existing items in the tree.
 * @param {Object[]} active - The new items to create the tree from.
 * @param {SVGCreator} creator - Function used to create nodes.
 * @param {SVGMaintainer} maintainer - Function used to update nodes.
 * @param {SVGDestroyer} destroyer - Function used to destroy nodes.
 */

/* eslint import/prefer-default-export: 0 */

/**
 * Hash an object
 * Modified version of Java's HashCode function
 * Source: {@link http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/}
 * @ignore
 *
 * @param  {Object} item Item to hash
 * @return {String}      Unique hash id
 */
function hashObject(item) {
  var hash = 0;
  var i;
  var chr;
  var len;
  item = JSON.stringify(item);

  if (item.length === 0) {
    return hash;
  }

  for (i = 0, len = item.length; i < len; i++) {
    chr = item.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}

function gradienter(bucket) {
  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;
  var cache = {};
  var uid = Date.now();
  var p = {
    getOrCreateGradient: function getOrCreateGradient() {
      var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var attr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fill';
      var url = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var gradientHash = hasher(item[attr]);
      var gradientId = "picasso-gradient-".concat(uid, "-").concat(gradientHash);

      if (!cache[gradientHash]) {
        var _item$attr = item[attr],
            orientation = _item$attr.orientation,
            degree = _item$attr.degree,
            _item$attr$stops = _item$attr.stops,
            stops = _item$attr$stops === void 0 ? [] : _item$attr$stops;
        var gradient = {};

        if (degree === undefined) {
          degree = 90;
        } // Default to linear


        if (orientation === 'radial') {
          gradient.type = 'radialGradient';
        } else {
          gradient = degreesToPoints(degree);
          gradient.type = 'linearGradient';
        }

        gradient.id = gradientId;
        gradient.children = stops.map(function (_ref) {
          var offset = _ref.offset,
              color = _ref.color,
              opacity = _ref.opacity;
          return {
            type: 'stop',
            offset: "".concat(offset * 100, "%"),
            style: "stop-color:".concat(color, ";stop-opacity:").concat(typeof opacity !== 'undefined' ? opacity : 1)
          };
        });
        bucket.push(gradient);
        cache[gradientHash] = gradientId;
      }

      return "url('".concat(url, "#").concat(gradientId, "')");
    },
    onCreate: function onCreate(state) {
      var url = '';

      if (typeof window !== 'undefined') {
        url = window.location.href.split('#')[0];
      }

      var item = state.node;

      if (item.fill && picasso_esm_typeof(item.fill) === 'object' && item.fill.type === 'gradient') {
        item.fillReference = p.getOrCreateGradient(item, 'fill', url);
      }

      if (item.stroke && picasso_esm_typeof(item.stroke) === 'object' && item.stroke.type === 'gradient') {
        item.strokeReference = p.getOrCreateGradient(item, 'stroke', url);
      }
    },
    clear: function clear() {
      cache = {};
    }
  };
  return p;
}

function patternizer$1(bucket) {
  var hasher = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : hashObject;
  var cache = {};
  var uid = Date.now();
  var p = {
    onCreate: function onCreate(state) {
      var inputs = {};

      if (state.node && picasso_esm_typeof(state.node.fill) === 'object' && state.node.fill.type === 'pattern' && state.node.fill.shapes) {
        inputs.fill = state.node.fill;
      }

      if (state.node && picasso_esm_typeof(state.node.stroke) === 'object' && state.node.stroke.type === 'pattern' && state.node.stroke.shapes) {
        inputs.stroke = state.node.stroke;
      }

      Object.keys(inputs).forEach(function (key) {
        var url = '';
        var input = inputs[key];
        var patternHash = hasher(input);
        var pnid = "picasso-pattern-".concat(uid, "-").concat(patternHash);

        if (typeof window !== 'undefined') {
          url = window.location.href.split('#')[0];
        }

        if (!cache[patternHash]) {
          var pn = {
            patternUnits: 'userSpaceOnUse',
            x: 0,
            y: 0,
            width: input.width,
            height: input.height,
            type: 'pattern',
            id: pnid,
            children: [],
            fill: input.fill
          };
          input.shapes.forEach(function (s) {
            pn.children.push(s);
          });
          bucket.push(pn);
          cache[patternHash] = true;
        }

        state.node["".concat(key, "Reference")] = "url('".concat(url, "#").concat(pnid, "')");
      });
    },
    clear: function clear() {
      cache = {};
    }
  };
  return p;
}

/**
 * Create a new svg renderer
 * @typedef {function} svgRendererFactory
 * @param {function} treeFactory - Node tree factory
 * @param {string} ns - Namespace definition
 * @param {function} sceneFn - Scene factory
 * @returns {renderer} A svg renderer instance
 */

function renderer$1() {
  var treeFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tree;
  var ns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : svgNs;
  var sceneFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : scene;
  var tree$1 = treeFn();
  var el;
  var group;
  var hasChangedRect = false;
  var rect = createRendererBox();
  var scene$1;
  var svg = create$n();
  var defs = {
    type: 'defs',
    children: []
  };
  var patterns = patternizer$1(defs.children);
  var gradients = gradienter(defs.children);

  svg.element = function () {
    return el;
  };

  svg.root = function () {
    return group;
  };

  svg.appendTo = function (element) {
    if (!el) {
      el = element.ownerDocument.createElementNS(ns, 'svg');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
      el.setAttribute('xmlns', ns);
      group = element.ownerDocument.createElementNS(ns, 'g');
      group.style.pointerEvents = 'auto';
      el.appendChild(group);
    }

    element.appendChild(el);
    return el;
  };

  svg.render = function (nodes) {
    if (!el) {
      return false;
    }

    var scaleX = rect.scaleRatio.x;
    var scaleY = rect.scaleRatio.y;

    if (hasChangedRect) {
      el.style.left = "".concat(rect.computedPhysical.x, "px");
      el.style.top = "".concat(rect.computedPhysical.y, "px");
      el.setAttribute('width', rect.computedPhysical.width);
      el.setAttribute('height', rect.computedPhysical.height);
    }

    gradients.clear();
    patterns.clear();
    defs.children.length = 0;
    var sceneContainer = {
      type: 'container',
      children: Array.isArray(nodes) ? [].concat(_toConsumableArray$1(nodes), [defs]) : nodes,
      transform: rect.edgeBleed.bool ? "translate(".concat(rect.edgeBleed.left * scaleX, ", ").concat(rect.edgeBleed.top * scaleY, ")") : ''
    };

    if (scaleX !== 1 || scaleY !== 1) {
      sceneContainer.transform += "scale(".concat(scaleX, ", ").concat(scaleY, ")");
    }

    var newScene = sceneFn({
      items: [sceneContainer],
      on: {
        create: [function (state) {
          state.node.fillReference = undefined;
          state.node.strokeReference = undefined;
        }, gradients.onCreate, patterns.onCreate, onLineBreak(svg.measureText), injectTextBoundsFn(svg)]
      }
    });
    var hasChangedScene = scene$1 ? !newScene.equals(scene$1) : true;
    var doRender = hasChangedRect || hasChangedScene;

    if (doRender) {
      svg.clear();
      tree$1.render(newScene.children, group);
    }

    hasChangedRect = false;
    scene$1 = newScene;
    return doRender;
  };

  svg.itemsAt = function (input) {
    return scene$1 ? scene$1.getItemsFrom(input) : [];
  };

  svg.findShapes = function (selector) {
    return scene$1 ? scene$1.findShapes(selector) : [];
  };

  svg.clear = function () {
    if (!group) {
      return svg;
    }

    scene$1 = null;
    var g = group.cloneNode(false);
    el.replaceChild(g, group);
    group = g;
    return svg;
  };

  svg.destroy = function () {
    // parentElement is not supported in IE11 for SVGElement.
    if (el && el.parentNode) {
      el.parentNode.removeChild(el);
    }

    el = null;
    group = null;
  };

  svg.size = function (opts) {
    if (opts) {
      var newRect = createRendererBox(opts);

      if (JSON.stringify(rect) !== JSON.stringify(newRect)) {
        hasChangedRect = true;
        rect = newRect;
      }
    }

    return rect;
  };

  return svg;
}
function rendererComponent$1(picasso) {
  picasso.renderer('svg', renderer$1);
}

var VNode = function VNode() {};

var picasso_esm_options = {};

var stack$1 = [];

var EMPTY_CHILDREN = [];

function h(nodeName, attributes) {
	var children = EMPTY_CHILDREN,
	    lastSimple,
	    child,
	    simple,
	    i;
	for (i = arguments.length; i-- > 2;) {
		stack$1.push(arguments[i]);
	}
	if (attributes && attributes.children != null) {
		if (!stack$1.length) stack$1.push(attributes.children);
		delete attributes.children;
	}
	while (stack$1.length) {
		if ((child = stack$1.pop()) && child.pop !== undefined) {
			for (i = child.length; i--;) {
				stack$1.push(child[i]);
			}
		} else {
			if (typeof child === 'boolean') child = null;

			if (simple = typeof nodeName !== 'function') {
				if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
			}

			if (simple && lastSimple) {
				children[children.length - 1] += child;
			} else if (children === EMPTY_CHILDREN) {
				children = [child];
			} else {
				children.push(child);
			}

			lastSimple = simple;
		}
	}

	var p = new VNode();
	p.nodeName = nodeName;
	p.children = children;
	p.attributes = attributes == null ? undefined : attributes;
	p.key = attributes == null ? undefined : attributes.key;

	return p;
}

function extend$2(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }return obj;
}

function applyRef(ref, value) {
  if (ref != null) {
    if (typeof ref == 'function') ref(value);else ref.current = value;
  }
}

var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

var items = [];

function enqueueRender(component) {
	if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
		(defer)(rerender);
	}
}

function rerender() {
	var p;
	while (p = items.pop()) {
		if (p._dirty) renderComponent(p);
	}
}

function isSameNodeType(node, vnode, hydrating) {
	if (typeof vnode === 'string' || typeof vnode === 'number') {
		return node.splitText !== undefined;
	}
	if (typeof vnode.nodeName === 'string') {
		return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
	}
	return hydrating || node._componentConstructor === vnode.nodeName;
}

function isNamedNode(node, nodeName) {
	return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}

function getNodeProps(vnode) {
	var props = extend$2({}, vnode.attributes);
	props.children = vnode.children;

	var defaultProps = vnode.nodeName.defaultProps;
	if (defaultProps !== undefined) {
		for (var i in defaultProps) {
			if (props[i] === undefined) {
				props[i] = defaultProps[i];
			}
		}
	}

	return props;
}

function createNode(nodeName, isSvg) {
	var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
	node.normalizedNodeName = nodeName;
	return node;
}

function removeNode(node) {
	var parentNode = node.parentNode;
	if (parentNode) parentNode.removeChild(node);
}

function setAccessor(node, name, old, value, isSvg) {
	if (name === 'className') name = 'class';

	if (name === 'key') ; else if (name === 'ref') {
		applyRef(old, null);
		applyRef(value, node);
	} else if (name === 'class' && !isSvg) {
		node.className = value || '';
	} else if (name === 'style') {
		if (!value || typeof value === 'string' || typeof old === 'string') {
			node.style.cssText = value || '';
		}
		if (value && typeof value === 'object') {
			if (typeof old !== 'string') {
				for (var i in old) {
					if (!(i in value)) node.style[i] = '';
				}
			}
			for (var i in value) {
				node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
			}
		}
	} else if (name === 'dangerouslySetInnerHTML') {
		if (value) node.innerHTML = value.__html || '';
	} else if (name[0] == 'o' && name[1] == 'n') {
		var useCapture = name !== (name = name.replace(/Capture$/, ''));
		name = name.toLowerCase().substring(2);
		if (value) {
			if (!old) node.addEventListener(name, eventProxy, useCapture);
		} else {
			node.removeEventListener(name, eventProxy, useCapture);
		}
		(node._listeners || (node._listeners = {}))[name] = value;
	} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
		try {
			node[name] = value == null ? '' : value;
		} catch (e) {}
		if ((value == null || value === false) && name != 'spellcheck') node.removeAttribute(name);
	} else {
		var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));

		if (value == null || value === false) {
			if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
		} else if (typeof value !== 'function') {
			if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
		}
	}
}

function eventProxy(e) {
	return this._listeners[e.type](e);
}

var mounts = [];

var diffLevel = 0;

var isSvgMode = false;

var hydrating = false;

function flushMounts() {
	var c;
	while (c = mounts.shift()) {
		if (c.componentDidMount) c.componentDidMount();
	}
}

function diff$2(dom, vnode, context, mountAll, parent, componentRoot) {
	if (!diffLevel++) {
		isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

		hydrating = dom != null && !('__preactattr_' in dom);
	}

	var ret = idiff(dom, vnode, context, mountAll, componentRoot);

	if (parent && ret.parentNode !== parent) parent.appendChild(ret);

	if (! --diffLevel) {
		hydrating = false;

		if (!componentRoot) flushMounts();
	}

	return ret;
}

function idiff(dom, vnode, context, mountAll, componentRoot) {
	var out = dom,
	    prevSvgMode = isSvgMode;

	if (vnode == null || typeof vnode === 'boolean') vnode = '';

	if (typeof vnode === 'string' || typeof vnode === 'number') {
		if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
			if (dom.nodeValue != vnode) {
				dom.nodeValue = vnode;
			}
		} else {
			out = document.createTextNode(vnode);
			if (dom) {
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
				recollectNodeTree(dom, true);
			}
		}

		out['__preactattr_'] = true;

		return out;
	}

	var vnodeName = vnode.nodeName;
	if (typeof vnodeName === 'function') {
		return buildComponentFromVNode(dom, vnode, context, mountAll);
	}

	isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

	vnodeName = String(vnodeName);
	if (!dom || !isNamedNode(dom, vnodeName)) {
		out = createNode(vnodeName, isSvgMode);

		if (dom) {
			while (dom.firstChild) {
				out.appendChild(dom.firstChild);
			}
			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

			recollectNodeTree(dom, true);
		}
	}

	var fc = out.firstChild,
	    props = out['__preactattr_'],
	    vchildren = vnode.children;

	if (props == null) {
		props = out['__preactattr_'] = {};
		for (var a = out.attributes, i = a.length; i--;) {
			props[a[i].name] = a[i].value;
		}
	}

	if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
		if (fc.nodeValue != vchildren[0]) {
			fc.nodeValue = vchildren[0];
		}
	} else if (vchildren && vchildren.length || fc != null) {
			innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
		}

	diffAttributes(out, vnode.attributes, props);

	isSvgMode = prevSvgMode;

	return out;
}

function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
	var originalChildren = dom.childNodes,
	    children = [],
	    keyed = {},
	    keyedLen = 0,
	    min = 0,
	    len = originalChildren.length,
	    childrenLen = 0,
	    vlen = vchildren ? vchildren.length : 0,
	    j,
	    c,
	    f,
	    vchild,
	    child;

	if (len !== 0) {
		for (var i = 0; i < len; i++) {
			var _child = originalChildren[i],
			    props = _child['__preactattr_'],
			    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
			if (key != null) {
				keyedLen++;
				keyed[key] = _child;
			} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
				children[childrenLen++] = _child;
			}
		}
	}

	if (vlen !== 0) {
		for (var i = 0; i < vlen; i++) {
			vchild = vchildren[i];
			child = null;

			var key = vchild.key;
			if (key != null) {
				if (keyedLen && keyed[key] !== undefined) {
					child = keyed[key];
					keyed[key] = undefined;
					keyedLen--;
				}
			} else if (min < childrenLen) {
					for (j = min; j < childrenLen; j++) {
						if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
							child = c;
							children[j] = undefined;
							if (j === childrenLen - 1) childrenLen--;
							if (j === min) min++;
							break;
						}
					}
				}

			child = idiff(child, vchild, context, mountAll);

			f = originalChildren[i];
			if (child && child !== dom && child !== f) {
				if (f == null) {
					dom.appendChild(child);
				} else if (child === f.nextSibling) {
					removeNode(f);
				} else {
					dom.insertBefore(child, f);
				}
			}
		}
	}

	if (keyedLen) {
		for (var i in keyed) {
			if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
		}
	}

	while (min <= childrenLen) {
		if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
	}
}

function recollectNodeTree(node, unmountOnly) {
	var component = node._component;
	if (component) {
		unmountComponent(component);
	} else {
		if (node['__preactattr_'] != null) applyRef(node['__preactattr_'].ref, null);

		if (unmountOnly === false || node['__preactattr_'] == null) {
			removeNode(node);
		}

		removeChildren(node);
	}
}

function removeChildren(node) {
	node = node.lastChild;
	while (node) {
		var next = node.previousSibling;
		recollectNodeTree(node, true);
		node = next;
	}
}

function diffAttributes(dom, attrs, old) {
	var name;

	for (name in old) {
		if (!(attrs && attrs[name] != null) && old[name] != null) {
			setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
		}
	}

	for (name in attrs) {
		if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
			setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
		}
	}
}

var recyclerComponents = [];

function createComponent(Ctor, props, context) {
	var inst,
	    i = recyclerComponents.length;

	if (Ctor.prototype && Ctor.prototype.render) {
		inst = new Ctor(props, context);
		picasso_esm_Component.call(inst, props, context);
	} else {
		inst = new picasso_esm_Component(props, context);
		inst.constructor = Ctor;
		inst.render = doRender;
	}

	while (i--) {
		if (recyclerComponents[i].constructor === Ctor) {
			inst.nextBase = recyclerComponents[i].nextBase;
			recyclerComponents.splice(i, 1);
			return inst;
		}
	}

	return inst;
}

function doRender(props, state, context) {
	return this.constructor(props, context);
}

function setComponentProps(component, props, renderMode, context, mountAll) {
	if (component._disable) return;
	component._disable = true;

	component.__ref = props.ref;
	component.__key = props.key;
	delete props.ref;
	delete props.key;

	if (typeof component.constructor.getDerivedStateFromProps === 'undefined') {
		if (!component.base || mountAll) {
			if (component.componentWillMount) component.componentWillMount();
		} else if (component.componentWillReceiveProps) {
			component.componentWillReceiveProps(props, context);
		}
	}

	if (context && context !== component.context) {
		if (!component.prevContext) component.prevContext = component.context;
		component.context = context;
	}

	if (!component.prevProps) component.prevProps = component.props;
	component.props = props;

	component._disable = false;

	if (renderMode !== 0) {
		if (renderMode === 1 || picasso_esm_options.syncComponentUpdates !== false || !component.base) {
			renderComponent(component, 1, mountAll);
		} else {
			enqueueRender(component);
		}
	}

	applyRef(component.__ref, component);
}

function renderComponent(component, renderMode, mountAll, isChild) {
	if (component._disable) return;

	var props = component.props,
	    state = component.state,
	    context = component.context,
	    previousProps = component.prevProps || props,
	    previousState = component.prevState || state,
	    previousContext = component.prevContext || context,
	    isUpdate = component.base,
	    nextBase = component.nextBase,
	    initialBase = isUpdate || nextBase,
	    initialChildComponent = component._component,
	    skip = false,
	    snapshot = previousContext,
	    rendered,
	    inst,
	    cbase;

	if (component.constructor.getDerivedStateFromProps) {
		state = extend$2(extend$2({}, state), component.constructor.getDerivedStateFromProps(props, state));
		component.state = state;
	}

	if (isUpdate) {
		component.props = previousProps;
		component.state = previousState;
		component.context = previousContext;
		if (renderMode !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
			skip = true;
		} else if (component.componentWillUpdate) {
			component.componentWillUpdate(props, state, context);
		}
		component.props = props;
		component.state = state;
		component.context = context;
	}

	component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
	component._dirty = false;

	if (!skip) {
		rendered = component.render(props, state, context);

		if (component.getChildContext) {
			context = extend$2(extend$2({}, context), component.getChildContext());
		}

		if (isUpdate && component.getSnapshotBeforeUpdate) {
			snapshot = component.getSnapshotBeforeUpdate(previousProps, previousState);
		}

		var childComponent = rendered && rendered.nodeName,
		    toUnmount,
		    base;

		if (typeof childComponent === 'function') {

			var childProps = getNodeProps(rendered);
			inst = initialChildComponent;

			if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
				setComponentProps(inst, childProps, 1, context, false);
			} else {
				toUnmount = inst;

				component._component = inst = createComponent(childComponent, childProps, context);
				inst.nextBase = inst.nextBase || nextBase;
				inst._parentComponent = component;
				setComponentProps(inst, childProps, 0, context, false);
				renderComponent(inst, 1, mountAll, true);
			}

			base = inst.base;
		} else {
			cbase = initialBase;

			toUnmount = initialChildComponent;
			if (toUnmount) {
				cbase = component._component = null;
			}

			if (initialBase || renderMode === 1) {
				if (cbase) cbase._component = null;
				base = diff$2(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
			}
		}

		if (initialBase && base !== initialBase && inst !== initialChildComponent) {
			var baseParent = initialBase.parentNode;
			if (baseParent && base !== baseParent) {
				baseParent.replaceChild(base, initialBase);

				if (!toUnmount) {
					initialBase._component = null;
					recollectNodeTree(initialBase, false);
				}
			}
		}

		if (toUnmount) {
			unmountComponent(toUnmount);
		}

		component.base = base;
		if (base && !isChild) {
			var componentRef = component,
			    t = component;
			while (t = t._parentComponent) {
				(componentRef = t).base = base;
			}
			base._component = componentRef;
			base._componentConstructor = componentRef.constructor;
		}
	}

	if (!isUpdate || mountAll) {
		mounts.push(component);
	} else if (!skip) {

		if (component.componentDidUpdate) {
			component.componentDidUpdate(previousProps, previousState, snapshot);
		}
	}

	while (component._renderCallbacks.length) {
		component._renderCallbacks.pop().call(component);
	}if (!diffLevel && !isChild) flushMounts();
}

function buildComponentFromVNode(dom, vnode, context, mountAll) {
	var c = dom && dom._component,
	    originalComponent = c,
	    oldDom = dom,
	    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
	    isOwner = isDirectOwner,
	    props = getNodeProps(vnode);
	while (c && !isOwner && (c = c._parentComponent)) {
		isOwner = c.constructor === vnode.nodeName;
	}

	if (c && isOwner && (!mountAll || c._component)) {
		setComponentProps(c, props, 3, context, mountAll);
		dom = c.base;
	} else {
		if (originalComponent && !isDirectOwner) {
			unmountComponent(originalComponent);
			dom = oldDom = null;
		}

		c = createComponent(vnode.nodeName, props, context);
		if (dom && !c.nextBase) {
			c.nextBase = dom;

			oldDom = null;
		}
		setComponentProps(c, props, 1, context, mountAll);
		dom = c.base;

		if (oldDom && dom !== oldDom) {
			oldDom._component = null;
			recollectNodeTree(oldDom, false);
		}
	}

	return dom;
}

function unmountComponent(component) {

	var base = component.base;

	component._disable = true;

	if (component.componentWillUnmount) component.componentWillUnmount();

	component.base = null;

	var inner = component._component;
	if (inner) {
		unmountComponent(inner);
	} else if (base) {
		if (base['__preactattr_'] != null) applyRef(base['__preactattr_'].ref, null);

		component.nextBase = base;

		removeNode(base);
		recyclerComponents.push(component);

		removeChildren(base);
	}

	applyRef(component.__ref, null);
}

function picasso_esm_Component(props, context) {
	this._dirty = true;

	this.context = context;

	this.props = props;

	this.state = this.state || {};

	this._renderCallbacks = [];
}

extend$2(picasso_esm_Component.prototype, {
	setState: function setState(state, callback) {
		if (!this.prevState) this.prevState = this.state;
		this.state = extend$2(extend$2({}, this.state), typeof state === 'function' ? state(this.state, this.props) : state);
		if (callback) this._renderCallbacks.push(callback);
		enqueueRender(this);
	},
	forceUpdate: function forceUpdate(callback) {
		if (callback) this._renderCallbacks.push(callback);
		renderComponent(this, 2);
	},
	render: function render() {}
});

function render$9(vnode, parent, merge) {
  return diff$2(merge, vnode, {}, false, parent, false);
}

function renderer$2() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _opts$createElement = opts.createElement,
      createElement = _opts$createElement === void 0 ? document.createElement.bind(document) : _opts$createElement;
  var el;
  var rect = createRendererBox();
  var dNode;
  var dom = create$n();

  dom.element = function () {
    return el;
  };

  dom.root = function () {
    return el;
  };

  dom.appendTo = function (element) {
    if (!el) {
      el = createElement('div');
      el.style.position = 'absolute';
      el.style['-webkit-font-smoothing'] = 'antialiased';
      el.style['-moz-osx-font-smoothing'] = 'antialiased';
      el.style.pointerEvents = 'none';
    }

    element.appendChild(el);
    return el;
  };

  dom.render = function (nodes) {
    if (!el) {
      return false;
    }

    el.style.left = "".concat(rect.computedPhysical.x, "px");
    el.style.top = "".concat(rect.computedPhysical.y, "px");
    el.style.width = "".concat(rect.computedPhysical.width, "px");
    el.style.height = "".concat(rect.computedPhysical.height, "px");
    var vNode;

    if (Array.isArray(nodes)) {
      vNode = h("div", null, nodes);
    } else {
      vNode = nodes;
    }

    dNode = render$9(vNode, el, dNode);
    return true;
  };

  dom.renderArgs = [h]; // Arguments to render functions using the DOM renderer

  dom.clear = function () {
    if (el) {
      var first = el.firstChild;

      while (first) {
        el.removeChild(first);
        first = el.firstChild;
      }

      dNode = null;
    }

    return dom;
  };

  dom.destroy = function () {
    if (el && el.parentElement) {
      el.parentElement.removeChild(el);
    }

    el = null;
    dNode = null;
  };

  dom.size = function (inner) {
    if (inner) {
      rect = createRendererBox(inner);
    }

    return rect;
  };

  return dom;
}

function rendererComponent$2(picasso) {
  picasso.renderer('dom', renderer$2);
}

var renderers = [rendererComponent$1, rendererComponent, rendererComponent$2];

var scales = [];

var LOG_LEVEL = {
  OFF: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  DEBUG: 4
};

var loggerFn = function loggerFn() {
  var _LOG_FN;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$level = _ref.level,
      level = _ref$level === void 0 ? LOG_LEVEL.OFF : _ref$level,
      _ref$pipe = _ref.pipe,
      pipe = _ref$pipe === void 0 ? console : _ref$pipe;

  var currentlevel = level;
  var LOG_FN = (_LOG_FN = {}, _defineProperty(_LOG_FN, LOG_LEVEL.OFF, function () {}), _defineProperty(_LOG_FN, LOG_LEVEL.ERROR, function () {
    return pipe.error.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.WARN, function () {
    return pipe.warn.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.INFO, function () {
    return pipe.info.apply(pipe, arguments);
  }), _defineProperty(_LOG_FN, LOG_LEVEL.DEBUG, function () {
    return pipe.log.apply(pipe, arguments);
  }), _LOG_FN);

  var log = function log(lev) {
    if (!lev || currentlevel < lev) {
      return;
    }

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (LOG_FN[lev] || LOG_FN[LOG_LEVEL.DEBUG]).apply(void 0, args);
  };
  /**
   * @typedef {object} logger
   * @private
   */


  return (
    /** @lends logger */
    {
      /**
       * Log a message
       * @param {number} lev - The log level
       * @param {...any} args
       * @kind function
       */
      log: log,

      /**
       * Log an error message
       * @param {...any} args
       */
      error: function error() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return log.apply(void 0, [LOG_LEVEL.ERROR].concat(args));
      },

      /**
       * Log a warning message
       * @param {...any} args
       */
      warn: function warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return log.apply(void 0, [LOG_LEVEL.WARN].concat(args));
      },

      /**
       * Log an info message
       * @param {...any} args
       */
      info: function info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return log.apply(void 0, [LOG_LEVEL.INFO].concat(args));
      },

      /**
       * Log a debug message
       * @param {...any} args
       */
      debug: function debug() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return log.apply(void 0, [LOG_LEVEL.DEBUG].concat(args));
      },

      /**
       * Set the current log level
       * @param {number} lev - The log level
       */
      level: function level(lev) {
        if (typeof lev === 'number') {
          currentlevel = lev;
        }

        return currentlevel;
      },
      LOG_LEVEL: LOG_LEVEL
    }
  );
};

var palettes = [{
  key: 'categorical',
  colors: [['#a54343', '#d76c6c', '#ec983d', '#ecc43d', '#f9ec86', '#cbe989', '#70ba6e', '#578b60', '#79d69f', '#26a0a7', '#138185', '#65d3da'] // breeze colors
  ]
}, {
  key: 'diverging',
  colors: [['#3d52a1', '#3a89c9', '#77b7e5', '#b4ddf7', '#e6f5fe', '#ffe3aa', '#f9bd7e', '#ed875e', '#d24d3e', '#ae1c3e']]
}, {
  key: 'sequential',
  colors: [['rgb(180,221,212)', 'rgb(34, 83, 90)']]
}];
/* eslint quote-props: 0 */

var picasso_esm_style = {
  // -- FOUNDATION --
  // fonts
  '$font-family': "'Source Sans Pro', Arial, sans-serif",
  '$font-size': '12px',
  '$line-height': '16px',
  '$font-size--l': '16px',
  // base grays
  '$gray-100': '#ffffff',
  '$gray-98': '#f9f9f9',
  '$gray-95': '#f2f2f2',
  '$gray-90': '#e6e6e6',
  '$gray-35': '#595959',
  '$gray-30': '#4d4d4d',
  '$gray-25': '#404040',
  '$gray-20': '#333333',
  // borders
  '$border-95': 'rgba(255, 255, 255, 0.05)',
  '$border-90': 'rgba(255, 255, 255, 0.1)',
  '$border-80': 'rgba(255, 255, 255, 0.2)',
  '$border-20': 'rgba(0, 0, 0, 0.2)',
  '$border-10': 'rgba(0, 0, 0, 0.1)',
  '$border-5': 'rgba(0, 0, 0, 0.05)',
  // primary colors
  '$primary-blue': '#3F8AB3',
  '$primary-green': '#6CB33F',
  '$primary-red': '#DC423F',
  '$primary-orange': '#EF960F',
  // spacing
  '$spacing--s': 4,
  '$spacing': 8,
  '$spacing--l': 12,
  // -------------------------
  // -- ALIASES --
  '$font-color': '$gray-35',
  '$font-color--inverted': '$gray-90',
  '$guide-color': '$gray-90',
  '$guide-color--inverted': '$gray-35',
  '$border': '$border-80',
  '$border--inverted': '$border-10',
  // -------------------------
  // -- MIXINS --
  // data points
  '$shape': {
    // data shape
    fill: '$primary-blue',
    strokeWidth: 1,
    stroke: '$border'
  },
  '$shape-outline': {
    // data shape which usually does not have a fill, e.g. the line in a linechart
    stroke: '$primary-blue',
    strokeWidth: 2
  },
  '$shape-guide': {
    // lines that somehow belongs to a data shape, e.g. whiskers in a boxplot
    stroke: '$guide-color',
    strokeWidth: 1
  },
  '$shape-guide--inverted': {
    '@extend': '$shape-guide',
    stroke: '$guide-color--inverted'
  },
  '$label': {
    fontSize: '$font-size',
    fontFamily: '$font-family',
    fill: '$font-color'
  },
  '$label--inverted': {
    '$extend': '$label',
    fill: '$font-color--inverted'
  },
  // user interface
  '$label-overlay': {
    // e.g. selection range bubble
    fontSize: '$font-size--l',
    fontFamily: '$font-family',
    fill: '$gray-100',
    // background fill
    color: '$font-color',
    stroke: '$guide-color--inverted',
    strokeWidth: 1,
    borderRadius: 4
  },
  '$title': {
    '@extend': '$label',
    fontSize: '$font-size--l'
  },
  '$guide-line': {
    strokeWidth: 1,
    stroke: '$guide-color'
  },
  '$guide-line--minor': {
    strokeWidth: 1,
    stroke: '$gray-95' // needs alias

  },
  '$padding--s': {
    left: '$spacing--s',
    right: '$spacing--s',
    top: '$spacing--s',
    bottom: '$spacing--s'
  },
  '$padding': {
    left: '$spacing',
    right: '$spacing',
    top: '$spacing',
    bottom: '$spacing'
  },
  '$selection-area-target': {
    fill: '$primary-green',
    strokeWidth: 0,
    opacity: 0.2
  }
};

function usePlugin(plugin) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var api = arguments.length > 2 ? arguments[2] : undefined;
  plugin(api, options);
}

function pic() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var registries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var logger = loggerFn(config.logger);
  /**
   * @lends picassojs
   */

  var regis = {
    // -- registries --

    /**
     * Component registry
     * @type {registry}
     */
    component: registryFactory(registries.component, 'component', logger),

    /**
     * Data registry
     * @type {registry}
     */
    data: registryFactory(registries.data, 'data', logger),

    /**
     * Formatter registry
     * @type {registry}
     */
    formatter: registryFactory(registries.formatter, 'formatter', logger),

    /**
     * Interaction registry
     * @type {registry}
     */
    interaction: registryFactory(registries.interaction, 'interaction', logger),

    /**
     * Renderer registry
     * @type {registry}
     */
    renderer: rendererRegistry(registries.renderer, 'renderer', logger),

    /**
     * Scale registry
     * @type {registry}
     */
    scale: registryFactory(registries.scale, 'scale', logger),

    /**
     * Symbol registry
     * @type {registry}
     * @private
     */
    symbol: registryFactory(registries.symbol, 'symbol', logger),
    // -- misc --

    /**
     * log some some stuff
     * @type {logger}
     * @private
     */
    logger: logger
  };

  if (config.renderer && config.renderer.prio) {
    regis.renderer.default(config.renderer.prio[0]);
  }
  /**
   * picasso.js entry point
   * @experimental
   * @entry
   * @alias picassojs
   * @param {object} cfg
   * @param {object} cfg.renderer
   * @param {Array<string>} cfg.renderer.prio
   * @param {object} cfg.logger
   * @param {number} cfg.logger.level
   * @param {object} cfg.style
   * @param {Array<object>} cfg.palettes
   * @returns {picassojs}
   */


  function picassojs() {
    var cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var cc = {
      palettes: config.palettes.concat(cfg.palettes || []),
      style: extend({}, config.style, cfg.style),
      logger: cfg.logger || config.logger,
      renderer: cfg.renderer || config.renderer
    };
    return pic(cc, regis);
  }
  /**
   * @callback picassojs~plugin
   * @param {picassojs~registries} registries
   * @param {object} options
   */

  /**
   * @param {picassojs~plugin} plugin
   * @param {object} [options]
   */


  picassojs.use = function (plugin) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return usePlugin(plugin, options, regis);
  };
  /**
   * @param {chart-definition} definition
   * @returns {chart}
   */


  picassojs.chart = function (definition) {
    return chartFn(definition, {
      registries: regis,
      logger: logger,
      style: config.style,
      palettes: config.palettes
    });
  };

  picassojs.config = function () {
    return config;
  };

  Object.keys(regis).forEach(function (key) {
    picassojs[key] = regis[key];
  });
  /**
   * picasso.js version
   * @type {string}
   */

  picassojs.version = about.version;
  return picassojs;
}

var picasso_esm_p = pic({
  renderer: {
    prio: ['svg', 'canvas']
  },
  logger: {
    level: 0
  },
  style: picasso_esm_style,
  palettes: palettes
}, {
  component: componentRegistry,
  data: dataRegistry,
  formatter: formatterRegistry,
  interaction: reg$2,
  renderer: rendererRegistry(),
  scale: scaleRegistry,
  symbol: reg$1
});
components.forEach(picasso_esm_p.use);
renderers.forEach(picasso_esm_p.use);
scales.forEach(picasso_esm_p.use);

/* harmony default export */ var picasso_esm = (picasso_esm_p);
//# sourceMappingURL=picasso.esm.js.map

// EXTERNAL MODULE: ./node_modules/picasso-plugin-hammer/dist/picasso-hammer.esm.js
var picasso_hammer_esm = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/picasso-plugin-q/dist/picasso-q.esm.js
var picasso_q_esm = __webpack_require__(23);

// CONCATENATED MODULE: ./src/picasso/components/domPointLabel.js

/* harmony default export */ var components_domPointLabel = ({
  require: ['resolver'],
  renderer: 'dom',
  defaultSettings: {
    settings: {}
  },
  beforeRender: function beforeRender(options) {
    this.size = options.size;
  },
  generatePoints: function generatePoints(data) {
    var _this = this;

    var visible = [];
    return data.items.map(function (row) {
      var left = _this.size.width * row.x - data.settings.width / 2;
      var top = _this.size.height * row.y - data.settings.height / 2 - data.settings.offset;
      var display = 'inline';
      var p = {
        w: data.settings.width,
        h: data.settings.height
      }; // Collision detection

      if (visible.length) {
        for (var _i = 0, _visible = visible; _i < _visible.length; _i++) {
          var n = _visible[_i];

          // eslint-disable-line no-restricted-syntax
          if (left < n.left + p.w && left + p.w > n.left && top < n.top + p.h && p.h + top > n.top) {
            display = 'none';
            break;
          }
        }
      }

      if (display === 'inline') visible = [].concat(toConsumableArray_default()(visible), [{
        left: left,
        top: top
      }]);
      var style = {
        position: 'absolute',
        left: "".concat(left, "px"),
        top: "".concat(top, "px"),
        'font-size': data.settings.fontSize ? data.settings.fontSize : '10px',
        color: data.settings.color ? data.settings.color : '#000000',
        width: "".concat(data.settings.width, "px"),
        'text-align': 'center',
        display: display
      };

      var res = _this.h('div', {
        attrs: {
          "class": 'domLabel'
        },
        style: style
      }, row.data.label);

      return res;
    });
  },
  render: function render(h, _ref) {
    var data = _ref.data;
    this.h = h; // snabbdom reference

    var resolved = this.resolver.resolve({
      data: data,
      settings: this.settings.settings,
      scaled: {
        x: this.size.width,
        y: this.size.height
      }
    });
    return this.generatePoints(resolved);
  }
});
// CONCATENATED MODULE: ./src/picasso/components/domPointImage.js
/* harmony default export */ var domPointImage = ({
  require: ['resolver'],
  renderer: 'dom',
  defaultSettings: {
    settings: {}
  },
  beforeRender: function beforeRender(options) {
    this.size = options.size;
  },
  generatePoints: function generatePoints(data) {
    var _this = this;

    return data.items.map(function (row) {
      var style = {
        position: 'absolute',
        left: "".concat(_this.size.width * row.x - data.settings.width / 2, "px"),
        top: "".concat(_this.size.height * row.y - data.settings.height / 2 - 10, "px"),
        // extra 10px for the text
        'text-align': 'center',
        'font-size': '10px',
        color: data.settings.color,
        'background-image': "url(\"".concat(data.settings.image, "\")"),
        'background-repeat': 'no-repeat',
        'background-position': 'center bottom',
        width: "".concat(data.settings.width, "px"),
        height: "".concat(data.settings.height + 12, "px") // extra 12px for the text

      };

      var res = _this.h('div', {
        attrs: {
          "class": 'domPointImage'
        },
        style: style
      }, row.data.label);

      return res;
    });
  },
  render: function render(h, _ref) {
    var data = _ref.data;
    this.h = h; // snabbdom reference

    var resolved = this.resolver.resolve({
      data: data,
      settings: this.settings.settings,
      scaled: {
        x: this.size.width,
        y: this.size.height
      }
    });
    return this.generatePoints(resolved);
  }
});
// CONCATENATED MODULE: ./src/picasso/components/tooltip.js
/* harmony default export */ var components_tooltip = ({
  require: ['chart', 'renderer'],
  defaultSettings: {
    background: '#f9f9f9',
    fontSize: '12px'
  },
  renderer: 'dom',
  on: {
    hover: function hover(e) {
      // eslint-disable-line consistent-return
      var clientX = e.clientX,
          clientY = e.clientY,
          pageX = e.pageX,
          pageY = e.pageY;

      var _this$chart$element$g = this.chart.element.getBoundingClientRect(),
          left = _this$chart$element$g.left,
          top = _this$chart$element$g.top;

      var x = clientX - left;
      var y = clientY - top;
      var shapes = this.chart.shapesAt({
        x: x,
        y: y
      });
      shapes = shapes.filter(function (shape) {
        return shape.type !== 'text';
      });
      if (!shapes.length) return this.renderer.render([]);
      var target = shapes[shapes.length - 1];
      this.renderer.render(this.buildTooltip(target, pageX - window.scrollX, pageY - window.scrollY));
    },
    leave: function leave() {
      this.renderer.render([]);
    }
  },
  buildTooltip: function buildTooltip(target, x, y) {
    return this.h('div', {
      style: {
        position: 'fixed',
        'z-index': 1,
        left: "".concat(x, "px"),
        top: "".concat(y - 34, "px"),
        background: this.settings.background,
        color: '#888',
        display: 'flex',
        'box-shadow': '0px 0px 5px 0px rgba(123, 123, 123, 0.5)',
        'border-radius': '5px',
        padding: '8px',
        'font-size': this.settings.fontSize,
        'font-family': 'Arial'
      }
    }, "".concat(target.data.qDimension.label, ": ").concat(target.data.qMeasure.value));
  },
  render: function render(h) {
    this.h = h;
    return [];
  }
});
// CONCATENATED MODULE: ./src/picasso/components/index.js




// CONCATENATED MODULE: ./src/components/QdtPicasso.jsx


















picasso_esm.component('domPointLabel', components_domPointLabel);
picasso_esm.component('domPointImage', domPointImage);
picasso_esm.use(picasso_hammer_esm["a" /* default */]);
picasso_esm.use(picasso_q_esm["a" /* default */]);

var QdtPicasso_QdtPicassoComponent =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtPicassoComponent, _React$Component);

  function QdtPicassoComponent(props) {
    var _this;

    classCallCheck_default()(this, QdtPicassoComponent);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtPicassoComponent).call(this, props));

    _this.handleOutsideClick = function (event) {
      var outsideClick = !_this.root.contains(event.target);

      if (outsideClick) {
        _this.confirmSelections();
      }
    };

    _this.handleResize = function () {
      _this.pic.update();
    };

    _this.cancelSelections = function () {
      var brush = _this.pic.brush;
      var endSelections = _this.props.endSelections;
      brush('select').end();
      endSelections(false);
    };

    _this.confirmSelections = function () {
      var brush = _this.pic.brush;
      var _this$props = _this.props,
          selections = _this$props.selections,
          endSelections = _this$props.endSelections,
          afterConfirmSelections = _this$props.afterConfirmSelections;

      if (selections) {
        brush('select').end();
        endSelections(true);

        if (afterConfirmSelections) {
          afterConfirmSelections();
        }
      }
    };

    _this.createPic =
    /*#__PURE__*/
    asyncToGenerator_default()(
    /*#__PURE__*/
    regenerator_default.a.mark(function _callee() {
      var _this$props2, qLayout, qData, settings, type, prio, options, select, selections, beginSelections, data;

      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _this$props2 = _this.props, qLayout = _this$props2.qLayout, qData = _this$props2.qData, settings = _this$props2.settings, type = _this$props2.type, prio = _this$props2.prio, options = _this$props2.options, select = _this$props2.select, selections = _this$props2.selections, beginSelections = _this$props2.beginSelections;
              _this.mySettings = type ? picasso_settings[type] : settings;
              data = objectSpread_default()({}, qLayout, {
                qHyperCube: objectSpread_default()({}, qLayout.qHyperCube, {
                  qDataPages: [qData]
                })
              });

              if (type === 'horizontalBarchart' && options.bar && options.bar.fill) {
                _this.mySettings.components[2].settings.box.fill = options.bar.fill;
              }

              if (type === 'verticalGauge' && options.min) {
                _this.mySettings.scales.y.min = options.min;
                _this.mySettings.components[1].start = options.min;
                _this.mySettings.components[2].start = options.min;
              }

              if (type === 'verticalGauge' && options.max) {
                _this.mySettings.scales.y.max = options.max;
                _this.mySettings.components[1].end = options.max;
              }

              _this.pic = picasso_esm({
                renderer: {
                  prio: [prio]
                }
              }).chart({
                element: _this.element,
                data: [{
                  type: 'q',
                  key: 'qHyperCube',
                  data: data.qHyperCube
                }],
                settings: _this.mySettings
              });

              _this.pic.brush('select').on('start', function () {
                beginSelections();
                select(0, [], false);
              });

              _this.pic.brush('select').on('update', function (added, removed) {
                if (!selections && !added) return;
                var mySelections = [].concat(toConsumableArray_default()(added), toConsumableArray_default()(removed)).map(function (v) {
                  return v.values[0];
                });
                select(0, mySelections);
              });

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    _this.updatePic = function () {
      var selections = _this.props.selections;
      if (selections) return;
      var _this$props3 = _this.props,
          qLayout = _this$props3.qLayout,
          qData = _this$props3.qData,
          type = _this$props3.type,
          options = _this$props3.options;

      var data = objectSpread_default()({}, qLayout, {
        qHyperCube: objectSpread_default()({}, qLayout.qHyperCube, {
          qDataPages: [qData]
        })
      });

      if (type === 'horizontalBarchart' && options.bar && options.bar.fill) {
        _this.mySettings.components[2].settings.box.fill = options.bar.fill;
      }

      if (type === 'verticalGauge' && options.min) {
        _this.mySettings.scales.y.min = options.min;
        _this.mySettings.components[1].start = options.min;
        _this.mySettings.components[2].start = options.min;
      }

      if (type === 'verticalGauge' && options.max) {
        _this.mySettings.scales.y.max = options.max;
        _this.mySettings.components[1].end = options.max;
      }

      _this.pic.update({
        data: [{
          type: 'q',
          key: 'qHyperCube',
          data: data.qHyperCube
        }],
        settings: _this.mySettings
      });
    };

    _this.mySettings = null;
    return _this;
  }

  createClass_default()(QdtPicassoComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.createPic();
      window.addEventListener('click', this.handleOutsideClick);
      window.addEventListener('resize', this.handleResize);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updatePic();
      this.updatePic();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('click', this.handleOutsideClick);
      window.removeEventListener('resize', this.handleResize);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props4 = this.props,
          selections = _this$props4.selections,
          type = _this$props4.type,
          qData = _this$props4.qData,
          outerWidth = _this$props4.outerWidth,
          outerHeight = _this$props4.outerHeight,
          innerWidth = _this$props4.innerWidth,
          innerHeight = _this$props4.innerHeight,
          options = _this$props4.options;
      var myInnerHeight = innerHeight;
      var maxWidth = '100%';
      var maxHeight = '100%';

      if (type === 'horizontalBarchart' && options.bar && options.bar.height && innerHeight === '100%') {
        maxHeight = qData.qMatrix.length * options.bar.height;
        myInnerHeight = maxHeight;
      }

      if (type === 'verticalBarchart') {
        maxWidth = qData.qMatrix.length * 50;
      }

      return react_default.a.createElement("div", {
        ref: function ref(node) {
          return _this2.root = node;
        },
        style: {
          position: 'relative'
        }
      }, selections && react_default.a.createElement("div", {
        style: {
          position: 'absolute',
          top: '-2rem',
          right: 0
        }
      }, react_default.a.createElement("button", {
        type: "button",
        className: "lui-button lui-button--danger",
        style: {
          marginRight: '1rem'
        },
        onClick: this.cancelSelections
      }, react_default.a.createElement("span", {
        className: "lui-icon lui-icon--close"
      })), react_default.a.createElement("button", {
        type: "button",
        className: "lui-button lui-button--success",
        style: {
          marginRight: '1rem'
        },
        onClick: this.confirmSelections
      }, react_default.a.createElement("span", {
        className: "lui-icon lui-icon--tick"
      }))), react_default.a.createElement("div", {
        style: {
          position: 'relative',
          width: outerWidth,
          height: outerHeight,
          overflow: 'auto',
          paddingRight: 10
        }
      }, react_default.a.createElement("div", {
        ref: function ref(node) {
          return _this2.element = node;
        },
        style: {
          width: innerWidth,
          height: myInnerHeight,
          maxWidth: maxWidth,
          maxHeight: maxHeight
        }
      })));
    }
  }]);

  return QdtPicassoComponent;
}(react_default.a.Component);

QdtPicasso_QdtPicassoComponent.propTypes = {
  qData: prop_types_default.a.object.isRequired,
  qLayout: prop_types_default.a.object.isRequired,
  select: prop_types_default.a.func.isRequired,
  beginSelections: prop_types_default.a.func.isRequired,
  endSelections: prop_types_default.a.func.isRequired,
  selections: prop_types_default.a.bool.isRequired,
  outerWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  outerHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  innerWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  innerHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]).isRequired,
  type: prop_types_default.a.string,
  settings: prop_types_default.a.object,
  options: prop_types_default.a.object,
  afterConfirmSelections: prop_types_default.a.func,
  prio: prop_types_default.a.oneOf(['canvas', 'svg'])
};
QdtPicasso_QdtPicassoComponent.defaultProps = {
  type: null,
  settings: {},
  options: {},
  afterConfirmSelections: null,
  prio: 'canvas'
};
var QdtPicasso = withHyperCube(QdtPicasso_QdtPicassoComponent);
QdtPicasso.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  qHyperCubeDef: prop_types_default.a.object,
  qPage: prop_types_default.a.object,
  type: prop_types_default.a.oneOf(['comboLineBarchart', 'horizontalBarchart', 'lineChart', 'multiLineChart', 'pie', 'piechart', 'scatterplot', 'verticalBarchart', 'verticalGroupBarchart', 'stackedBarchart', 'verticalGauge', 'verticalRangeGauge', 'rangeArea', 'gantt']),
  settings: prop_types_default.a.object,
  options: prop_types_default.a.object,
  outerWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  outerHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  innerWidth: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  innerHeight: prop_types_default.a.oneOfType([prop_types_default.a.number, prop_types_default.a.string]),
  afterConfirmSelections: prop_types_default.a.func,
  prio: prop_types_default.a.oneOf(['canvas', 'svg'])
};
QdtPicasso.defaultProps = {
  cols: null,
  qHyperCubeDef: null,
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 10,
    qHeight: 1000
  },
  type: null,
  settings: {},
  options: {},
  outerWidth: '100%',
  outerHeight: '100%',
  innerWidth: '100%',
  innerHeight: '100%',
  afterConfirmSelections: null,
  prio: 'canvas'
};
/* harmony default export */ var components_QdtPicasso = (QdtPicasso);
// CONCATENATED MODULE: ./src/components/QdtSearch.jsx














var QdtSearch_DropdownItemList = function DropdownItemList(_ref) {
  var qMatrix = _ref.qMatrix,
      rowHeight = _ref.rowHeight,
      select = _ref.select;
  return react_default.a.createElement("span", null, qMatrix.map(function (row) {
    return react_default.a.createElement(qdt_lui["LuiListItem"], {
      className: "".concat(row[0].qState),
      key: row[0].qElemNumber,
      "data-q-elem-number": row[0].qElemNumber,
      "data-q-state": row[0].qState,
      onClick: select,
      style: {
        height: "".concat(rowHeight - 1, "px")
      }
    }, row[0].qText);
  }));
};

QdtSearch_DropdownItemList.propTypes = {
  qMatrix: prop_types_default.a.array.isRequired,
  rowHeight: prop_types_default.a.number.isRequired,
  select: prop_types_default.a.func.isRequired
};

var QdtSearch_QdtSearchComponent =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtSearchComponent, _React$Component);

  function QdtSearchComponent() {
    var _getPrototypeOf2;

    var _this;

    classCallCheck_default()(this, QdtSearchComponent);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = possibleConstructorReturn_default()(this, (_getPrototypeOf2 = getPrototypeOf_default()(QdtSearchComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _this.state = {
      dropdownOpen: false,
      value: ''
    };

    _this.toggle = function (event) {
      var _this$props = _this.props,
          beginSelections = _this$props.beginSelections,
          endSelections = _this$props.endSelections;
      var dropdownOpen = _this.state.dropdownOpen;
      var outsideClick = event ? !_this.node.contains(event.target) : true;

      if (outsideClick || !dropdownOpen) {
        _this.setState({
          dropdownOpen: !dropdownOpen
        }, function () {
          if (!dropdownOpen) {
            beginSelections();
          }

          if (dropdownOpen) {
            endSelections(true);

            _this.clear();
          }
        });
      }
    };

    _this.select =
    /*#__PURE__*/
    function () {
      var _ref2 = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee(qElemNumber, qState) {
        var _this$props2, select, ignoreLock, single, afterSelect;

        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _this$props2 = _this.props, select = _this$props2.select, ignoreLock = _this$props2.ignoreLock, single = _this$props2.single, afterSelect = _this$props2.afterSelect;

                if (!(qState === 'S')) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return select(Number(qElemNumber), true, ignoreLock);

              case 4:
                _context.next = 9;
                break;

              case 6:
                _context.next = 8;
                return select(Number(qElemNumber), !single, ignoreLock);

              case 8:
                if (single) _this.toggle();

              case 9:
                if (afterSelect) {
                  afterSelect();
                }

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }();

    _this.handleSelect = function (event) {
      var _event$currentTarget$ = event.currentTarget.dataset,
          qElemNumber = _event$currentTarget$.qElemNumber,
          qState = _event$currentTarget$.qState;

      _this.select(qElemNumber, qState);
    };

    _this.clear = function () {
      var searchListObjectFor = _this.props.searchListObjectFor;

      _this.setState({
        value: ''
      });

      searchListObjectFor('');
    };

    _this.searchListObjectFor = function (event) {
      var _this$props3 = _this.props,
          offset = _this$props3.offset,
          searchListObjectFor = _this$props3.searchListObjectFor;

      _this.setState({
        value: event.target.value
      });

      offset(0);
      searchListObjectFor(event.target.value);
    };

    _this.acceptListObjectSearch = function () {
      var _this$props4 = _this.props,
          single = _this$props4.single,
          acceptListObjectSearch = _this$props4.acceptListObjectSearch,
          ignoreLock = _this$props4.ignoreLock,
          qData = _this$props4.qData;
      if (!single) acceptListObjectSearch(ignoreLock);
      if (single) _this.select(qData.qMatrix[0][0].qElemNumber, qData.qMatrix[0][0].qState);

      _this.setState({
        value: ''
      });
    };

    _this.handleKeyPress = function (event) {
      if (event.charCode === 13) {
        _this.acceptListObjectSearch();
      }
    };

    return _this;
  }

  createClass_default()(QdtSearchComponent, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props5 = this.props,
          qData = _this$props5.qData,
          qLayout = _this$props5.qLayout,
          offset = _this$props5.offset,
          inverse = _this$props5.inverse,
          placeholder = _this$props5.placeholder,
          tooltipDock = _this$props5.tooltipDock,
          tooltipContent = _this$props5.tooltipContent,
          showGo = _this$props5.showGo;
      var _this$state = this.state,
          dropdownOpen = _this$state.dropdownOpen,
          value = _this$state.value;
      return react_default.a.createElement("div", {
        ref: function ref(node) {
          return _this2.node = node;
        }
      }, react_default.a.createElement(qdt_lui["LuiDropdown"], {
        isOpen: dropdownOpen,
        toggle: this.toggle,
        select: false
      }, react_default.a.createElement(qdt_lui["LuiSearch"], {
        value: value,
        clear: this.clear,
        inverse: !!inverse,
        placeholder: placeholder,
        tooltipDock: tooltipDock,
        tooltipContent: tooltipContent,
        onChange: this.searchListObjectFor,
        onKeyPress: this.handleKeyPress,
        onGo: showGo ? this.acceptListObjectSearch : null
      }), react_default.a.createElement(qdt_lui["LuiList"], {
        style: {
          width: '15rem'
        }
      }, react_default.a.createElement(QdtVirtualScroll_QdtVirtualScroll, {
        qData: qData,
        qcy: qLayout.qListObject.qSize.qcy,
        Component: QdtSearch_DropdownItemList,
        componentProps: {
          select: this.handleSelect
        },
        offset: offset,
        rowHeight: 38,
        viewportHeight: 190
      }))));
    }
  }]);

  return QdtSearchComponent;
}(react_default.a.Component);

QdtSearch_QdtSearchComponent.propTypes = {
  qData: prop_types_default.a.object.isRequired,
  qLayout: prop_types_default.a.object.isRequired,
  offset: prop_types_default.a.func.isRequired,
  select: prop_types_default.a.func.isRequired,
  beginSelections: prop_types_default.a.func.isRequired,
  endSelections: prop_types_default.a.func.isRequired,
  searchListObjectFor: prop_types_default.a.func.isRequired,
  acceptListObjectSearch: prop_types_default.a.func.isRequired,
  ignoreLock: prop_types_default.a.bool.isRequired,
  showGo: prop_types_default.a.bool.isRequired,
  afterSelect: prop_types_default.a.func,
  single: prop_types_default.a.bool,
  inverse: prop_types_default.a.bool,
  placeholder: prop_types_default.a.string,
  tooltipDock: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),
  tooltipContent: prop_types_default.a.string
};
QdtSearch_QdtSearchComponent.defaultProps = {
  afterSelect: null,
  single: false,
  inverse: false,
  placeholder: 'Search',
  tooltipDock: 'top',
  tooltipContent: null
};
var QdtSearch = withListObject(QdtSearch_QdtSearchComponent);
QdtSearch.propTypes = {
  qDocPromise: prop_types_default.a.object.isRequired,
  cols: prop_types_default.a.array,
  qListObjectDef: prop_types_default.a.object,
  qPage: prop_types_default.a.object,
  afterSelect: prop_types_default.a.func,
  single: prop_types_default.a.bool,
  inverse: prop_types_default.a.bool,
  placeholder: prop_types_default.a.string,
  tooltipDock: prop_types_default.a.oneOf(['top', 'right', 'bottom', 'left']),
  tooltipContent: prop_types_default.a.string,
  ignoreLock: prop_types_default.a.bool,
  showGo: prop_types_default.a.bool
};
QdtSearch.defaultProps = {
  cols: null,
  qListObjectDef: null,
  afterSelect: null,
  single: false,
  inverse: false,
  placeholder: 'Search',
  tooltipDock: 'top',
  tooltipContent: null,
  ignoreLock: false,
  showGo: false,
  qPage: {
    qTop: 0,
    qLeft: 0,
    qWidth: 1,
    qHeight: 100
  }
};
/* harmony default export */ var components_QdtSearch = (QdtSearch);
// CONCATENATED MODULE: ./src/components/QdtCurrentSelections.jsx












var QdtCurrentSelections_QdtViz =
/*#__PURE__*/
function (_React$Component) {
  inherits_default()(QdtViz, _React$Component);

  function QdtViz(props) {
    var _this;

    classCallCheck_default()(this, QdtViz);

    _this = possibleConstructorReturn_default()(this, getPrototypeOf_default()(QdtViz).call(this, props));
    _this.uid = utilities.Uid(8);
    _this.state = {
      loading: true,
      error: null
    };
    return _this;
  }

  createClass_default()(QdtViz, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.create();
    }
  }, {
    key: "create",
    value: function () {
      var _create = asyncToGenerator_default()(
      /*#__PURE__*/
      regenerator_default.a.mark(function _callee() {
        var qAppPromise, qApp;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                qAppPromise = this.props.qAppPromise;
                _context.next = 4;
                return qAppPromise;

              case 4:
                qApp = _context.sent;
                qApp.getObject(this.uid, 'CurrentSelections');
                _context.next = 8;
                return this.setState({
                  loading: false
                });

              case 8:
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](0);
                this.setState({
                  error: _context.t0
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 10]]);
      }));

      function create() {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height;
      var _this$state = this.state,
          error = _this$state.error,
          loading = _this$state.loading;

      if (error) {
        return react_default.a.createElement("div", null, error.message);
      }

      if (loading) {
        var paddingTop = parseInt(height, 0) ? height / 2 - 10 : 0;
        return react_default.a.createElement(utilities_Preloader, {
          width: width,
          height: height,
          paddingTop: paddingTop
        });
      }

      return react_default.a.createElement("div", {
        style: {
          width: width,
          height: height
        },
        id: this.uid
      });
    }
  }]);

  return QdtViz;
}(react_default.a.Component);

QdtCurrentSelections_QdtViz.propTypes = {
  qAppPromise: prop_types_default.a.object.isRequired,
  width: prop_types_default.a.string,
  height: prop_types_default.a.string
};
QdtCurrentSelections_QdtViz.defaultProps = {
  width: '100%',
  height: '100%'
};

// CONCATENATED MODULE: ./src/QdtComponents.jsx





var QdtComponents_class, QdtComponents_temp;


















var QdtComponents_components = {
  QdtFilter: components_QdtFilter,
  QdtTable: components_QdtTable,
  QdtViz: QdtViz_QdtViz,
  QdtSelectionToolbar: components_QdtSelectionToolbar,
  QdtKpi: components_QdtKpi,
  QdtButton: QdtButton_QdtButton,
  QdtPicasso: components_QdtPicasso,
  QdtSearch: components_QdtSearch,
  QdtCurrentSelections: QdtCurrentSelections_QdtViz
};
var QdtComponents_QdtComponents = (QdtComponents_temp = QdtComponents_class = function QdtComponents() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var connections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    vizApi: true,
    engineApi: true,
    useUniqueSessionID: null
  };

  classCallCheck_default()(this, QdtComponents);

  this.render =
  /*#__PURE__*/
  function () {
    var _ref = asyncToGenerator_default()(
    /*#__PURE__*/
    regenerator_default.a.mark(function _callee(type, props, element) {
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                try {
                  var qAppPromise = _this.qAppPromise,
                      qDocPromise = _this.qDocPromise;
                  var Component = QdtComponents_components[type];
                  react_dom_default.a.render(react_default.a.createElement(Component, extends_default()({}, props, {
                    qAppPromise: qAppPromise,
                    qDocPromise: qDocPromise,
                    ref: function ref(node) {
                      return resolve(node);
                    }
                  })), element); //   console.info(version);
                } catch (error) {
                  reject(error);
                }
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  var myConfig = config; // Make it work for Qlik Core scaling https://github.com/qlik-oss/core-scaling
  // No identity needed, core scaling is handling all of the sessions
  // qlikcore/engine:12.248.0

  if (connections.useUniqueSessionID) {
    myConfig.identity = connections.useUniqueSessionID;
  } else if (myConfig.core) {
    myConfig.identity = null;
  } else {
    myConfig.identity = utilities.Uid(16);
  }

  this.qAppPromise = connections.vizApi ? src_qApp(myConfig) : null;
  this.qDocPromise = connections.engineApi ? src_qDoc(myConfig) : null;
}, QdtComponents_class.picasso = {
  settings: picasso_settings,
  components: components_namespaceObject,
  interactions: interactions_namespaceObject
}, QdtComponents_class.unmountQdtComponent = function (element) {
  return react_dom_default.a.unmountComponentAtNode(element);
}, QdtComponents_class.globals = utilities.globals, QdtComponents_temp);
/* harmony default export */ var src_QdtComponents = (QdtComponents_QdtComponents);
// CONCATENATED MODULE: ./src/index.jsx

/* harmony default export */ var src = __webpack_exports__["default"] = (src_QdtComponents);

/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=qdt-components.js.map